; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4xx_adc.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4xx_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4xx_adc.crf ..\..\libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;211      */
;;;212    void ADC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;213    {
;;;214      /* Enable all ADCs reset state */
;;;215      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;216      
;;;217      /* Release all ADCs from reset state */
;;;218      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f44f7080          MOV      r0,#0x100
000010  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;219    }
000014  bd10              POP      {r4,pc}
;;;220    
                          ENDP

                  ADC_Init PROC
;;;233      */
;;;234    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000016  b530              PUSH     {r4,r5,lr}
;;;235    {
000018  4602              MOV      r2,r0
;;;236      uint32_t tmpreg1 = 0;
00001a  2000              MOVS     r0,#0
;;;237      uint8_t tmpreg2 = 0;
00001c  2300              MOVS     r3,#0
;;;238      /* Check the parameters */
;;;239      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;240      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
;;;241      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;242      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
;;;243      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
;;;244      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
;;;245      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;246      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
;;;247      
;;;248      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;249      /* Get the ADCx CR1 value */
;;;250      tmpreg1 = ADCx->CR1;
00001e  6850              LDR      r0,[r2,#4]
;;;251      
;;;252      /* Clear RES and SCAN bits */
;;;253      tmpreg1 &= CR1_CLEAR_MASK;
000020  4cf8              LDR      r4,|L1.1028|
000022  4020              ANDS     r0,r0,r4
;;;254      
;;;255      /* Configure ADCx: scan conversion mode and resolution */
;;;256      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;257      /* Set RES bit according to ADC_Resolution value */ 
;;;258      tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
000024  790d              LDRB     r5,[r1,#4]
000026  680c              LDR      r4,[r1,#0]
000028  ea442405          ORR      r4,r4,r5,LSL #8
00002c  4320              ORRS     r0,r0,r4
;;;259                                       ADC_InitStruct->ADC_Resolution);
;;;260      /* Write to ADCx CR1 */
;;;261      ADCx->CR1 = tmpreg1;
00002e  6050              STR      r0,[r2,#4]
;;;262      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;263      /* Get the ADCx CR2 value */
;;;264      tmpreg1 = ADCx->CR2;
000030  6890              LDR      r0,[r2,#8]
;;;265      
;;;266      /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
;;;267      tmpreg1 &= CR2_CLEAR_MASK;
000032  4cf5              LDR      r4,|L1.1032|
000034  4020              ANDS     r0,r0,r4
;;;268      
;;;269      /* Configure ADCx: external trigger event and edge, data alignment and 
;;;270         continuous conversion mode */
;;;271      /* Set ALIGN bit according to ADC_DataAlign value */
;;;272      /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
;;;273      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;274      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;275      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
000036  e9d15403          LDRD     r5,r4,[r1,#0xc]
00003a  432c              ORRS     r4,r4,r5
00003c  688d              LDR      r5,[r1,#8]
00003e  432c              ORRS     r4,r4,r5
000040  794d              LDRB     r5,[r1,#5]
000042  ea440445          ORR      r4,r4,r5,LSL #1
000046  4320              ORRS     r0,r0,r4
;;;276                            ADC_InitStruct->ADC_ExternalTrigConv | 
;;;277                            ADC_InitStruct->ADC_ExternalTrigConvEdge | \
;;;278                            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;279                            
;;;280      /* Write to ADCx CR2 */
;;;281      ADCx->CR2 = tmpreg1;
000048  6090              STR      r0,[r2,#8]
;;;282      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;283      /* Get the ADCx SQR1 value */
;;;284      tmpreg1 = ADCx->SQR1;
00004a  6ad0              LDR      r0,[r2,#0x2c]
;;;285      
;;;286      /* Clear L bits */
;;;287      tmpreg1 &= SQR1_L_RESET;
00004c  f4200070          BIC      r0,r0,#0xf00000
;;;288      
;;;289      /* Configure ADCx: regular channel sequence length */
;;;290      /* Set L bits according to ADC_NbrOfConversion value */
;;;291      tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
000050  7d0c              LDRB     r4,[r1,#0x14]
000052  1e64              SUBS     r4,r4,#1
000054  b2e4              UXTB     r4,r4
000056  4323              ORRS     r3,r3,r4
;;;292      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
000058  ea405003          ORR      r0,r0,r3,LSL #20
;;;293      
;;;294      /* Write to ADCx SQR1 */
;;;295      ADCx->SQR1 = tmpreg1;
00005c  62d0              STR      r0,[r2,#0x2c]
;;;296    }
00005e  bd30              POP      {r4,r5,pc}
;;;297    
                          ENDP

                  ADC_StructInit PROC
;;;308      */
;;;309    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000060  2100              MOVS     r1,#0
;;;310    {
;;;311      /* Initialize the ADC_Mode member */
;;;312      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
000062  6001              STR      r1,[r0,#0]
;;;313    
;;;314      /* initialize the ADC_ScanConvMode member */
;;;315      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000064  7101              STRB     r1,[r0,#4]
;;;316    
;;;317      /* Initialize the ADC_ContinuousConvMode member */
;;;318      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000066  7141              STRB     r1,[r0,#5]
;;;319    
;;;320      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;321      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
000068  6081              STR      r1,[r0,#8]
;;;322    
;;;323      /* Initialize the ADC_ExternalTrigConv member */
;;;324      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
00006a  60c1              STR      r1,[r0,#0xc]
;;;325    
;;;326      /* Initialize the ADC_DataAlign member */
;;;327      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00006c  6101              STR      r1,[r0,#0x10]
;;;328    
;;;329      /* Initialize the ADC_NbrOfConversion member */
;;;330      ADC_InitStruct->ADC_NbrOfConversion = 1;
00006e  2101              MOVS     r1,#1
000070  7501              STRB     r1,[r0,#0x14]
;;;331    }
000072  4770              BX       lr
;;;332    
                          ENDP

                  ADC_CommonInit PROC
;;;339      */
;;;340    void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000074  2100              MOVS     r1,#0
;;;341    {
;;;342      uint32_t tmpreg1 = 0;
;;;343      /* Check the parameters */
;;;344      assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
;;;345      assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
;;;346      assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
;;;347      assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
;;;348      /*---------------------------- ADC CCR Configuration -----------------*/
;;;349      /* Get the ADC CCR value */
;;;350      tmpreg1 = ADC->CCR;
000076  4ae5              LDR      r2,|L1.1036|
000078  6811              LDR      r1,[r2,#0]
;;;351      
;;;352      /* Clear MULTI, DELAY, DMA and ADCPRE bits */
;;;353      tmpreg1 &= CR_CLEAR_MASK;
00007a  4ae5              LDR      r2,|L1.1040|
00007c  4011              ANDS     r1,r1,r2
;;;354      
;;;355      /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
;;;356         and DMA access mode for multimode */
;;;357      /* Set MULTI bits according to ADC_Mode value */
;;;358      /* Set ADCPRE bits according to ADC_Prescaler value */
;;;359      /* Set DMA bits according to ADC_DMAAccessMode value */
;;;360      /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
;;;361      tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
00007e  e9d02300          LDRD     r2,r3,[r0,#0]
000082  431a              ORRS     r2,r2,r3
000084  6883              LDR      r3,[r0,#8]
000086  431a              ORRS     r2,r2,r3
000088  68c3              LDR      r3,[r0,#0xc]
00008a  431a              ORRS     r2,r2,r3
00008c  4311              ORRS     r1,r1,r2
;;;362                            ADC_CommonInitStruct->ADC_Prescaler | 
;;;363                            ADC_CommonInitStruct->ADC_DMAAccessMode | 
;;;364                            ADC_CommonInitStruct->ADC_TwoSamplingDelay);
;;;365                            
;;;366      /* Write to ADC CCR */
;;;367      ADC->CCR = tmpreg1;
00008e  4ae1              LDR      r2,|L1.1044|
000090  f8c21304          STR      r1,[r2,#0x304]
;;;368    }
000094  4770              BX       lr
;;;369    
                          ENDP

                  ADC_CommonStructInit PROC
;;;375      */
;;;376    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000096  2100              MOVS     r1,#0
;;;377    {
;;;378      /* Initialize the ADC_Mode member */
;;;379      ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
000098  6001              STR      r1,[r0,#0]
;;;380    
;;;381      /* initialize the ADC_Prescaler member */
;;;382      ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
00009a  6041              STR      r1,[r0,#4]
;;;383    
;;;384      /* Initialize the ADC_DMAAccessMode member */
;;;385      ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
00009c  6081              STR      r1,[r0,#8]
;;;386    
;;;387      /* Initialize the ADC_TwoSamplingDelay member */
;;;388      ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
00009e  60c1              STR      r1,[r0,#0xc]
;;;389    }
0000a0  4770              BX       lr
;;;390    
                          ENDP

                  ADC_Cmd PROC
;;;397      */
;;;398    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000a2  b121              CBZ      r1,|L1.174|
;;;399    {
;;;400      /* Check the parameters */
;;;401      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403      if (NewState != DISABLE)
;;;404      {
;;;405        /* Set the ADON bit to wake up the ADC from power down mode */
;;;406        ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
0000a4  6882              LDR      r2,[r0,#8]
0000a6  f0420201          ORR      r2,r2,#1
0000aa  6082              STR      r2,[r0,#8]
0000ac  e003              B        |L1.182|
                  |L1.174|
;;;407      }
;;;408      else
;;;409      {
;;;410        /* Disable the selected ADC peripheral */
;;;411        ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
0000ae  6882              LDR      r2,[r0,#8]
0000b0  f0220201          BIC      r2,r2,#1
0000b4  6082              STR      r2,[r0,#8]
                  |L1.182|
;;;412      }
;;;413    }
0000b6  4770              BX       lr
;;;414    /**
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;455      */
;;;456    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
0000b8  460a              MOV      r2,r1
;;;457    {
;;;458      uint32_t tmpreg = 0;
0000ba  2100              MOVS     r1,#0
;;;459      /* Check the parameters */
;;;460      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;461      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;462      
;;;463      /* Get the old register value */
;;;464      tmpreg = ADCx->CR1;
0000bc  6841              LDR      r1,[r0,#4]
;;;465      
;;;466      /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;467      tmpreg &= CR1_AWDMode_RESET;
0000be  4bd6              LDR      r3,|L1.1048|
0000c0  4019              ANDS     r1,r1,r3
;;;468      
;;;469      /* Set the analog watchdog enable mode */
;;;470      tmpreg |= ADC_AnalogWatchdog;
0000c2  4311              ORRS     r1,r1,r2
;;;471      
;;;472      /* Store the new register value */
;;;473      ADCx->CR1 = tmpreg;
0000c4  6041              STR      r1,[r0,#4]
;;;474    }
0000c6  4770              BX       lr
;;;475    
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;484      */
;;;485    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
0000c8  6241              STR      r1,[r0,#0x24]
;;;486                                            uint16_t LowThreshold)
;;;487    {
;;;488      /* Check the parameters */
;;;489      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;490      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;491      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;492      
;;;493      /* Set the ADCx high threshold */
;;;494      ADCx->HTR = HighThreshold;
;;;495      
;;;496      /* Set the ADCx low threshold */
;;;497      ADCx->LTR = LowThreshold;
0000ca  6282              STR      r2,[r0,#0x28]
;;;498    }
0000cc  4770              BX       lr
;;;499    
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;525      */
;;;526    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
0000ce  460a              MOV      r2,r1
;;;527    {
;;;528      uint32_t tmpreg = 0;
0000d0  2100              MOVS     r1,#0
;;;529      /* Check the parameters */
;;;530      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;531      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;532      
;;;533      /* Get the old register value */
;;;534      tmpreg = ADCx->CR1;
0000d2  6841              LDR      r1,[r0,#4]
;;;535      
;;;536      /* Clear the Analog watchdog channel select bits */
;;;537      tmpreg &= CR1_AWDCH_RESET;
0000d4  f021011f          BIC      r1,r1,#0x1f
;;;538      
;;;539      /* Set the Analog watchdog channel */
;;;540      tmpreg |= ADC_Channel;
0000d8  4311              ORRS     r1,r1,r2
;;;541      
;;;542      /* Store the new register value */
;;;543      ADCx->CR1 = tmpreg;
0000da  6041              STR      r1,[r0,#4]
;;;544    }
0000dc  4770              BX       lr
;;;545    /**
                          ENDP

                  ADC_TempSensorVrefintCmd PROC
;;;590      */
;;;591    void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
0000de  b138              CBZ      r0,|L1.240|
;;;592    {
;;;593      /* Check the parameters */
;;;594      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;595      if (NewState != DISABLE)
;;;596      {
;;;597        /* Enable the temperature sensor and Vrefint channel*/
;;;598        ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
0000e0  49ca              LDR      r1,|L1.1036|
0000e2  6809              LDR      r1,[r1,#0]
0000e4  f4410100          ORR      r1,r1,#0x800000
0000e8  4aca              LDR      r2,|L1.1044|
0000ea  f8c21304          STR      r1,[r2,#0x304]
0000ee  e006              B        |L1.254|
                  |L1.240|
;;;599      }
;;;600      else
;;;601      {
;;;602        /* Disable the temperature sensor and Vrefint channel*/
;;;603        ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
0000f0  49c6              LDR      r1,|L1.1036|
0000f2  6809              LDR      r1,[r1,#0]
0000f4  f4210100          BIC      r1,r1,#0x800000
0000f8  4ac6              LDR      r2,|L1.1044|
0000fa  f8c21304          STR      r1,[r2,#0x304]
                  |L1.254|
;;;604      }
;;;605    }
0000fe  4770              BX       lr
;;;606    
                          ENDP

                  ADC_VBATCmd PROC
;;;612      */
;;;613    void ADC_VBATCmd(FunctionalState NewState)                             
000100  b138              CBZ      r0,|L1.274|
;;;614    {
;;;615      /* Check the parameters */
;;;616      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;617      if (NewState != DISABLE)
;;;618      {
;;;619        /* Enable the VBAT channel*/
;;;620        ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
000102  49c2              LDR      r1,|L1.1036|
000104  6809              LDR      r1,[r1,#0]
000106  f4410180          ORR      r1,r1,#0x400000
00010a  4ac2              LDR      r2,|L1.1044|
00010c  f8c21304          STR      r1,[r2,#0x304]
000110  e006              B        |L1.288|
                  |L1.274|
;;;621      }
;;;622      else
;;;623      {
;;;624        /* Disable the VBAT channel*/
;;;625        ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
000112  49be              LDR      r1,|L1.1036|
000114  6809              LDR      r1,[r1,#0]
000116  f4210180          BIC      r1,r1,#0x400000
00011a  4abe              LDR      r2,|L1.1044|
00011c  f8c21304          STR      r1,[r2,#0x304]
                  |L1.288|
;;;626      }
;;;627    }
000120  4770              BX       lr
;;;628    
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;713      */
;;;714    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000122  b5f0              PUSH     {r4-r7,lr}
;;;715    {
000124  4604              MOV      r4,r0
000126  460d              MOV      r5,r1
;;;716      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000128  2000              MOVS     r0,#0
00012a  2100              MOVS     r1,#0
;;;717      /* Check the parameters */
;;;718      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;719      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;720      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;721      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;722      
;;;723      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;724      if (ADC_Channel > ADC_Channel_9)
00012c  2d09              CMP      r5,#9
00012e  dd11              BLE      |L1.340|
;;;725      {
;;;726        /* Get the old register value */
;;;727        tmpreg1 = ADCx->SMPR1;
000130  68e0              LDR      r0,[r4,#0xc]
;;;728        
;;;729        /* Calculate the mask to clear */
;;;730        tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
000132  f1a5060a          SUB      r6,r5,#0xa
000136  eb060746          ADD      r7,r6,r6,LSL #1
00013a  2607              MOVS     r6,#7
00013c  fa06f107          LSL      r1,r6,r7
;;;731        
;;;732        /* Clear the old sample time */
;;;733        tmpreg1 &= ~tmpreg2;
000140  4388              BICS     r0,r0,r1
;;;734        
;;;735        /* Calculate the mask to set */
;;;736        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000142  f1a5060a          SUB      r6,r5,#0xa
000146  eb060646          ADD      r6,r6,r6,LSL #1
00014a  fa03f106          LSL      r1,r3,r6
;;;737        
;;;738        /* Set the new sample time */
;;;739        tmpreg1 |= tmpreg2;
00014e  4308              ORRS     r0,r0,r1
;;;740        
;;;741        /* Store the new register value */
;;;742        ADCx->SMPR1 = tmpreg1;
000150  60e0              STR      r0,[r4,#0xc]
000152  e00c              B        |L1.366|
                  |L1.340|
;;;743      }
;;;744      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;745      {
;;;746        /* Get the old register value */
;;;747        tmpreg1 = ADCx->SMPR2;
000154  6920              LDR      r0,[r4,#0x10]
;;;748        
;;;749        /* Calculate the mask to clear */
;;;750        tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
000156  eb050745          ADD      r7,r5,r5,LSL #1
00015a  2607              MOVS     r6,#7
00015c  fa06f107          LSL      r1,r6,r7
;;;751        
;;;752        /* Clear the old sample time */
;;;753        tmpreg1 &= ~tmpreg2;
000160  4388              BICS     r0,r0,r1
;;;754        
;;;755        /* Calculate the mask to set */
;;;756        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000162  eb050645          ADD      r6,r5,r5,LSL #1
000166  fa03f106          LSL      r1,r3,r6
;;;757        
;;;758        /* Set the new sample time */
;;;759        tmpreg1 |= tmpreg2;
00016a  4308              ORRS     r0,r0,r1
;;;760        
;;;761        /* Store the new register value */
;;;762        ADCx->SMPR2 = tmpreg1;
00016c  6120              STR      r0,[r4,#0x10]
                  |L1.366|
;;;763      }
;;;764      /* For Rank 1 to 6 */
;;;765      if (Rank < 7)
00016e  2a07              CMP      r2,#7
000170  da0f              BGE      |L1.402|
;;;766      {
;;;767        /* Get the old register value */
;;;768        tmpreg1 = ADCx->SQR3;
000172  6b60              LDR      r0,[r4,#0x34]
;;;769        
;;;770        /* Calculate the mask to clear */
;;;771        tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
000174  1e56              SUBS     r6,r2,#1
000176  eb060786          ADD      r7,r6,r6,LSL #2
00017a  261f              MOVS     r6,#0x1f
00017c  fa06f107          LSL      r1,r6,r7
;;;772        
;;;773        /* Clear the old SQx bits for the selected rank */
;;;774        tmpreg1 &= ~tmpreg2;
000180  4388              BICS     r0,r0,r1
;;;775        
;;;776        /* Calculate the mask to set */
;;;777        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
000182  1e56              SUBS     r6,r2,#1
000184  eb060686          ADD      r6,r6,r6,LSL #2
000188  fa05f106          LSL      r1,r5,r6
;;;778        
;;;779        /* Set the SQx bits for the selected rank */
;;;780        tmpreg1 |= tmpreg2;
00018c  4308              ORRS     r0,r0,r1
;;;781        
;;;782        /* Store the new register value */
;;;783        ADCx->SQR3 = tmpreg1;
00018e  6360              STR      r0,[r4,#0x34]
000190  e022              B        |L1.472|
                  |L1.402|
;;;784      }
;;;785      /* For Rank 7 to 12 */
;;;786      else if (Rank < 13)
000192  2a0d              CMP      r2,#0xd
000194  da0f              BGE      |L1.438|
;;;787      {
;;;788        /* Get the old register value */
;;;789        tmpreg1 = ADCx->SQR2;
000196  6b20              LDR      r0,[r4,#0x30]
;;;790        
;;;791        /* Calculate the mask to clear */
;;;792        tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
000198  1fd6              SUBS     r6,r2,#7
00019a  eb060786          ADD      r7,r6,r6,LSL #2
00019e  261f              MOVS     r6,#0x1f
0001a0  fa06f107          LSL      r1,r6,r7
;;;793        
;;;794        /* Clear the old SQx bits for the selected rank */
;;;795        tmpreg1 &= ~tmpreg2;
0001a4  4388              BICS     r0,r0,r1
;;;796        
;;;797        /* Calculate the mask to set */
;;;798        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
0001a6  1fd6              SUBS     r6,r2,#7
0001a8  eb060686          ADD      r6,r6,r6,LSL #2
0001ac  fa05f106          LSL      r1,r5,r6
;;;799        
;;;800        /* Set the SQx bits for the selected rank */
;;;801        tmpreg1 |= tmpreg2;
0001b0  4308              ORRS     r0,r0,r1
;;;802        
;;;803        /* Store the new register value */
;;;804        ADCx->SQR2 = tmpreg1;
0001b2  6320              STR      r0,[r4,#0x30]
0001b4  e010              B        |L1.472|
                  |L1.438|
;;;805      }
;;;806      /* For Rank 13 to 16 */
;;;807      else
;;;808      {
;;;809        /* Get the old register value */
;;;810        tmpreg1 = ADCx->SQR1;
0001b6  6ae0              LDR      r0,[r4,#0x2c]
;;;811        
;;;812        /* Calculate the mask to clear */
;;;813        tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
0001b8  f1a2060d          SUB      r6,r2,#0xd
0001bc  eb060786          ADD      r7,r6,r6,LSL #2
0001c0  261f              MOVS     r6,#0x1f
0001c2  fa06f107          LSL      r1,r6,r7
;;;814        
;;;815        /* Clear the old SQx bits for the selected rank */
;;;816        tmpreg1 &= ~tmpreg2;
0001c6  4388              BICS     r0,r0,r1
;;;817        
;;;818        /* Calculate the mask to set */
;;;819        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
0001c8  f1a2060d          SUB      r6,r2,#0xd
0001cc  eb060686          ADD      r6,r6,r6,LSL #2
0001d0  fa05f106          LSL      r1,r5,r6
;;;820        
;;;821        /* Set the SQx bits for the selected rank */
;;;822        tmpreg1 |= tmpreg2;
0001d4  4308              ORRS     r0,r0,r1
;;;823        
;;;824        /* Store the new register value */
;;;825        ADCx->SQR1 = tmpreg1;
0001d6  62e0              STR      r0,[r4,#0x2c]
                  |L1.472|
;;;826      }
;;;827    }
0001d8  bdf0              POP      {r4-r7,pc}
;;;828    
                          ENDP

                  ADC_SoftwareStartConv PROC
;;;833      */
;;;834    void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
0001da  6881              LDR      r1,[r0,#8]
;;;835    {
;;;836      /* Check the parameters */
;;;837      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;838      
;;;839      /* Enable the selected ADC conversion for regular group */
;;;840      ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
0001dc  f0414180          ORR      r1,r1,#0x40000000
0001e0  6081              STR      r1,[r0,#8]
;;;841    }
0001e2  4770              BX       lr
;;;842    
                          ENDP

                  ADC_GetSoftwareStartConvStatus PROC
;;;847      */
;;;848    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
0001e4  4601              MOV      r1,r0
;;;849    {
;;;850      FlagStatus bitstatus = RESET;
0001e6  2000              MOVS     r0,#0
;;;851      /* Check the parameters */
;;;852      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;853      
;;;854      /* Check the status of SWSTART bit */
;;;855      if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
0001e8  688a              LDR      r2,[r1,#8]
0001ea  f4020280          AND      r2,r2,#0x400000
0001ee  b10a              CBZ      r2,|L1.500|
;;;856      {
;;;857        /* SWSTART bit is set */
;;;858        bitstatus = SET;
0001f0  2001              MOVS     r0,#1
0001f2  e000              B        |L1.502|
                  |L1.500|
;;;859      }
;;;860      else
;;;861      {
;;;862        /* SWSTART bit is reset */
;;;863        bitstatus = RESET;
0001f4  2000              MOVS     r0,#0
                  |L1.502|
;;;864      }
;;;865      
;;;866      /* Return the SWSTART bit status */
;;;867      return  bitstatus;
;;;868    }
0001f6  4770              BX       lr
;;;869    
                          ENDP

                  ADC_EOCOnEachRegularChannelCmd PROC
;;;877      */
;;;878    void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0001f8  b121              CBZ      r1,|L1.516|
;;;879    {
;;;880      /* Check the parameters */
;;;881      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;882      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;883      
;;;884      if (NewState != DISABLE)
;;;885      {
;;;886        /* Enable the selected ADC EOC rising on each regular channel conversion */
;;;887        ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
0001fa  6882              LDR      r2,[r0,#8]
0001fc  f4426280          ORR      r2,r2,#0x400
000200  6082              STR      r2,[r0,#8]
000202  e003              B        |L1.524|
                  |L1.516|
;;;888      }
;;;889      else
;;;890      {
;;;891        /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;892        ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
000204  6882              LDR      r2,[r0,#8]
000206  f4226280          BIC      r2,r2,#0x400
00020a  6082              STR      r2,[r0,#8]
                  |L1.524|
;;;893      }
;;;894    }
00020c  4770              BX       lr
;;;895    
                          ENDP

                  ADC_ContinuousModeCmd PROC
;;;902      */
;;;903    void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00020e  b121              CBZ      r1,|L1.538|
;;;904    {
;;;905      /* Check the parameters */
;;;906      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;907      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;908      
;;;909      if (NewState != DISABLE)
;;;910      {
;;;911        /* Enable the selected ADC continuous conversion mode */
;;;912        ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
000210  6882              LDR      r2,[r0,#8]
000212  f0420202          ORR      r2,r2,#2
000216  6082              STR      r2,[r0,#8]
000218  e003              B        |L1.546|
                  |L1.538|
;;;913      }
;;;914      else
;;;915      {
;;;916        /* Disable the selected ADC continuous conversion mode */
;;;917        ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
00021a  6882              LDR      r2,[r0,#8]
00021c  f0220202          BIC      r2,r2,#2
000220  6082              STR      r2,[r0,#8]
                  |L1.546|
;;;918      }
;;;919    }
000222  4770              BX       lr
;;;920    
                          ENDP

                  ADC_DiscModeChannelCountConfig PROC
;;;928      */
;;;929    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000224  b510              PUSH     {r4,lr}
;;;930    {
000226  460a              MOV      r2,r1
;;;931      uint32_t tmpreg1 = 0;
000228  2100              MOVS     r1,#0
;;;932      uint32_t tmpreg2 = 0;
00022a  2300              MOVS     r3,#0
;;;933      
;;;934      /* Check the parameters */
;;;935      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;936      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;937      
;;;938      /* Get the old register value */
;;;939      tmpreg1 = ADCx->CR1;
00022c  6841              LDR      r1,[r0,#4]
;;;940      
;;;941      /* Clear the old discontinuous mode channel count */
;;;942      tmpreg1 &= CR1_DISCNUM_RESET;
00022e  f4214160          BIC      r1,r1,#0xe000
;;;943      
;;;944      /* Set the discontinuous mode channel count */
;;;945      tmpreg2 = Number - 1;
000232  1e53              SUBS     r3,r2,#1
;;;946      tmpreg1 |= tmpreg2 << 13;
000234  ea413143          ORR      r1,r1,r3,LSL #13
;;;947      
;;;948      /* Store the new register value */
;;;949      ADCx->CR1 = tmpreg1;
000238  6041              STR      r1,[r0,#4]
;;;950    }
00023a  bd10              POP      {r4,pc}
;;;951    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;960      */
;;;961    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00023c  b121              CBZ      r1,|L1.584|
;;;962    {
;;;963      /* Check the parameters */
;;;964      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;965      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;966      
;;;967      if (NewState != DISABLE)
;;;968      {
;;;969        /* Enable the selected ADC regular discontinuous mode */
;;;970        ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
00023e  6842              LDR      r2,[r0,#4]
000240  f4426200          ORR      r2,r2,#0x800
000244  6042              STR      r2,[r0,#4]
000246  e003              B        |L1.592|
                  |L1.584|
;;;971      }
;;;972      else
;;;973      {
;;;974        /* Disable the selected ADC regular discontinuous mode */
;;;975        ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
000248  6842              LDR      r2,[r0,#4]
00024a  f4226200          BIC      r2,r2,#0x800
00024e  6042              STR      r2,[r0,#4]
                  |L1.592|
;;;976      }
;;;977    }
000250  4770              BX       lr
;;;978    
                          ENDP

                  ADC_GetConversionValue PROC
;;;983      */
;;;984    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000252  4601              MOV      r1,r0
;;;985    {
;;;986      /* Check the parameters */
;;;987      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;988      
;;;989      /* Return the selected ADC conversion value */
;;;990      return (uint16_t) ADCx->DR;
000254  6cc8              LDR      r0,[r1,#0x4c]
000256  b280              UXTH     r0,r0
;;;991    }
000258  4770              BX       lr
;;;992    
                          ENDP

                  ADC_GetMultiModeConversionValue PROC
;;;1004     */
;;;1005   uint32_t ADC_GetMultiModeConversionValue(void)
00025a  486c              LDR      r0,|L1.1036|
;;;1006   {
;;;1007     /* Return the multi mode conversion value */
;;;1008     return (*(__IO uint32_t *) CDR_ADDRESS);
00025c  1d00              ADDS     r0,r0,#4
00025e  6800              LDR      r0,[r0,#0]
;;;1009   }
000260  4770              BX       lr
;;;1010   /**
                          ENDP

                  ADC_DMACmd PROC
;;;1053     */
;;;1054   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000262  b121              CBZ      r1,|L1.622|
;;;1055   {
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1058     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1059     if (NewState != DISABLE)
;;;1060     {
;;;1061       /* Enable the selected ADC DMA request */
;;;1062       ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
000264  6882              LDR      r2,[r0,#8]
000266  f4427280          ORR      r2,r2,#0x100
00026a  6082              STR      r2,[r0,#8]
00026c  e003              B        |L1.630|
                  |L1.622|
;;;1063     }
;;;1064     else
;;;1065     {
;;;1066       /* Disable the selected ADC DMA request */
;;;1067       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
00026e  6882              LDR      r2,[r0,#8]
000270  f4227280          BIC      r2,r2,#0x100
000274  6082              STR      r2,[r0,#8]
                  |L1.630|
;;;1068     }
;;;1069   }
000276  4770              BX       lr
;;;1070   
                          ENDP

                  ADC_DMARequestAfterLastTransferCmd PROC
;;;1077     */
;;;1078   void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000278  b121              CBZ      r1,|L1.644|
;;;1079   {
;;;1080     /* Check the parameters */
;;;1081     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1082     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1083     if (NewState != DISABLE)
;;;1084     {
;;;1085       /* Enable the selected ADC DMA request after last transfer */
;;;1086       ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
00027a  6882              LDR      r2,[r0,#8]
00027c  f4427200          ORR      r2,r2,#0x200
000280  6082              STR      r2,[r0,#8]
000282  e003              B        |L1.652|
                  |L1.644|
;;;1087     }
;;;1088     else
;;;1089     {
;;;1090       /* Disable the selected ADC DMA request after last transfer */
;;;1091       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
000284  6882              LDR      r2,[r0,#8]
000286  f4227200          BIC      r2,r2,#0x200
00028a  6082              STR      r2,[r0,#8]
                  |L1.652|
;;;1092     }
;;;1093   }
00028c  4770              BX       lr
;;;1094   
                          ENDP

                  ADC_MultiModeDMARequestAfterLastTransferCmd PROC
;;;1104     */
;;;1105   void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
00028e  b138              CBZ      r0,|L1.672|
;;;1106   {
;;;1107     /* Check the parameters */
;;;1108     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1109     if (NewState != DISABLE)
;;;1110     {
;;;1111       /* Enable the selected ADC DMA request after last transfer */
;;;1112       ADC->CCR |= (uint32_t)ADC_CCR_DDS;
000290  495e              LDR      r1,|L1.1036|
000292  6809              LDR      r1,[r1,#0]
000294  f4415100          ORR      r1,r1,#0x2000
000298  4a5e              LDR      r2,|L1.1044|
00029a  f8c21304          STR      r1,[r2,#0x304]
00029e  e006              B        |L1.686|
                  |L1.672|
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       /* Disable the selected ADC DMA request after last transfer */
;;;1117       ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
0002a0  495a              LDR      r1,|L1.1036|
0002a2  6809              LDR      r1,[r1,#0]
0002a4  f4215100          BIC      r1,r1,#0x2000
0002a8  4a5a              LDR      r2,|L1.1044|
0002aa  f8c21304          STR      r1,[r2,#0x304]
                  |L1.686|
;;;1118     }
;;;1119   }
0002ae  4770              BX       lr
;;;1120   /**
                          ENDP

                  ADC_InjectedChannelConfig PROC
;;;1191     */
;;;1192   void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
0002b0  b5f0              PUSH     {r4-r7,lr}
;;;1193   {
0002b2  4604              MOV      r4,r0
0002b4  4615              MOV      r5,r2
;;;1194     uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
0002b6  2000              MOVS     r0,#0
0002b8  2200              MOVS     r2,#0
0002ba  2600              MOVS     r6,#0
;;;1195     /* Check the parameters */
;;;1196     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1197     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1198     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1199     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1200     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1201     if (ADC_Channel > ADC_Channel_9)
0002bc  2909              CMP      r1,#9
0002be  dd11              BLE      |L1.740|
;;;1202     {
;;;1203       /* Get the old register value */
;;;1204       tmpreg1 = ADCx->SMPR1;
0002c0  68e0              LDR      r0,[r4,#0xc]
;;;1205       /* Calculate the mask to clear */
;;;1206       tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
0002c2  f1a1070a          SUB      r7,r1,#0xa
0002c6  eb070c47          ADD      r12,r7,r7,LSL #1
0002ca  2707              MOVS     r7,#7
0002cc  fa07f20c          LSL      r2,r7,r12
;;;1207       /* Clear the old sample time */
;;;1208       tmpreg1 &= ~tmpreg2;
0002d0  4390              BICS     r0,r0,r2
;;;1209       /* Calculate the mask to set */
;;;1210       tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
0002d2  f1a1070a          SUB      r7,r1,#0xa
0002d6  eb070747          ADD      r7,r7,r7,LSL #1
0002da  fa03f207          LSL      r2,r3,r7
;;;1211       /* Set the new sample time */
;;;1212       tmpreg1 |= tmpreg2;
0002de  4310              ORRS     r0,r0,r2
;;;1213       /* Store the new register value */
;;;1214       ADCx->SMPR1 = tmpreg1;
0002e0  60e0              STR      r0,[r4,#0xc]
0002e2  e00c              B        |L1.766|
                  |L1.740|
;;;1215     }
;;;1216     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1217     {
;;;1218       /* Get the old register value */
;;;1219       tmpreg1 = ADCx->SMPR2;
0002e4  6920              LDR      r0,[r4,#0x10]
;;;1220       /* Calculate the mask to clear */
;;;1221       tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
0002e6  eb010c41          ADD      r12,r1,r1,LSL #1
0002ea  2707              MOVS     r7,#7
0002ec  fa07f20c          LSL      r2,r7,r12
;;;1222       /* Clear the old sample time */
;;;1223       tmpreg1 &= ~tmpreg2;
0002f0  4390              BICS     r0,r0,r2
;;;1224       /* Calculate the mask to set */
;;;1225       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
0002f2  eb010741          ADD      r7,r1,r1,LSL #1
0002f6  fa03f207          LSL      r2,r3,r7
;;;1226       /* Set the new sample time */
;;;1227       tmpreg1 |= tmpreg2;
0002fa  4310              ORRS     r0,r0,r2
;;;1228       /* Store the new register value */
;;;1229       ADCx->SMPR2 = tmpreg1;
0002fc  6120              STR      r0,[r4,#0x10]
                  |L1.766|
;;;1230     }
;;;1231     /* Rank configuration */
;;;1232     /* Get the old register value */
;;;1233     tmpreg1 = ADCx->JSQR;
0002fe  6ba0              LDR      r0,[r4,#0x38]
;;;1234     /* Get JL value: Number = JL+1 */
;;;1235     tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
000300  f3c05601          UBFX     r6,r0,#20,#2
;;;1236     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1237     tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000304  1cef              ADDS     r7,r5,#3
000306  f1060c01          ADD      r12,r6,#1
00030a  eba7070c          SUB      r7,r7,r12
00030e  eb070c87          ADD      r12,r7,r7,LSL #2
000312  271f              MOVS     r7,#0x1f
000314  fa07f20c          LSL      r2,r7,r12
;;;1238     /* Clear the old JSQx bits for the selected rank */
;;;1239     tmpreg1 &= ~tmpreg2;
000318  4390              BICS     r0,r0,r2
;;;1240     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1241     tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
00031a  1cef              ADDS     r7,r5,#3
00031c  f1060c01          ADD      r12,r6,#1
000320  eba7070c          SUB      r7,r7,r12
000324  eb070787          ADD      r7,r7,r7,LSL #2
000328  fa01f207          LSL      r2,r1,r7
;;;1242     /* Set the JSQx bits for the selected rank */
;;;1243     tmpreg1 |= tmpreg2;
00032c  4310              ORRS     r0,r0,r2
;;;1244     /* Store the new register value */
;;;1245     ADCx->JSQR = tmpreg1;
00032e  63a0              STR      r0,[r4,#0x38]
;;;1246   }
000330  bdf0              POP      {r4-r7,pc}
;;;1247   
                          ENDP

                  ADC_InjectedSequencerLengthConfig PROC
;;;1254     */
;;;1255   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000332  b510              PUSH     {r4,lr}
;;;1256   {
000334  460a              MOV      r2,r1
;;;1257     uint32_t tmpreg1 = 0;
000336  2100              MOVS     r1,#0
;;;1258     uint32_t tmpreg2 = 0;
000338  2300              MOVS     r3,#0
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1261     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1262     
;;;1263     /* Get the old register value */
;;;1264     tmpreg1 = ADCx->JSQR;
00033a  6b81              LDR      r1,[r0,#0x38]
;;;1265     
;;;1266     /* Clear the old injected sequence length JL bits */
;;;1267     tmpreg1 &= JSQR_JL_RESET;
00033c  f4211140          BIC      r1,r1,#0x300000
;;;1268     
;;;1269     /* Set the injected sequence length JL bits */
;;;1270     tmpreg2 = Length - 1; 
000340  1e53              SUBS     r3,r2,#1
;;;1271     tmpreg1 |= tmpreg2 << 20;
000342  ea415103          ORR      r1,r1,r3,LSL #20
;;;1272     
;;;1273     /* Store the new register value */
;;;1274     ADCx->JSQR = tmpreg1;
000346  6381              STR      r1,[r0,#0x38]
;;;1275   }
000348  bd10              POP      {r4,pc}
;;;1276   
                          ENDP

                  ADC_SetInjectedOffset PROC
;;;1289     */
;;;1290   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
00034a  b508              PUSH     {r3,lr}
;;;1291   {
;;;1292       __IO uint32_t tmp = 0;
00034c  2300              MOVS     r3,#0
00034e  9300              STR      r3,[sp,#0]
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1295     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1296     assert_param(IS_ADC_OFFSET(Offset));
;;;1297     
;;;1298     tmp = (uint32_t)ADCx;
000350  9000              STR      r0,[sp,#0]
;;;1299     tmp += ADC_InjectedChannel;
000352  9b00              LDR      r3,[sp,#0]
000354  440b              ADD      r3,r3,r1
000356  9300              STR      r3,[sp,#0]
;;;1300     
;;;1301     /* Set the selected injected channel data offset */
;;;1302    *(__IO uint32_t *) tmp = (uint32_t)Offset;
000358  9b00              LDR      r3,[sp,#0]
00035a  601a              STR      r2,[r3,#0]
;;;1303   }
00035c  bd08              POP      {r3,pc}
;;;1304   
                          ENDP

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;1327     */
;;;1328   void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
00035e  460a              MOV      r2,r1
;;;1329   {
;;;1330     uint32_t tmpreg = 0;
000360  2100              MOVS     r1,#0
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1333     assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;1334     
;;;1335     /* Get the old register value */
;;;1336     tmpreg = ADCx->CR2;
000362  6881              LDR      r1,[r0,#8]
;;;1337     
;;;1338     /* Clear the old external event selection for injected group */
;;;1339     tmpreg &= CR2_JEXTSEL_RESET;
000364  f4212170          BIC      r1,r1,#0xf0000
;;;1340     
;;;1341     /* Set the external event selection for injected group */
;;;1342     tmpreg |= ADC_ExternalTrigInjecConv;
000368  4311              ORRS     r1,r1,r2
;;;1343     
;;;1344     /* Store the new register value */
;;;1345     ADCx->CR2 = tmpreg;
00036a  6081              STR      r1,[r0,#8]
;;;1346   }
00036c  4770              BX       lr
;;;1347   
                          ENDP

                  ADC_ExternalTrigInjectedConvEdgeConfig PROC
;;;1361     */
;;;1362   void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
00036e  460a              MOV      r2,r1
;;;1363   {
;;;1364     uint32_t tmpreg = 0;
000370  2100              MOVS     r1,#0
;;;1365     /* Check the parameters */
;;;1366     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1367     assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
;;;1368     /* Get the old register value */
;;;1369     tmpreg = ADCx->CR2;
000372  6881              LDR      r1,[r0,#8]
;;;1370     /* Clear the old external trigger edge for injected group */
;;;1371     tmpreg &= CR2_JEXTEN_RESET;
000374  f4211140          BIC      r1,r1,#0x300000
;;;1372     /* Set the new external trigger edge for injected group */
;;;1373     tmpreg |= ADC_ExternalTrigInjecConvEdge;
000378  4311              ORRS     r1,r1,r2
;;;1374     /* Store the new register value */
;;;1375     ADCx->CR2 = tmpreg;
00037a  6081              STR      r1,[r0,#8]
;;;1376   }
00037c  4770              BX       lr
;;;1377   
                          ENDP

                  ADC_SoftwareStartInjectedConv PROC
;;;1382     */
;;;1383   void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
00037e  6881              LDR      r1,[r0,#8]
;;;1384   {
;;;1385     /* Check the parameters */
;;;1386     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1387     /* Enable the selected ADC conversion for injected group */
;;;1388     ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
000380  f4410180          ORR      r1,r1,#0x400000
000384  6081              STR      r1,[r0,#8]
;;;1389   }
000386  4770              BX       lr
;;;1390   
                          ENDP

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;1395     */
;;;1396   FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000388  4601              MOV      r1,r0
;;;1397   {
;;;1398     FlagStatus bitstatus = RESET;
00038a  2000              MOVS     r0,#0
;;;1399     /* Check the parameters */
;;;1400     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1401     
;;;1402     /* Check the status of JSWSTART bit */
;;;1403     if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
00038c  688a              LDR      r2,[r1,#8]
00038e  f4020280          AND      r2,r2,#0x400000
000392  b10a              CBZ      r2,|L1.920|
;;;1404     {
;;;1405       /* JSWSTART bit is set */
;;;1406       bitstatus = SET;
000394  2001              MOVS     r0,#1
000396  e000              B        |L1.922|
                  |L1.920|
;;;1407     }
;;;1408     else
;;;1409     {
;;;1410       /* JSWSTART bit is reset */
;;;1411       bitstatus = RESET;
000398  2000              MOVS     r0,#0
                  |L1.922|
;;;1412     }
;;;1413     /* Return the JSWSTART bit status */
;;;1414     return  bitstatus;
;;;1415   }
00039a  4770              BX       lr
;;;1416   
                          ENDP

                  ADC_AutoInjectedConvCmd PROC
;;;1424     */
;;;1425   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00039c  b121              CBZ      r1,|L1.936|
;;;1426   {
;;;1427     /* Check the parameters */
;;;1428     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1429     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1430     if (NewState != DISABLE)
;;;1431     {
;;;1432       /* Enable the selected ADC automatic injected group conversion */
;;;1433       ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
00039e  6842              LDR      r2,[r0,#4]
0003a0  f4426280          ORR      r2,r2,#0x400
0003a4  6042              STR      r2,[r0,#4]
0003a6  e003              B        |L1.944|
                  |L1.936|
;;;1434     }
;;;1435     else
;;;1436     {
;;;1437       /* Disable the selected ADC automatic injected group conversion */
;;;1438       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
0003a8  6842              LDR      r2,[r0,#4]
0003aa  f4226280          BIC      r2,r2,#0x400
0003ae  6042              STR      r2,[r0,#4]
                  |L1.944|
;;;1439     }
;;;1440   }
0003b0  4770              BX       lr
;;;1441   
                          ENDP

                  ADC_InjectedDiscModeCmd PROC
;;;1450     */
;;;1451   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0003b2  b121              CBZ      r1,|L1.958|
;;;1452   {
;;;1453     /* Check the parameters */
;;;1454     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1455     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1456     if (NewState != DISABLE)
;;;1457     {
;;;1458       /* Enable the selected ADC injected discontinuous mode */
;;;1459       ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
0003b4  6842              LDR      r2,[r0,#4]
0003b6  f4425280          ORR      r2,r2,#0x1000
0003ba  6042              STR      r2,[r0,#4]
0003bc  e003              B        |L1.966|
                  |L1.958|
;;;1460     }
;;;1461     else
;;;1462     {
;;;1463       /* Disable the selected ADC injected discontinuous mode */
;;;1464       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
0003be  6842              LDR      r2,[r0,#4]
0003c0  f4225280          BIC      r2,r2,#0x1000
0003c4  6042              STR      r2,[r0,#4]
                  |L1.966|
;;;1465     }
;;;1466   }
0003c6  4770              BX       lr
;;;1467   
                          ENDP

                  ADC_GetInjectedConversionValue PROC
;;;1478     */
;;;1479   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
0003c8  b508              PUSH     {r3,lr}
;;;1480   {
0003ca  4602              MOV      r2,r0
;;;1481     __IO uint32_t tmp = 0;
0003cc  2000              MOVS     r0,#0
0003ce  9000              STR      r0,[sp,#0]
;;;1482     
;;;1483     /* Check the parameters */
;;;1484     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1485     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1486   
;;;1487     tmp = (uint32_t)ADCx;
0003d0  9200              STR      r2,[sp,#0]
;;;1488     tmp += ADC_InjectedChannel + JDR_OFFSET;
0003d2  f1010028          ADD      r0,r1,#0x28
0003d6  9b00              LDR      r3,[sp,#0]
0003d8  4418              ADD      r0,r0,r3
0003da  9000              STR      r0,[sp,#0]
;;;1489     
;;;1490     /* Returns the selected injected channel conversion data value */
;;;1491     return (uint16_t) (*(__IO uint32_t*)  tmp); 
0003dc  9800              LDR      r0,[sp,#0]
0003de  6800              LDR      r0,[r0,#0]
0003e0  b280              UXTH     r0,r0
;;;1492   }
0003e2  bd08              POP      {r3,pc}
;;;1493   /**
                          ENDP

                  ADC_ITConfig PROC
;;;1586     */
;;;1587   void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
0003e4  b510              PUSH     {r4,lr}
;;;1588   {
0003e6  460b              MOV      r3,r1
;;;1589     uint32_t itmask = 0;
0003e8  2100              MOVS     r1,#0
;;;1590     /* Check the parameters */
;;;1591     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1592     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1593     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1594   
;;;1595     /* Get the ADC IT index */
;;;1596     itmask = (uint8_t)ADC_IT;
0003ea  b2d9              UXTB     r1,r3
;;;1597     itmask = (uint32_t)0x01 << itmask;    
0003ec  2401              MOVS     r4,#1
0003ee  fa04f101          LSL      r1,r4,r1
;;;1598   
;;;1599     if (NewState != DISABLE)
0003f2  b11a              CBZ      r2,|L1.1020|
;;;1600     {
;;;1601       /* Enable the selected ADC interrupts */
;;;1602       ADCx->CR1 |= itmask;
0003f4  6844              LDR      r4,[r0,#4]
0003f6  430c              ORRS     r4,r4,r1
0003f8  6044              STR      r4,[r0,#4]
0003fa  e002              B        |L1.1026|
                  |L1.1020|
;;;1603     }
;;;1604     else
;;;1605     {
;;;1606       /* Disable the selected ADC interrupts */
;;;1607       ADCx->CR1 &= (~(uint32_t)itmask);
0003fc  6844              LDR      r4,[r0,#4]
0003fe  438c              BICS     r4,r4,r1
000400  6044              STR      r4,[r0,#4]
                  |L1.1026|
;;;1608     }
;;;1609   }
000402  bd10              POP      {r4,pc}
                  |L1.1028|
                          DCD      0xfcfffeff
                  |L1.1032|
                          DCD      0xc0fff7fd
                  |L1.1036|
                          DCD      0x40012304
                  |L1.1040|
                          DCD      0xfffc30e0
                  |L1.1044|
                          DCD      0x40012000
                  |L1.1048|
                          DCD      0xff3ffdff
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1623     */
;;;1624   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
00041c  4602              MOV      r2,r0
;;;1625   {
;;;1626     FlagStatus bitstatus = RESET;
00041e  2000              MOVS     r0,#0
;;;1627     /* Check the parameters */
;;;1628     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1629     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1630   
;;;1631     /* Check the status of the specified ADC flag */
;;;1632     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000420  6813              LDR      r3,[r2,#0]
000422  400b              ANDS     r3,r3,r1
000424  b10b              CBZ      r3,|L1.1066|
;;;1633     {
;;;1634       /* ADC_FLAG is set */
;;;1635       bitstatus = SET;
000426  2001              MOVS     r0,#1
000428  e000              B        |L1.1068|
                  |L1.1066|
;;;1636     }
;;;1637     else
;;;1638     {
;;;1639       /* ADC_FLAG is reset */
;;;1640       bitstatus = RESET;
00042a  2000              MOVS     r0,#0
                  |L1.1068|
;;;1641     }
;;;1642     /* Return the ADC_FLAG status */
;;;1643     return  bitstatus;
;;;1644   }
00042c  4770              BX       lr
;;;1645   
                          ENDP

                  ADC_ClearFlag PROC
;;;1658     */
;;;1659   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
00042e  43ca              MVNS     r2,r1
;;;1660   {
;;;1661     /* Check the parameters */
;;;1662     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1663     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1664   
;;;1665     /* Clear the selected ADC flags */
;;;1666     ADCx->SR = ~(uint32_t)ADC_FLAG;
000430  6002              STR      r2,[r0,#0]
;;;1667   }
000432  4770              BX       lr
;;;1668   
                          ENDP

                  ADC_GetITStatus PROC
;;;1679     */
;;;1680   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000434  b570              PUSH     {r4-r6,lr}
;;;1681   {
000436  4602              MOV      r2,r0
;;;1682     ITStatus bitstatus = RESET;
000438  2000              MOVS     r0,#0
;;;1683     uint32_t itmask = 0, enablestatus = 0;
00043a  2300              MOVS     r3,#0
00043c  2400              MOVS     r4,#0
;;;1684   
;;;1685     /* Check the parameters */
;;;1686     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1687     assert_param(IS_ADC_IT(ADC_IT));
;;;1688   
;;;1689     /* Get the ADC IT index */
;;;1690     itmask = ADC_IT >> 8;
00043e  120b              ASRS     r3,r1,#8
;;;1691   
;;;1692     /* Get the ADC_IT enable bit status */
;;;1693     enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
000440  6855              LDR      r5,[r2,#4]
000442  2601              MOVS     r6,#1
000444  408e              LSLS     r6,r6,r1
000446  ea050406          AND      r4,r5,r6
;;;1694   
;;;1695     /* Check the status of the specified ADC interrupt */
;;;1696     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
00044a  6815              LDR      r5,[r2,#0]
00044c  401d              ANDS     r5,r5,r3
00044e  b115              CBZ      r5,|L1.1110|
000450  b10c              CBZ      r4,|L1.1110|
;;;1697     {
;;;1698       /* ADC_IT is set */
;;;1699       bitstatus = SET;
000452  2001              MOVS     r0,#1
000454  e000              B        |L1.1112|
                  |L1.1110|
;;;1700     }
;;;1701     else
;;;1702     {
;;;1703       /* ADC_IT is reset */
;;;1704       bitstatus = RESET;
000456  2000              MOVS     r0,#0
                  |L1.1112|
;;;1705     }
;;;1706     /* Return the ADC_IT status */
;;;1707     return  bitstatus;
;;;1708   }
000458  bd70              POP      {r4-r6,pc}
;;;1709   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1720     */
;;;1721   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
00045a  2200              MOVS     r2,#0
;;;1722   {
;;;1723     uint8_t itmask = 0;
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1726     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1727     /* Get the ADC IT index */
;;;1728     itmask = (uint8_t)(ADC_IT >> 8);
00045c  120a              ASRS     r2,r1,#8
;;;1729     /* Clear the selected ADC interrupt pending bits */
;;;1730     ADCx->SR = ~(uint32_t)itmask;
00045e  43d3              MVNS     r3,r2
000460  6003              STR      r3,[r0,#0]
;;;1731   }                    
000462  4770              BX       lr
;;;1732   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_adc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_adc_c_e11a2ea2____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_adc_c_e11a2ea2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_adc_c_e11a2ea2____REVSH|
#line 128
|__asm___15_stm32f4xx_adc_c_e11a2ea2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
