; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\rt_system.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\rt_system.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\rt_system.crf ..\..\libraries\rtx-v4.73\SRC\rt_System.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_tsk_lock PROC
;;;172    
;;;173    void rt_tsk_lock (void) {
000000  48b9              LDR      r0,|L1.744|
;;;174      /* Prevent task switching by locking out scheduler */
;;;175      if (os_tick_irqn < 0) {
000002  6800              LDR      r0,[r0,#0]  ; os_tick_irqn
000004  2800              CMP      r0,#0
000006  da11              BGE      |L1.44|
;;;176        OS_LOCK();
000008  2005              MOVS     r0,#5
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;177        os_lock = __TRUE;
000010  2001              MOVS     r0,#1
000012  49b6              LDR      r1,|L1.748|
000014  7008              STRB     r0,[r1,#0]
;;;178        OS_UNPEND (&pend_flags);
000016  48b6              LDR      r0,|L1.752|
000018  6800              LDR      r0,[r0,#0]
00001a  2105              MOVS     r1,#5
00001c  ea016090          AND      r0,r1,r0,LSR #26
000020  49b4              LDR      r1,|L1.756|
000022  7008              STRB     r0,[r1,#0]
000024  0640              LSLS     r0,r0,#25
000026  49b2              LDR      r1,|L1.752|
000028  6008              STR      r0,[r1,#0]
00002a  e019              B        |L1.96|
                  |L1.44|
;;;179      } else {
;;;180        OS_X_LOCK(os_tick_irqn);
00002c  48ae              LDR      r0,|L1.744|
00002e  7800              LDRB     r0,[r0,#0]  ; os_tick_irqn
000030  f000011f          AND      r1,r0,#0x1f
000034  2001              MOVS     r0,#1
000036  4088              LSLS     r0,r0,r1
000038  49ab              LDR      r1,|L1.744|
00003a  6809              LDR      r1,[r1,#0]  ; os_tick_irqn
00003c  1149              ASRS     r1,r1,#5
00003e  0089              LSLS     r1,r1,#2
000040  f10121e0          ADD      r1,r1,#0xe000e000
000044  f8c10180          STR      r0,[r1,#0x180]
;;;181        os_lock = __TRUE;
000048  2001              MOVS     r0,#1
00004a  49a8              LDR      r1,|L1.748|
00004c  7008              STRB     r0,[r1,#0]
;;;182        OS_X_UNPEND (&pend_flags);
00004e  48a8              LDR      r0,|L1.752|
000050  6800              LDR      r0,[r0,#0]
000052  f3c07000          UBFX     r0,r0,#28,#1
000056  49a7              LDR      r1,|L1.756|
000058  7008              STRB     r0,[r1,#0]
00005a  06c0              LSLS     r0,r0,#27
00005c  49a4              LDR      r1,|L1.752|
00005e  6008              STR      r0,[r1,#0]
                  |L1.96|
;;;183      }
;;;184    }
000060  4770              BX       lr
;;;185    
                          ENDP

                  rt_suspend PROC
;;;82     
;;;83     U32 rt_suspend (void) {
000062  b570              PUSH     {r4-r6,lr}
;;;84       /* Suspend OS scheduler */
;;;85       U32 delta = 0xFFFF;
000064  f64f75ff          MOV      r5,#0xffff
;;;86     #ifdef __CMSIS_RTOS
;;;87       U32 sleep;
;;;88     #endif
;;;89     
;;;90       rt_tsk_lock();
000068  f7fffffe          BL       rt_tsk_lock
;;;91       
;;;92       if (os_dly.p_dlnk) {
00006c  48a2              LDR      r0,|L1.760|
00006e  68c0              LDR      r0,[r0,#0xc]  ; os_dly
000070  b108              CBZ      r0,|L1.118|
;;;93         delta = os_dly.delta_time;
000072  48a1              LDR      r0,|L1.760|
000074  8a85              LDRH     r5,[r0,#0x14]  ; os_dly
                  |L1.118|
;;;94       }
;;;95     #ifdef __CMSIS_RTOS
;;;96       sleep = sysUserTimerWakeupTime();
000076  f7fffffe          BL       sysUserTimerWakeupTime
00007a  4604              MOV      r4,r0
;;;97       if (sleep < delta) delta = sleep;
00007c  42ac              CMP      r4,r5
00007e  d200              BCS      |L1.130|
000080  4625              MOV      r5,r4
                  |L1.130|
;;;98     #else
;;;99       if (os_tmr.next) {
;;;100        if (os_tmr.tcnt < delta) delta = os_tmr.tcnt;
;;;101      }
;;;102    #endif
;;;103    
;;;104      return (delta);
000082  4628              MOV      r0,r5
;;;105    }
000084  bd70              POP      {r4-r6,pc}
;;;106    
                          ENDP

                  rt_tsk_unlock PROC
;;;188    
;;;189    void rt_tsk_unlock (void) {
000086  4898              LDR      r0,|L1.744|
;;;190      /* Unlock scheduler and re-enable task switching */
;;;191      if (os_tick_irqn < 0) {
000088  6800              LDR      r0,[r0,#0]  ; os_tick_irqn
00008a  2800              CMP      r0,#0
00008c  da13              BGE      |L1.182|
;;;192        OS_UNLOCK();
00008e  2007              MOVS     r0,#7
000090  f04f21e0          MOV      r1,#0xe000e000
000094  6108              STR      r0,[r1,#0x10]
;;;193        os_lock = __FALSE;
000096  2000              MOVS     r0,#0
000098  4994              LDR      r1,|L1.748|
00009a  7008              STRB     r0,[r1,#0]
;;;194        OS_PEND (pend_flags, os_psh_flag);
00009c  4895              LDR      r0,|L1.756|
00009e  7800              LDRB     r0,[r0,#0]  ; pend_flags
0000a0  4996              LDR      r1,|L1.764|
0000a2  7809              LDRB     r1,[r1,#0]  ; os_psh_flag
0000a4  ea400081          ORR      r0,r0,r1,LSL #2
0000a8  0680              LSLS     r0,r0,#26
0000aa  4991              LDR      r1,|L1.752|
0000ac  6008              STR      r0,[r1,#0]
;;;195        os_psh_flag = __FALSE;
0000ae  2000              MOVS     r0,#0
0000b0  4992              LDR      r1,|L1.764|
0000b2  7008              STRB     r0,[r1,#0]
0000b4  e01b              B        |L1.238|
                  |L1.182|
;;;196      } else {
;;;197        OS_X_UNLOCK(os_tick_irqn);
0000b6  488c              LDR      r0,|L1.744|
0000b8  7800              LDRB     r0,[r0,#0]  ; os_tick_irqn
0000ba  f000011f          AND      r1,r0,#0x1f
0000be  2001              MOVS     r0,#1
0000c0  4088              LSLS     r0,r0,r1
0000c2  4989              LDR      r1,|L1.744|
0000c4  6809              LDR      r1,[r1,#0]  ; os_tick_irqn
0000c6  1149              ASRS     r1,r1,#5
0000c8  0089              LSLS     r1,r1,#2
0000ca  f10121e0          ADD      r1,r1,#0xe000e000
0000ce  f8c10100          STR      r0,[r1,#0x100]
;;;198        os_lock = __FALSE;
0000d2  2000              MOVS     r0,#0
0000d4  4985              LDR      r1,|L1.748|
0000d6  7008              STRB     r0,[r1,#0]
;;;199        OS_X_PEND (pend_flags, os_psh_flag);
0000d8  4886              LDR      r0,|L1.756|
0000da  7800              LDRB     r0,[r0,#0]  ; pend_flags
0000dc  4987              LDR      r1,|L1.764|
0000de  7809              LDRB     r1,[r1,#0]  ; os_psh_flag
0000e0  4308              ORRS     r0,r0,r1
0000e2  0700              LSLS     r0,r0,#28
0000e4  4982              LDR      r1,|L1.752|
0000e6  6008              STR      r0,[r1,#0]
;;;200        os_psh_flag = __FALSE;
0000e8  2000              MOVS     r0,#0
0000ea  4984              LDR      r1,|L1.764|
0000ec  7008              STRB     r0,[r1,#0]
                  |L1.238|
;;;201      }
;;;202    }
0000ee  4770              BX       lr
;;;203    
                          ENDP

                  rt_resume PROC
;;;111    
;;;112    void rt_resume (U32 sleep_time) {
0000f0  b570              PUSH     {r4-r6,lr}
0000f2  4605              MOV      r5,r0
;;;113      /* Resume OS scheduler after suspend */
;;;114      P_TCB next;
;;;115      U32   delta;
;;;116    
;;;117      os_tsk.run->state = READY;
0000f4  2001              MOVS     r0,#1
0000f6  4982              LDR      r1,|L1.768|
0000f8  6809              LDR      r1,[r1,#0]  ; os_tsk
0000fa  7048              STRB     r0,[r1,#1]
;;;118      rt_put_rdy_first (os_tsk.run);
0000fc  4980              LDR      r1,|L1.768|
0000fe  6808              LDR      r0,[r1,#0]  ; os_tsk
000100  f7fffffe          BL       rt_put_rdy_first
;;;119    
;;;120      os_robin.task = NULL;
000104  2000              MOVS     r0,#0
000106  497f              LDR      r1,|L1.772|
000108  6008              STR      r0,[r1,#0]  ; os_robin
;;;121    
;;;122      /* Update delays. */
;;;123      if (os_dly.p_dlnk) {
00010a  487b              LDR      r0,|L1.760|
00010c  68c0              LDR      r0,[r0,#0xc]  ; os_dly
00010e  b360              CBZ      r0,|L1.362|
;;;124        delta = sleep_time;
000110  462c              MOV      r4,r5
;;;125        if (delta >= os_dly.delta_time) {
000112  4879              LDR      r0,|L1.760|
000114  8a80              LDRH     r0,[r0,#0x14]  ; os_dly
000116  42a0              CMP      r0,r4
000118  d81c              BHI      |L1.340|
;;;126          delta   -= os_dly.delta_time;
00011a  4877              LDR      r0,|L1.760|
00011c  8a80              LDRH     r0,[r0,#0x14]  ; os_dly
00011e  1a24              SUBS     r4,r4,r0
;;;127          os_time += os_dly.delta_time;
000120  4875              LDR      r0,|L1.760|
000122  8a80              LDRH     r0,[r0,#0x14]  ; os_dly
000124  4978              LDR      r1,|L1.776|
000126  6809              LDR      r1,[r1,#0]  ; os_time
000128  4408              ADD      r0,r0,r1
00012a  4977              LDR      r1,|L1.776|
00012c  6008              STR      r0,[r1,#0]  ; os_time
;;;128          os_dly.delta_time = 1;
00012e  2001              MOVS     r0,#1
000130  4971              LDR      r1,|L1.760|
000132  8288              STRH     r0,[r1,#0x14]
;;;129          while (os_dly.p_dlnk) {
000134  e009              B        |L1.330|
                  |L1.310|
;;;130            rt_dec_dly();
000136  f7fffffe          BL       rt_dec_dly
;;;131            if (delta == 0) break;
00013a  b904              CBNZ     r4,|L1.318|
00013c  e009              B        |L1.338|
                  |L1.318|
;;;132            delta--;
00013e  1e64              SUBS     r4,r4,#1
;;;133            os_time++;
000140  4871              LDR      r0,|L1.776|
000142  6800              LDR      r0,[r0,#0]  ; os_time
000144  1c40              ADDS     r0,r0,#1
000146  4970              LDR      r1,|L1.776|
000148  6008              STR      r0,[r1,#0]  ; os_time
                  |L1.330|
00014a  486b              LDR      r0,|L1.760|
00014c  68c0              LDR      r0,[r0,#0xc]          ;129  ; os_dly
00014e  2800              CMP      r0,#0                 ;129
000150  d1f1              BNE      |L1.310|
                  |L1.338|
000152  e00f              B        |L1.372|
                  |L1.340|
;;;134          }
;;;135        } else {
;;;136          os_time           += delta;
000154  486c              LDR      r0,|L1.776|
000156  6800              LDR      r0,[r0,#0]  ; os_time
000158  4420              ADD      r0,r0,r4
00015a  496b              LDR      r1,|L1.776|
00015c  6008              STR      r0,[r1,#0]  ; os_time
;;;137          os_dly.delta_time -= delta;
00015e  4866              LDR      r0,|L1.760|
000160  8a80              LDRH     r0,[r0,#0x14]  ; os_dly
000162  1b00              SUBS     r0,r0,r4
000164  4964              LDR      r1,|L1.760|
000166  8288              STRH     r0,[r1,#0x14]
000168  e004              B        |L1.372|
                  |L1.362|
;;;138        }
;;;139      } else {
;;;140        os_time += sleep_time;
00016a  4867              LDR      r0,|L1.776|
00016c  6800              LDR      r0,[r0,#0]  ; os_time
00016e  4428              ADD      r0,r0,r5
000170  4965              LDR      r1,|L1.776|
000172  6008              STR      r0,[r1,#0]  ; os_time
                  |L1.372|
;;;141      }
;;;142    
;;;143      /* Check the user timers. */
;;;144    #ifdef __CMSIS_RTOS
;;;145      sysUserTimerUpdate(sleep_time);
000174  4628              MOV      r0,r5
000176  f7fffffe          BL       sysUserTimerUpdate
;;;146    #else
;;;147      if (os_tmr.next) {
;;;148        delta = sleep_time;
;;;149        if (delta >= os_tmr.tcnt) {
;;;150          delta   -= os_tmr.tcnt;
;;;151          os_tmr.tcnt = 1;
;;;152          while (os_tmr.next) {
;;;153            rt_tmr_tick();
;;;154            if (delta == 0) break;
;;;155            delta--;
;;;156          }
;;;157        } else {
;;;158          os_tmr.tcnt -= delta;
;;;159        }
;;;160      }
;;;161    #endif
;;;162    
;;;163      /* Switch back to highest ready task */
;;;164      next = rt_get_first (&os_rdy);
00017a  4864              LDR      r0,|L1.780|
00017c  f7fffffe          BL       rt_get_first
000180  4606              MOV      r6,r0
;;;165      rt_switch_req (next);
000182  4630              MOV      r0,r6
000184  f7fffffe          BL       rt_switch_req
;;;166    
;;;167      rt_tsk_unlock();
000188  f7fffffe          BL       rt_tsk_unlock
;;;168    }
00018c  bd70              POP      {r4-r6,pc}
;;;169    
                          ENDP

                  rt_psh_req PROC
;;;206    
;;;207    void rt_psh_req (void) {
00018e  4857              LDR      r0,|L1.748|
;;;208      /* Initiate a post service handling request if required. */
;;;209      if (os_lock == __FALSE) {
000190  7800              LDRB     r0,[r0,#0]  ; os_lock
000192  b920              CBNZ     r0,|L1.414|
;;;210        OS_PEND_IRQ ();
000194  f04f5080          MOV      r0,#0x10000000
000198  4955              LDR      r1,|L1.752|
00019a  6008              STR      r0,[r1,#0]
00019c  e002              B        |L1.420|
                  |L1.414|
;;;211      }
;;;212      else {
;;;213        os_psh_flag = __TRUE;
00019e  2001              MOVS     r0,#1
0001a0  4956              LDR      r1,|L1.764|
0001a2  7008              STRB     r0,[r1,#0]
                  |L1.420|
;;;214      }
;;;215    }
0001a4  4770              BX       lr
;;;216    
                          ENDP

                  rt_pop_req PROC
;;;219    
;;;220    void rt_pop_req (void) {
0001a6  b570              PUSH     {r4-r6,lr}
;;;221      /* Process an ISR post service requests. */
;;;222      struct OS_XCB *p_CB;
;;;223      P_TCB next;
;;;224      U32  idx;
;;;225    
;;;226      os_tsk.run->state = READY;
0001a8  2001              MOVS     r0,#1
0001aa  4955              LDR      r1,|L1.768|
0001ac  6809              LDR      r1,[r1,#0]  ; os_tsk
0001ae  7048              STRB     r0,[r1,#1]
;;;227      rt_put_rdy_first (os_tsk.run);
0001b0  4953              LDR      r1,|L1.768|
0001b2  6808              LDR      r0,[r1,#0]  ; os_tsk
0001b4  f7fffffe          BL       rt_put_rdy_first
;;;228    
;;;229      idx = os_psq->last;
0001b8  4855              LDR      r0,|L1.784|
0001ba  7844              LDRB     r4,[r0,#1]  ; os_fifo
;;;230      while (os_psq->count) {
0001bc  e032              B        |L1.548|
                  |L1.446|
;;;231        p_CB = os_psq->q[idx].id;
0001be  4854              LDR      r0,|L1.784|
0001c0  1d00              ADDS     r0,r0,#4
0001c2  f8505034          LDR      r5,[r0,r4,LSL #3]
;;;232        if (p_CB->cb_type == TCB) {
0001c6  7828              LDRB     r0,[r5,#0]
0001c8  b948              CBNZ     r0,|L1.478|
;;;233          /* Is of TCB type */
;;;234          rt_evt_psh ((P_TCB)p_CB, (U16)os_psq->q[idx].arg);
0001ca  4851              LDR      r0,|L1.784|
0001cc  1d00              ADDS     r0,r0,#4
0001ce  eb0000c4          ADD      r0,r0,r4,LSL #3
0001d2  8880              LDRH     r0,[r0,#4]
0001d4  b281              UXTH     r1,r0
0001d6  4628              MOV      r0,r5
0001d8  f7fffffe          BL       rt_evt_psh
0001dc  e00e              B        |L1.508|
                  |L1.478|
;;;235        }
;;;236        else if (p_CB->cb_type == MCB) {
0001de  7828              LDRB     r0,[r5,#0]
0001e0  2801              CMP      r0,#1
0001e2  d108              BNE      |L1.502|
;;;237          /* Is of MCB type */
;;;238          rt_mbx_psh ((P_MCB)p_CB, (void *)os_psq->q[idx].arg);
0001e4  484a              LDR      r0,|L1.784|
0001e6  1d00              ADDS     r0,r0,#4
0001e8  eb0000c4          ADD      r0,r0,r4,LSL #3
0001ec  6841              LDR      r1,[r0,#4]
0001ee  4628              MOV      r0,r5
0001f0  f7fffffe          BL       rt_mbx_psh
0001f4  e002              B        |L1.508|
                  |L1.502|
;;;239        }
;;;240        else {
;;;241          /* Must be of SCB type */
;;;242          rt_sem_psh ((P_SCB)p_CB);
0001f6  4628              MOV      r0,r5
0001f8  f7fffffe          BL       rt_sem_psh
                  |L1.508|
;;;243        }
;;;244        if (++idx == os_psq->size) idx = 0;
0001fc  1c60              ADDS     r0,r4,#1
0001fe  4604              MOV      r4,r0
000200  4943              LDR      r1,|L1.784|
000202  78c9              LDRB     r1,[r1,#3]  ; os_fifo
000204  4288              CMP      r0,r1
000206  d100              BNE      |L1.522|
000208  2400              MOVS     r4,#0
                  |L1.522|
;;;245        rt_dec (&os_psq->count);
00020a  bf00              NOP      
                  |L1.524|
00020c  4840              LDR      r0,|L1.784|
00020e  1c80              ADDS     r0,r0,#2
000210  e8d00f4f          LDREXB   r0,[r0]
000214  1e40              SUBS     r0,r0,#1
000216  b2c1              UXTB     r1,r0
000218  483d              LDR      r0,|L1.784|
00021a  1c80              ADDS     r0,r0,#2
00021c  e8c01f42          STREXB   r2,r1,[r0]
000220  2a00              CMP      r2,#0
000222  d1f3              BNE      |L1.524|
                  |L1.548|
000224  483a              LDR      r0,|L1.784|
000226  7880              LDRB     r0,[r0,#2]            ;230  ; os_fifo
000228  2800              CMP      r0,#0                 ;230
00022a  d1c8              BNE      |L1.446|
;;;246      }
;;;247      os_psq->last = idx;
00022c  4938              LDR      r1,|L1.784|
00022e  704c              STRB     r4,[r1,#1]
;;;248    
;;;249      next = rt_get_first (&os_rdy);
000230  4836              LDR      r0,|L1.780|
000232  f7fffffe          BL       rt_get_first
000236  4606              MOV      r6,r0
;;;250      rt_switch_req (next);
000238  4630              MOV      r0,r6
00023a  f7fffffe          BL       rt_switch_req
;;;251    }
00023e  bd70              POP      {r4-r6,pc}
;;;252    
                          ENDP

                  os_tick_init PROC
;;;255    
;;;256    __weak int os_tick_init (void) {
000240  bf00              NOP      
000242  4834              LDR      r0,|L1.788|
000244  6800              LDR      r0,[r0,#0]  ; os_trv
000246  f04f21e0          MOV      r1,#0xe000e000
00024a  6148              STR      r0,[r1,#0x14]
00024c  2000              MOVS     r0,#0
00024e  6188              STR      r0,[r1,#0x18]
000250  2007              MOVS     r0,#7
000252  6108              STR      r0,[r1,#0x10]
000254  4826              LDR      r0,|L1.752|
000256  301c              ADDS     r0,r0,#0x1c
000258  6800              LDR      r0,[r0,#0]
00025a  f040407f          ORR      r0,r0,#0xff000000
00025e  4924              LDR      r1,|L1.752|
000260  311c              ADDS     r1,r1,#0x1c
000262  6008              STR      r0,[r1,#0]
000264  bf00              NOP      
;;;257      /* Initialize SysTick timer as system tick timer. */
;;;258      rt_systick_init();
;;;259      return (-1);  /* Return IRQ number of SysTick timer */
000266  1748              ASRS     r0,r1,#29
;;;260    }
000268  4770              BX       lr
;;;261    
                          ENDP

                  os_tick_val PROC
;;;263    
;;;264    __weak U32 os_tick_val (void) {
00026a  bf00              NOP      
00026c  f04f20e0          MOV      r0,#0xe000e000
000270  6980              LDR      r0,[r0,#0x18]
000272  4928              LDR      r1,|L1.788|
000274  6809              LDR      r1,[r1,#0]  ; os_trv
000276  1a08              SUBS     r0,r1,r0
;;;265      /* Get SysTick timer current value (0 .. OS_TRV). */
;;;266      return rt_systick_val();
;;;267    }
000278  4770              BX       lr
;;;268    
                          ENDP

                  os_tick_ovf PROC
;;;270    
;;;271    __weak U32 os_tick_ovf (void) {
00027a  bf00              NOP      
00027c  481c              LDR      r0,|L1.752|
00027e  6800              LDR      r0,[r0,#0]
000280  f3c06080          UBFX     r0,r0,#26,#1
;;;272      /* Get SysTick timer overflow flag */
;;;273      return rt_systick_ovf();
;;;274    }
000284  4770              BX       lr
;;;275    
                          ENDP

                  os_tick_irqack PROC
;;;277    
;;;278    __weak void os_tick_irqack (void) {
000286  4770              BX       lr
;;;279      /* Acknowledge timer interrupt. */
;;;280    }
;;;281    
                          ENDP

                  rt_systick PROC
;;;286    
;;;287    void rt_systick (void) {
000288  b510              PUSH     {r4,lr}
;;;288      /* Check for system clock update, suspend running task. */
;;;289      P_TCB next;
;;;290    
;;;291      os_tsk.run->state = READY;
00028a  2001              MOVS     r0,#1
00028c  491c              LDR      r1,|L1.768|
00028e  6809              LDR      r1,[r1,#0]  ; os_tsk
000290  7048              STRB     r0,[r1,#1]
;;;292      rt_put_rdy_first (os_tsk.run);
000292  491b              LDR      r1,|L1.768|
000294  6808              LDR      r0,[r1,#0]  ; os_tsk
000296  f7fffffe          BL       rt_put_rdy_first
;;;293    
;;;294      /* Check Round Robin timeout. */
;;;295      rt_chk_robin ();
00029a  f7fffffe          BL       rt_chk_robin
;;;296    
;;;297      /* Update delays. */
;;;298      os_time++;
00029e  481a              LDR      r0,|L1.776|
0002a0  6800              LDR      r0,[r0,#0]  ; os_time
0002a2  1c40              ADDS     r0,r0,#1
0002a4  4918              LDR      r1,|L1.776|
0002a6  6008              STR      r0,[r1,#0]  ; os_time
;;;299      rt_dec_dly ();
0002a8  f7fffffe          BL       rt_dec_dly
;;;300    
;;;301      /* Check the user timers. */
;;;302    #ifdef __CMSIS_RTOS
;;;303      sysTimerTick();
0002ac  f7fffffe          BL       sysTimerTick
;;;304    #else
;;;305      rt_tmr_tick ();
;;;306    #endif
;;;307    
;;;308      /* Switch back to highest ready task */
;;;309      next = rt_get_first (&os_rdy);
0002b0  4816              LDR      r0,|L1.780|
0002b2  f7fffffe          BL       rt_get_first
0002b6  4604              MOV      r4,r0
;;;310      rt_switch_req (next);
0002b8  4620              MOV      r0,r4
0002ba  f7fffffe          BL       rt_switch_req
;;;311    }
0002be  bd10              POP      {r4,pc}
;;;312    
                          ENDP

                  rt_stk_check PROC
;;;314    
;;;315    __weak void rt_stk_check (void) {
0002c0  b510              PUSH     {r4,lr}
;;;316      /* Check for stack overflow. */
;;;317      if ((os_tsk.run->tsk_stack < (U32)os_tsk.run->stack) || 
0002c2  480f              LDR      r0,|L1.768|
0002c4  6800              LDR      r0,[r0,#0]  ; os_tsk
0002c6  6a80              LDR      r0,[r0,#0x28]
0002c8  490d              LDR      r1,|L1.768|
0002ca  6809              LDR      r1,[r1,#0]  ; os_tsk
0002cc  6ac9              LDR      r1,[r1,#0x2c]
0002ce  4288              CMP      r0,r1
0002d0  d306              BCC      |L1.736|
;;;318          (os_tsk.run->stack[0] != MAGIC_WORD)) {
0002d2  480b              LDR      r0,|L1.768|
0002d4  6800              LDR      r0,[r0,#0]  ; os_tsk
0002d6  6ac0              LDR      r0,[r0,#0x2c]
0002d8  6800              LDR      r0,[r0,#0]
0002da  490f              LDR      r1,|L1.792|
0002dc  4288              CMP      r0,r1
0002de  d002              BEQ      |L1.742|
                  |L1.736|
;;;319        os_error (OS_ERR_STK_OVF);
0002e0  2001              MOVS     r0,#1
0002e2  f7fffffe          BL       os_error
                  |L1.742|
;;;320      }
;;;321    }
0002e6  bd10              POP      {r4,pc}
;;;322    
                          ENDP

                  |L1.744|
                          DCD      os_tick_irqn
                  |L1.748|
                          DCD      os_lock
                  |L1.752|
                          DCD      0xe000ed04
                  |L1.756|
                          DCD      pend_flags
                  |L1.760|
                          DCD      os_dly
                  |L1.764|
                          DCD      os_psh_flag
                  |L1.768|
                          DCD      os_tsk
                  |L1.772|
                          DCD      os_robin
                  |L1.776|
                          DCD      os_time
                  |L1.780|
                          DCD      os_rdy
                  |L1.784|
                          DCD      os_fifo
                  |L1.788|
                          DCD      os_trv
                  |L1.792|
                          DCD      0xe25a2ea5

                          AREA ||.data||, DATA, ALIGN=2

                  os_tick_irqn
                          DCD      0x00000000
                  os_lock
000004  00                DCB      0x00
                  os_psh_flag
000005  00                DCB      0x00
                  pend_flags
000006  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\rtx-v4.73\\SRC\\rt_System.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT ||$$RTX$$version||
#line 69
||$$RTX$$version|| PROC
#line 69

 

 EXPORT __RL_RTX_VER

__RL_RTX_VER EQU 0x473
	ENDP

;*** End   embedded assembler ***
