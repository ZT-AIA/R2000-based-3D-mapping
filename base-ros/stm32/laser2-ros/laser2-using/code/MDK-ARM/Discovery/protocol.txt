; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\protocol.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\protocol.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\protocol.crf ..\..\libraries\ptpd-2.0.0\src\protocol.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  toState PROC
;;;50     /* Perform actions required when leaving 'port_state' and entering 'state' */
;;;51     void toState(PtpClock *ptpClock, uint8_t state)
000000  b570              PUSH     {r4-r6,lr}
;;;52     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;53     	ptpClock->messageActivity = TRUE;
000006  2001              MOVS     r0,#1
000008  f88403c8          STRB     r0,[r4,#0x3c8]
;;;54     
;;;55     	DBG("leaving state %s\n", stateString(ptpClock->portDS.portState));
;;;56     
;;;57     	/* leaving state tasks */
;;;58     	switch (ptpClock->portDS.portState)
00000c  2062              MOVS     r0,#0x62
00000e  5d00              LDRB     r0,[r0,r4]
000010  1ec0              SUBS     r0,r0,#3
000012  2806              CMP      r0,#6
000014  d247              BCS      |L1.166|
000016  e8dff000          TBB      [pc,r0]
00001a  383f              DCB      0x38,0x3f
00001c  032e1011          DCB      0x03,0x2e,0x10,0x11
;;;59     	{
;;;60     		case PTP_MASTER:
;;;61     
;;;62     			initClock(ptpClock);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       initClock
;;;63     			timerStop(SYNC_INTERVAL_TIMER);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       timerStop
;;;64     			timerStop(ANNOUNCE_INTERVAL_TIMER);
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       timerStop
;;;65     			timerStop(PDELAYREQ_INTERVAL_TIMER);
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       timerStop
;;;66     			break;
000038  e036              B        |L1.168|
;;;67     
;;;68     		case PTP_UNCALIBRATED:
;;;69     		case PTP_SLAVE:
00003a  bf00              NOP      
;;;70     
;;;71     			if (state == PTP_UNCALIBRATED || state == PTP_SLAVE)
00003c  2d07              CMP      r5,#7
00003e  d001              BEQ      |L1.68|
000040  2d08              CMP      r5,#8
000042  d100              BNE      |L1.70|
                  |L1.68|
;;;72     			{
;;;73     				break;
000044  e030              B        |L1.168|
                  |L1.70|
;;;74     			}
;;;75     			timerStop(ANNOUNCE_RECEIPT_TIMER);
000046  2003              MOVS     r0,#3
000048  f7fffffe          BL       timerStop
;;;76     			switch (ptpClock->portDS.delayMechanism)
00004c  206f              MOVS     r0,#0x6f
00004e  5d00              LDRB     r0,[r0,r4]
000050  2801              CMP      r0,#1
000052  d002              BEQ      |L1.90|
000054  2802              CMP      r0,#2
000056  d108              BNE      |L1.106|
000058  e003              B        |L1.98|
                  |L1.90|
;;;77     			{
;;;78     				case E2E:
;;;79     					timerStop(DELAYREQ_INTERVAL_TIMER);
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       timerStop
;;;80     					break;
000060  e004              B        |L1.108|
                  |L1.98|
;;;81     				case P2P:
;;;82     					timerStop(PDELAYREQ_INTERVAL_TIMER);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       timerStop
;;;83     					break;
000068  e000              B        |L1.108|
                  |L1.106|
;;;84     				default:
;;;85     					/* none */
;;;86     					break;
00006a  bf00              NOP      
                  |L1.108|
00006c  bf00              NOP                            ;80
;;;87     			}
;;;88     			initClock(ptpClock);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       initClock
;;;89     
;;;90     			break;
000074  e018              B        |L1.168|
;;;91     
;;;92     		case PTP_PASSIVE:
;;;93     
;;;94     			initClock(ptpClock);
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       initClock
;;;95     			timerStop(PDELAYREQ_INTERVAL_TIMER);
00007c  2000              MOVS     r0,#0
00007e  f7fffffe          BL       timerStop
;;;96     			timerStop(ANNOUNCE_RECEIPT_TIMER);
000082  2003              MOVS     r0,#3
000084  f7fffffe          BL       timerStop
;;;97     			break;
000088  e00e              B        |L1.168|
;;;98     
;;;99     		case PTP_LISTENING:
;;;100    
;;;101    			initClock(ptpClock);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       initClock
;;;102    			timerStop(ANNOUNCE_RECEIPT_TIMER);
000090  2003              MOVS     r0,#3
000092  f7fffffe          BL       timerStop
;;;103    			break;
000096  e007              B        |L1.168|
;;;104    
;;;105    		case PTP_PRE_MASTER:
;;;106    
;;;107    			initClock(ptpClock);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       initClock
;;;108    			timerStop(QUALIFICATION_TIMEOUT);
00009e  2005              MOVS     r0,#5
0000a0  f7fffffe          BL       timerStop
;;;109    			break;
0000a4  e000              B        |L1.168|
                  |L1.166|
;;;110    
;;;111    		default:
;;;112    			break;
0000a6  bf00              NOP      
                  |L1.168|
0000a8  bf00              NOP                            ;66
;;;113    	}
;;;114    
;;;115    	DBG("entering state %s\n", stateString(state));
;;;116    
;;;117    	/* Entering state tasks */
;;;118    	switch (state)
0000aa  2d09              CMP      r5,#9
0000ac  d271              BCS      |L1.402|
0000ae  e8dff005          TBB      [pc,r5]
0000b2  050c              DCB      0x05,0x0c
0000b4  10143233          DCB      0x10,0x14,0x32,0x33
0000b8  86c1fc00          DCB      0x86,0xc1,0xfc,0x00
;;;119    	{
;;;120    		case PTP_INITIALIZING:
;;;121    
;;;122    			ptpClock->portDS.portState = PTP_INITIALIZING;
0000bc  2100              MOVS     r1,#0
0000be  2062              MOVS     r0,#0x62
0000c0  5501              STRB     r1,[r0,r4]
;;;123    			ptpClock->recommendedState = PTP_INITIALIZING;
0000c2  2000              MOVS     r0,#0
0000c4  f8840438          STRB     r0,[r4,#0x438]
;;;124    			break;
0000c8  e118              B        |L1.764|
;;;125    
;;;126    		case PTP_FAULTY:
;;;127    
;;;128    			ptpClock->portDS.portState = PTP_FAULTY;
0000ca  2101              MOVS     r1,#1
0000cc  2062              MOVS     r0,#0x62
0000ce  5501              STRB     r1,[r0,r4]
;;;129    			break;
0000d0  e114              B        |L1.764|
;;;130    
;;;131    		case PTP_DISABLED:
;;;132    
;;;133    			ptpClock->portDS.portState = PTP_DISABLED;
0000d2  2102              MOVS     r1,#2
0000d4  2062              MOVS     r0,#0x62
0000d6  5501              STRB     r1,[r0,r4]
;;;134    			break;
0000d8  e110              B        |L1.764|
;;;135    
;;;136    		case PTP_LISTENING:
;;;137    
;;;138    			timerStart(ANNOUNCE_RECEIPT_TIMER, (ptpClock->portDS.announceReceiptTimeout) * (pow2ms(ptpClock->portDS.logAnnounceInterval)));
0000da  206d              MOVS     r0,#0x6d
0000dc  5d02              LDRB     r2,[r0,r4]
0000de  f994006c          LDRSB    r0,[r4,#0x6c]
0000e2  2800              CMP      r0,#0
0000e4  dd05              BLE      |L1.242|
0000e6  206c              MOVS     r0,#0x6c
0000e8  5d03              LDRB     r3,[r0,r4]
0000ea  f44f707a          MOV      r0,#0x3e8
0000ee  4098              LSLS     r0,r0,r3
0000f0  e005              B        |L1.254|
                  |L1.242|
0000f2  206c              MOVS     r0,#0x6c
0000f4  5d00              LDRB     r0,[r0,r4]
0000f6  4243              RSBS     r3,r0,#0
0000f8  f44f707a          MOV      r0,#0x3e8
0000fc  4118              ASRS     r0,r0,r3
                  |L1.254|
0000fe  fb02f100          MUL      r1,r2,r0
000102  2003              MOVS     r0,#3
000104  f7fffffe          BL       timerStart
;;;139    			ptpClock->portDS.portState = PTP_LISTENING;
000108  2103              MOVS     r1,#3
00010a  2062              MOVS     r0,#0x62
00010c  5501              STRB     r1,[r0,r4]
;;;140    			ptpClock->recommendedState = PTP_LISTENING;
00010e  2003              MOVS     r0,#3
000110  f8840438          STRB     r0,[r4,#0x438]
;;;141    			break;
000114  e0f2              B        |L1.764|
;;;142    
;;;143    		case PTP_PRE_MASTER:
;;;144    
;;;145    			/* If you implement not ordinary clock, you can manage this code */
;;;146    			/* timerStart(QUALIFICATION_TIMEOUT, pow2ms(DEFAULT_QUALIFICATION_TIMEOUT));
;;;147    			ptpClock->portDS.portState = PTP_PRE_MASTER;
;;;148    			break;
;;;149    			*/
;;;150    
;;;151    		case PTP_MASTER:
000116  bf00              NOP      
;;;152    
;;;153    			ptpClock->portDS.logMinDelayReqInterval = DEFAULT_DELAYREQ_INTERVAL; /* it may change during slave state */
000118  2103              MOVS     r1,#3
00011a  2063              MOVS     r0,#0x63
00011c  5501              STRB     r1,[r0,r4]
;;;154    			timerStart(SYNC_INTERVAL_TIMER, pow2ms(ptpClock->portDS.logSyncInterval));
00011e  f994006e          LDRSB    r0,[r4,#0x6e]
000122  2800              CMP      r0,#0
000124  dd05              BLE      |L1.306|
000126  206e              MOVS     r0,#0x6e
000128  5d02              LDRB     r2,[r0,r4]
00012a  f44f707a          MOV      r0,#0x3e8
00012e  4090              LSLS     r0,r0,r2
000130  e005              B        |L1.318|
                  |L1.306|
000132  206e              MOVS     r0,#0x6e
000134  5d00              LDRB     r0,[r0,r4]
000136  4242              RSBS     r2,r0,#0
000138  f44f707a          MOV      r0,#0x3e8
00013c  4110              ASRS     r0,r0,r2
                  |L1.318|
00013e  4601              MOV      r1,r0
000140  2002              MOVS     r0,#2
000142  f7fffffe          BL       timerStart
;;;155    			DBG("SYNC INTERVAL TIMER : %d \n", pow2ms(ptpClock->portDS.logSyncInterval));
;;;156    			timerStart(ANNOUNCE_INTERVAL_TIMER, pow2ms(ptpClock->portDS.logAnnounceInterval));
000146  f994006c          LDRSB    r0,[r4,#0x6c]
00014a  2800              CMP      r0,#0
00014c  dd05              BLE      |L1.346|
00014e  206c              MOVS     r0,#0x6c
000150  5d02              LDRB     r2,[r0,r4]
000152  f44f707a          MOV      r0,#0x3e8
000156  4090              LSLS     r0,r0,r2
000158  e005              B        |L1.358|
                  |L1.346|
00015a  206c              MOVS     r0,#0x6c
00015c  5d00              LDRB     r0,[r0,r4]
00015e  4242              RSBS     r2,r0,#0
000160  f44f707a          MOV      r0,#0x3e8
000164  4110              ASRS     r0,r0,r2
                  |L1.358|
000166  4601              MOV      r1,r0
000168  2004              MOVS     r0,#4
00016a  f7fffffe          BL       timerStart
;;;157    
;;;158    			switch (ptpClock->portDS.delayMechanism)
00016e  206f              MOVS     r0,#0x6f
000170  5d00              LDRB     r0,[r0,r4]
000172  2801              CMP      r0,#1
000174  d002              BEQ      |L1.380|
000176  2802              CMP      r0,#2
000178  d11b              BNE      |L1.434|
00017a  e000              B        |L1.382|
                  |L1.380|
;;;159    			{
;;;160    				case E2E:
;;;161    						/* none */
;;;162    						break;
00017c  e01a              B        |L1.436|
                  |L1.382|
;;;163    				case P2P:
;;;164    						timerStart(PDELAYREQ_INTERVAL_TIMER, getRand(pow2ms(ptpClock->portDS.logMinPdelayReqInterval) + 1));
00017e  f9941070          LDRSB    r1,[r4,#0x70]
000182  2900              CMP      r1,#0
000184  dd06              BLE      |L1.404|
000186  2170              MOVS     r1,#0x70
000188  5d0a              LDRB     r2,[r1,r4]
00018a  f44f717a          MOV      r1,#0x3e8
00018e  4091              LSLS     r1,r1,r2
000190  e006              B        |L1.416|
                  |L1.402|
000192  e0b2              B        |L1.762|
                  |L1.404|
000194  2170              MOVS     r1,#0x70
000196  5d09              LDRB     r1,[r1,r4]
000198  424a              RSBS     r2,r1,#0
00019a  f44f717a          MOV      r1,#0x3e8
00019e  4111              ASRS     r1,r1,r2
                  |L1.416|
0001a0  1c48              ADDS     r0,r1,#1
0001a2  f7fffffe          BL       getRand
0001a6  4606              MOV      r6,r0
0001a8  4631              MOV      r1,r6
0001aa  2000              MOVS     r0,#0
0001ac  f7fffffe          BL       timerStart
;;;165    						break;
0001b0  e000              B        |L1.436|
                  |L1.434|
;;;166    				default:
;;;167    						break;
0001b2  bf00              NOP      
                  |L1.436|
0001b4  bf00              NOP                            ;162
;;;168    			}
;;;169    
;;;170    			ptpClock->portDS.portState = PTP_MASTER;
0001b6  2105              MOVS     r1,#5
0001b8  2062              MOVS     r0,#0x62
0001ba  5501              STRB     r1,[r0,r4]
;;;171    
;;;172    			break;
0001bc  e09e              B        |L1.764|
;;;173    
;;;174    		case PTP_PASSIVE:
;;;175    
;;;176    			timerStart(ANNOUNCE_RECEIPT_TIMER, (ptpClock->portDS.announceReceiptTimeout)*(pow2ms(ptpClock->portDS.logAnnounceInterval)));
0001be  206d              MOVS     r0,#0x6d
0001c0  5d02              LDRB     r2,[r0,r4]
0001c2  f994006c          LDRSB    r0,[r4,#0x6c]
0001c6  2800              CMP      r0,#0
0001c8  dd05              BLE      |L1.470|
0001ca  206c              MOVS     r0,#0x6c
0001cc  5d03              LDRB     r3,[r0,r4]
0001ce  f44f707a          MOV      r0,#0x3e8
0001d2  4098              LSLS     r0,r0,r3
0001d4  e005              B        |L1.482|
                  |L1.470|
0001d6  206c              MOVS     r0,#0x6c
0001d8  5d00              LDRB     r0,[r0,r4]
0001da  4243              RSBS     r3,r0,#0
0001dc  f44f707a          MOV      r0,#0x3e8
0001e0  4118              ASRS     r0,r0,r3
                  |L1.482|
0001e2  fb02f100          MUL      r1,r2,r0
0001e6  2003              MOVS     r0,#3
0001e8  f7fffffe          BL       timerStart
;;;177    			if (ptpClock->portDS.delayMechanism == P2P)
0001ec  206f              MOVS     r0,#0x6f
0001ee  5d00              LDRB     r0,[r0,r4]
0001f0  2802              CMP      r0,#2
0001f2  d11b              BNE      |L1.556|
;;;178    			{
;;;179    				timerStart(PDELAYREQ_INTERVAL_TIMER, getRand(pow2ms(ptpClock->portDS.logMinPdelayReqInterval + 1)));
0001f4  f9941070          LDRSB    r1,[r4,#0x70]
0001f8  1c49              ADDS     r1,r1,#1
0001fa  2900              CMP      r1,#0
0001fc  dd07              BLE      |L1.526|
0001fe  2170              MOVS     r1,#0x70
000200  5d09              LDRB     r1,[r1,r4]
000202  1c49              ADDS     r1,r1,#1
000204  f44f727a          MOV      r2,#0x3e8
000208  fa02f101          LSL      r1,r2,r1
00020c  e006              B        |L1.540|
                  |L1.526|
00020e  2170              MOVS     r1,#0x70
000210  5d09              LDRB     r1,[r1,r4]
000212  1c49              ADDS     r1,r1,#1
000214  424a              RSBS     r2,r1,#0
000216  f44f717a          MOV      r1,#0x3e8
00021a  4111              ASRS     r1,r1,r2
                  |L1.540|
00021c  4608              MOV      r0,r1
00021e  f7fffffe          BL       getRand
000222  4606              MOV      r6,r0
000224  4631              MOV      r1,r6
000226  2000              MOVS     r0,#0
000228  f7fffffe          BL       timerStart
                  |L1.556|
;;;180    			}
;;;181    			ptpClock->portDS.portState = PTP_PASSIVE;
00022c  2106              MOVS     r1,#6
00022e  2062              MOVS     r0,#0x62
000230  5501              STRB     r1,[r0,r4]
;;;182    
;;;183    			break;
000232  e063              B        |L1.764|
;;;184    
;;;185    		case PTP_UNCALIBRATED:
;;;186    
;;;187    			timerStart(ANNOUNCE_RECEIPT_TIMER, (ptpClock->portDS.announceReceiptTimeout)*(pow2ms(ptpClock->portDS.logAnnounceInterval)));
000234  206d              MOVS     r0,#0x6d
000236  5d02              LDRB     r2,[r0,r4]
000238  f994006c          LDRSB    r0,[r4,#0x6c]
00023c  2800              CMP      r0,#0
00023e  dd05              BLE      |L1.588|
000240  206c              MOVS     r0,#0x6c
000242  5d03              LDRB     r3,[r0,r4]
000244  f44f707a          MOV      r0,#0x3e8
000248  4098              LSLS     r0,r0,r3
00024a  e005              B        |L1.600|
                  |L1.588|
00024c  206c              MOVS     r0,#0x6c
00024e  5d00              LDRB     r0,[r0,r4]
000250  4243              RSBS     r3,r0,#0
000252  f44f707a          MOV      r0,#0x3e8
000256  4118              ASRS     r0,r0,r3
                  |L1.600|
000258  fb02f100          MUL      r1,r2,r0
00025c  2003              MOVS     r0,#3
00025e  f7fffffe          BL       timerStart
;;;188    			switch (ptpClock->portDS.delayMechanism)
000262  206f              MOVS     r0,#0x6f
000264  5d00              LDRB     r0,[r0,r4]
000266  2801              CMP      r0,#1
000268  d002              BEQ      |L1.624|
00026a  2802              CMP      r0,#2
00026c  d13b              BNE      |L1.742|
00026e  e01d              B        |L1.684|
                  |L1.624|
;;;189    			{
;;;190    				case E2E:
;;;191    						timerStart(DELAYREQ_INTERVAL_TIMER, getRand(pow2ms(ptpClock->portDS.logMinDelayReqInterval + 1)));
000270  f9941063          LDRSB    r1,[r4,#0x63]
000274  1c49              ADDS     r1,r1,#1
000276  2900              CMP      r1,#0
000278  dd07              BLE      |L1.650|
00027a  2163              MOVS     r1,#0x63
00027c  5d09              LDRB     r1,[r1,r4]
00027e  1c49              ADDS     r1,r1,#1
000280  f44f727a          MOV      r2,#0x3e8
000284  fa02f101          LSL      r1,r2,r1
000288  e006              B        |L1.664|
                  |L1.650|
00028a  2163              MOVS     r1,#0x63
00028c  5d09              LDRB     r1,[r1,r4]
00028e  1c49              ADDS     r1,r1,#1
000290  424a              RSBS     r2,r1,#0
000292  f44f717a          MOV      r1,#0x3e8
000296  4111              ASRS     r1,r1,r2
                  |L1.664|
000298  4608              MOV      r0,r1
00029a  f7fffffe          BL       getRand
00029e  4606              MOV      r6,r0
0002a0  4631              MOV      r1,r6
0002a2  2001              MOVS     r0,#1
0002a4  f7fffffe          BL       timerStart
;;;192    						break;
0002a8  e01e              B        |L1.744|
0002aa  e022              B        |L1.754|
                  |L1.684|
;;;193    				case P2P:
;;;194    						timerStart(PDELAYREQ_INTERVAL_TIMER, getRand(pow2ms(ptpClock->portDS.logMinPdelayReqInterval + 1)));
0002ac  f9941070          LDRSB    r1,[r4,#0x70]
0002b0  1c49              ADDS     r1,r1,#1
0002b2  2900              CMP      r1,#0
0002b4  dd07              BLE      |L1.710|
0002b6  2170              MOVS     r1,#0x70
0002b8  5d09              LDRB     r1,[r1,r4]
0002ba  1c49              ADDS     r1,r1,#1
0002bc  f44f727a          MOV      r2,#0x3e8
0002c0  fa02f101          LSL      r1,r2,r1
0002c4  e006              B        |L1.724|
                  |L1.710|
0002c6  2170              MOVS     r1,#0x70
0002c8  5d09              LDRB     r1,[r1,r4]
0002ca  1c49              ADDS     r1,r1,#1
0002cc  424a              RSBS     r2,r1,#0
0002ce  f44f717a          MOV      r1,#0x3e8
0002d2  4111              ASRS     r1,r1,r2
                  |L1.724|
0002d4  4608              MOV      r0,r1
0002d6  f7fffffe          BL       getRand
0002da  4606              MOV      r6,r0
0002dc  4631              MOV      r1,r6
0002de  2000              MOVS     r0,#0
0002e0  f7fffffe          BL       timerStart
;;;195    						break;
0002e4  e000              B        |L1.744|
                  |L1.742|
;;;196    				default:
;;;197    						/* none */
;;;198    						break;
0002e6  bf00              NOP      
                  |L1.744|
0002e8  bf00              NOP                            ;192
;;;199    			}
;;;200    			ptpClock->portDS.portState = PTP_UNCALIBRATED;
0002ea  2107              MOVS     r1,#7
0002ec  2062              MOVS     r0,#0x62
0002ee  5501              STRB     r1,[r0,r4]
;;;201    
;;;202    			break;
0002f0  e004              B        |L1.764|
                  |L1.754|
;;;203    
;;;204    		case PTP_SLAVE:
;;;205    
;;;206    			ptpClock->portDS.portState = PTP_SLAVE;
0002f2  2108              MOVS     r1,#8
0002f4  2062              MOVS     r0,#0x62
0002f6  5501              STRB     r1,[r0,r4]
;;;207    
;;;208    			break;
0002f8  e000              B        |L1.764|
                  |L1.762|
;;;209    
;;;210    		default:
;;;211    
;;;212    			break;
0002fa  bf00              NOP      
                  |L1.764|
0002fc  bf00              NOP                            ;124
;;;213    	}
;;;214    }
0002fe  bd70              POP      {r4-r6,pc}
;;;215    
                          ENDP

                  doInit PROC
;;;216    
;;;217    static bool doInit(PtpClock *ptpClock)
000300  b510              PUSH     {r4,lr}
;;;218    {
000302  4604              MOV      r4,r0
;;;219    	DBG("manufacturerIdentity: %s\n", MANUFACTURER_ID);
;;;220    
;;;221    	/* initialize networking */
;;;222    	netShutdown(&ptpClock->netPath);
000304  f5047073          ADD      r0,r4,#0x3cc
000308  f7fffffe          BL       netShutdown
;;;223    
;;;224    	if (!netInit(&ptpClock->netPath, ptpClock))
00030c  4621              MOV      r1,r4
00030e  f5047073          ADD      r0,r4,#0x3cc
000312  f7fffffe          BL       netInit
000316  b908              CBNZ     r0,|L1.796|
;;;225    	{
;;;226    		ERROR("doInit: failed to initialize network\n");
;;;227    		return FALSE;
000318  2000              MOVS     r0,#0
                  |L1.794|
;;;228    	}
;;;229    	else
;;;230    	{
;;;231    		/* initialize other stuff */
;;;232    		initData(ptpClock);
;;;233    		initTimer();
;;;234    		initClock(ptpClock);
;;;235    		m1(ptpClock);//model is master
;;;236    		msgPackHeader(ptpClock, ptpClock->msgObuf);
;;;237    		return TRUE;
;;;238    	}
;;;239    }
00031a  bd10              POP      {r4,pc}
                  |L1.796|
00031c  4620              MOV      r0,r4                 ;232
00031e  f7fffffe          BL       initData
000322  f7fffffe          BL       initTimer
000326  4620              MOV      r0,r4                 ;234
000328  f7fffffe          BL       initClock
00032c  4620              MOV      r0,r4                 ;235
00032e  f7fffffe          BL       ||m1||
000332  f10401cc          ADD      r1,r4,#0xcc           ;236
000336  4620              MOV      r0,r4                 ;236
000338  f7fffffe          BL       msgPackHeader
00033c  2001              MOVS     r0,#1                 ;237
00033e  e7ec              B        |L1.794|
;;;240    
                          ENDP

                  issuePDelayReq PROC
;;;1375   /* Pack and send on event multicast ip adress a PDelayReq message */
;;;1376   static void issuePDelayReq(PtpClock *ptpClock)
000340  b510              PUSH     {r4,lr}
;;;1377   {
000342  b086              SUB      sp,sp,#0x18
000344  4604              MOV      r4,r0
;;;1378   	Timestamp originTimestamp;
;;;1379   	TimeInternal internalTime;
;;;1380   
;;;1381   	getTime(&internalTime);
000346  a801              ADD      r0,sp,#4
000348  f7fffffe          BL       getTime
;;;1382   	fromInternalTime(&internalTime, &originTimestamp);
00034c  a903              ADD      r1,sp,#0xc
00034e  a801              ADD      r0,sp,#4
000350  f7fffffe          BL       fromInternalTime
;;;1383   
;;;1384   	msgPackPDelayReq(ptpClock, ptpClock->msgObuf, &originTimestamp);
000354  aa03              ADD      r2,sp,#0xc
000356  f10401cc          ADD      r1,r4,#0xcc
00035a  4620              MOV      r0,r4
00035c  f7fffffe          BL       msgPackPDelayReq
;;;1385   
;;;1386   	if (!netSendPeerEvent(&ptpClock->netPath, ptpClock->msgObuf, PDELAY_REQ_LENGTH, &internalTime))
000360  ab01              ADD      r3,sp,#4
000362  2236              MOVS     r2,#0x36
000364  f10401cc          ADD      r1,r4,#0xcc
000368  f5047073          ADD      r0,r4,#0x3cc
00036c  f7fffffe          BL       netSendPeerEvent
000370  b920              CBNZ     r0,|L1.892|
;;;1387   	{
;;;1388   		ERROR("issuePDelayReq: can't sent\n");
;;;1389   		toState(ptpClock, PTP_FAULTY);
000372  2101              MOVS     r1,#1
000374  4620              MOV      r0,r4
000376  f7fffffe          BL       toState
00037a  e013              B        |L1.932|
                  |L1.892|
;;;1390   	}
;;;1391   	else
;;;1392   	{
;;;1393   		DBGV("issuePDelayReq\n");
;;;1394   		ptpClock->sentPDelayReqSequenceId++;
00037c  f8b40380          LDRH     r0,[r4,#0x380]
000380  1c40              ADDS     r0,r0,#1
000382  b200              SXTH     r0,r0
000384  f8a40380          STRH     r0,[r4,#0x380]
;;;1395   
;;;1396   		/* Delay req TX timestamp is valid */
;;;1397   		if (internalTime.seconds != 0)
000388  9801              LDR      r0,[sp,#4]
00038a  b158              CBZ      r0,|L1.932|
;;;1398   		{
;;;1399   			addTime(&internalTime, &internalTime, &ptpClock->outboundLatency);
00038c  f5046289          ADD      r2,r4,#0x448
000390  a901              ADD      r1,sp,#4
000392  a801              ADD      r0,sp,#4
000394  f7fffffe          BL       addTime
;;;1400   			ptpClock->pdelay_t1 = internalTime;
000398  f5047040          ADD      r0,r4,#0x300
00039c  e9dd1201          LDRD     r1,r2,[sp,#4]
0003a0  e9c0120e          STRD     r1,r2,[r0,#0x38]
                  |L1.932|
;;;1401   		}
;;;1402   	}
;;;1403   }
0003a4  b006              ADD      sp,sp,#0x18
0003a6  bd10              POP      {r4,pc}
;;;1404   
                          ENDP

                  issueDelayReq PROC
;;;1345   /* Pack and send on event multicast ip address a DelayReq message */
;;;1346   static void issueDelayReq(PtpClock *ptpClock)
0003a8  b510              PUSH     {r4,lr}
;;;1347   {
0003aa  b086              SUB      sp,sp,#0x18
0003ac  4604              MOV      r4,r0
;;;1348   	Timestamp originTimestamp;
;;;1349   	TimeInternal internalTime;
;;;1350   
;;;1351   	getTime(&internalTime);
0003ae  a801              ADD      r0,sp,#4
0003b0  f7fffffe          BL       getTime
;;;1352   	fromInternalTime(&internalTime, &originTimestamp);
0003b4  a903              ADD      r1,sp,#0xc
0003b6  a801              ADD      r0,sp,#4
0003b8  f7fffffe          BL       fromInternalTime
;;;1353   
;;;1354   	msgPackDelayReq(ptpClock, ptpClock->msgObuf, &originTimestamp);
0003bc  aa03              ADD      r2,sp,#0xc
0003be  f10401cc          ADD      r1,r4,#0xcc
0003c2  4620              MOV      r0,r4
0003c4  f7fffffe          BL       msgPackDelayReq
;;;1355   
;;;1356   	if (!netSendEvent(&ptpClock->netPath, ptpClock->msgObuf, DELAY_REQ_LENGTH, &internalTime))
0003c8  ab01              ADD      r3,sp,#4
0003ca  222c              MOVS     r2,#0x2c
0003cc  f10401cc          ADD      r1,r4,#0xcc
0003d0  f5047073          ADD      r0,r4,#0x3cc
0003d4  f7fffffe          BL       netSendEvent
0003d8  b920              CBNZ     r0,|L1.996|
;;;1357   	{
;;;1358   		ERROR("issueDelayReq: can't sent\n");
;;;1359   		toState(ptpClock, PTP_FAULTY);
0003da  2101              MOVS     r1,#1
0003dc  4620              MOV      r0,r4
0003de  f7fffffe          BL       toState
0003e2  e013              B        |L1.1036|
                  |L1.996|
;;;1360   	}
;;;1361   	else
;;;1362   	{
;;;1363   		DBGV("issueDelayReq\n");
;;;1364   		ptpClock->sentDelayReqSequenceId++;
0003e4  f8b40382          LDRH     r0,[r4,#0x382]
0003e8  1c40              ADDS     r0,r0,#1
0003ea  b200              SXTH     r0,r0
0003ec  f8a40382          STRH     r0,[r4,#0x382]
;;;1365   
;;;1366   		/* Delay req TX timestamp is valid */
;;;1367   		if (internalTime.seconds != 0)
0003f0  9801              LDR      r0,[sp,#4]
0003f2  b158              CBZ      r0,|L1.1036|
;;;1368   		{
;;;1369   			addTime(&internalTime, &internalTime, &ptpClock->outboundLatency);
0003f4  f5046289          ADD      r2,r4,#0x448
0003f8  a901              ADD      r1,sp,#4
0003fa  a801              ADD      r0,sp,#4
0003fc  f7fffffe          BL       addTime
;;;1370   			ptpClock->timestamp_delayReqSend = internalTime;
000400  f5047040          ADD      r0,r4,#0x300
000404  e9dd1201          LDRD     r1,r2,[sp,#4]
000408  e9c01218          STRD     r1,r2,[r0,#0x60]
                  |L1.1036|
;;;1371   		}
;;;1372   	}
;;;1373   }
00040c  b006              ADD      sp,sp,#0x18
00040e  bd10              POP      {r4,pc}
;;;1374   
                          ENDP

                  issueDelayReqTimerExpired PROC
;;;1236   
;;;1237   static void issueDelayReqTimerExpired(PtpClock *ptpClock)
000410  b570              PUSH     {r4-r6,lr}
;;;1238   {
000412  4604              MOV      r4,r0
;;;1239   	switch (ptpClock->portDS.delayMechanism)
000414  206f              MOVS     r0,#0x6f
000416  5d00              LDRB     r0,[r0,r4]
000418  2801              CMP      r0,#1
00041a  d002              BEQ      |L1.1058|
00041c  2802              CMP      r0,#2
00041e  d14d              BNE      |L1.1212|
000420  e028              B        |L1.1140|
                  |L1.1058|
;;;1240   	{
;;;1241   		case E2E:
;;;1242   
;;;1243   			if (ptpClock->portDS.portState != PTP_SLAVE)
000422  2062              MOVS     r0,#0x62
000424  5d00              LDRB     r0,[r0,r4]
000426  2808              CMP      r0,#8
000428  d000              BEQ      |L1.1068|
;;;1244   			{
;;;1245   					break;
00042a  e048              B        |L1.1214|
                  |L1.1068|
;;;1246   			}
;;;1247   
;;;1248   			if (timerExpired(DELAYREQ_INTERVAL_TIMER))
00042c  2001              MOVS     r0,#1
00042e  f7fffffe          BL       timerExpired
000432  b1f0              CBZ      r0,|L1.1138|
;;;1249   			{
;;;1250   					timerStart(DELAYREQ_INTERVAL_TIMER, getRand(pow2ms(ptpClock->portDS.logMinDelayReqInterval + 1)));
000434  f9941063          LDRSB    r1,[r4,#0x63]
000438  1c49              ADDS     r1,r1,#1
00043a  2900              CMP      r1,#0
00043c  dd07              BLE      |L1.1102|
00043e  2163              MOVS     r1,#0x63
000440  5d09              LDRB     r1,[r1,r4]
000442  1c49              ADDS     r1,r1,#1
000444  f44f727a          MOV      r2,#0x3e8
000448  fa02f101          LSL      r1,r2,r1
00044c  e006              B        |L1.1116|
                  |L1.1102|
00044e  2163              MOVS     r1,#0x63
000450  5d09              LDRB     r1,[r1,r4]
000452  1c49              ADDS     r1,r1,#1
000454  424a              RSBS     r2,r1,#0
000456  f44f717a          MOV      r1,#0x3e8
00045a  4111              ASRS     r1,r1,r2
                  |L1.1116|
00045c  4608              MOV      r0,r1
00045e  f7fffffe          BL       getRand
000462  4605              MOV      r5,r0
000464  4629              MOV      r1,r5
000466  2001              MOVS     r0,#1
000468  f7fffffe          BL       timerStart
;;;1251   					DBGV("event DELAYREQ_INTERVAL_TIMEOUT_EXPIRES\n");
;;;1252   					issueDelayReq(ptpClock);
00046c  4620              MOV      r0,r4
00046e  f7fffffe          BL       issueDelayReq
                  |L1.1138|
;;;1253   			}
;;;1254   
;;;1255   			break;
000472  e024              B        |L1.1214|
                  |L1.1140|
;;;1256   
;;;1257   		case P2P:
;;;1258   
;;;1259   			if (timerExpired(PDELAYREQ_INTERVAL_TIMER))
000474  2000              MOVS     r0,#0
000476  f7fffffe          BL       timerExpired
00047a  b1f0              CBZ      r0,|L1.1210|
;;;1260   			{
;;;1261   					timerStart(PDELAYREQ_INTERVAL_TIMER, getRand(pow2ms(ptpClock->portDS.logMinPdelayReqInterval + 1)));
00047c  f9941070          LDRSB    r1,[r4,#0x70]
000480  1c49              ADDS     r1,r1,#1
000482  2900              CMP      r1,#0
000484  dd07              BLE      |L1.1174|
000486  2170              MOVS     r1,#0x70
000488  5d09              LDRB     r1,[r1,r4]
00048a  1c49              ADDS     r1,r1,#1
00048c  f44f727a          MOV      r2,#0x3e8
000490  fa02f101          LSL      r1,r2,r1
000494  e006              B        |L1.1188|
                  |L1.1174|
000496  2170              MOVS     r1,#0x70
000498  5d09              LDRB     r1,[r1,r4]
00049a  1c49              ADDS     r1,r1,#1
00049c  424a              RSBS     r2,r1,#0
00049e  f44f717a          MOV      r1,#0x3e8
0004a2  4111              ASRS     r1,r1,r2
                  |L1.1188|
0004a4  4608              MOV      r0,r1
0004a6  f7fffffe          BL       getRand
0004aa  4605              MOV      r5,r0
0004ac  4629              MOV      r1,r5
0004ae  2000              MOVS     r0,#0
0004b0  f7fffffe          BL       timerStart
;;;1262   					DBGV("event PDELAYREQ_INTERVAL_TIMEOUT_EXPIRES\n");
;;;1263   					issuePDelayReq(ptpClock);
0004b4  4620              MOV      r0,r4
0004b6  f7fffffe          BL       issuePDelayReq
                  |L1.1210|
;;;1264   			}
;;;1265   			break;
0004ba  e000              B        |L1.1214|
                  |L1.1212|
;;;1266   
;;;1267   		default:
;;;1268   				break;
0004bc  bf00              NOP      
                  |L1.1214|
0004be  bf00              NOP                            ;1245
;;;1269   	}
;;;1270   }
0004c0  bd70              POP      {r4-r6,pc}
;;;1271   
                          ENDP

                  handleSignaling PROC
;;;1232   
;;;1233   static void handleSignaling(PtpClock *ptpClock, bool  isFromSelf)
0004c2  4770              BX       lr
;;;1234   {
;;;1235   }
;;;1236   
                          ENDP

                  handleManagement PROC
;;;1226   
;;;1227   static void handleManagement(PtpClock *ptpClock, bool isFromSelf)
0004c4  4770              BX       lr
;;;1228   {
;;;1229   	/* ENABLE_PORT -> DESIGNATED_ENABLED -> toState(PTP_INITIALIZING) */
;;;1230   	/* DISABLE_PORT -> DESIGNATED_DISABLED -> toState(PTP_DISABLED) */
;;;1231   }
;;;1232   
                          ENDP

                  handlePDelayRespFollowUp PROC
;;;1162   
;;;1163   static void handlePDelayRespFollowUp(PtpClock *ptpClock, bool isFromSelf)
0004c6  b57f              PUSH     {r0-r6,lr}
;;;1164   {
0004c8  4604              MOV      r4,r0
0004ca  460d              MOV      r5,r1
;;;1165   	TimeInternal responseOriginTimestamp;
;;;1166   	TimeInternal correctionField;
;;;1167   
;;;1168   	switch (ptpClock->portDS.delayMechanism)
0004cc  206f              MOVS     r0,#0x6f
0004ce  5d00              LDRB     r0,[r0,r4]
0004d0  2801              CMP      r0,#1
0004d2  d002              BEQ      |L1.1242|
0004d4  2802              CMP      r0,#2
0004d6  d14e              BNE      |L1.1398|
0004d8  e000              B        |L1.1244|
                  |L1.1242|
;;;1169   	{
;;;1170   		case E2E:
;;;1171   
;;;1172   			ERROR("handlePDelayRespFollowUp: disreguard in E2E mode\n");
;;;1173   			break;
0004da  e04d              B        |L1.1400|
                  |L1.1244|
;;;1174   
;;;1175   		case P2P:
;;;1176   
;;;1177   			DBGV("handlePDelayRespFollowUp: received in mode P2P in state %s\n", stateString(ptpClock->portDS.portState));
;;;1178   			if (ptpClock->msgIbufLength < PDELAY_RESP_FOLLOW_UP_LENGTH)
0004dc  f8d40324          LDR      r0,[r4,#0x324]
0004e0  2836              CMP      r0,#0x36
0004e2  da04              BGE      |L1.1262|
;;;1179   			{
;;;1180   				ERROR("handlePDelayRespFollowUp: short message\n");
;;;1181   				toState(ptpClock, PTP_FAULTY);
0004e4  2101              MOVS     r1,#1
0004e6  4620              MOV      r0,r4
0004e8  f7fffffe          BL       toState
                  |L1.1260|
;;;1182   				return;
;;;1183   			}
;;;1184   
;;;1185   			switch (ptpClock->portDS.portState)
;;;1186   			{
;;;1187   				case PTP_INITIALIZING:
;;;1188   				case PTP_FAULTY:
;;;1189   				case PTP_DISABLED:
;;;1190   				case PTP_UNCALIBRATED:
;;;1191   					DBGV("handlePDelayRespFollowUp: disreguard\n");
;;;1192   					return;
;;;1193   
;;;1194   				case PTP_SLAVE:
;;;1195   				case PTP_MASTER:
;;;1196   
;;;1197   					if (!ptpClock->waitingForPDelayRespFollowUp)
;;;1198   					{
;;;1199   						DBG("handlePDelayRespFollowUp: not waiting a message\n");
;;;1200   						break;
;;;1201   					}
;;;1202   
;;;1203   					if (ptpClock->msgTmpHeader.sequenceId == ptpClock->sentPDelayReqSequenceId - 1)
;;;1204   					{
;;;1205   							msgUnpackPDelayRespFollowUp(ptpClock->msgIbuf, &ptpClock->msgTmp.prespfollow);
;;;1206   							toInternalTime(&responseOriginTimestamp, &ptpClock->msgTmp.prespfollow.responseOriginTimestamp);
;;;1207   							ptpClock->pdelay_t3 = responseOriginTimestamp;
;;;1208   							scaledNanosecondsToInternalTime(&ptpClock->msgTmpHeader.correctionfield, &correctionField);
;;;1209   							addTime(&correctionField, &correctionField, &ptpClock->correctionField_pDelayResp);
;;;1210   							updatePeerDelay(ptpClock, &correctionField, TRUE);
;;;1211   							ptpClock->waitingForPDelayRespFollowUp = FALSE;
;;;1212   							break;
;;;1213   					}
;;;1214   
;;;1215   				default:
;;;1216   
;;;1217   					DBGV("handlePDelayRespFollowUp: unrecognized state\n");
;;;1218   			}
;;;1219   			break;
;;;1220   
;;;1221   		default:
;;;1222   
;;;1223   			break;
;;;1224   	}
;;;1225   }
0004ec  bd7f              POP      {r0-r6,pc}
                  |L1.1262|
0004ee  2062              MOVS     r0,#0x62              ;1185
0004f0  5d00              LDRB     r0,[r0,r4]            ;1185
0004f2  2809              CMP      r0,#9                 ;1185
0004f4  d23c              BCS      |L1.1392|
0004f6  e8dff000          TBB      [pc,r0]               ;1185
0004fa  0506              DCB      0x05,0x06
0004fc  073b3b0a          DCB      0x07,0x3b,0x3b,0x0a
000500  3b080900          DCB      0x3b,0x08,0x09,0x00
000504  bf00              NOP                            ;1188
000506  bf00              NOP                            ;1189
000508  bf00              NOP                            ;1190
00050a  e7ef              B        |L1.1260|
00050c  bf00              NOP                            ;1195
00050e  f894038d          LDRB     r0,[r4,#0x38d]        ;1197
000512  b900              CBNZ     r0,|L1.1302|
000514  e02d              B        |L1.1394|
                  |L1.1302|
000516  f9b410a2          LDRSH    r1,[r4,#0xa2]         ;1203
00051a  f9b40380          LDRSH    r0,[r4,#0x380]        ;1203
00051e  1e40              SUBS     r0,r0,#1              ;1203
000520  4281              CMP      r1,r0                 ;1203
000522  d124              BNE      |L1.1390|
000524  f10401a8          ADD      r1,r4,#0xa8           ;1205
000528  f50470fc          ADD      r0,r4,#0x1f8          ;1205
00052c  f7fffffe          BL       msgUnpackPDelayRespFollowUp
000530  f10401a8          ADD      r1,r4,#0xa8           ;1206
000534  a802              ADD      r0,sp,#8              ;1206
000536  f7fffffe          BL       toInternalTime
00053a  f5047040          ADD      r0,r4,#0x300          ;1207
00053e  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1207
000542  e9c01212          STRD     r1,r2,[r0,#0x48]      ;1207
000546  4669              MOV      r1,sp                 ;1208
000548  f1040090          ADD      r0,r4,#0x90           ;1208
00054c  f7fffffe          BL       scaledNanosecondsToInternalTime
000550  f504725e          ADD      r2,r4,#0x378          ;1209
000554  4669              MOV      r1,sp                 ;1209
000556  4668              MOV      r0,sp                 ;1209
000558  f7fffffe          BL       addTime
00055c  2201              MOVS     r2,#1                 ;1210
00055e  4669              MOV      r1,sp                 ;1210
000560  4620              MOV      r0,r4                 ;1210
000562  f7fffffe          BL       updatePeerDelay
000566  2000              MOVS     r0,#0                 ;1211
000568  f884038d          STRB     r0,[r4,#0x38d]        ;1211
00056c  e001              B        |L1.1394|
                  |L1.1390|
00056e  bf00              NOP                            ;1215
                  |L1.1392|
000570  bf00              NOP                            ;1185
                  |L1.1394|
000572  bf00              NOP                            ;1200
000574  e000              B        |L1.1400|
                  |L1.1398|
000576  bf00              NOP                            ;1223
                  |L1.1400|
000578  bf00              NOP                            ;1173
00057a  bf00              NOP      
00057c  e7b6              B        |L1.1260|
;;;1226   
                          ENDP

                  handlePDelayResp PROC
;;;1058   
;;;1059   static void handlePDelayResp(PtpClock *ptpClock, TimeInternal *time, bool isFromSelf)
00057e  e92d41ff          PUSH     {r0-r8,lr}
;;;1060   {
000582  4604              MOV      r4,r0
000584  460d              MOV      r5,r1
000586  4617              MOV      r7,r2
;;;1061   	TimeInternal requestReceiptTimestamp;
;;;1062   	TimeInternal correctionField;
;;;1063   	bool  isCurrentRequest;
;;;1064   
;;;1065   	switch (ptpClock->portDS.delayMechanism)
000588  206f              MOVS     r0,#0x6f
00058a  5d00              LDRB     r0,[r0,r4]
00058c  2801              CMP      r0,#1
00058e  d002              BEQ      |L1.1430|
000590  2802              CMP      r0,#2
000592  d170              BNE      |L1.1654|
000594  e000              B        |L1.1432|
                  |L1.1430|
;;;1066   	{
;;;1067   		case E2E:
;;;1068   
;;;1069   			ERROR("handlePDelayResp: disreguard in E2E mode\n");
;;;1070   			break;
000596  e06f              B        |L1.1656|
                  |L1.1432|
;;;1071   
;;;1072   		case P2P:
;;;1073   
;;;1074   			DBGV("handlePDelayResp: received in mode P2P in state %s\n", stateString(ptpClock->portDS.portState));
;;;1075   			if (ptpClock->msgIbufLength < PDELAY_RESP_LENGTH)
000598  f8d40324          LDR      r0,[r4,#0x324]
00059c  2836              CMP      r0,#0x36
00059e  da05              BGE      |L1.1452|
;;;1076   			{
;;;1077   					ERROR("handlePDelayResp: short message\n");
;;;1078   					toState(ptpClock, PTP_FAULTY);
0005a0  2101              MOVS     r1,#1
0005a2  4620              MOV      r0,r4
0005a4  f7fffffe          BL       toState
                  |L1.1448|
;;;1079   					return;
;;;1080   			}
;;;1081   
;;;1082   			switch (ptpClock->portDS.portState)
;;;1083   			{
;;;1084   				case PTP_INITIALIZING:
;;;1085   				case PTP_FAULTY:
;;;1086   				case PTP_DISABLED:
;;;1087   				case PTP_UNCALIBRATED:
;;;1088   				case PTP_LISTENING:
;;;1089   
;;;1090   				DBGV("handlePDelayResp: disreguard\n");
;;;1091   				return;
;;;1092   
;;;1093   				case PTP_MASTER:
;;;1094   				case PTP_SLAVE:
;;;1095   
;;;1096   					if (isFromSelf)
;;;1097   					{
;;;1098   							DBGV("handlePDelayResp: ignore from self\n");
;;;1099   							break;
;;;1100   					}
;;;1101   
;;;1102   //            if (isFromSelf)  && loopback mode
;;;1103   //            {
;;;1104   //                addTime(time, time, &rtOpts->outboundLatency);
;;;1105   //                issuePDelayRespFollowUp(time, ptpClock);
;;;1106   //                break;
;;;1107   //            }
;;;1108   
;;;1109   
;;;1110   					msgUnpackPDelayResp(ptpClock->msgIbuf, &ptpClock->msgTmp.presp);
;;;1111   
;;;1112   					isCurrentRequest = isSamePortIdentity(
;;;1113   					&ptpClock->portDS.portIdentity,
;;;1114   					&ptpClock->msgTmp.presp.requestingPortIdentity);
;;;1115   
;;;1116   					if (((ptpClock->sentPDelayReqSequenceId - 1) == ptpClock->msgTmpHeader.sequenceId) && isCurrentRequest)
;;;1117   					{
;;;1118   						if (getFlag(ptpClock->msgTmpHeader.flagField[0], FLAG0_TWO_STEP))
;;;1119   						{
;;;1120   							ptpClock->waitingForPDelayRespFollowUp = TRUE;
;;;1121   
;;;1122   							/* Store  t4 (Fig 35)*/
;;;1123   							ptpClock->pdelay_t4 = *time;
;;;1124   
;;;1125   							/* store  t2 (Fig 35)*/
;;;1126   							toInternalTime(&requestReceiptTimestamp, &ptpClock->msgTmp.presp.requestReceiptTimestamp);
;;;1127   							ptpClock->pdelay_t2 = requestReceiptTimestamp;
;;;1128   
;;;1129   							scaledNanosecondsToInternalTime(&ptpClock->msgTmpHeader.correctionfield, &correctionField);
;;;1130   							ptpClock->correctionField_pDelayResp = correctionField;
;;;1131   						}//Two Step Clock
;;;1132   						else //One step Clock
;;;1133   						{
;;;1134   							ptpClock->waitingForPDelayRespFollowUp = FALSE;
;;;1135   
;;;1136   							/* Store  t4 (Fig 35)*/
;;;1137   							ptpClock->pdelay_t4 = *time;
;;;1138   
;;;1139   							scaledNanosecondsToInternalTime(&ptpClock->msgTmpHeader.correctionfield, &correctionField);
;;;1140   							updatePeerDelay(ptpClock, &correctionField, FALSE);
;;;1141   						}
;;;1142   					}
;;;1143   					else
;;;1144   					{
;;;1145   							DBGV("handlePDelayResp: PDelayResp doesn't match with the PDelayReq.\n");
;;;1146   					}
;;;1147   
;;;1148   					break;
;;;1149   
;;;1150   				default:
;;;1151   
;;;1152   						DBG("handlePDelayResp: unrecognized state\n");
;;;1153   						break;
;;;1154   			}
;;;1155   			break;
;;;1156   
;;;1157   		default:
;;;1158   
;;;1159   			break;
;;;1160   	}
;;;1161   }
0005a8  e8bd81ff          POP      {r0-r8,pc}
                  |L1.1452|
0005ac  2062              MOVS     r0,#0x62              ;1082
0005ae  5d00              LDRB     r0,[r0,r4]            ;1082
0005b0  2809              CMP      r0,#9                 ;1082
0005b2  d25c              BCS      |L1.1646|
0005b4  e8dff000          TBB      [pc,r0]               ;1082
0005b8  05060709          DCB      0x05,0x06,0x07,0x09
0005bc  5b0a5b08          DCB      0x5b,0x0a,0x5b,0x08
0005c0  0b00              DCB      0x0b,0x00
0005c2  bf00              NOP                            ;1085
0005c4  bf00              NOP                            ;1086
0005c6  bf00              NOP                            ;1087
0005c8  bf00              NOP                            ;1088
0005ca  e7ed              B        |L1.1448|
0005cc  bf00              NOP                            ;1094
0005ce  b107              CBZ      r7,|L1.1490|
0005d0  e04e              B        |L1.1648|
                  |L1.1490|
0005d2  f10401a8          ADD      r1,r4,#0xa8           ;1110
0005d6  f50470fc          ADD      r0,r4,#0x1f8          ;1110
0005da  f7fffffe          BL       msgUnpackPDelayResp
0005de  f10401b4          ADD      r1,r4,#0xb4           ;1112
0005e2  f1040058          ADD      r0,r4,#0x58           ;1112
0005e6  f7fffffe          BL       isSamePortIdentity
0005ea  4606              MOV      r6,r0                 ;1112
0005ec  f9b40380          LDRSH    r0,[r4,#0x380]        ;1116
0005f0  1e40              SUBS     r0,r0,#1              ;1116
0005f2  f9b410a2          LDRSH    r1,[r4,#0xa2]         ;1116
0005f6  4288              CMP      r0,r1                 ;1116
0005f8  d138              BNE      |L1.1644|
0005fa  b31e              CBZ      r6,|L1.1604|
0005fc  2087              MOVS     r0,#0x87              ;1118
0005fe  5d00              LDRB     r0,[r0,r4]            ;1118
000600  f3c00040          UBFX     r0,r0,#1,#1           ;1118
000604  b1f8              CBZ      r0,|L1.1606|
000606  2001              MOVS     r0,#1                 ;1120
000608  f884038d          STRB     r0,[r4,#0x38d]        ;1120
00060c  f5047040          ADD      r0,r4,#0x300          ;1123
000610  e9d51200          LDRD     r1,r2,[r5,#0]         ;1123
000614  e9c01214          STRD     r1,r2,[r0,#0x50]      ;1123
000618  f10401a8          ADD      r1,r4,#0xa8           ;1126
00061c  a802              ADD      r0,sp,#8              ;1126
00061e  f7fffffe          BL       toInternalTime
000622  f5047040          ADD      r0,r4,#0x300          ;1127
000626  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1127
00062a  e9c01210          STRD     r1,r2,[r0,#0x40]      ;1127
00062e  4669              MOV      r1,sp                 ;1129
000630  f1040090          ADD      r0,r4,#0x90           ;1129
000634  f7fffffe          BL       scaledNanosecondsToInternalTime
000638  f5047040          ADD      r0,r4,#0x300          ;1130
00063c  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1130
000640  e9c0121e          STRD     r1,r2,[r0,#0x78]      ;1130
                  |L1.1604|
000644  e012              B        |L1.1644|
                  |L1.1606|
000646  2000              MOVS     r0,#0                 ;1134
000648  f884038d          STRB     r0,[r4,#0x38d]        ;1134
00064c  f5047040          ADD      r0,r4,#0x300          ;1137
000650  e9d51200          LDRD     r1,r2,[r5,#0]         ;1137
000654  e9c01214          STRD     r1,r2,[r0,#0x50]      ;1137
000658  4669              MOV      r1,sp                 ;1139
00065a  f1040090          ADD      r0,r4,#0x90           ;1139
00065e  f7fffffe          BL       scaledNanosecondsToInternalTime
000662  2200              MOVS     r2,#0                 ;1140
000664  4669              MOV      r1,sp                 ;1140
000666  4620              MOV      r0,r4                 ;1140
000668  f7fffffe          BL       updatePeerDelay
                  |L1.1644|
00066c  e000              B        |L1.1648|
                  |L1.1646|
00066e  bf00              NOP                            ;1153
                  |L1.1648|
000670  bf00              NOP                            ;1099
000672  e001              B        |L1.1656|
000674  e7ff              B        |L1.1654|
                  |L1.1654|
000676  bf00              NOP                            ;1159
                  |L1.1656|
000678  bf00              NOP                            ;1070
00067a  bf00              NOP      
00067c  e794              B        |L1.1448|
;;;1162   
                          ENDP

                  handleDelayResp PROC
;;;913    
;;;914    static void handleDelayResp(PtpClock *ptpClock, bool  isFromSelf)
00067e  e92d41fc          PUSH     {r2-r8,lr}
;;;915    {
000682  4604              MOV      r4,r0
000684  460f              MOV      r7,r1
;;;916    	bool  isFromCurrentParent = FALSE;
000686  2500              MOVS     r5,#0
;;;917    	bool  isCurrentRequest = FALSE;
000688  2600              MOVS     r6,#0
;;;918    	TimeInternal correctionField;
;;;919    
;;;920    	switch (ptpClock->portDS.delayMechanism)
00068a  206f              MOVS     r0,#0x6f
00068c  5d00              LDRB     r0,[r0,r4]
00068e  2801              CMP      r0,#1
000690  d002              BEQ      |L1.1688|
000692  2802              CMP      r0,#2
000694  d153              BNE      |L1.1854|
000696  e051              B        |L1.1852|
                  |L1.1688|
;;;921    	{
;;;922    		case E2E:
;;;923    
;;;924    			DBGV("handleDelayResp: received in mode E2E in state %s\n", stateString(ptpClock->portDS.portState));
;;;925    			if (ptpClock->msgIbufLength < DELAY_RESP_LENGTH)
000698  f8d40324          LDR      r0,[r4,#0x324]
00069c  2836              CMP      r0,#0x36
00069e  da05              BGE      |L1.1708|
;;;926    			{
;;;927    				ERROR("handleDelayResp: short message\n");
;;;928    				toState(ptpClock, PTP_FAULTY);
0006a0  2101              MOVS     r1,#1
0006a2  4620              MOV      r0,r4
0006a4  f7fffffe          BL       toState
                  |L1.1704|
;;;929    				return;
;;;930    			}
;;;931    
;;;932    			switch (ptpClock->portDS.portState)
;;;933    			{
;;;934    				case PTP_INITIALIZING:
;;;935    				case PTP_FAULTY:
;;;936    				case PTP_DISABLED:
;;;937    				case PTP_LISTENING:
;;;938    					DBGV("handleDelayResp: disreguard\n");
;;;939    					return;
;;;940    
;;;941    				case PTP_UNCALIBRATED:
;;;942    				case PTP_SLAVE:
;;;943    
;;;944    					msgUnpackDelayResp(ptpClock->msgIbuf, &ptpClock->msgTmp.resp);
;;;945    
;;;946    					isFromCurrentParent = isSamePortIdentity(
;;;947    					&ptpClock->parentDS.parentPortIdentity,
;;;948    					&ptpClock->msgTmpHeader.sourcePortIdentity);
;;;949    
;;;950    					isCurrentRequest = isSamePortIdentity(
;;;951    					&ptpClock->portDS.portIdentity,
;;;952    					&ptpClock->msgTmp.resp.requestingPortIdentity);
;;;953    
;;;954    					if (((ptpClock->sentDelayReqSequenceId - 1) == ptpClock->msgTmpHeader.sequenceId) && isCurrentRequest && isFromCurrentParent)
;;;955    					{
;;;956    						/* TODO: revisit 11.3 */
;;;957    						toInternalTime(&ptpClock->timestamp_delayReqRecieve, &ptpClock->msgTmp.resp.receiveTimestamp);
;;;958    
;;;959    						scaledNanosecondsToInternalTime(&ptpClock->msgTmpHeader.correctionfield, &correctionField);
;;;960    						updateDelay(ptpClock, &ptpClock->timestamp_delayReqSend, &ptpClock->timestamp_delayReqRecieve, &correctionField);
;;;961    
;;;962    						ptpClock->portDS.logMinDelayReqInterval = ptpClock->msgTmpHeader.logMessageInterval;
;;;963    					}
;;;964    					else
;;;965    					{
;;;966    						DBGV("handleDelayResp: doesn't match with the delayReq\n");
;;;967    						break;
;;;968    					}
;;;969    			}
;;;970    			break;
;;;971    
;;;972    		case P2P:
;;;973    
;;;974    			ERROR("handleDelayResp: disreguard in P2P mode\n");
;;;975    			break;
;;;976    
;;;977    		default:
;;;978    
;;;979    			break;
;;;980    	}
;;;981    }
0006a8  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1708|
0006ac  2062              MOVS     r0,#0x62              ;932
0006ae  5d00              LDRB     r0,[r0,r4]            ;932
0006b0  2809              CMP      r0,#9                 ;932
0006b2  d241              BCS      |L1.1848|
0006b4  e8dff000          TBB      [pc,r0]               ;932
0006b8  05060708          DCB      0x05,0x06,0x07,0x08
0006bc  40404009          DCB      0x40,0x40,0x40,0x09
0006c0  0a00              DCB      0x0a,0x00
0006c2  bf00              NOP                            ;935
0006c4  bf00              NOP                            ;936
0006c6  bf00              NOP                            ;937
0006c8  e7ee              B        |L1.1704|
0006ca  bf00              NOP                            ;942
0006cc  f10401a8          ADD      r1,r4,#0xa8           ;944
0006d0  f50470fc          ADD      r0,r4,#0x1f8          ;944
0006d4  f7fffffe          BL       msgUnpackDelayResp
0006d8  f1040198          ADD      r1,r4,#0x98           ;946
0006dc  f1040028          ADD      r0,r4,#0x28           ;946
0006e0  f7fffffe          BL       isSamePortIdentity
0006e4  4605              MOV      r5,r0                 ;946
0006e6  f10401b4          ADD      r1,r4,#0xb4           ;950
0006ea  f1040058          ADD      r0,r4,#0x58           ;950
0006ee  f7fffffe          BL       isSamePortIdentity
0006f2  4606              MOV      r6,r0                 ;950
0006f4  f9b40382          LDRSH    r0,[r4,#0x382]        ;954
0006f8  1e40              SUBS     r0,r0,#1              ;954
0006fa  f9b410a2          LDRSH    r1,[r4,#0xa2]         ;954
0006fe  4288              CMP      r0,r1                 ;954
000700  d119              BNE      |L1.1846|
000702  b1c6              CBZ      r6,|L1.1846|
000704  b1bd              CBZ      r5,|L1.1846|
000706  f10401a8          ADD      r1,r4,#0xa8           ;957
00070a  f504705a          ADD      r0,r4,#0x368          ;957
00070e  f7fffffe          BL       toInternalTime
000712  4669              MOV      r1,sp                 ;959
000714  f1040090          ADD      r0,r4,#0x90           ;959
000718  f7fffffe          BL       scaledNanosecondsToInternalTime
00071c  466b              MOV      r3,sp                 ;960
00071e  f504725a          ADD      r2,r4,#0x368          ;960
000722  f5047158          ADD      r1,r4,#0x360          ;960
000726  4620              MOV      r0,r4                 ;960
000728  f7fffffe          BL       updateDelay
00072c  f89410a5          LDRB     r1,[r4,#0xa5]         ;962
000730  2063              MOVS     r0,#0x63              ;962
000732  5501              STRB     r1,[r0,r4]            ;962
000734  e000              B        |L1.1848|
                  |L1.1846|
000736  bf00              NOP                            ;967
                  |L1.1848|
000738  bf00              NOP                            ;967
00073a  e001              B        |L1.1856|
                  |L1.1852|
00073c  e000              B        |L1.1856|
                  |L1.1854|
00073e  bf00              NOP                            ;979
                  |L1.1856|
000740  bf00              NOP                            ;970
000742  bf00              NOP      
000744  e7b0              B        |L1.1704|
;;;982    
                          ENDP

                  issuePDelayRespFollowUp PROC
;;;1449   
;;;1450   static void issuePDelayRespFollowUp(PtpClock *ptpClock, const TimeInternal *time, const MsgHeader * pDelayReqHeader)
000746  b5fe              PUSH     {r1-r7,lr}
;;;1451   {
000748  4604              MOV      r4,r0
00074a  460d              MOV      r5,r1
00074c  4616              MOV      r6,r2
;;;1452   	Timestamp responseOriginTimestamp;
;;;1453   	fromInternalTime(time, &responseOriginTimestamp);
00074e  4669              MOV      r1,sp
000750  4628              MOV      r0,r5
000752  f7fffffe          BL       fromInternalTime
;;;1454   
;;;1455   	msgPackPDelayRespFollowUp(ptpClock->msgObuf, pDelayReqHeader, &responseOriginTimestamp);
000756  466a              MOV      r2,sp
000758  4631              MOV      r1,r6
00075a  f10400cc          ADD      r0,r4,#0xcc
00075e  f7fffffe          BL       msgPackPDelayRespFollowUp
;;;1456   
;;;1457   	if (!netSendPeerGeneral(&ptpClock->netPath, ptpClock->msgObuf, PDELAY_RESP_FOLLOW_UP_LENGTH))
000762  2236              MOVS     r2,#0x36
000764  f10401cc          ADD      r1,r4,#0xcc
000768  f5047073          ADD      r0,r4,#0x3cc
00076c  f7fffffe          BL       netSendPeerGeneral
000770  b918              CBNZ     r0,|L1.1914|
;;;1458   	{
;;;1459   		ERROR("issuePDelayRespFollowUp: can't sent\n");
;;;1460   		toState(ptpClock, PTP_FAULTY);
000772  2101              MOVS     r1,#1
000774  4620              MOV      r0,r4
000776  f7fffffe          BL       toState
                  |L1.1914|
;;;1461   	}
;;;1462   	else
;;;1463   	{
;;;1464   		DBGV("issuePDelayRespFollowUp\n");
;;;1465   	}
;;;1466   }
00077a  bdfe              POP      {r1-r7,pc}
;;;1467   
                          ENDP

                  issuePDelayResp PROC
;;;1405   /* Pack and send on event multicast ip adress a PDelayResp message */
;;;1406   static void issuePDelayResp(PtpClock *ptpClock, TimeInternal *time, const MsgHeader * pDelayReqHeader)
00077c  b5fe              PUSH     {r1-r7,lr}
;;;1407   {
00077e  4604              MOV      r4,r0
000780  460d              MOV      r5,r1
000782  4616              MOV      r6,r2
;;;1408   	Timestamp requestReceiptTimestamp;
;;;1409   
;;;1410   	fromInternalTime(time, &requestReceiptTimestamp);
000784  4669              MOV      r1,sp
000786  4628              MOV      r0,r5
000788  f7fffffe          BL       fromInternalTime
;;;1411   	msgPackPDelayResp(ptpClock->msgObuf, pDelayReqHeader, &requestReceiptTimestamp);
00078c  466a              MOV      r2,sp
00078e  4631              MOV      r1,r6
000790  f10400cc          ADD      r0,r4,#0xcc
000794  f7fffffe          BL       msgPackPDelayResp
;;;1412   
;;;1413   	if (!netSendPeerEvent(&ptpClock->netPath, ptpClock->msgObuf, PDELAY_RESP_LENGTH, time))
000798  462b              MOV      r3,r5
00079a  2236              MOVS     r2,#0x36
00079c  f10401cc          ADD      r1,r4,#0xcc
0007a0  f5047073          ADD      r0,r4,#0x3cc
0007a4  f7fffffe          BL       netSendPeerEvent
0007a8  b920              CBNZ     r0,|L1.1972|
;;;1414   	{
;;;1415   		ERROR("issuePDelayResp: can't sent\n");
;;;1416   		toState(ptpClock, PTP_FAULTY);
0007aa  2101              MOVS     r1,#1
0007ac  4620              MOV      r0,r4
0007ae  f7fffffe          BL       toState
0007b2  e007              B        |L1.1988|
                  |L1.1972|
;;;1417   	}
;;;1418   	else
;;;1419   	{
;;;1420   		if (time->seconds != 0)
0007b4  6828              LDR      r0,[r5,#0]
0007b6  b128              CBZ      r0,|L1.1988|
;;;1421   		{
;;;1422   			/* Add  latency */
;;;1423   			addTime(time, time, &ptpClock->outboundLatency);
0007b8  f5046289          ADD      r2,r4,#0x448
0007bc  4629              MOV      r1,r5
0007be  4628              MOV      r0,r5
0007c0  f7fffffe          BL       addTime
                  |L1.1988|
;;;1424   		}
;;;1425   
;;;1426   		DBGV("issuePDelayResp\n");
;;;1427   	}
;;;1428   }
0007c4  bdfe              POP      {r1-r7,pc}
;;;1429   
                          ENDP

                  handlePDelayReq PROC
;;;983    
;;;984    static void handlePDelayReq(PtpClock *ptpClock, TimeInternal *time, bool  isFromSelf)
0007c6  b570              PUSH     {r4-r6,lr}
;;;985    {
0007c8  4604              MOV      r4,r0
0007ca  460d              MOV      r5,r1
0007cc  4616              MOV      r6,r2
;;;986    	switch (ptpClock->portDS.delayMechanism)
0007ce  206f              MOVS     r0,#0x6f
0007d0  5d00              LDRB     r0,[r0,r4]
0007d2  2801              CMP      r0,#1
0007d4  d002              BEQ      |L1.2012|
0007d6  2802              CMP      r0,#2
0007d8  d135              BNE      |L1.2118|
0007da  e000              B        |L1.2014|
                  |L1.2012|
;;;987    	{
;;;988    		case E2E:
;;;989    			ERROR("handlePDelayReq: disreguard in E2E mode\n");
;;;990    			break;
0007dc  e034              B        |L1.2120|
                  |L1.2014|
;;;991    
;;;992    		case P2P:
;;;993    
;;;994    			DBGV("handlePDelayReq: received in mode P2P in state %s\n", stateString(ptpClock->portDS.portState));
;;;995    			if (ptpClock->msgIbufLength < PDELAY_REQ_LENGTH)
0007de  f8d40324          LDR      r0,[r4,#0x324]
0007e2  2836              CMP      r0,#0x36
0007e4  da04              BGE      |L1.2032|
;;;996    			{
;;;997    					ERROR("handlePDelayReq: short message\n");
;;;998    					toState(ptpClock, PTP_FAULTY);
0007e6  2101              MOVS     r1,#1
0007e8  4620              MOV      r0,r4
0007ea  f7fffffe          BL       toState
                  |L1.2030|
;;;999    					return;
;;;1000   			}
;;;1001   
;;;1002   			switch (ptpClock->portDS.portState)
;;;1003   			{
;;;1004   				case PTP_INITIALIZING:
;;;1005   				case PTP_FAULTY:
;;;1006   				case PTP_DISABLED:
;;;1007   				case PTP_UNCALIBRATED:
;;;1008   				case PTP_LISTENING:
;;;1009   					DBGV("handlePDelayReq: disreguard\n");
;;;1010   					return;
;;;1011   
;;;1012   				case PTP_PASSIVE:
;;;1013   				case PTP_SLAVE:
;;;1014   				case PTP_MASTER:
;;;1015   
;;;1016   					if (isFromSelf)
;;;1017   					{
;;;1018   							DBGV("handlePDelayReq: ignore from self\n");
;;;1019   							break;
;;;1020   					}
;;;1021   
;;;1022   //            if (isFromSelf) /* && loopback mode */
;;;1023   //            {
;;;1024   //                /* Get sending timestamp from IP stack with So_TIMESTAMP */
;;;1025   //                ptpClock->pdelay_req_send_time = *time;
;;;1026   //
;;;1027   //                /* Add  latency */
;;;1028   //                addTime(&ptpClock->pdelay_req_send_time, &ptpClock->pdelay_req_send_time, &rtOpts->outboundLatency);
;;;1029   //                break;
;;;1030   //            }
;;;1031   //            else
;;;1032   //            {
;;;1033   						//ptpClock->PdelayReqHeader = ptpClock->msgTmpHeader;
;;;1034   
;;;1035   					issuePDelayResp(ptpClock, time, &ptpClock->msgTmpHeader);
;;;1036   
;;;1037   					if ((time->seconds != 0) && getFlag(ptpClock->msgTmpHeader.flagField[0], FLAG0_TWO_STEP)) /* not loopback mode */
;;;1038   					{
;;;1039   							issuePDelayRespFollowUp(ptpClock, time, &ptpClock->msgTmpHeader);
;;;1040   					}
;;;1041   
;;;1042   					break;
;;;1043   
;;;1044   //            }
;;;1045   
;;;1046   				default:
;;;1047   
;;;1048   					DBG("handlePDelayReq: unrecognized state\n");
;;;1049   					break;
;;;1050   			}
;;;1051   			break;
;;;1052   
;;;1053   		default:
;;;1054   
;;;1055   			break;
;;;1056   	}
;;;1057   }
0007ee  bd70              POP      {r4-r6,pc}
                  |L1.2032|
0007f0  2062              MOVS     r0,#0x62              ;1002
0007f2  5d00              LDRB     r0,[r0,r4]            ;1002
0007f4  2809              CMP      r0,#9                 ;1002
0007f6  d223              BCS      |L1.2112|
0007f8  e8dff000          TBB      [pc,r0]               ;1002
0007fc  05060709          DCB      0x05,0x06,0x07,0x09
000800  220c0a08          DCB      0x22,0x0c,0x0a,0x08
000804  0b00              DCB      0x0b,0x00
000806  bf00              NOP                            ;1005
000808  bf00              NOP                            ;1006
00080a  bf00              NOP                            ;1007
00080c  bf00              NOP                            ;1008
00080e  e7ee              B        |L1.2030|
000810  bf00              NOP                            ;1013
000812  bf00              NOP                            ;1014
000814  b106              CBZ      r6,|L1.2072|
000816  e014              B        |L1.2114|
                  |L1.2072|
000818  f1040280          ADD      r2,r4,#0x80           ;1035
00081c  4629              MOV      r1,r5                 ;1035
00081e  4620              MOV      r0,r4                 ;1035
000820  f7fffffe          BL       issuePDelayResp
000824  6828              LDR      r0,[r5,#0]            ;1037
000826  b150              CBZ      r0,|L1.2110|
000828  2087              MOVS     r0,#0x87              ;1037
00082a  5d00              LDRB     r0,[r0,r4]            ;1037
00082c  f3c00040          UBFX     r0,r0,#1,#1           ;1037
000830  b128              CBZ      r0,|L1.2110|
000832  f1040280          ADD      r2,r4,#0x80           ;1039
000836  4629              MOV      r1,r5                 ;1039
000838  4620              MOV      r0,r4                 ;1039
00083a  f7fffffe          BL       issuePDelayRespFollowUp
                  |L1.2110|
00083e  e000              B        |L1.2114|
                  |L1.2112|
000840  bf00              NOP                            ;1049
                  |L1.2114|
000842  bf00              NOP                            ;1019
000844  e000              B        |L1.2120|
                  |L1.2118|
000846  bf00              NOP                            ;1055
                  |L1.2120|
000848  bf00              NOP                            ;990
00084a  bf00              NOP      
00084c  e7cf              B        |L1.2030|
;;;1058   
                          ENDP

                  issueDelayResp PROC
;;;1431   /* Pack and send on event multicast ip adress a DelayResp message */
;;;1432   static void issueDelayResp(PtpClock *ptpClock, const TimeInternal *time, const MsgHeader * delayReqHeader)
00084e  b5fe              PUSH     {r1-r7,lr}
;;;1433   {
000850  4604              MOV      r4,r0
000852  460d              MOV      r5,r1
000854  4616              MOV      r6,r2
;;;1434   	Timestamp requestReceiptTimestamp;
;;;1435   
;;;1436   	fromInternalTime(time, &requestReceiptTimestamp);
000856  4669              MOV      r1,sp
000858  4628              MOV      r0,r5
00085a  f7fffffe          BL       fromInternalTime
;;;1437   	msgPackDelayResp(ptpClock, ptpClock->msgObuf, delayReqHeader, &requestReceiptTimestamp);
00085e  466b              MOV      r3,sp
000860  4632              MOV      r2,r6
000862  f10401cc          ADD      r1,r4,#0xcc
000866  4620              MOV      r0,r4
000868  f7fffffe          BL       msgPackDelayResp
;;;1438   
;;;1439   	if (!netSendGeneral(&ptpClock->netPath, ptpClock->msgObuf, PDELAY_RESP_LENGTH))
00086c  2236              MOVS     r2,#0x36
00086e  f10401cc          ADD      r1,r4,#0xcc
000872  f5047073          ADD      r0,r4,#0x3cc
000876  f7fffffe          BL       netSendGeneral
00087a  b918              CBNZ     r0,|L1.2180|
;;;1440   	{
;;;1441   		ERROR("issueDelayResp: can't sent\n");
;;;1442   		toState(ptpClock, PTP_FAULTY);
00087c  2101              MOVS     r1,#1
00087e  4620              MOV      r0,r4
000880  f7fffffe          BL       toState
                  |L1.2180|
;;;1443   	}
;;;1444   	else
;;;1445   	{
;;;1446   		DBGV("issueDelayResp\n");
;;;1447   	}
;;;1448   }
000884  bdfe              POP      {r1-r7,pc}
;;;1449   
                          ENDP

                  handleDelayReq PROC
;;;849    
;;;850    static void handleDelayReq(PtpClock *ptpClock, TimeInternal *time, bool isFromSelf)
000886  b570              PUSH     {r4-r6,lr}
;;;851    {
000888  4604              MOV      r4,r0
00088a  460d              MOV      r5,r1
00088c  4616              MOV      r6,r2
;;;852    	switch (ptpClock->portDS.delayMechanism)
00088e  206f              MOVS     r0,#0x6f
000890  5d00              LDRB     r0,[r0,r4]
000892  2801              CMP      r0,#1
000894  d002              BEQ      |L1.2204|
000896  2802              CMP      r0,#2
000898  d125              BNE      |L1.2278|
00089a  e023              B        |L1.2276|
                  |L1.2204|
;;;853    	{
;;;854    		case E2E:
;;;855    
;;;856    			DBGV("handleDelayReq: received in mode E2E in state %s\n", stateString(ptpClock->portDS.portState));
;;;857    			if (ptpClock->msgIbufLength < DELAY_REQ_LENGTH)
00089c  f8d40324          LDR      r0,[r4,#0x324]
0008a0  282c              CMP      r0,#0x2c
0008a2  da04              BGE      |L1.2222|
;;;858    			{
;;;859    				ERROR("handleDelayReq: short message\n");
;;;860    				toState(ptpClock, PTP_FAULTY);
0008a4  2101              MOVS     r1,#1
0008a6  4620              MOV      r0,r4
0008a8  f7fffffe          BL       toState
                  |L1.2220|
;;;861    				return;
;;;862    			}
;;;863    
;;;864    			switch (ptpClock->portDS.portState)
;;;865    			{
;;;866    				case PTP_INITIALIZING:
;;;867    				case PTP_FAULTY:
;;;868    				case PTP_DISABLED:
;;;869    				case PTP_UNCALIBRATED:
;;;870    				case PTP_LISTENING:
;;;871    					DBGV("handleDelayReq: disreguard\n");
;;;872    					return;
;;;873    
;;;874    				case PTP_SLAVE:
;;;875    					DBGV("handleDelayReq: disreguard\n");
;;;876    //            if (isFromSelf)
;;;877    //            {
;;;878    //    /* waitingForLoopback? */
;;;879    //                /* Get sending timestamp from IP stack with So_TIMESTAMP */
;;;880    //                ptpClock->delay_req_send_time = *time;
;;;881    
;;;882    //                /* Add  latency */
;;;883    //                addTime(&ptpClock->delay_req_send_time, &ptpClock->delay_req_send_time, &rtOpts->outboundLatency);
;;;884    //                break;
;;;885    //            }
;;;886    					break;
;;;887    
;;;888    				case PTP_MASTER:
;;;889    					/* TODO: manage the value of ptpClock->logMinDelayReqInterval form logSyncInterval to logSyncInterval + 5 */
;;;890    					issueDelayResp(ptpClock, time, &ptpClock->msgTmpHeader);
;;;891    					break;
;;;892    
;;;893    				default:
;;;894    					DBG("handleDelayReq: unrecognized state\n");
;;;895    					break;
;;;896    			}
;;;897    
;;;898    			break;
;;;899    
;;;900    		case P2P:
;;;901    
;;;902    			ERROR("handleDelayReq: disreguard in P2P mode\n");
;;;903    			break;
;;;904    
;;;905    		default:
;;;906    
;;;907    			/* none */
;;;908    			break;
;;;909    	}
;;;910    }
0008ac  bd70              POP      {r4-r6,pc}
                  |L1.2222|
0008ae  2062              MOVS     r0,#0x62              ;864
0008b0  5d00              LDRB     r0,[r0,r4]            ;864
0008b2  2809              CMP      r0,#9                 ;864
0008b4  d213              BCS      |L1.2270|
0008b6  e8dff000          TBB      [pc,r0]               ;864
0008ba  0506              DCB      0x05,0x06
0008bc  0709120b          DCB      0x07,0x09,0x12,0x0b
0008c0  12080a00          DCB      0x12,0x08,0x0a,0x00
0008c4  bf00              NOP                            ;867
0008c6  bf00              NOP                            ;868
0008c8  bf00              NOP                            ;869
0008ca  bf00              NOP                            ;870
0008cc  e7ee              B        |L1.2220|
0008ce  e007              B        |L1.2272|
0008d0  f1040280          ADD      r2,r4,#0x80           ;890
0008d4  4629              MOV      r1,r5                 ;890
0008d6  4620              MOV      r0,r4                 ;890
0008d8  f7fffffe          BL       issueDelayResp
0008dc  e000              B        |L1.2272|
                  |L1.2270|
0008de  bf00              NOP                            ;895
                  |L1.2272|
0008e0  bf00              NOP                            ;886
0008e2  e001              B        |L1.2280|
                  |L1.2276|
0008e4  e000              B        |L1.2280|
                  |L1.2278|
0008e6  bf00              NOP                            ;908
                  |L1.2280|
0008e8  bf00              NOP                            ;898
0008ea  bf00              NOP      
0008ec  e7de              B        |L1.2220|
;;;911    
                          ENDP

                  handleFollowUp PROC
;;;761    
;;;762    static void handleFollowUp(PtpClock *ptpClock, bool isFromSelf)
0008ee  b57f              PUSH     {r0-r6,lr}
;;;763    {
0008f0  4604              MOV      r4,r0
0008f2  460d              MOV      r5,r1
;;;764    	TimeInternal preciseOriginTimestamp;
;;;765    	TimeInternal correctionField;
;;;766    	bool  isFromCurrentParent = FALSE;
0008f4  2600              MOVS     r6,#0
;;;767    
;;;768    	DBGV("handleFollowup: received in state %s\n", stateString(ptpClock->portDS.portState));
;;;769    
;;;770    	if (ptpClock->msgIbufLength < FOLLOW_UP_LENGTH)
0008f6  f8d40324          LDR      r0,[r4,#0x324]
0008fa  282c              CMP      r0,#0x2c
0008fc  da04              BGE      |L1.2312|
;;;771    	{
;;;772    		ERROR("handleFollowup: short message\n");
;;;773    		toState(ptpClock, PTP_FAULTY);
0008fe  2101              MOVS     r1,#1
000900  4620              MOV      r0,r4
000902  f7fffffe          BL       toState
                  |L1.2310|
;;;774    		return;
;;;775    	}
;;;776    
;;;777    	if (isFromSelf)
;;;778    	{
;;;779    		DBGV("handleFollowup: ignore from self\n");
;;;780    		return;
;;;781    	}
;;;782    
;;;783    	switch (ptpClock->portDS.portState)
;;;784    	{
;;;785    		case PTP_INITIALIZING:
;;;786    		case PTP_FAULTY:
;;;787    		case PTP_DISABLED:
;;;788    		case PTP_LISTENING:
;;;789    
;;;790    			DBGV("handleFollowup: disreguard\n");
;;;791    			break;
;;;792    
;;;793    		case PTP_UNCALIBRATED:
;;;794    		case PTP_SLAVE:
;;;795    
;;;796    			isFromCurrentParent = isSamePortIdentity(
;;;797    			&ptpClock->parentDS.parentPortIdentity,
;;;798    			&ptpClock->msgTmpHeader.sourcePortIdentity);
;;;799    
;;;800    			if (!ptpClock->waitingForFollowUp)
;;;801    			{
;;;802    				DBGV("handleFollowup: not waiting a message\n");
;;;803    				break;
;;;804    			}
;;;805    
;;;806    			if (!isFromCurrentParent)
;;;807    			{
;;;808    				DBGV("handleFollowup: not from current parent\n");
;;;809    				break;
;;;810    			}
;;;811    
;;;812    			if (ptpClock->recvSyncSequenceId !=  ptpClock->msgTmpHeader.sequenceId)
;;;813    			{
;;;814    				DBGV("handleFollowup: SequenceID doesn't match with last Sync message\n");
;;;815    				break;
;;;816    			}
;;;817    
;;;818    			msgUnpackFollowUp(ptpClock->msgIbuf, &ptpClock->msgTmp.follow);
;;;819    
;;;820    			ptpClock->waitingForFollowUp = FALSE;
;;;821    			/* synchronize local clock */
;;;822    			toInternalTime(&preciseOriginTimestamp, &ptpClock->msgTmp.follow.preciseOriginTimestamp);
;;;823    			scaledNanosecondsToInternalTime(&ptpClock->msgTmpHeader.correctionfield, &correctionField);
;;;824    			addTime(&correctionField, &correctionField, &ptpClock->correctionField_sync);
;;;825    			updateOffset(ptpClock, &ptpClock->timestamp_syncRecieve, &preciseOriginTimestamp, &correctionField);
;;;826    			updateClock(ptpClock);
;;;827    
;;;828    			issueDelayReqTimerExpired(ptpClock);
;;;829    			break;
;;;830    
;;;831    		case PTP_MASTER:
;;;832    
;;;833    			DBGV("handleFollowup: from another master\n");
;;;834    			break;
;;;835    
;;;836    		case PTP_PASSIVE:
;;;837    
;;;838    			DBGV("handleFollowup: disreguard\n");
;;;839    			issueDelayReqTimerExpired(ptpClock);
;;;840    			break;
;;;841    
;;;842    		default:
;;;843    
;;;844    			DBG("handleFollowup: unrecognized state\n");
;;;845    			break;
;;;846    	}
;;;847    }
000906  bd7f              POP      {r0-r6,pc}
                  |L1.2312|
000908  b105              CBZ      r5,|L1.2316|
00090a  e7fc              B        |L1.2310|
                  |L1.2316|
00090c  2062              MOVS     r0,#0x62              ;783
00090e  5d00              LDRB     r0,[r0,r4]            ;783
000910  2809              CMP      r0,#9                 ;783
000912  d24b              BCS      |L1.2476|
000914  e8dff000          TBB      [pc,r0]               ;783
000918  05060708          DCB      0x05,0x06,0x07,0x08
00091c  4a454609          DCB      0x4a,0x45,0x46,0x09
000920  0a00              DCB      0x0a,0x00
000922  bf00              NOP                            ;786
000924  bf00              NOP                            ;787
000926  bf00              NOP                            ;788
000928  e041              B        |L1.2478|
00092a  bf00              NOP                            ;794
00092c  f1040198          ADD      r1,r4,#0x98           ;796
000930  f1040028          ADD      r0,r4,#0x28           ;796
000934  f7fffffe          BL       isSamePortIdentity
000938  4606              MOV      r6,r0                 ;796
00093a  f894038c          LDRB     r0,[r4,#0x38c]        ;800
00093e  b900              CBNZ     r0,|L1.2370|
000940  e035              B        |L1.2478|
                  |L1.2370|
000942  b906              CBNZ     r6,|L1.2374|
000944  e033              B        |L1.2478|
                  |L1.2374|
000946  f9b4138a          LDRSH    r1,[r4,#0x38a]        ;812
00094a  f9b400a2          LDRSH    r0,[r4,#0xa2]         ;812
00094e  4281              CMP      r1,r0                 ;812
000950  d000              BEQ      |L1.2388|
000952  e02c              B        |L1.2478|
                  |L1.2388|
000954  f10401a8          ADD      r1,r4,#0xa8           ;818
000958  f50470fc          ADD      r0,r4,#0x1f8          ;818
00095c  f7fffffe          BL       msgUnpackFollowUp
000960  2000              MOVS     r0,#0                 ;820
000962  f884038c          STRB     r0,[r4,#0x38c]        ;820
000966  f10401a8          ADD      r1,r4,#0xa8           ;822
00096a  a802              ADD      r0,sp,#8              ;822
00096c  f7fffffe          BL       toInternalTime
000970  4669              MOV      r1,sp                 ;823
000972  f1040090          ADD      r0,r4,#0x90           ;823
000976  f7fffffe          BL       scaledNanosecondsToInternalTime
00097a  f504725c          ADD      r2,r4,#0x370          ;824
00097e  4669              MOV      r1,sp                 ;824
000980  4668              MOV      r0,sp                 ;824
000982  f7fffffe          BL       addTime
000986  466b              MOV      r3,sp                 ;825
000988  aa02              ADD      r2,sp,#8              ;825
00098a  f5047156          ADD      r1,r4,#0x358          ;825
00098e  4620              MOV      r0,r4                 ;825
000990  f7fffffe          BL       updateOffset
000994  4620              MOV      r0,r4                 ;826
000996  f7fffffe          BL       updateClock
00099a  4620              MOV      r0,r4                 ;828
00099c  f7fffffe          BL       issueDelayReqTimerExpired
0009a0  e005              B        |L1.2478|
0009a2  e004              B        |L1.2478|
0009a4  4620              MOV      r0,r4                 ;839
0009a6  f7fffffe          BL       issueDelayReqTimerExpired
0009aa  e000              B        |L1.2478|
                  |L1.2476|
0009ac  bf00              NOP                            ;845
                  |L1.2478|
0009ae  bf00              NOP                            ;791
0009b0  bf00              NOP      
0009b2  e7a8              B        |L1.2310|
;;;848    
                          ENDP

                  handleSync PROC
;;;658    
;;;659    static void handleSync(PtpClock *ptpClock, TimeInternal *time, bool isFromSelf)
0009b4  e92d41ff          PUSH     {r0-r8,lr}
;;;660    {
0009b8  4604              MOV      r4,r0
0009ba  460e              MOV      r6,r1
0009bc  4615              MOV      r5,r2
;;;661    	TimeInternal originTimestamp;
;;;662    	TimeInternal correctionField;
;;;663    	bool  isFromCurrentParent = FALSE;
0009be  2700              MOVS     r7,#0
;;;664    
;;;665    	DBGV("handleSync: received in state %s\n", stateString(ptpClock->portDS.portState));
;;;666    
;;;667    	if (ptpClock->msgIbufLength < SYNC_LENGTH)
0009c0  f8d40324          LDR      r0,[r4,#0x324]
0009c4  282c              CMP      r0,#0x2c
0009c6  da05              BGE      |L1.2516|
;;;668    	{
;;;669    		ERROR("handleSync: short message\n");
;;;670    		toState(ptpClock, PTP_FAULTY);
0009c8  2101              MOVS     r1,#1
0009ca  4620              MOV      r0,r4
0009cc  f7fffffe          BL       toState
                  |L1.2512|
;;;671    		return;
;;;672    	}
;;;673    
;;;674    	switch (ptpClock->portDS.portState)
;;;675    	{
;;;676    		case PTP_INITIALIZING:
;;;677    		case PTP_FAULTY:
;;;678    		case PTP_DISABLED:
;;;679    
;;;680    			DBGV("handleSync: disreguard\n");
;;;681    			break;
;;;682    
;;;683    		case PTP_UNCALIBRATED:
;;;684    		case PTP_SLAVE:
;;;685    
;;;686    			if (isFromSelf)
;;;687    			{
;;;688    				DBGV("handleSync: ignore from self\n");
;;;689    				break;
;;;690    			}
;;;691    
;;;692    			isFromCurrentParent = isSamePortIdentity(
;;;693    			&ptpClock->parentDS.parentPortIdentity,
;;;694    			&ptpClock->msgTmpHeader.sourcePortIdentity);
;;;695    
;;;696    			if (!isFromCurrentParent)
;;;697    			{
;;;698    				DBGV("handleSync: ignore from another master\n");
;;;699    				break;
;;;700    			}
;;;701    
;;;702    			ptpClock->timestamp_syncRecieve = *time;
;;;703    			scaledNanosecondsToInternalTime(&ptpClock->msgTmpHeader.correctionfield, &correctionField);
;;;704    
;;;705    			if (getFlag(ptpClock->msgTmpHeader.flagField[0], FLAG0_TWO_STEP))
;;;706    			{
;;;707    				ptpClock->waitingForFollowUp = TRUE;
;;;708    				ptpClock->recvSyncSequenceId = ptpClock->msgTmpHeader.sequenceId;
;;;709    				/* Save correctionField of Sync message for future use */
;;;710    				ptpClock->correctionField_sync = correctionField;
;;;711    			}
;;;712    			else
;;;713    			{
;;;714    				msgUnpackSync(ptpClock->msgIbuf, &ptpClock->msgTmp.sync);
;;;715    				ptpClock->waitingForFollowUp = FALSE;
;;;716    				/* Synchronize  local clock */
;;;717    				toInternalTime(&originTimestamp, &ptpClock->msgTmp.sync.originTimestamp);
;;;718    				/* use correctionField of Sync message for future use */
;;;719    				updateOffset(ptpClock, &ptpClock->timestamp_syncRecieve, &originTimestamp, &correctionField);
;;;720    				updateClock(ptpClock);
;;;721    				issueDelayReqTimerExpired(ptpClock);
;;;722    			}
;;;723    
;;;724    			break;
;;;725    
;;;726    		case PTP_MASTER:
;;;727    
;;;728    			if (!isFromSelf)
;;;729    			{
;;;730    				DBGV("handleSync: from another master\n");
;;;731    				break;
;;;732    			}
;;;733    			else
;;;734    			{
;;;735    				DBGV("handleSync: ignore from self\n");
;;;736    				break;
;;;737    			}
;;;738    
;;;739    //      if waitingForLoopback && TWO_STEP_FLAG
;;;740    //        {
;;;741    //            /* Add  latency */
;;;742    //            addTime(time, time, &rtOpts->outboundLatency);
;;;743    //
;;;744    //            issueFollowup(ptpClock, time);
;;;745    //            break;
;;;746    //        }
;;;747    		case PTP_PASSIVE:
;;;748    
;;;749    			DBGV("handleSync: disreguard\n");
;;;750    			issueDelayReqTimerExpired(ptpClock);
;;;751    
;;;752    			break;
;;;753    
;;;754    		default:
;;;755    
;;;756    			DBGV("handleSync: disreguard\n");
;;;757    			break;
;;;758    	}
;;;759    }
0009d0  e8bd81ff          POP      {r0-r8,pc}
                  |L1.2516|
0009d4  2062              MOVS     r0,#0x62              ;674
0009d6  5d00              LDRB     r0,[r0,r4]            ;674
0009d8  2809              CMP      r0,#9                 ;674
0009da  d256              BCS      |L1.2698|
0009dc  e8dff000          TBB      [pc,r0]               ;674
0009e0  05060755          DCB      0x05,0x06,0x07,0x55
0009e4  554e5108          DCB      0x55,0x4e,0x51,0x08
0009e8  0900              DCB      0x09,0x00
0009ea  bf00              NOP                            ;677
0009ec  bf00              NOP                            ;678
0009ee  e04d              B        |L1.2700|
0009f0  bf00              NOP                            ;684
0009f2  b105              CBZ      r5,|L1.2550|
0009f4  e04a              B        |L1.2700|
                  |L1.2550|
0009f6  f1040198          ADD      r1,r4,#0x98           ;692
0009fa  f1040028          ADD      r0,r4,#0x28           ;692
0009fe  f7fffffe          BL       isSamePortIdentity
000a02  4607              MOV      r7,r0                 ;692
000a04  b907              CBNZ     r7,|L1.2568|
000a06  e041              B        |L1.2700|
                  |L1.2568|
000a08  f5047040          ADD      r0,r4,#0x300          ;702
000a0c  e9d61200          LDRD     r1,r2,[r6,#0]         ;702
000a10  e9c01216          STRD     r1,r2,[r0,#0x58]      ;702
000a14  4669              MOV      r1,sp                 ;703
000a16  f1040090          ADD      r0,r4,#0x90           ;703
000a1a  f7fffffe          BL       scaledNanosecondsToInternalTime
000a1e  2087              MOVS     r0,#0x87              ;705
000a20  5d00              LDRB     r0,[r0,r4]            ;705
000a22  f3c00040          UBFX     r0,r0,#1,#1           ;705
000a26  b168              CBZ      r0,|L1.2628|
000a28  2001              MOVS     r0,#1                 ;707
000a2a  f884038c          STRB     r0,[r4,#0x38c]        ;707
000a2e  20a2              MOVS     r0,#0xa2              ;708
000a30  5b00              LDRH     r0,[r0,r4]            ;708
000a32  f8a4038a          STRH     r0,[r4,#0x38a]        ;708
000a36  f5047040          ADD      r0,r4,#0x300          ;710
000a3a  e9dd1200          LDRD     r1,r2,[sp,#0]         ;710
000a3e  e9c0121c          STRD     r1,r2,[r0,#0x70]      ;710
000a42  e01a              B        |L1.2682|
                  |L1.2628|
000a44  f10401a8          ADD      r1,r4,#0xa8           ;714
000a48  f50470fc          ADD      r0,r4,#0x1f8          ;714
000a4c  f7fffffe          BL       msgUnpackSync
000a50  2000              MOVS     r0,#0                 ;715
000a52  f884038c          STRB     r0,[r4,#0x38c]        ;715
000a56  f10401a8          ADD      r1,r4,#0xa8           ;717
000a5a  a802              ADD      r0,sp,#8              ;717
000a5c  f7fffffe          BL       toInternalTime
000a60  466b              MOV      r3,sp                 ;719
000a62  aa02              ADD      r2,sp,#8              ;719
000a64  f5047156          ADD      r1,r4,#0x358          ;719
000a68  4620              MOV      r0,r4                 ;719
000a6a  f7fffffe          BL       updateOffset
000a6e  4620              MOV      r0,r4                 ;720
000a70  f7fffffe          BL       updateClock
000a74  4620              MOV      r0,r4                 ;721
000a76  f7fffffe          BL       issueDelayReqTimerExpired
                  |L1.2682|
000a7a  e007              B        |L1.2700|
000a7c  b905              CBNZ     r5,|L1.2688|
000a7e  e005              B        |L1.2700|
                  |L1.2688|
000a80  e004              B        |L1.2700|
000a82  4620              MOV      r0,r4                 ;750
000a84  f7fffffe          BL       issueDelayReqTimerExpired
000a88  e000              B        |L1.2700|
                  |L1.2698|
000a8a  bf00              NOP                            ;757
                  |L1.2700|
000a8c  bf00              NOP                            ;681
000a8e  bf00              NOP      
000a90  e79e              B        |L1.2512|
;;;760    
                          ENDP

                  handleAnnounce PROC
;;;588    /* spec 9.5.3 */
;;;589    static void handleAnnounce(PtpClock *ptpClock, bool isFromSelf)
000a92  b570              PUSH     {r4-r6,lr}
;;;590    {
000a94  4604              MOV      r4,r0
000a96  460d              MOV      r5,r1
;;;591    	bool  isFromCurrentParent = FALSE;
000a98  2600              MOVS     r6,#0
;;;592    
;;;593    	DBGV("handleAnnounce: received in state %s\n", stateString(ptpClock->portDS.portState));
;;;594    
;;;595    	if (ptpClock->msgIbufLength < ANNOUNCE_LENGTH)
000a9a  f8d40324          LDR      r0,[r4,#0x324]
000a9e  2840              CMP      r0,#0x40
000aa0  da04              BGE      |L1.2732|
;;;596    	{
;;;597    			ERROR("handleAnnounce: short message\n");
;;;598    			toState(ptpClock, PTP_FAULTY);
000aa2  2101              MOVS     r1,#1
000aa4  4620              MOV      r0,r4
000aa6  f7fffffe          BL       toState
                  |L1.2730|
;;;599    			return;
;;;600    	}
;;;601    
;;;602    	if (isFromSelf)
;;;603    	{
;;;604    			DBGV("handleAnnounce: ignore from self\n");
;;;605    			return;
;;;606    	}
;;;607    
;;;608    	switch (ptpClock->portDS.portState)
;;;609    	{
;;;610    		case PTP_INITIALIZING:
;;;611    		case PTP_FAULTY:
;;;612    		case PTP_DISABLED:
;;;613    
;;;614    			DBGV("handleAnnounce: disreguard\n");
;;;615    			break;
;;;616    
;;;617    		case PTP_UNCALIBRATED:
;;;618    		case PTP_SLAVE:
;;;619    
;;;620    			/* Valid announce message is received : BMC algorithm will be executed */
;;;621    			setFlag(ptpClock->events, STATE_DECISION_EVENT);
;;;622    			isFromCurrentParent = isSamePortIdentity(
;;;623    			&ptpClock->parentDS.parentPortIdentity,
;;;624    			&ptpClock->msgTmpHeader.sourcePortIdentity);
;;;625    			msgUnpackAnnounce(ptpClock->msgIbuf, &ptpClock->msgTmp.announce);
;;;626    			if (isFromCurrentParent)
;;;627    			{
;;;628    					s1(ptpClock, &ptpClock->msgTmpHeader, &ptpClock->msgTmp.announce);
;;;629    					/* Reset  Timer handling Announce receipt timeout */
;;;630    					timerStart(ANNOUNCE_RECEIPT_TIMER, (ptpClock->portDS.announceReceiptTimeout) * (pow2ms(ptpClock->portDS.logAnnounceInterval)));
;;;631    			}
;;;632    			else
;;;633    			{
;;;634    				DBGV("handleAnnounce: from another foreign master\n");
;;;635    				/* addForeign takes care  of AnnounceUnpacking */
;;;636    				addForeign(ptpClock, &ptpClock->msgTmpHeader, &ptpClock->msgTmp.announce);
;;;637    			}
;;;638    
;;;639    			break;
;;;640    
;;;641    		case PTP_PASSIVE:
;;;642    				timerStart(ANNOUNCE_RECEIPT_TIMER, (ptpClock->portDS.announceReceiptTimeout)*(pow2ms(ptpClock->portDS.logAnnounceInterval)));
;;;643    		case PTP_MASTER:
;;;644    		case PTP_PRE_MASTER:
;;;645    		case PTP_LISTENING:
;;;646    		default :
;;;647    
;;;648    			DBGV("handleAnnounce: from another foreign master\n");
;;;649    			msgUnpackAnnounce(ptpClock->msgIbuf, &ptpClock->msgTmp.announce);
;;;650    
;;;651    			/* Valid announce message is received : BMC algorithm will be executed */
;;;652    			setFlag(ptpClock->events, STATE_DECISION_EVENT);
;;;653    			addForeign(ptpClock, &ptpClock->msgTmpHeader, &ptpClock->msgTmp.announce);
;;;654    
;;;655    			break;
;;;656    	}
;;;657    }
000aaa  bd70              POP      {r4-r6,pc}
                  |L1.2732|
000aac  b105              CBZ      r5,|L1.2736|
000aae  e7fc              B        |L1.2730|
                  |L1.2736|
000ab0  2062              MOVS     r0,#0x62              ;608
000ab2  5d00              LDRB     r0,[r0,r4]            ;608
000ab4  2809              CMP      r0,#9                 ;608
000ab6  d25d              BCS      |L1.2932|
000ab8  e8dff000          TBB      [pc,r0]               ;608
000abc  0506075f          DCB      0x05,0x06,0x07,0x5f
000ac0  5e5d4408          DCB      0x5e,0x5d,0x44,0x08
000ac4  0900              DCB      0x09,0x00
000ac6  bf00              NOP                            ;611
000ac8  bf00              NOP                            ;612
000aca  e06a              B        |L1.2978|
000acc  bf00              NOP                            ;618
000ace  f8d4045c          LDR      r0,[r4,#0x45c]        ;621
000ad2  f0400040          ORR      r0,r0,#0x40           ;621
000ad6  f8c4045c          STR      r0,[r4,#0x45c]        ;621
000ada  f1040198          ADD      r1,r4,#0x98           ;622
000ade  f1040028          ADD      r0,r4,#0x28           ;622
000ae2  f7fffffe          BL       isSamePortIdentity
000ae6  4606              MOV      r6,r0                 ;622
000ae8  f10401a8          ADD      r1,r4,#0xa8           ;625
000aec  f50470fc          ADD      r0,r4,#0x1f8          ;625
000af0  f7fffffe          BL       msgUnpackAnnounce
000af4  b1f6              CBZ      r6,|L1.2868|
000af6  f10402a8          ADD      r2,r4,#0xa8           ;628
000afa  f1040180          ADD      r1,r4,#0x80           ;628
000afe  4620              MOV      r0,r4                 ;628
000b00  f7fffffe          BL       ||s1||
000b04  206d              MOVS     r0,#0x6d              ;630
000b06  5d02              LDRB     r2,[r0,r4]            ;630
000b08  f994006c          LDRSB    r0,[r4,#0x6c]         ;630
000b0c  2800              CMP      r0,#0                 ;630
000b0e  dd05              BLE      |L1.2844|
000b10  206c              MOVS     r0,#0x6c              ;630
000b12  5d03              LDRB     r3,[r0,r4]            ;630
000b14  f44f707a          MOV      r0,#0x3e8             ;630
000b18  4098              LSLS     r0,r0,r3              ;630
000b1a  e005              B        |L1.2856|
                  |L1.2844|
000b1c  206c              MOVS     r0,#0x6c              ;630
000b1e  5d00              LDRB     r0,[r0,r4]            ;630
000b20  4243              RSBS     r3,r0,#0              ;630
000b22  f44f707a          MOV      r0,#0x3e8             ;630
000b26  4118              ASRS     r0,r0,r3              ;630
                  |L1.2856|
000b28  fb02f100          MUL      r1,r2,r0              ;630
000b2c  2003              MOVS     r0,#3                 ;630
000b2e  f7fffffe          BL       timerStart
000b32  e006              B        |L1.2882|
                  |L1.2868|
000b34  f10402a8          ADD      r2,r4,#0xa8           ;636
000b38  f1040180          ADD      r1,r4,#0x80           ;636
000b3c  4620              MOV      r0,r4                 ;636
000b3e  f7fffffe          BL       addForeign
                  |L1.2882|
000b42  e02e              B        |L1.2978|
000b44  206d              MOVS     r0,#0x6d              ;642
000b46  5d02              LDRB     r2,[r0,r4]            ;642
000b48  f994006c          LDRSB    r0,[r4,#0x6c]         ;642
000b4c  2800              CMP      r0,#0                 ;642
000b4e  dd05              BLE      |L1.2908|
000b50  206c              MOVS     r0,#0x6c              ;642
000b52  5d03              LDRB     r3,[r0,r4]            ;642
000b54  f44f707a          MOV      r0,#0x3e8             ;642
000b58  4098              LSLS     r0,r0,r3              ;642
000b5a  e005              B        |L1.2920|
                  |L1.2908|
000b5c  206c              MOVS     r0,#0x6c              ;642
000b5e  5d00              LDRB     r0,[r0,r4]            ;642
000b60  4243              RSBS     r3,r0,#0              ;642
000b62  f44f707a          MOV      r0,#0x3e8             ;642
000b66  4118              ASRS     r0,r0,r3              ;642
                  |L1.2920|
000b68  fb02f100          MUL      r1,r2,r0              ;642
000b6c  2003              MOVS     r0,#3                 ;642
000b6e  f7fffffe          BL       timerStart
000b72  bf00              NOP                            ;643
                  |L1.2932|
000b74  bf00              NOP                            ;643
000b76  bf00              NOP                            ;644
000b78  bf00              NOP                            ;645
000b7a  f10401a8          ADD      r1,r4,#0xa8           ;649
000b7e  f50470fc          ADD      r0,r4,#0x1f8          ;649
000b82  f7fffffe          BL       msgUnpackAnnounce
000b86  f8d4045c          LDR      r0,[r4,#0x45c]        ;652
000b8a  f0400040          ORR      r0,r0,#0x40           ;652
000b8e  f8c4045c          STR      r0,[r4,#0x45c]        ;652
000b92  f10402a8          ADD      r2,r4,#0xa8           ;653
000b96  f1040180          ADD      r1,r4,#0x80           ;653
000b9a  4620              MOV      r0,r4                 ;653
000b9c  f7fffffe          BL       addForeign
000ba0  bf00              NOP                            ;655
                  |L1.2978|
000ba2  bf00              NOP                            ;615
000ba4  bf00              NOP      
000ba6  e780              B        |L1.2730|
;;;658    
                          ENDP

                  handle PROC
;;;450    /* Check and handle received messages */
;;;451    static void handle(PtpClock *ptpClock)
000ba8  b57c              PUSH     {r2-r6,lr}
;;;452    {
000baa  4604              MOV      r4,r0
;;;453    
;;;454    		int ret;
;;;455    		bool  isFromSelf;
;;;456    		TimeInternal time = { 0, 0 };
000bac  2000              MOVS     r0,#0
000bae  9000              STR      r0,[sp,#0]
000bb0  9001              STR      r0,[sp,#4]
;;;457    
;;;458    		if (FALSE == ptpClock->messageActivity)
000bb2  f89403c8          LDRB     r0,[r4,#0x3c8]
000bb6  b970              CBNZ     r0,|L1.3030|
;;;459    		{
;;;460    				ret = netSelect(&ptpClock->netPath, 0);
000bb8  2100              MOVS     r1,#0
000bba  f5047073          ADD      r0,r4,#0x3cc
000bbe  f7fffffe          BL       netSelect
000bc2  4606              MOV      r6,r0
;;;461    
;;;462    				if (ret < 0)
000bc4  2e00              CMP      r6,#0
000bc6  da04              BGE      |L1.3026|
;;;463    				{
;;;464    						ERROR("handle: failed to poll sockets\n");
;;;465    						toState(ptpClock, PTP_FAULTY);
000bc8  2101              MOVS     r1,#1
000bca  4620              MOV      r0,r4
000bcc  f7fffffe          BL       toState
                  |L1.3024|
;;;466    						return;
;;;467    				}
;;;468    				else if (!ret)
;;;469    				{
;;;470    						DBGVV("handle: nothing\n");
;;;471    						return;
;;;472    				}
;;;473    		}
;;;474    
;;;475    		DBGVV("handle: something\n");
;;;476    
;;;477    		/* Receive an event. */
;;;478    		ptpClock->msgIbufLength = netRecvEvent(&ptpClock->netPath, ptpClock->msgIbuf, &time);
;;;479    		/* local time is not UTC, we can calculate UTC on demand, otherwise UTC time is not used */
;;;480    		/* time.seconds += ptpClock->timePropertiesDS.currentUtcOffset; */
;;;481    		DBGV("handle: netRecvEvent returned %d\n", ptpClock->msgIbufLength);
;;;482    
;;;483    		if (ptpClock->msgIbufLength < 0)
;;;484    		{
;;;485    				ERROR("handle: failed to receive on the event socket\n");
;;;486    				toState(ptpClock, PTP_FAULTY);
;;;487    				return;
;;;488    		}
;;;489    		else if (!ptpClock->msgIbufLength)//
;;;490    		{
;;;491    				/* Receive a general packet. */
;;;492    				ptpClock->msgIbufLength = netRecvGeneral(&ptpClock->netPath, ptpClock->msgIbuf, &time);
;;;493    				DBGV("handle: netRecvGeneral returned %d\n", ptpClock->msgIbufLength);
;;;494    
;;;495    				if (ptpClock->msgIbufLength < 0)
;;;496    				{
;;;497    						ERROR("handle: failed to receive on the general socket\n");
;;;498    						toState(ptpClock, PTP_FAULTY);
;;;499    						return;
;;;500    				}
;;;501    				else if (!ptpClock->msgIbufLength)
;;;502    						return;
;;;503    		}
;;;504    
;;;505    		ptpClock->messageActivity = TRUE;
;;;506    
;;;507    		if (ptpClock->msgIbufLength < HEADER_LENGTH)
;;;508    		{
;;;509    				ERROR("handle: message shorter than header length\n");
;;;510    				toState(ptpClock, PTP_FAULTY);
;;;511    				return;
;;;512    		}
;;;513    
;;;514    		msgUnpackHeader(ptpClock->msgIbuf, &ptpClock->msgTmpHeader);
;;;515    		DBGV("handle: unpacked message type %d\n", ptpClock->msgTmpHeader.messageType);
;;;516    
;;;517    		if (ptpClock->msgTmpHeader.versionPTP != ptpClock->portDS.versionNumber)
;;;518    		{
;;;519    				DBGV("handle: ignore version %d message\n", ptpClock->msgTmpHeader.versionPTP);
;;;520    				return;
;;;521    		}
;;;522    
;;;523    		if (ptpClock->msgTmpHeader.domainNumber != ptpClock->defaultDS.domainNumber)
;;;524    		{
;;;525    				DBGV("handle: ignore message from domainNumber %d\n", ptpClock->msgTmpHeader.domainNumber);
;;;526    				return;
;;;527    		}
;;;528    
;;;529    		/* Spec 9.5.2.2 */
;;;530    		isFromSelf = isSamePortIdentity(
;;;531    		&ptpClock->portDS.portIdentity,
;;;532    		&ptpClock->msgTmpHeader.sourcePortIdentity);
;;;533    
;;;534    		/* Subtract the inbound latency adjustment if it is not a loop back and the
;;;535    			 time stamp seems reasonable */
;;;536    		if (!isFromSelf && time.seconds > 0)
;;;537    				subTime(&time, &time, &ptpClock->inboundLatency);
;;;538    
;;;539    		switch (ptpClock->msgTmpHeader.messageType)
;;;540    		{
;;;541    
;;;542    		case ANNOUNCE:
;;;543    				handleAnnounce(ptpClock, isFromSelf);
;;;544    				break;
;;;545    
;;;546    		case SYNC:
;;;547    				handleSync(ptpClock, &time, isFromSelf);
;;;548    				break;
;;;549    
;;;550    		case FOLLOW_UP:
;;;551    				handleFollowUp(ptpClock, isFromSelf);
;;;552    				break;
;;;553    
;;;554    		case DELAY_REQ:
;;;555    				handleDelayReq(ptpClock, &time, isFromSelf);
;;;556    				break;
;;;557    
;;;558    		case PDELAY_REQ:
;;;559    				handlePDelayReq(ptpClock, &time, isFromSelf);
;;;560    				break;
;;;561    
;;;562    		case DELAY_RESP:
;;;563    				handleDelayResp(ptpClock, isFromSelf);
;;;564    				break;
;;;565    
;;;566    		case PDELAY_RESP:
;;;567    				handlePDelayResp(ptpClock, &time, isFromSelf);
;;;568    				break;
;;;569    
;;;570    		case PDELAY_RESP_FOLLOW_UP:
;;;571    				handlePDelayRespFollowUp(ptpClock, isFromSelf);
;;;572    				break;
;;;573    
;;;574    		case MANAGEMENT:
;;;575    				handleManagement(ptpClock, isFromSelf);
;;;576    				break;
;;;577    
;;;578    		case SIGNALING:
;;;579    				handleSignaling(ptpClock, isFromSelf);
;;;580    				break;
;;;581    
;;;582    		default:
;;;583    				DBG("handle: unrecognized message %d\n", ptpClock->msgTmpHeader.messageType);
;;;584    				break;
;;;585    		}
;;;586    }
000bd0  bd7c              POP      {r2-r6,pc}
                  |L1.3026|
000bd2  b906              CBNZ     r6,|L1.3030|
000bd4  e7fc              B        |L1.3024|
                  |L1.3030|
000bd6  466a              MOV      r2,sp                 ;478
000bd8  f50471fc          ADD      r1,r4,#0x1f8          ;478
000bdc  f5047073          ADD      r0,r4,#0x3cc          ;478
000be0  f7fffffe          BL       netRecvEvent
000be4  f8c40324          STR      r0,[r4,#0x324]        ;478
000be8  f8d40324          LDR      r0,[r4,#0x324]        ;483
000bec  2800              CMP      r0,#0                 ;483
000bee  da04              BGE      |L1.3066|
000bf0  2101              MOVS     r1,#1                 ;486
000bf2  4620              MOV      r0,r4                 ;486
000bf4  f7fffffe          BL       toState
000bf8  e7ea              B        |L1.3024|
                  |L1.3066|
000bfa  f8d40324          LDR      r0,[r4,#0x324]        ;489
000bfe  b9a8              CBNZ     r0,|L1.3116|
000c00  466a              MOV      r2,sp                 ;492
000c02  f50471fc          ADD      r1,r4,#0x1f8          ;492
000c06  f5047073          ADD      r0,r4,#0x3cc          ;492
000c0a  f7fffffe          BL       netRecvGeneral
000c0e  f8c40324          STR      r0,[r4,#0x324]        ;492
000c12  f8d40324          LDR      r0,[r4,#0x324]        ;495
000c16  2800              CMP      r0,#0                 ;495
000c18  da04              BGE      |L1.3108|
000c1a  2101              MOVS     r1,#1                 ;498
000c1c  4620              MOV      r0,r4                 ;498
000c1e  f7fffffe          BL       toState
000c22  e7d5              B        |L1.3024|
                  |L1.3108|
000c24  f8d40324          LDR      r0,[r4,#0x324]        ;501
000c28  b900              CBNZ     r0,|L1.3116|
000c2a  e7d1              B        |L1.3024|
                  |L1.3116|
000c2c  2001              MOVS     r0,#1                 ;505
000c2e  f88403c8          STRB     r0,[r4,#0x3c8]        ;505
000c32  f8d40324          LDR      r0,[r4,#0x324]        ;507
000c36  2822              CMP      r0,#0x22              ;507
000c38  da04              BGE      |L1.3140|
000c3a  2101              MOVS     r1,#1                 ;510
000c3c  4620              MOV      r0,r4                 ;510
000c3e  f7fffffe          BL       toState
000c42  e7c5              B        |L1.3024|
                  |L1.3140|
000c44  f1040180          ADD      r1,r4,#0x80           ;514
000c48  f50470fc          ADD      r0,r4,#0x1f8          ;514
000c4c  f7fffffe          BL       msgUnpackHeader
000c50  2082              MOVS     r0,#0x82              ;517
000c52  5d01              LDRB     r1,[r0,r4]            ;517
000c54  2071              MOVS     r0,#0x71              ;517
000c56  5d00              LDRB     r0,[r0,r4]            ;517
000c58  4281              CMP      r1,r0                 ;517
000c5a  d000              BEQ      |L1.3166|
000c5c  e7b8              B        |L1.3024|
                  |L1.3166|
000c5e  2086              MOVS     r0,#0x86              ;523
000c60  5d00              LDRB     r0,[r0,r4]            ;523
000c62  7ca1              LDRB     r1,[r4,#0x12]         ;523
000c64  4288              CMP      r0,r1                 ;523
000c66  d000              BEQ      |L1.3178|
000c68  e7b2              B        |L1.3024|
                  |L1.3178|
000c6a  f1040198          ADD      r1,r4,#0x98           ;530
000c6e  f1040058          ADD      r0,r4,#0x58           ;530
000c72  f7fffffe          BL       isSamePortIdentity
000c76  4605              MOV      r5,r0                 ;530
000c78  b945              CBNZ     r5,|L1.3212|
000c7a  9800              LDR      r0,[sp,#0]            ;536
000c7c  2800              CMP      r0,#0                 ;536
000c7e  dd05              BLE      |L1.3212|
000c80  f5046288          ADD      r2,r4,#0x440          ;537
000c84  4669              MOV      r1,sp                 ;537
000c86  4668              MOV      r0,sp                 ;537
000c88  f7fffffe          BL       subTime
                  |L1.3212|
000c8c  2081              MOVS     r0,#0x81              ;539
000c8e  5d00              LDRB     r0,[r0,r4]            ;539
000c90  280e              CMP      r0,#0xe               ;539
000c92  d23e              BCS      |L1.3346|
000c94  e8dff000          TBB      [pc,r0]               ;539
000c98  0c171d28          DCB      0x0c,0x17,0x1d,0x28
000c9c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000ca0  12232e07          DCB      0x12,0x23,0x2e,0x07
000ca4  3833              DCB      0x38,0x33
000ca6  4629              MOV      r1,r5                 ;543
000ca8  4620              MOV      r0,r4                 ;543
000caa  f7fffffe          BL       handleAnnounce
000cae  e031              B        |L1.3348|
000cb0  462a              MOV      r2,r5                 ;547
000cb2  4669              MOV      r1,sp                 ;547
000cb4  4620              MOV      r0,r4                 ;547
000cb6  f7fffffe          BL       handleSync
000cba  e02b              B        |L1.3348|
000cbc  4629              MOV      r1,r5                 ;551
000cbe  4620              MOV      r0,r4                 ;551
000cc0  f7fffffe          BL       handleFollowUp
000cc4  e026              B        |L1.3348|
000cc6  462a              MOV      r2,r5                 ;555
000cc8  4669              MOV      r1,sp                 ;555
000cca  4620              MOV      r0,r4                 ;555
000ccc  f7fffffe          BL       handleDelayReq
000cd0  e020              B        |L1.3348|
000cd2  462a              MOV      r2,r5                 ;559
000cd4  4669              MOV      r1,sp                 ;559
000cd6  4620              MOV      r0,r4                 ;559
000cd8  f7fffffe          BL       handlePDelayReq
000cdc  e01a              B        |L1.3348|
000cde  4629              MOV      r1,r5                 ;563
000ce0  4620              MOV      r0,r4                 ;563
000ce2  f7fffffe          BL       handleDelayResp
000ce6  e015              B        |L1.3348|
000ce8  462a              MOV      r2,r5                 ;567
000cea  4669              MOV      r1,sp                 ;567
000cec  4620              MOV      r0,r4                 ;567
000cee  f7fffffe          BL       handlePDelayResp
000cf2  e00f              B        |L1.3348|
000cf4  4629              MOV      r1,r5                 ;571
000cf6  4620              MOV      r0,r4                 ;571
000cf8  f7fffffe          BL       handlePDelayRespFollowUp
000cfc  e00a              B        |L1.3348|
000cfe  4629              MOV      r1,r5                 ;575
000d00  4620              MOV      r0,r4                 ;575
000d02  f7fffffe          BL       handleManagement
000d06  e005              B        |L1.3348|
000d08  4629              MOV      r1,r5                 ;579
000d0a  4620              MOV      r0,r4                 ;579
000d0c  f7fffffe          BL       handleSignaling
000d10  e000              B        |L1.3348|
                  |L1.3346|
000d12  bf00              NOP                            ;584
                  |L1.3348|
000d14  bf00              NOP                            ;544
000d16  bf00              NOP      
000d18  e75a              B        |L1.3024|
;;;587    
                          ENDP

                  issueAnnounce PROC
;;;1273   /* Pack and send  on general multicast ip adress an Announce message */
;;;1274   static void issueAnnounce(PtpClock *ptpClock)
000d1a  b510              PUSH     {r4,lr}
;;;1275   {
000d1c  4604              MOV      r4,r0
;;;1276   	msgPackAnnounce(ptpClock, ptpClock->msgObuf);
000d1e  f10401cc          ADD      r1,r4,#0xcc
000d22  4620              MOV      r0,r4
000d24  f7fffffe          BL       msgPackAnnounce
;;;1277   
;;;1278   	if (!netSendGeneral(&ptpClock->netPath, ptpClock->msgObuf, ANNOUNCE_LENGTH))
000d28  2240              MOVS     r2,#0x40
000d2a  f10401cc          ADD      r1,r4,#0xcc
000d2e  f5047073          ADD      r0,r4,#0x3cc
000d32  f7fffffe          BL       netSendGeneral
000d36  b920              CBNZ     r0,|L1.3394|
;;;1279   	{
;;;1280   		ERROR("issueAnnounce: can't sent\n");
;;;1281   		toState(ptpClock, PTP_FAULTY);
000d38  2101              MOVS     r1,#1
000d3a  4620              MOV      r0,r4
000d3c  f7fffffe          BL       toState
000d40  e005              B        |L1.3406|
                  |L1.3394|
;;;1282   	}
;;;1283   	else
;;;1284   	{
;;;1285   		DBGV("issueAnnounce\n");
;;;1286   		ptpClock->sentAnnounceSequenceId++;
000d42  f8b40386          LDRH     r0,[r4,#0x386]
000d46  1c40              ADDS     r0,r0,#1
000d48  b200              SXTH     r0,r0
000d4a  f8a40386          STRH     r0,[r4,#0x386]
                  |L1.3406|
;;;1287   	}
;;;1288   }
000d4e  bd10              POP      {r4,pc}
;;;1289   
                          ENDP

                  issueFollowup PROC
;;;1325   /* Pack and send on general multicast ip adress a FollowUp message */
;;;1326   static void issueFollowup(PtpClock *ptpClock, const TimeInternal *time)
000d50  b53e              PUSH     {r1-r5,lr}
;;;1327   {
000d52  4604              MOV      r4,r0
000d54  460d              MOV      r5,r1
;;;1328   	Timestamp preciseOriginTimestamp;
;;;1329   
;;;1330   	fromInternalTime(time, &preciseOriginTimestamp);
000d56  4669              MOV      r1,sp
000d58  4628              MOV      r0,r5
000d5a  f7fffffe          BL       fromInternalTime
;;;1331   	msgPackFollowUp(ptpClock, ptpClock->msgObuf, &preciseOriginTimestamp);
000d5e  466a              MOV      r2,sp
000d60  f10401cc          ADD      r1,r4,#0xcc
000d64  4620              MOV      r0,r4
000d66  f7fffffe          BL       msgPackFollowUp
;;;1332   
;;;1333   	if (!netSendGeneral(&ptpClock->netPath, ptpClock->msgObuf, FOLLOW_UP_LENGTH))
000d6a  222c              MOVS     r2,#0x2c
000d6c  f10401cc          ADD      r1,r4,#0xcc
000d70  f5047073          ADD      r0,r4,#0x3cc
000d74  f7fffffe          BL       netSendGeneral
000d78  b918              CBNZ     r0,|L1.3458|
;;;1334   	{
;;;1335   		ERROR("issueFollowup: can't sent\n");
;;;1336   		toState(ptpClock, PTP_FAULTY);
000d7a  2101              MOVS     r1,#1
000d7c  4620              MOV      r0,r4
000d7e  f7fffffe          BL       toState
                  |L1.3458|
;;;1337   	}
;;;1338   	else
;;;1339   	{
;;;1340   		DBGV("issueFollowup\n");
;;;1341   	}
;;;1342   }
000d82  bd3e              POP      {r1-r5,pc}
;;;1343   
                          ENDP

                  issueSync PROC
;;;1290   /* Pack and send  on event multicast ip adress a Sync message */
;;;1291   static void issueSync(PtpClock *ptpClock)
000d84  b510              PUSH     {r4,lr}
;;;1292   {
000d86  b086              SUB      sp,sp,#0x18
000d88  4604              MOV      r4,r0
;;;1293   	Timestamp originTimestamp;
;;;1294   	TimeInternal internalTime;
;;;1295   
;;;1296   	/* try to predict outgoing time stamp */
;;;1297   	getTime(&internalTime);
000d8a  a801              ADD      r0,sp,#4
000d8c  f7fffffe          BL       getTime
;;;1298   	fromInternalTime(&internalTime, &originTimestamp);
000d90  a903              ADD      r1,sp,#0xc
000d92  a801              ADD      r0,sp,#4
000d94  f7fffffe          BL       fromInternalTime
;;;1299   	msgPackSync(ptpClock, ptpClock->msgObuf, &originTimestamp);
000d98  aa03              ADD      r2,sp,#0xc
000d9a  f10401cc          ADD      r1,r4,#0xcc
000d9e  4620              MOV      r0,r4
000da0  f7fffffe          BL       msgPackSync
;;;1300   
;;;1301   	if (!netSendEvent(&ptpClock->netPath, ptpClock->msgObuf, SYNC_LENGTH, &internalTime))
000da4  ab01              ADD      r3,sp,#4
000da6  222c              MOVS     r2,#0x2c
000da8  f10401cc          ADD      r1,r4,#0xcc
000dac  f5047073          ADD      r0,r4,#0x3cc
000db0  f7fffffe          BL       netSendEvent
000db4  b920              CBNZ     r0,|L1.3520|
;;;1302   	{
;;;1303   		ERROR("issueSync: can't sent\n");
;;;1304   		toState(ptpClock, PTP_FAULTY);
000db6  2101              MOVS     r1,#1
000db8  4620              MOV      r0,r4
000dba  f7fffffe          BL       toState
000dbe  e013              B        |L1.3560|
                  |L1.3520|
;;;1305   	}
;;;1306   	else
;;;1307   	{
;;;1308   		DBGV("issueSync\n");
;;;1309   		ptpClock->sentSyncSequenceId++;
000dc0  f8b40384          LDRH     r0,[r4,#0x384]
000dc4  1c40              ADDS     r0,r0,#1
000dc6  b200              SXTH     r0,r0
000dc8  f8a40384          STRH     r0,[r4,#0x384]
;;;1310   
;;;1311   		/* sync TX timestamp is valid */
;;;1312   		if ((internalTime.seconds != 0) && (ptpClock->defaultDS.twoStepFlag))
000dcc  9801              LDR      r0,[sp,#4]
000dce  b158              CBZ      r0,|L1.3560|
000dd0  7820              LDRB     r0,[r4,#0]
000dd2  b148              CBZ      r0,|L1.3560|
;;;1313   		{
;;;1314   			// waitingForLoopback = false;
;;;1315   			addTime(&internalTime, &internalTime, &ptpClock->outboundLatency);
000dd4  f5046289          ADD      r2,r4,#0x448
000dd8  a901              ADD      r1,sp,#4
000dda  a801              ADD      r0,sp,#4
000ddc  f7fffffe          BL       addTime
;;;1316   			issueFollowup(ptpClock, &internalTime);
000de0  a901              ADD      r1,sp,#4
000de2  4620              MOV      r0,r4
000de4  f7fffffe          BL       issueFollowup
                  |L1.3560|
;;;1317   		}
;;;1318   		else
;;;1319   		{
;;;1320   			// waitingForLoopback = ptpClock->twoStepFlag;
;;;1321   		}
;;;1322   	}
;;;1323   }
000de8  b006              ADD      sp,sp,#0x18
000dea  bd10              POP      {r4,pc}
;;;1324   
                          ENDP

                  doState PROC
;;;241    /* Handle actions and events for 'port_state' */
;;;242    void doState(PtpClock *ptpClock)
000dec  b510              PUSH     {r4,lr}
;;;243    {
000dee  4604              MOV      r4,r0
;;;244    	ptpClock->messageActivity = FALSE;
000df0  2000              MOVS     r0,#0
000df2  f88403c8          STRB     r0,[r4,#0x3c8]
;;;245    
;;;246    	switch (ptpClock->portDS.portState)
000df6  2062              MOVS     r0,#0x62
000df8  5d00              LDRB     r0,[r0,r4]
000dfa  1ec0              SUBS     r0,r0,#3
000dfc  2806              CMP      r0,#6
000dfe  d22d              BCS      |L1.3676|
000e00  e8dff000          TBB      [pc,r0]
000e04  03060708          DCB      0x03,0x06,0x07,0x08
000e08  0405              DCB      0x04,0x05
;;;247    	{
;;;248    		case PTP_LISTENING:
;;;249    		case PTP_UNCALIBRATED:
000e0a  bf00              NOP      
;;;250    		case PTP_SLAVE:
000e0c  bf00              NOP      
;;;251    		case PTP_PRE_MASTER:
000e0e  bf00              NOP      
;;;252    		case PTP_MASTER:
000e10  bf00              NOP      
;;;253    		case PTP_PASSIVE:
000e12  bf00              NOP      
;;;254    
;;;255    			/* State decision Event */
;;;256    			if (getFlag(ptpClock->events, STATE_DECISION_EVENT))
000e14  f894045c          LDRB     r0,[r4,#0x45c]
000e18  f3c01080          UBFX     r0,r0,#6,#1
000e1c  b1e8              CBZ      r0,|L1.3674|
;;;257    			{
;;;258    				DBGV("event STATE_DECISION_EVENT\n");
;;;259    				clearFlag(ptpClock->events, STATE_DECISION_EVENT);
000e1e  f8d4045c          LDR      r0,[r4,#0x45c]
000e22  f0200040          BIC      r0,r0,#0x40
000e26  f8c4045c          STR      r0,[r4,#0x45c]
;;;260    				ptpClock->recommendedState = bmc(ptpClock);
000e2a  4620              MOV      r0,r4
000e2c  f7fffffe          BL       bmc
000e30  f8840438          STRB     r0,[r4,#0x438]
;;;261    				DBGV("recommending state %s\n", stateString(ptpClock->recommendedState));
;;;262    
;;;263    				switch (ptpClock->recommendedState)
000e34  f8940438          LDRB     r0,[r4,#0x438]
000e38  2805              CMP      r0,#5
000e3a  d002              BEQ      |L1.3650|
000e3c  2806              CMP      r0,#6
000e3e  d10a              BNE      |L1.3670|
000e40  e000              B        |L1.3652|
                  |L1.3650|
;;;264    				{
;;;265    					case PTP_MASTER:
;;;266    					case PTP_PASSIVE:
000e42  bf00              NOP      
                  |L1.3652|
;;;267    						if (ptpClock->defaultDS.slaveOnly || ptpClock->defaultDS.clockQuality.clockClass == 255)
000e44  7ce0              LDRB     r0,[r4,#0x13]
000e46  b910              CBNZ     r0,|L1.3662|
000e48  7b20              LDRB     r0,[r4,#0xc]
000e4a  28ff              CMP      r0,#0xff
000e4c  d102              BNE      |L1.3668|
                  |L1.3662|
;;;268    						{
;;;269    								ptpClock->recommendedState = PTP_LISTENING;
000e4e  2003              MOVS     r0,#3
000e50  f8840438          STRB     r0,[r4,#0x438]
                  |L1.3668|
;;;270    								DBGV("recommending state %s\n", stateString(ptpClock->recommendedState));
;;;271    						}
;;;272    						break;
000e54  e000              B        |L1.3672|
                  |L1.3670|
;;;273    
;;;274    					default:
;;;275    						break;
000e56  bf00              NOP      
                  |L1.3672|
000e58  bf00              NOP                            ;272
                  |L1.3674|
;;;276    				}
;;;277    			}
;;;278    			break;
000e5a  e000              B        |L1.3678|
                  |L1.3676|
;;;279    
;;;280    			default:
;;;281    				break;
000e5c  bf00              NOP      
                  |L1.3678|
000e5e  bf00              NOP                            ;278
;;;282    	}
;;;283    
;;;284    	switch (ptpClock->recommendedState)
000e60  f8940438          LDRB     r0,[r4,#0x438]
000e64  2809              CMP      r0,#9
000e66  d27e              BCS      |L1.3942|
000e68  e8dff000          TBB      [pc,r0]
000e6c  7c7d7d71          DCB      0x7c,0x7d,0x7d,0x71
000e70  7d051d7d          DCB      0x7d,0x05,0x1d,0x7d
000e74  2800              DCB      0x28,0x00
;;;285    	{
;;;286    		case PTP_MASTER:
;;;287    			switch (ptpClock->portDS.portState)
000e76  2062              MOVS     r0,#0x62
000e78  5d00              LDRB     r0,[r0,r4]
000e7a  2804              CMP      r0,#4
000e7c  d002              BEQ      |L1.3716|
000e7e  2805              CMP      r0,#5
000e80  d10a              BNE      |L1.3736|
000e82  e008              B        |L1.3734|
                  |L1.3716|
;;;288    			{
;;;289    				case PTP_PRE_MASTER:
;;;290    					if (timerExpired(QUALIFICATION_TIMEOUT)) toState(ptpClock, PTP_MASTER);
000e84  2005              MOVS     r0,#5
000e86  f7fffffe          BL       timerExpired
000e8a  b118              CBZ      r0,|L1.3732|
000e8c  2105              MOVS     r1,#5
000e8e  4620              MOV      r0,r4
000e90  f7fffffe          BL       toState
                  |L1.3732|
;;;291    					break;
000e94  e005              B        |L1.3746|
                  |L1.3734|
;;;292    				case PTP_MASTER:
;;;293    					break;
000e96  e004              B        |L1.3746|
                  |L1.3736|
;;;294    				default:
;;;295    					toState(ptpClock, PTP_PRE_MASTER);
000e98  2104              MOVS     r1,#4
000e9a  4620              MOV      r0,r4
000e9c  f7fffffe          BL       toState
;;;296    					break;
000ea0  bf00              NOP      
                  |L1.3746|
000ea2  bf00              NOP                            ;291
;;;297    			}
;;;298    			break;
000ea4  e060              B        |L1.3944|
;;;299    
;;;300    		case PTP_PASSIVE:
;;;301    			if (ptpClock->portDS.portState != ptpClock->recommendedState) toState(ptpClock, PTP_PASSIVE);
000ea6  2062              MOVS     r0,#0x62
000ea8  5d00              LDRB     r0,[r0,r4]
000eaa  f8941438          LDRB     r1,[r4,#0x438]
000eae  4288              CMP      r0,r1
000eb0  d003              BEQ      |L1.3770|
000eb2  2106              MOVS     r1,#6
000eb4  4620              MOV      r0,r4
000eb6  f7fffffe          BL       toState
                  |L1.3770|
;;;302    			break;
000eba  e055              B        |L1.3944|
;;;303    
;;;304    		case PTP_SLAVE:
;;;305    
;;;306    			switch (ptpClock->portDS.portState)
000ebc  2062              MOVS     r0,#0x62
000ebe  5d00              LDRB     r0,[r0,r4]
000ec0  2807              CMP      r0,#7
000ec2  d002              BEQ      |L1.3786|
000ec4  2808              CMP      r0,#8
000ec6  d13a              BNE      |L1.3902|
000ec8  e01a              B        |L1.3840|
                  |L1.3786|
;;;307    			{
;;;308    				case PTP_UNCALIBRATED:
;;;309    
;;;310    					if (getFlag(ptpClock->events, MASTER_CLOCK_SELECTED))
000eca  f8b4045c          LDRH     r0,[r4,#0x45c]
000ece  f3c02080          UBFX     r0,r0,#10,#1
000ed2  b148              CBZ      r0,|L1.3816|
;;;311    					{
;;;312    						DBG("event MASTER_CLOCK_SELECTED\n");
;;;313    						clearFlag(ptpClock->events, MASTER_CLOCK_SELECTED);
000ed4  f8d4045c          LDR      r0,[r4,#0x45c]
000ed8  f4206080          BIC      r0,r0,#0x400
000edc  f8c4045c          STR      r0,[r4,#0x45c]
;;;314    						toState(ptpClock, PTP_SLAVE);
000ee0  2108              MOVS     r1,#8
000ee2  4620              MOV      r0,r4
000ee4  f7fffffe          BL       toState
                  |L1.3816|
;;;315    					}
;;;316    
;;;317    					if (getFlag(ptpClock->events, MASTER_CLOCK_CHANGED))
000ee8  f8b4045c          LDRH     r0,[r4,#0x45c]
000eec  f3c020c0          UBFX     r0,r0,#11,#1
000ef0  b128              CBZ      r0,|L1.3838|
;;;318    					{
;;;319    						DBG("event MASTER_CLOCK_CHANGED\n");
;;;320    						clearFlag(ptpClock->events, MASTER_CLOCK_CHANGED);
000ef2  f8d4045c          LDR      r0,[r4,#0x45c]
000ef6  f4206000          BIC      r0,r0,#0x800
000efa  f8c4045c          STR      r0,[r4,#0x45c]
                  |L1.3838|
;;;321    					}
;;;322    
;;;323    					break;
000efe  e023              B        |L1.3912|
                  |L1.3840|
;;;324    
;;;325    				case PTP_SLAVE:
;;;326    
;;;327    					if (getFlag(ptpClock->events, SYNCHRONIZATION_FAULT))
000f00  f8b4045c          LDRH     r0,[r4,#0x45c]
000f04  f3c02040          UBFX     r0,r0,#9,#1
000f08  b148              CBZ      r0,|L1.3870|
;;;328    					{
;;;329    							DBG("event SYNCHRONIZATION_FAULT\n");
;;;330    							clearFlag(ptpClock->events, SYNCHRONIZATION_FAULT);
000f0a  f8d4045c          LDR      r0,[r4,#0x45c]
000f0e  f4207000          BIC      r0,r0,#0x200
000f12  f8c4045c          STR      r0,[r4,#0x45c]
;;;331    							toState(ptpClock, PTP_UNCALIBRATED);
000f16  2107              MOVS     r1,#7
000f18  4620              MOV      r0,r4
000f1a  f7fffffe          BL       toState
                  |L1.3870|
;;;332    					}
;;;333    
;;;334    					if (getFlag(ptpClock->events, MASTER_CLOCK_CHANGED))
000f1e  f8b4045c          LDRH     r0,[r4,#0x45c]
000f22  f3c020c0          UBFX     r0,r0,#11,#1
000f26  b148              CBZ      r0,|L1.3900|
;;;335    					{
;;;336    							DBG("event MASTER_CLOCK_CHANGED\n");
;;;337    							clearFlag(ptpClock->events, MASTER_CLOCK_CHANGED);
000f28  f8d4045c          LDR      r0,[r4,#0x45c]
000f2c  f4206000          BIC      r0,r0,#0x800
000f30  f8c4045c          STR      r0,[r4,#0x45c]
;;;338    							toState(ptpClock, PTP_UNCALIBRATED);
000f34  2107              MOVS     r1,#7
000f36  4620              MOV      r0,r4
000f38  f7fffffe          BL       toState
                  |L1.3900|
;;;339    					}
;;;340    
;;;341    					break;
000f3c  e004              B        |L1.3912|
                  |L1.3902|
;;;342    
;;;343    				default:
;;;344    
;;;345    					toState(ptpClock, PTP_UNCALIBRATED);
000f3e  2107              MOVS     r1,#7
000f40  4620              MOV      r0,r4
000f42  f7fffffe          BL       toState
;;;346    					break;
000f46  bf00              NOP      
                  |L1.3912|
000f48  bf00              NOP                            ;323
;;;347    			}
;;;348    
;;;349    			break;
000f4a  e00d              B        |L1.3944|
000f4c  e00b              B        |L1.3942|
;;;350    
;;;351    		case PTP_LISTENING:
;;;352    
;;;353    			if (ptpClock->portDS.portState != ptpClock->recommendedState)
000f4e  2062              MOVS     r0,#0x62
000f50  5d00              LDRB     r0,[r0,r4]
000f52  f8941438          LDRB     r1,[r4,#0x438]
000f56  4288              CMP      r0,r1
000f58  d003              BEQ      |L1.3938|
;;;354    			{
;;;355    				toState(ptpClock, PTP_LISTENING);
000f5a  2103              MOVS     r1,#3
000f5c  4620              MOV      r0,r4
000f5e  f7fffffe          BL       toState
                  |L1.3938|
;;;356    			}
;;;357    
;;;358    			break;
000f62  e001              B        |L1.3944|
;;;359    
;;;360    		case PTP_INITIALIZING:
;;;361    			break;
000f64  e000              B        |L1.3944|
                  |L1.3942|
;;;362    
;;;363    		default:
;;;364    			DBG("doState: unrecognized recommended state %d\n", ptpClock->recommendedState);
;;;365    			break;
000f66  bf00              NOP      
                  |L1.3944|
000f68  bf00              NOP                            ;298
;;;366    	}
;;;367    
;;;368    	switch (ptpClock->portDS.portState)
000f6a  2062              MOVS     r0,#0x62
000f6c  5d00              LDRB     r0,[r0,r4]
000f6e  2809              CMP      r0,#9
000f70  d25b              BCS      |L1.4138|
000f72  e8dff000          TBB      [pc,r0]
000f76  0513              DCB      0x05,0x13
000f78  181c5a45          DCB      0x18,0x1c,0x5a,0x45
000f7c  1f1d1e00          DCB      0x1f,0x1d,0x1e,0x00
;;;369    	{
;;;370    		case PTP_INITIALIZING:
;;;371    
;;;372    			if (doInit(ptpClock) == TRUE)
000f80  4620              MOV      r0,r4
000f82  f7fffffe          BL       doInit
000f86  b120              CBZ      r0,|L1.3986|
;;;373    			{
;;;374    				toState(ptpClock, PTP_LISTENING);
000f88  2103              MOVS     r1,#3
000f8a  4620              MOV      r0,r4
000f8c  f7fffffe          BL       toState
000f90  e003              B        |L1.3994|
                  |L1.3986|
;;;375    			}
;;;376    			else
;;;377    			{
;;;378    				toState(ptpClock, PTP_FAULTY);
000f92  2101              MOVS     r1,#1
000f94  4620              MOV      r0,r4
000f96  f7fffffe          BL       toState
                  |L1.3994|
;;;379    			}
;;;380    
;;;381    			break;
000f9a  e047              B        |L1.4140|
;;;382    
;;;383    		case PTP_FAULTY:
;;;384    
;;;385    			/* Imaginary troubleshooting */
;;;386    			DBG("event FAULT_CLEARED for state PTP_FAULT\n");
;;;387    			toState(ptpClock, PTP_INITIALIZING);
000f9c  2100              MOVS     r1,#0
000f9e  4620              MOV      r0,r4
000fa0  f7fffffe          BL       toState
                  |L1.4004|
;;;388    			return;
;;;389    
;;;390    		case PTP_DISABLED:
;;;391    			handle(ptpClock);
;;;392    			break;
;;;393    
;;;394    		case PTP_LISTENING:
;;;395    		case PTP_UNCALIBRATED:
;;;396    		case PTP_SLAVE:
;;;397    		case PTP_PASSIVE:
;;;398    
;;;399    			if (timerExpired(ANNOUNCE_RECEIPT_TIMER))
;;;400    			{
;;;401    				DBGV("event ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES for state %s\n", stateString(ptpClock->portDS.portState));
;;;402    				ptpClock->foreignMasterDS.count = 0;
;;;403    				ptpClock->foreignMasterDS.i = 0;
;;;404    
;;;405    				if (!(ptpClock->defaultDS.slaveOnly || ptpClock->defaultDS.clockQuality.clockClass == 255))
;;;406    				{
;;;407    					m1(ptpClock);
;;;408    					ptpClock->recommendedState = PTP_MASTER;
;;;409    					DBGV("recommending state %s\n", stateString(ptpClock->recommendedState));
;;;410    					toState(ptpClock, PTP_MASTER);
;;;411    				}
;;;412    				else if (ptpClock->portDS.portState != PTP_LISTENING)
;;;413    				{
;;;414    					toState(ptpClock, PTP_LISTENING);
;;;415    				}
;;;416    
;;;417    				break;
;;;418    			}
;;;419    
;;;420    			handle(ptpClock);
;;;421    
;;;422    			break;
;;;423    
;;;424    		case PTP_MASTER:
;;;425    
;;;426    			if (timerExpired(SYNC_INTERVAL_TIMER))
;;;427    			{
;;;428    					DBGV("event SYNC_INTERVAL_TIMEOUT_EXPIRES for state PTP_MASTER\n");
;;;429    					issueSync(ptpClock);
;;;430    			}
;;;431    
;;;432    			if (timerExpired(ANNOUNCE_INTERVAL_TIMER))
;;;433    			{
;;;434    					DBGV("event ANNOUNCE_INTERVAL_TIMEOUT_EXPIRES for state PTP_MASTER\n");
;;;435    					issueAnnounce(ptpClock);
;;;436    			}
;;;437    
;;;438    			handle(ptpClock);
;;;439    			issueDelayReqTimerExpired(ptpClock);
;;;440    
;;;441    			break;
;;;442    
;;;443    		default:
;;;444    			DBG("doState: do unrecognized state %d\n", ptpClock->portDS.portState);
;;;445    			break;
;;;446    	}
;;;447    }
000fa4  bd10              POP      {r4,pc}
000fa6  4620              MOV      r0,r4                 ;391
000fa8  f7fffffe          BL       handle
000fac  e03e              B        |L1.4140|
000fae  bf00              NOP                            ;395
000fb0  bf00              NOP                            ;396
000fb2  bf00              NOP                            ;397
000fb4  2003              MOVS     r0,#3                 ;399
000fb6  f7fffffe          BL       timerExpired
000fba  b1e8              CBZ      r0,|L1.4088|
000fbc  2100              MOVS     r1,#0                 ;402
000fbe  2078              MOVS     r0,#0x78              ;402
000fc0  5301              STRH     r1,[r0,r4]            ;402
000fc2  207c              MOVS     r0,#0x7c              ;403
000fc4  5301              STRH     r1,[r0,r4]            ;403
000fc6  7ce0              LDRB     r0,[r4,#0x13]         ;405
000fc8  b968              CBNZ     r0,|L1.4070|
000fca  7b20              LDRB     r0,[r4,#0xc]          ;405
000fcc  28ff              CMP      r0,#0xff              ;405
000fce  d00a              BEQ      |L1.4070|
000fd0  4620              MOV      r0,r4                 ;407
000fd2  f7fffffe          BL       ||m1||
000fd6  2005              MOVS     r0,#5                 ;408
000fd8  f8840438          STRB     r0,[r4,#0x438]        ;408
000fdc  2105              MOVS     r1,#5                 ;410
000fde  4620              MOV      r0,r4                 ;410
000fe0  f7fffffe          BL       toState
000fe4  e007              B        |L1.4086|
                  |L1.4070|
000fe6  2062              MOVS     r0,#0x62              ;412
000fe8  5d00              LDRB     r0,[r0,r4]            ;412
000fea  2803              CMP      r0,#3                 ;412
000fec  d003              BEQ      |L1.4086|
000fee  2103              MOVS     r1,#3                 ;414
000ff0  4620              MOV      r0,r4                 ;414
000ff2  f7fffffe          BL       toState
                  |L1.4086|
000ff6  e019              B        |L1.4140|
                  |L1.4088|
000ff8  4620              MOV      r0,r4                 ;420
000ffa  f7fffffe          BL       handle
000ffe  e015              B        |L1.4140|
001000  2002              MOVS     r0,#2                 ;426
001002  f7fffffe          BL       timerExpired
001006  b110              CBZ      r0,|L1.4110|
001008  4620              MOV      r0,r4                 ;429
00100a  f7fffffe          BL       issueSync
                  |L1.4110|
00100e  2004              MOVS     r0,#4                 ;432
001010  f7fffffe          BL       timerExpired
001014  b110              CBZ      r0,|L1.4124|
001016  4620              MOV      r0,r4                 ;435
001018  f7fffffe          BL       issueAnnounce
                  |L1.4124|
00101c  4620              MOV      r0,r4                 ;438
00101e  f7fffffe          BL       handle
001022  4620              MOV      r0,r4                 ;439
001024  f7fffffe          BL       issueDelayReqTimerExpired
001028  e000              B        |L1.4140|
                  |L1.4138|
00102a  bf00              NOP                            ;445
                  |L1.4140|
00102c  bf00              NOP                            ;381
00102e  bf00              NOP      
001030  e7b8              B        |L1.4004|
;;;448    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\protocol.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_protocol_c_toState____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_protocol_c_toState____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_protocol_c_toState____REVSH|
#line 128
|__asm___10_protocol_c_toState____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
