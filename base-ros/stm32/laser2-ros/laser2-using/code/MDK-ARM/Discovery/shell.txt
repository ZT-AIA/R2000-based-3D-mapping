; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\shell.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\shell.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\shell.crf ..\src\shell.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  shell_exit PROC
;;;31     
;;;32     static bool shell_exit(int argc, char **argv)
000000  4602              MOV      r2,r0
;;;33     {
;;;34     	// Exit the shell interpreter.
;;;35     	return false;
000002  2000              MOVS     r0,#0
;;;36     }
000004  4770              BX       lr
;;;37     
                          ENDP

                  shell_help PROC
;;;38     static bool shell_help(int argc, char **argv)
000006  b570              PUSH     {r4-r6,lr}
;;;39     {
000008  4605              MOV      r5,r0
00000a  460e              MOV      r6,r1
;;;40     	uint32_t i;
;;;41     
;;;42     	// Loop over each shell command.
;;;43     	for (i = 0; i < sizeof(commands) / sizeof(struct shell_command); ++i)
00000c  2400              MOVS     r4,#0
00000e  e008              B        |L1.34|
                  |L1.16|
;;;44     	{
;;;45     		telnet_printf("%s\n", commands[i].name);
000010  eb040084          ADD      r0,r4,r4,LSL #2
000014  4aa4              LDR      r2,|L1.680|
000016  eb020180          ADD      r1,r2,r0,LSL #2
00001a  a0a4              ADR      r0,|L1.684|
00001c  f7fffffe          BL       telnet_printf
000020  1c64              ADDS     r4,r4,#1              ;43
                  |L1.34|
000022  2c04              CMP      r4,#4                 ;43
000024  d3f4              BCC      |L1.16|
;;;46     	}
;;;47     
;;;48     	return true;
000026  2001              MOVS     r0,#1
;;;49     }
000028  bd70              POP      {r4-r6,pc}
;;;50     
                          ENDP

                  shell_date PROC
;;;51     static bool shell_date(int argc, char **argv)
00002a  b570              PUSH     {r4-r6,lr}
;;;52     {
00002c  b08c              SUB      sp,sp,#0x30
00002e  4605              MOV      r5,r0
000030  460e              MOV      r6,r1
;;;53     	char buffer[32];
;;;54     	time_t seconds1900;
;;;55     	struct ptptime_t ptptime;
;;;56     
;;;57     	// Get the ethernet time values.
;;;58     	ETH_PTPTime_GetTime(&ptptime);
000032  a801              ADD      r0,sp,#4
000034  f7fffffe          BL       ETH_PTPTime_GetTime
;;;59     
;;;60     	// Get the seconds since 1900.
;;;61     	seconds1900 = (time_t) ptptime.tv_sec;
000038  9801              LDR      r0,[sp,#4]
00003a  9003              STR      r0,[sp,#0xc]
;;;62     
;;;63     	// Format into a string.
;;;64     	strftime(buffer, sizeof(buffer), "%a %b %d %H:%M:%S UTC %Y\n", localtime(&seconds1900));
00003c  a803              ADD      r0,sp,#0xc
00003e  f7fffffe          BL       localtime
000042  4604              MOV      r4,r0
000044  4623              MOV      r3,r4
000046  a29a              ADR      r2,|L1.688|
000048  2120              MOVS     r1,#0x20
00004a  a804              ADD      r0,sp,#0x10
00004c  f7fffffe          BL       strftime
;;;65     
;;;66     	// Print the string.
;;;67     	telnet_puts(buffer);
000050  a804              ADD      r0,sp,#0x10
000052  f7fffffe          BL       telnet_puts
;;;68     
;;;69     	return true;
000056  2001              MOVS     r0,#1
;;;70     }
000058  b00c              ADD      sp,sp,#0x30
00005a  bd70              POP      {r4-r6,pc}
;;;71     
                          ENDP

                  shell_ptpd PROC
;;;72     static bool shell_ptpd(int argc, char **argv)
00005c  e92d47f0          PUSH     {r4-r10,lr}
;;;73     {
000060  b086              SUB      sp,sp,#0x18
000062  4681              MOV      r9,r0
000064  468a              MOV      r10,r1
;;;74     	char sign;
;;;75     	const char *s;
;;;76     	unsigned char *uuid;
;;;77     	extern PtpClock ptpClock;
;;;78     
;;;79     	uuid = (unsigned char*) ptpClock.parentDS.parentPortIdentity.clockIdentity;
000066  4d99              LDR      r5,|L1.716|
;;;80     
;;;81     	/* Master clock UUID */
;;;82     	telnet_printf("master id: %02x%02x%02x%02x%02x%02x%02x%02x\n",
000068  79e8              LDRB     r0,[r5,#7]
00006a  79a9              LDRB     r1,[r5,#6]
00006c  796a              LDRB     r2,[r5,#5]
00006e  792b              LDRB     r3,[r5,#4]
000070  e9cd3201          STRD     r3,r2,[sp,#4]
000074  e9cd1003          STRD     r1,r0,[sp,#0xc]
000078  78e8              LDRB     r0,[r5,#3]
00007a  9000              STR      r0,[sp,#0]
00007c  78ab              LDRB     r3,[r5,#2]
00007e  786a              LDRB     r2,[r5,#1]
000080  7829              LDRB     r1,[r5,#0]
000082  a093              ADR      r0,|L1.720|
000084  f7fffffe          BL       telnet_printf
;;;83     					uuid[0], uuid[1],
;;;84     					uuid[2], uuid[3],
;;;85     					uuid[4], uuid[5],
;;;86     					uuid[6], uuid[7]);
;;;87     
;;;88     	switch (ptpClock.portDS.portState)
000088  f1a50028          SUB      r0,r5,#0x28
00008c  f8900062          LDRB     r0,[r0,#0x62]
000090  2809              CMP      r0,#9
000092  d218              BCS      |L1.198|
000094  e8dff000          TBB      [pc,r0]
000098  05071509          DCB      0x05,0x07,0x15,0x09
00009c  11130b0d          DCB      0x11,0x13,0x0b,0x0d
0000a0  0f00              DCB      0x0f,0x00
;;;89     	{
;;;90     		case PTP_INITIALIZING:  s = "init";  break;
0000a2  a497              ADR      r4,|L1.768|
0000a4  e011              B        |L1.202|
;;;91     		case PTP_FAULTY:        s = "faulty";   break;
0000a6  a498              ADR      r4,|L1.776|
0000a8  e00f              B        |L1.202|
;;;92     		case PTP_LISTENING:     s = "listening";  break;
0000aa  a499              ADR      r4,|L1.784|
0000ac  e00d              B        |L1.202|
;;;93     		case PTP_PASSIVE:       s = "passive";  break;
0000ae  a49b              ADR      r4,|L1.796|
0000b0  e00b              B        |L1.202|
;;;94     		case PTP_UNCALIBRATED:  s = "uncalibrated";  break;
0000b2  a49c              ADR      r4,|L1.804|
0000b4  e009              B        |L1.202|
;;;95     		case PTP_SLAVE:         s = "slave";   break;
0000b6  a49f              ADR      r4,|L1.820|
0000b8  e007              B        |L1.202|
;;;96     		case PTP_PRE_MASTER:    s = "pre master";  break;
0000ba  a4a0              ADR      r4,|L1.828|
0000bc  e005              B        |L1.202|
;;;97     		case PTP_MASTER:        s = "master";   break;
0000be  a4a0              ADR      r4,|L1.832|
0000c0  e003              B        |L1.202|
;;;98     		case PTP_DISABLED:      s = "disabled";  break;
0000c2  a4a1              ADR      r4,|L1.840|
0000c4  e001              B        |L1.202|
                  |L1.198|
;;;99     		default:                s = "?";     break;
0000c6  a4a3              ADR      r4,|L1.852|
0000c8  bf00              NOP      
                  |L1.202|
0000ca  bf00              NOP                            ;90
;;;100    	}
;;;101    
;;;102    	/* State of the PTP */
;;;103    	telnet_printf("state: %s\n", s);
0000cc  4621              MOV      r1,r4
0000ce  a0a2              ADR      r0,|L1.856|
0000d0  f7fffffe          BL       telnet_printf
;;;104    
;;;105    	/* One way delay */
;;;106    	switch (ptpClock.portDS.delayMechanism)
0000d4  487d              LDR      r0,|L1.716|
0000d6  3828              SUBS     r0,r0,#0x28
0000d8  f890006f          LDRB     r0,[r0,#0x6f]
0000dc  2801              CMP      r0,#1
0000de  d002              BEQ      |L1.230|
0000e0  2802              CMP      r0,#2
0000e2  d114              BNE      |L1.270|
0000e4  e009              B        |L1.250|
                  |L1.230|
;;;107    	{
;;;108    		case E2E:
;;;109    			telnet_puts("mode: end to end\n");
0000e6  a09f              ADR      r0,|L1.868|
0000e8  f7fffffe          BL       telnet_puts
;;;110    			telnet_printf("path delay: %d nsec\n", ptpClock.currentDS.meanPathDelay.nanoseconds);
0000ec  4877              LDR      r0,|L1.716|
0000ee  3828              SUBS     r0,r0,#0x28
0000f0  6a41              LDR      r1,[r0,#0x24]
0000f2  a0a1              ADR      r0,|L1.888|
0000f4  f7fffffe          BL       telnet_printf
;;;111    			break;
0000f8  e010              B        |L1.284|
                  |L1.250|
;;;112    		case P2P:
;;;113    			telnet_puts("mode: peer to peer\n");
0000fa  a0a5              ADR      r0,|L1.912|
0000fc  f7fffffe          BL       telnet_puts
;;;114    			telnet_printf("path delay: %d nsec\n", ptpClock.portDS.peerMeanPathDelay.nanoseconds);
000100  4872              LDR      r0,|L1.716|
000102  3828              SUBS     r0,r0,#0x28
000104  6e81              LDR      r1,[r0,#0x68]
000106  a09c              ADR      r0,|L1.888|
000108  f7fffffe          BL       telnet_printf
;;;115    			break;
00010c  e006              B        |L1.284|
                  |L1.270|
;;;116    		default:
;;;117    			telnet_puts("mode: unknown\n");
00010e  a0a5              ADR      r0,|L1.932|
000110  f7fffffe          BL       telnet_puts
;;;118    			telnet_printf("path delay: unknown\n");
000114  a0a7              ADR      r0,|L1.948|
000116  f7fffffe          BL       telnet_printf
;;;119    			/* none */
;;;120    			break;
00011a  bf00              NOP      
                  |L1.284|
00011c  bf00              NOP                            ;111
;;;121    	}
;;;122    
;;;123    	/* Offset from master */
;;;124    	if (ptpClock.currentDS.offsetFromMaster.seconds)
00011e  486b              LDR      r0,|L1.716|
000120  3828              SUBS     r0,r0,#0x28
000122  6980              LDR      r0,[r0,#0x18]
000124  b130              CBZ      r0,|L1.308|
;;;125    	{
;;;126    		telnet_printf("offset: %d sec\n", ptpClock.currentDS.offsetFromMaster.seconds);
000126  4869              LDR      r0,|L1.716|
000128  3828              SUBS     r0,r0,#0x28
00012a  6981              LDR      r1,[r0,#0x18]
00012c  a0a7              ADR      r0,|L1.972|
00012e  f7fffffe          BL       telnet_printf
000132  e005              B        |L1.320|
                  |L1.308|
;;;127    	}
;;;128    	else
;;;129    	{
;;;130    		telnet_printf("offset: %d nsec\n", ptpClock.currentDS.offsetFromMaster.nanoseconds);
000134  4865              LDR      r0,|L1.716|
000136  3828              SUBS     r0,r0,#0x28
000138  69c1              LDR      r1,[r0,#0x1c]
00013a  a0a8              ADR      r0,|L1.988|
00013c  f7fffffe          BL       telnet_printf
                  |L1.320|
;;;131    	}
;;;132    
;;;133    	/* Observed drift from master */
;;;134    	sign = ' ';
000140  2620              MOVS     r6,#0x20
;;;135    	if (ptpClock.observedDrift > 0) sign = '+';
000142  4862              LDR      r0,|L1.716|
000144  3828              SUBS     r0,r0,#0x28
000146  f8d003c4          LDR      r0,[r0,#0x3c4]  ; ptpClock
00014a  2800              CMP      r0,#0
00014c  dd00              BLE      |L1.336|
00014e  262b              MOVS     r6,#0x2b
                  |L1.336|
;;;136    	if (ptpClock.observedDrift < 0) sign = '-';
000150  485e              LDR      r0,|L1.716|
000152  3828              SUBS     r0,r0,#0x28
000154  f8d003c4          LDR      r0,[r0,#0x3c4]  ; ptpClock
000158  2800              CMP      r0,#0
00015a  da00              BGE      |L1.350|
00015c  262d              MOVS     r6,#0x2d
                  |L1.350|
;;;137    
;;;138    	telnet_printf("drift: %c%d.%03d ppm\n", sign, abs(ptpClock.observedDrift / 1000), abs(ptpClock.observedDrift % 1000));
00015e  485b              LDR      r0,|L1.716|
000160  3828              SUBS     r0,r0,#0x28
000162  f8d003c4          LDR      r0,[r0,#0x3c4]  ; ptpClock
000166  f44f717a          MOV      r1,#0x3e8
00016a  fb90f2f1          SDIV     r2,r0,r1
00016e  fb010712          MLS      r7,r1,r2,r0
000172  4856              LDR      r0,|L1.716|
000174  3828              SUBS     r0,r0,#0x28
000176  f8d003c4          LDR      r0,[r0,#0x3c4]  ; ptpClock
00017a  fb90f8f1          SDIV     r8,r0,r1
00017e  2f00              CMP      r7,#0
000180  db01              BLT      |L1.390|
000182  4638              MOV      r0,r7
000184  e000              B        |L1.392|
                  |L1.390|
000186  4278              RSBS     r0,r7,#0
                  |L1.392|
000188  4603              MOV      r3,r0
00018a  f1b80f00          CMP      r8,#0
00018e  db01              BLT      |L1.404|
000190  4640              MOV      r0,r8
000192  e001              B        |L1.408|
                  |L1.404|
000194  f1c80000          RSB      r0,r8,#0
                  |L1.408|
000198  4602              MOV      r2,r0
00019a  4631              MOV      r1,r6
00019c  a094              ADR      r0,|L1.1008|
00019e  f7fffffe          BL       telnet_printf
;;;139    
;;;140    	return true;
0001a2  2001              MOVS     r0,#1
;;;141    }
0001a4  b006              ADD      sp,sp,#0x18
0001a6  e8bd87f0          POP      {r4-r10,pc}
;;;142    
                          ENDP

                  shell_parse PROC
;;;146    // Returns 0:Failed, 1:Successful
;;;147    static int shell_parse(char **str, char **word)
0001aa  b570              PUSH     {r4-r6,lr}
;;;148    {
0001ac  4604              MOV      r4,r0
0001ae  460d              MOV      r5,r1
;;;149      // Skip leading spaces.
;;;150    	while (**str && isspace(**str)) (*str)++;
0001b0  e002              B        |L1.440|
                  |L1.434|
0001b2  6820              LDR      r0,[r4,#0]
0001b4  1c40              ADDS     r0,r0,#1
0001b6  6020              STR      r0,[r4,#0]
                  |L1.440|
0001b8  6820              LDR      r0,[r4,#0]
0001ba  7800              LDRB     r0,[r0,#0]
0001bc  b148              CBZ      r0,|L1.466|
0001be  f7fffffe          BL       __rt_ctype_table
0001c2  6800              LDR      r0,[r0,#0]
0001c4  6821              LDR      r1,[r4,#0]
0001c6  7809              LDRB     r1,[r1,#0]
0001c8  5c40              LDRB     r0,[r0,r1]
0001ca  f0000001          AND      r0,r0,#1
0001ce  2800              CMP      r0,#0
0001d0  d1ef              BNE      |L1.434|
                  |L1.466|
;;;151    
;;;152      // Set the word.
;;;153      *word = *str;
0001d2  6820              LDR      r0,[r4,#0]
0001d4  6028              STR      r0,[r5,#0]
;;;154    
;;;155      // Skip non-space characters.
;;;156    	while (**str && !isspace(**str)) (*str)++;
0001d6  e002              B        |L1.478|
                  |L1.472|
0001d8  6820              LDR      r0,[r4,#0]
0001da  1c40              ADDS     r0,r0,#1
0001dc  6020              STR      r0,[r4,#0]
                  |L1.478|
0001de  6820              LDR      r0,[r4,#0]
0001e0  7800              LDRB     r0,[r0,#0]
0001e2  b148              CBZ      r0,|L1.504|
0001e4  f7fffffe          BL       __rt_ctype_table
0001e8  6800              LDR      r0,[r0,#0]
0001ea  6821              LDR      r1,[r4,#0]
0001ec  7809              LDRB     r1,[r1,#0]
0001ee  5c40              LDRB     r0,[r0,r1]
0001f0  f0000001          AND      r0,r0,#1
0001f4  2800              CMP      r0,#0
0001f6  d0ef              BEQ      |L1.472|
                  |L1.504|
;;;157    
;;;158      // Null terminate the word.
;;;159      if (**str) *(*str)++ = 0;
0001f8  6820              LDR      r0,[r4,#0]
0001fa  7800              LDRB     r0,[r0,#0]
0001fc  b120              CBZ      r0,|L1.520|
0001fe  2100              MOVS     r1,#0
000200  6822              LDR      r2,[r4,#0]
000202  1c50              ADDS     r0,r2,#1
000204  6020              STR      r0,[r4,#0]
000206  7011              STRB     r1,[r2,#0]
                  |L1.520|
;;;160    
;;;161      return (*str != *word) ? 1 : 0;
000208  6820              LDR      r0,[r4,#0]
00020a  6829              LDR      r1,[r5,#0]
00020c  4288              CMP      r0,r1
00020e  d001              BEQ      |L1.532|
000210  2001              MOVS     r0,#1
                  |L1.530|
;;;162    }
000212  bd70              POP      {r4-r6,pc}
                  |L1.532|
000214  2000              MOVS     r0,#0                 ;161
000216  e7fc              B        |L1.530|
;;;163    
                          ENDP

                  shell_command PROC
;;;164    // Attempt to execute the shell command.
;;;165    static bool shell_command(char *cmdline)
000218  b5f1              PUSH     {r0,r4-r7,lr}
;;;166    {
00021a  b08a              SUB      sp,sp,#0x28
;;;167    	int i;
;;;168    	char *argv[8];
;;;169    	int argc = 0;
00021c  2600              MOVS     r6,#0
;;;170    	bool rv = true;
00021e  2701              MOVS     r7,#1
;;;171    	struct shell_command *command;
;;;172    
;;;173    	// Parse the command and any arguments into an array.
;;;174    	for (i = 0; i < (sizeof(argv) / sizeof(char *)); ++i)
000220  2400              MOVS     r4,#0
000222  e00c              B        |L1.574|
                  |L1.548|
;;;175    	{
;;;176    		shell_parse(&cmdline, &argv[i]);
000224  a802              ADD      r0,sp,#8
000226  eb000184          ADD      r1,r0,r4,LSL #2
00022a  a80a              ADD      r0,sp,#0x28
00022c  f7fffffe          BL       shell_parse
;;;177    		if (*argv[i] != 0) ++argc;
000230  a802              ADD      r0,sp,#8
000232  f8500024          LDR      r0,[r0,r4,LSL #2]
000236  7800              LDRB     r0,[r0,#0]
000238  b100              CBZ      r0,|L1.572|
00023a  1c76              ADDS     r6,r6,#1
                  |L1.572|
00023c  1c64              ADDS     r4,r4,#1              ;174
                  |L1.574|
00023e  2c08              CMP      r4,#8                 ;174
000240  d3f0              BCC      |L1.548|
;;;178    	}
;;;179    
;;;180    	// Search for a matching command.
;;;181    	command = (struct shell_command *) bsearch(argv[0], commands, sizeof(commands) / sizeof(struct shell_command), sizeof(struct shell_command), (int(*)	(const void*, const void*)) strcasecmp);
000242  4871              LDR      r0,|L1.1032|
000244  9000              STR      r0,[sp,#0]
000246  2314              MOVS     r3,#0x14
000248  2204              MOVS     r2,#4
00024a  4917              LDR      r1,|L1.680|
00024c  9802              LDR      r0,[sp,#8]
00024e  f7fffffe          BL       bsearch
000252  4605              MOV      r5,r0
;;;182    
;;;183    	// Call the command if found.
;;;184    	if (command) rv = (command->funcptr)(argc, argv);
000254  b125              CBZ      r5,|L1.608|
000256  a902              ADD      r1,sp,#8
000258  4630              MOV      r0,r6
00025a  692a              LDR      r2,[r5,#0x10]
00025c  4790              BLX      r2
00025e  4607              MOV      r7,r0
                  |L1.608|
;;;185    
;;;186    	return rv;
000260  4638              MOV      r0,r7
;;;187    }
000262  b00b              ADD      sp,sp,#0x2c
000264  bdf0              POP      {r4-r7,pc}
;;;188    
                          ENDP

                  shell_process PROC
;;;189    // Runs the shell by printing the prompt and processing each shell command typed in.
;;;190    void shell_process() 
000266  b500              PUSH     {lr}
;;;191    {
000268  b091              SUB      sp,sp,#0x44
;;;192    	char cmdbuf[64];
;;;193    
;;;194    	// Tell the user the shell is starting.
;;;195    	telnet_printf("Starting Shell...\n");
00026a  a068              ADR      r0,|L1.1036|
00026c  f7fffffe          BL       telnet_printf
;;;196    
;;;197    	// Send a prompt.
;;;198    	telnet_puts("> ");
000270  a06b              ADR      r0,|L1.1056|
000272  f7fffffe          BL       telnet_puts
;;;199    	telnet_flush();
000276  f7fffffe          BL       telnet_flush
;;;200    
;;;201    	// Get a string.
;;;202      while (telnet_gets(cmdbuf, sizeof(cmdbuf), 0, true))
00027a  e009              B        |L1.656|
                  |L1.636|
;;;203      {
;;;204    		// Process the line as a command.
;;;205    		if (!shell_command(cmdbuf)) break;
00027c  a801              ADD      r0,sp,#4
00027e  f7fffffe          BL       shell_command
000282  b900              CBNZ     r0,|L1.646|
000284  e00c              B        |L1.672|
                  |L1.646|
;;;206    
;;;207    		// Send a prompt.
;;;208    		telnet_puts("> ");
000286  a066              ADR      r0,|L1.1056|
000288  f7fffffe          BL       telnet_puts
;;;209    		telnet_flush();
00028c  f7fffffe          BL       telnet_flush
                  |L1.656|
000290  2301              MOVS     r3,#1                 ;202
000292  2200              MOVS     r2,#0                 ;202
000294  2140              MOVS     r1,#0x40              ;202
000296  a801              ADD      r0,sp,#4              ;202
000298  f7fffffe          BL       telnet_gets
00029c  2800              CMP      r0,#0                 ;202
00029e  d1ed              BNE      |L1.636|
                  |L1.672|
0002a0  bf00              NOP                            ;205
;;;210    	}
;;;211    }
0002a2  b011              ADD      sp,sp,#0x44
0002a4  bd00              POP      {pc}
;;;212    
                          ENDP

0002a6  0000              DCW      0x0000
                  |L1.680|
                          DCD      commands
                  |L1.684|
0002ac  25730a00          DCB      "%s\n",0
                  |L1.688|
0002b0  25612025          DCB      "%a %b %d %H:%M:%S UTC %Y\n",0
0002b4  62202564
0002b8  2025483a
0002bc  254d3a25
0002c0  53205554
0002c4  43202559
0002c8  0a00    
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L1.716|
                          DCD      ptpClock+0x28
                  |L1.720|
0002d0  6d617374          DCB      "master id: %02x%02x%02x%02x%02x%02x%02x%02x\n",0
0002d4  65722069
0002d8  643a2025
0002dc  30327825
0002e0  30327825
0002e4  30327825
0002e8  30327825
0002ec  30327825
0002f0  30327825
0002f4  30327825
0002f8  3032780a
0002fc  00      
0002fd  00                DCB      0
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L1.768|
000300  696e6974          DCB      "init",0
000304  00      
000305  00                DCB      0
000306  00                DCB      0
000307  00                DCB      0
                  |L1.776|
000308  6661756c          DCB      "faulty",0
00030c  747900  
00030f  00                DCB      0
                  |L1.784|
000310  6c697374          DCB      "listening",0
000314  656e696e
000318  6700    
00031a  00                DCB      0
00031b  00                DCB      0
                  |L1.796|
00031c  70617373          DCB      "passive",0
000320  69766500
                  |L1.804|
000324  756e6361          DCB      "uncalibrated",0
000328  6c696272
00032c  61746564
000330  00      
000331  00                DCB      0
000332  00                DCB      0
000333  00                DCB      0
                  |L1.820|
000334  736c6176          DCB      "slave",0
000338  6500    
00033a  00                DCB      0
00033b  00                DCB      0
                  |L1.828|
00033c  70726520          DCB      "pre "
                  |L1.832|
000340  6d617374          DCB      "master",0
000344  657200  
000347  00                DCB      0
                  |L1.840|
000348  64697361          DCB      "disabled",0
00034c  626c6564
000350  00      
000351  00                DCB      0
000352  00                DCB      0
000353  00                DCB      0
                  |L1.852|
000354  3f00              DCB      "?",0
000356  00                DCB      0
000357  00                DCB      0
                  |L1.856|
000358  73746174          DCB      "state: %s\n",0
00035c  653a2025
000360  730a00  
000363  00                DCB      0
                  |L1.868|
000364  6d6f6465          DCB      "mode: end to end\n",0
000368  3a20656e
00036c  6420746f
000370  20656e64
000374  0a00    
000376  00                DCB      0
000377  00                DCB      0
                  |L1.888|
000378  70617468          DCB      "path delay: %d nsec\n",0
00037c  2064656c
000380  61793a20
000384  2564206e
000388  7365630a
00038c  00      
00038d  00                DCB      0
00038e  00                DCB      0
00038f  00                DCB      0
                  |L1.912|
000390  6d6f6465          DCB      "mode: peer to peer\n",0
000394  3a207065
000398  65722074
00039c  6f207065
0003a0  65720a00
                  |L1.932|
0003a4  6d6f6465          DCB      "mode: unknown\n",0
0003a8  3a20756e
0003ac  6b6e6f77
0003b0  6e0a00  
0003b3  00                DCB      0
                  |L1.948|
0003b4  70617468          DCB      "path delay: unknown\n",0
0003b8  2064656c
0003bc  61793a20
0003c0  756e6b6e
0003c4  6f776e0a
0003c8  00      
0003c9  00                DCB      0
0003ca  00                DCB      0
0003cb  00                DCB      0
                  |L1.972|
0003cc  6f666673          DCB      "offset: %d sec\n",0
0003d0  65743a20
0003d4  25642073
0003d8  65630a00
                  |L1.988|
0003dc  6f666673          DCB      "offset: %d nsec\n",0
0003e0  65743a20
0003e4  2564206e
0003e8  7365630a
0003ec  00      
0003ed  00                DCB      0
0003ee  00                DCB      0
0003ef  00                DCB      0
                  |L1.1008|
0003f0  64726966          DCB      "drift: %c%d.%03d ppm\n",0
0003f4  743a2025
0003f8  6325642e
0003fc  25303364
000400  2070706d
000404  0a00    
000406  00                DCB      0
000407  00                DCB      0
                  |L1.1032|
                          DCD      strcasecmp
                  |L1.1036|
00040c  53746172          DCB      "Starting Shell...\n",0
000410  74696e67
000414  20536865
000418  6c6c2e2e
00041c  2e0a00  
00041f  00                DCB      0
                  |L1.1056|
000420  3e2000            DCB      "> ",0
000423  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  commands
000000  44415445          DCB      0x44,0x41,0x54,0x45
000004  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
                          DCD      shell_date
000014  45584954          DCB      0x45,0x58,0x49,0x54
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
                          DCD      shell_exit
000028  48454c50          DCB      0x48,0x45,0x4c,0x50
00002c  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
                          DCD      shell_help
00003c  50545044          DCB      0x50,0x54,0x50,0x44
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
                          DCD      shell_ptpd

;*** Start embedded assembler ***

#line 1 "..\\src\\shell.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_shell_c_commands____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_shell_c_commands____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_shell_c_commands____REVSH|
#line 128
|__asm___7_shell_c_commands____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
