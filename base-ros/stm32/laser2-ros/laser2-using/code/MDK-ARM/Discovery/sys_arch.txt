; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\sys_arch.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\sys_arch.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\sys_arch.crf ..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch\sys_arch.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sys_mbox_new PROC
;;;43      *---------------------------------------------------------------------------*/
;;;44     err_t sys_mbox_new(sys_mbox_t *mbox, int queue_sz)
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;46     	if (queue_sz > MB_SIZE)
000006  2d10              CMP      r5,#0x10
000008  dd02              BLE      |L1.16|
;;;47     		printf("sys_mbox_new size error\n");
00000a  a0ba              ADR      r0,|L1.756|
00000c  f7fffffe          BL       __2printf
                  |L1.16|
;;;48     	
;;;49     #ifdef __CMSIS_RTOS
;;;50     	memset(mbox->queue, 0, sizeof(mbox->queue));
000010  2150              MOVS     r1,#0x50
000012  f104000c          ADD      r0,r4,#0xc
000016  f7fffffe          BL       __aeabi_memclr4
;;;51     	mbox->def.pool = mbox->queue;
00001a  f104000c          ADD      r0,r4,#0xc
00001e  60a0              STR      r0,[r4,#8]
;;;52     	mbox->def.queue_sz = queue_sz;
000020  6065              STR      r5,[r4,#4]
;;;53     #endif
;;;54     	mbox->id = osMessageCreate(&mbox->def, NULL);
000022  2100              MOVS     r1,#0
000024  1d20              ADDS     r0,r4,#4
000026  f7fffffe          BL       osMessageCreate
00002a  6020              STR      r0,[r4,#0]
;;;55     	return (mbox->id == NULL) ? (ERR_MEM) : (ERR_OK);
00002c  6820              LDR      r0,[r4,#0]
00002e  b910              CBNZ     r0,|L1.54|
000030  f04f30ff          MOV      r0,#0xffffffff
                  |L1.52|
;;;56     }
000034  bd70              POP      {r4-r6,pc}
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;55
000038  e7fc              B        |L1.52|
;;;57      
                          ENDP

                  sys_mbox_free PROC
;;;67      *---------------------------------------------------------------------------*/
;;;68     void sys_mbox_free(sys_mbox_t *mbox)
00003a  b53e              PUSH     {r1-r5,lr}
;;;69     {
00003c  4604              MOV      r4,r0
;;;70     	osEvent event = osMessageGet(mbox->id, 0);
00003e  2100              MOVS     r1,#0
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       osMessageGet
000046  e88d0007          STM      sp,{r0-r2}
;;;71     	if (event.status == osEventMessage)
00004a  9800              LDR      r0,[sp,#0]
00004c  2810              CMP      r0,#0x10
00004e  d102              BNE      |L1.86|
;;;72     		printf("sys_mbox_free error\n");
000050  a0af              ADR      r0,|L1.784|
000052  f7fffffe          BL       __2printf
                  |L1.86|
;;;73     }
000056  bd3e              POP      {r1-r5,pc}
;;;74      
                          ENDP

                  sys_mbox_post PROC
;;;83      *---------------------------------------------------------------------------*/
;;;84     void sys_mbox_post(sys_mbox_t *mbox, void *msg)
000058  b570              PUSH     {r4-r6,lr}
;;;85     {
00005a  4604              MOV      r4,r0
00005c  460d              MOV      r5,r1
;;;86     	if (osMessagePut(mbox->id, (uint32_t)msg, osWaitForever) != osOK)
00005e  f04f32ff          MOV      r2,#0xffffffff
000062  4629              MOV      r1,r5
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       osMessagePut
00006a  b110              CBZ      r0,|L1.114|
;;;87     		printf("sys_mbox_post error\n");
00006c  a0ae              ADR      r0,|L1.808|
00006e  f7fffffe          BL       __2printf
                  |L1.114|
;;;88     }
000072  bd70              POP      {r4-r6,pc}
;;;89      
                          ENDP

                  sys_mbox_trypost PROC
;;;102     *---------------------------------------------------------------------------*/
;;;103    err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
000074  b570              PUSH     {r4-r6,lr}
;;;104    {
000076  4604              MOV      r4,r0
000078  460d              MOV      r5,r1
;;;105    	osStatus status = osMessagePut(mbox->id, (uint32_t)msg, 0);
00007a  2200              MOVS     r2,#0
00007c  4629              MOV      r1,r5
00007e  6820              LDR      r0,[r4,#0]
000080  f7fffffe          BL       osMessagePut
000084  4606              MOV      r6,r0
;;;106    	return (status == osOK) ? (ERR_OK) : (ERR_MEM);
000086  b90e              CBNZ     r6,|L1.140|
000088  2000              MOVS     r0,#0
                  |L1.138|
;;;107    }
00008a  bd70              POP      {r4-r6,pc}
                  |L1.140|
00008c  f04f30ff          MOV      r0,#0xffffffff        ;106
000090  e7fb              B        |L1.138|
;;;108     
                          ENDP

                  sys_arch_mbox_fetch PROC
;;;133     *---------------------------------------------------------------------------*/
;;;134    u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout) {
000092  b5fe              PUSH     {r1-r7,lr}
000094  4604              MOV      r4,r0
000096  460d              MOV      r5,r1
000098  4616              MOV      r6,r2
;;;135    	u32_t start = osKernelSysTick();
00009a  f7fffffe          BL       osKernelSysTick
00009e  4607              MOV      r7,r0
;;;136    	
;;;137    	osEvent event = osMessageGet(mbox->id, (timeout != 0)?(timeout):(osWaitForever));
0000a0  b10e              CBZ      r6,|L1.166|
0000a2  4632              MOV      r2,r6
0000a4  e001              B        |L1.170|
                  |L1.166|
0000a6  f04f32ff          MOV      r2,#0xffffffff
                  |L1.170|
0000aa  4611              MOV      r1,r2
0000ac  6820              LDR      r0,[r4,#0]
0000ae  f7fffffe          BL       osMessageGet
0000b2  e88d0007          STM      sp,{r0-r2}
;;;138    	if (event.status != osEventMessage)
0000b6  9800              LDR      r0,[sp,#0]
0000b8  2810              CMP      r0,#0x10
0000ba  d002              BEQ      |L1.194|
;;;139    		return SYS_ARCH_TIMEOUT;
0000bc  f04f30ff          MOV      r0,#0xffffffff
                  |L1.192|
;;;140    	
;;;141    	*msg = (void *)event.value.v;
;;;142    	
;;;143    	return osKernelSysTick() - start;
;;;144    }
0000c0  bdfe              POP      {r1-r7,pc}
                  |L1.194|
0000c2  9801              LDR      r0,[sp,#4]            ;141
0000c4  6028              STR      r0,[r5,#0]            ;141
0000c6  f7fffffe          BL       osKernelSysTick
0000ca  1bc0              SUBS     r0,r0,r7              ;143
0000cc  e7f8              B        |L1.192|
;;;145     
                          ENDP

                  sys_arch_mbox_tryfetch PROC
;;;159     *---------------------------------------------------------------------------*/
;;;160    u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
0000ce  b53e              PUSH     {r1-r5,lr}
;;;161    {
0000d0  4604              MOV      r4,r0
0000d2  460d              MOV      r5,r1
;;;162    	osEvent event = osMessageGet(mbox->id, 0);
0000d4  2100              MOVS     r1,#0
0000d6  6820              LDR      r0,[r4,#0]
0000d8  f7fffffe          BL       osMessageGet
0000dc  e88d0007          STM      sp,{r0-r2}
;;;163    	if (event.status != osEventMessage)
0000e0  9800              LDR      r0,[sp,#0]
0000e2  2810              CMP      r0,#0x10
0000e4  d002              BEQ      |L1.236|
;;;164    		return SYS_MBOX_EMPTY;
0000e6  f04f30ff          MOV      r0,#0xffffffff
                  |L1.234|
;;;165    	
;;;166    	*msg = (void *)event.value.v;
;;;167    	
;;;168    	return ERR_OK;
;;;169    }
0000ea  bd3e              POP      {r1-r5,pc}
                  |L1.236|
0000ec  9801              LDR      r0,[sp,#4]            ;166
0000ee  6028              STR      r0,[r5,#0]            ;166
0000f0  2000              MOVS     r0,#0                 ;168
0000f2  e7fa              B        |L1.234|
;;;170     
                          ENDP

                  sys_sem_new PROC
;;;182     *---------------------------------------------------------------------------*/
;;;183    err_t sys_sem_new(sys_sem_t *sem, u8_t count) {
0000f4  b570              PUSH     {r4-r6,lr}
0000f6  4604              MOV      r4,r0
0000f8  460d              MOV      r5,r1
;;;184    #ifdef __CMSIS_RTOS
;;;185    	memset(sem->data, 0, sizeof(uint32_t)*2);
0000fa  2000              MOVS     r0,#0
0000fc  60a0              STR      r0,[r4,#8]
0000fe  60e0              STR      r0,[r4,#0xc]
;;;186    	sem->def.semaphore = sem->data;
000100  f1040008          ADD      r0,r4,#8
000104  6060              STR      r0,[r4,#4]
;;;187    #endif
;;;188    	// We cannot initialize the semaphore to 0
;;;189    	sem->id = osSemaphoreCreate(&sem->def, count);
000106  4629              MOV      r1,r5
000108  1d20              ADDS     r0,r4,#4
00010a  f7fffffe          BL       osSemaphoreCreate
00010e  6020              STR      r0,[r4,#0]
;;;190    	if (sem->id == NULL)
000110  6820              LDR      r0,[r4,#0]
000112  b910              CBNZ     r0,|L1.282|
;;;191    		printf("sys_sem_new create error\n");
000114  a08a              ADR      r0,|L1.832|
000116  f7fffffe          BL       __2printf
                  |L1.282|
;;;192    	
;;;193    	return ERR_OK;
00011a  2000              MOVS     r0,#0
;;;194    }
00011c  bd70              POP      {r4-r6,pc}
;;;195     
                          ENDP

                  sys_arch_sem_wait PROC
;;;218     *---------------------------------------------------------------------------*/
;;;219    u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
00011e  b570              PUSH     {r4-r6,lr}
;;;220    {
000120  4604              MOV      r4,r0
000122  460d              MOV      r5,r1
;;;221    	u32_t start = osKernelSysTick();
000124  f7fffffe          BL       osKernelSysTick
000128  4606              MOV      r6,r0
;;;222    	
;;;223    	if (osSemaphoreWait(sem->id, (timeout != 0)?(timeout):(osWaitForever)) < 1)
00012a  b10d              CBZ      r5,|L1.304|
00012c  462a              MOV      r2,r5
00012e  e001              B        |L1.308|
                  |L1.304|
000130  f04f32ff          MOV      r2,#0xffffffff
                  |L1.308|
000134  4611              MOV      r1,r2
000136  6820              LDR      r0,[r4,#0]
000138  f7fffffe          BL       osSemaphoreWait
00013c  2801              CMP      r0,#1
00013e  da02              BGE      |L1.326|
;;;224    		return SYS_ARCH_TIMEOUT;
000140  f04f30ff          MOV      r0,#0xffffffff
                  |L1.324|
;;;225    	
;;;226    	return osKernelSysTick() - start;
;;;227    }
000144  bd70              POP      {r4-r6,pc}
                  |L1.326|
000146  f7fffffe          BL       osKernelSysTick
00014a  1b80              SUBS     r0,r0,r6              ;226
00014c  e7fa              B        |L1.324|
;;;228     
                          ENDP

                  sys_sem_signal PROC
;;;236     *---------------------------------------------------------------------------*/
;;;237    void sys_sem_signal(sys_sem_t *data)
00014e  b510              PUSH     {r4,lr}
;;;238    {
000150  4604              MOV      r4,r0
;;;239    	if (osSemaphoreRelease(data->id) != osOK)
000152  6820              LDR      r0,[r4,#0]
000154  f7fffffe          BL       osSemaphoreRelease
000158  b108              CBZ      r0,|L1.350|
;;;240    		for(;;); /* Can be called by ISR do not use printf */
00015a  bf00              NOP      
                  |L1.348|
00015c  e7fe              B        |L1.348|
                  |L1.350|
;;;241    }
00015e  bd10              POP      {r4,pc}
;;;242     
                          ENDP

                  sys_sem_free PROC
;;;250     *---------------------------------------------------------------------------*/
;;;251    void sys_sem_free(sys_sem_t *sem) {}
000160  4770              BX       lr
;;;252     
                          ENDP

                  sys_timer_new PROC
;;;258     * @return a new mutex */
;;;259    err_t sys_timer_new(sys_timer_t *timer, os_ptimer ptimer, os_timer_type type, void *argument)
000162  e92d41f0          PUSH     {r4-r8,lr}
;;;260    {
000166  4604              MOV      r4,r0
000168  460d              MOV      r5,r1
00016a  4616              MOV      r6,r2
00016c  461f              MOV      r7,r3
;;;261    #ifdef __CMSIS_RTOS
;;;262    	memset(timer->data, 0, sizeof(int32_t)*5);
00016e  2114              MOVS     r1,#0x14
000170  f104000c          ADD      r0,r4,#0xc
000174  f7fffffe          BL       __aeabi_memclr4
;;;263    	timer->def.timer = timer->data;
000178  f104000c          ADD      r0,r4,#0xc
00017c  60a0              STR      r0,[r4,#8]
;;;264    	timer->def.ptimer = ptimer;
00017e  6065              STR      r5,[r4,#4]
;;;265    #endif
;;;266    	timer->id = osTimerCreate(&timer->def, type, argument);
000180  463a              MOV      r2,r7
000182  4631              MOV      r1,r6
000184  1d20              ADDS     r0,r4,#4
000186  f7fffffe          BL       osTimerCreate
00018a  6020              STR      r0,[r4,#0]
;;;267    	if (timer->id == NULL)
00018c  6820              LDR      r0,[r4,#0]
00018e  b918              CBNZ     r0,|L1.408|
;;;268    		return ERR_MEM;
000190  f04f30ff          MOV      r0,#0xffffffff
                  |L1.404|
;;;269    	
;;;270    	return ERR_OK;
;;;271    }
000194  e8bd81f0          POP      {r4-r8,pc}
                  |L1.408|
000198  2000              MOVS     r0,#0                 ;270
00019a  e7fb              B        |L1.404|
;;;272    
                          ENDP

                  sys_timer_start PROC
;;;275     * @param millisec the value of the timer */
;;;276    void sys_timer_start(sys_timer_t *timer, uint32_t millisec) {
00019c  b570              PUSH     {r4-r6,lr}
00019e  4604              MOV      r4,r0
0001a0  460d              MOV      r5,r1
;;;277    	if (osTimerStart(timer->id, millisec) != osOK)
0001a2  4629              MOV      r1,r5
0001a4  6820              LDR      r0,[r4,#0]
0001a6  f7fffffe          BL       osTimerStart
0001aa  b110              CBZ      r0,|L1.434|
;;;278    		printf("sys_timer_start error\n");
0001ac  a06b              ADR      r0,|L1.860|
0001ae  f7fffffe          BL       __2printf
                  |L1.434|
;;;279    }
0001b2  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP

                  sys_timer_stop PROC
;;;282     * @param timer the timer to stop */
;;;283    void sys_timer_stop(sys_timer_t *timer) {
0001b4  b510              PUSH     {r4,lr}
0001b6  4604              MOV      r4,r0
;;;284    	if (osTimerStop(timer->id) != osOK)
0001b8  6820              LDR      r0,[r4,#0]
0001ba  f7fffffe          BL       osTimerStop
0001be  b110              CBZ      r0,|L1.454|
;;;285    		printf("sys_timer_stop error\n");
0001c0  a06c              ADR      r0,|L1.884|
0001c2  f7fffffe          BL       __2printf
                  |L1.454|
;;;286    }
0001c6  bd10              POP      {r4,pc}
;;;287    
                          ENDP

                  sys_timer_free PROC
;;;289     * @param timer the timer to delete */
;;;290    void sys_timer_free(sys_timer_t *timer) {}
0001c8  4770              BX       lr
;;;291     
                          ENDP

                  sys_mutex_new PROC
;;;294     * @return a new mutex */
;;;295    err_t sys_mutex_new(sys_mutex_t *mutex)
0001ca  b510              PUSH     {r4,lr}
;;;296    {
0001cc  4604              MOV      r4,r0
;;;297    #ifdef __CMSIS_RTOS
;;;298    	memset(mutex->data, 0, sizeof(int32_t)*3);
0001ce  2000              MOVS     r0,#0
0001d0  60a0              STR      r0,[r4,#8]
0001d2  60e0              STR      r0,[r4,#0xc]
0001d4  6120              STR      r0,[r4,#0x10]
;;;299    	mutex->def.mutex = mutex->data;
0001d6  f1040008          ADD      r0,r4,#8
0001da  6060              STR      r0,[r4,#4]
;;;300    #endif
;;;301    	mutex->id = osMutexCreate(&mutex->def);
0001dc  1d20              ADDS     r0,r4,#4
0001de  f7fffffe          BL       osMutexCreate
0001e2  6020              STR      r0,[r4,#0]
;;;302    	if (mutex->id == NULL)
0001e4  6820              LDR      r0,[r4,#0]
0001e6  b910              CBNZ     r0,|L1.494|
;;;303    		return ERR_MEM;
0001e8  f04f30ff          MOV      r0,#0xffffffff
                  |L1.492|
;;;304    	
;;;305    	return ERR_OK;
;;;306    }
0001ec  bd10              POP      {r4,pc}
                  |L1.494|
0001ee  2000              MOVS     r0,#0                 ;305
0001f0  e7fc              B        |L1.492|
;;;307     
                          ENDP

                  sys_mutex_lock PROC
;;;309     * @param mutex the mutex to lock */
;;;310    void sys_mutex_lock(sys_mutex_t *mutex) {
0001f2  b510              PUSH     {r4,lr}
0001f4  4604              MOV      r4,r0
;;;311    	if (osMutexWait(mutex->id, osWaitForever) != osOK)
0001f6  f04f31ff          MOV      r1,#0xffffffff
0001fa  6820              LDR      r0,[r4,#0]
0001fc  f7fffffe          BL       osMutexWait
000200  b110              CBZ      r0,|L1.520|
;;;312    		printf("sys_mutex_lock error\n");
000202  a062              ADR      r0,|L1.908|
000204  f7fffffe          BL       __2printf
                  |L1.520|
;;;313    }
000208  bd10              POP      {r4,pc}
;;;314     
                          ENDP

                  sys_mutex_unlock PROC
;;;316     * @param mutex the mutex to unlock */
;;;317    void sys_mutex_unlock(sys_mutex_t *mutex)
00020a  b510              PUSH     {r4,lr}
;;;318    {
00020c  4604              MOV      r4,r0
;;;319    	if (osMutexRelease(mutex->id) != osOK)
00020e  6820              LDR      r0,[r4,#0]
000210  f7fffffe          BL       osMutexRelease
000214  b110              CBZ      r0,|L1.540|
;;;320    		printf("sys_mutex_unlock error\n");
000216  a063              ADR      r0,|L1.932|
000218  f7fffffe          BL       __2printf
                  |L1.540|
;;;321    }
00021c  bd10              POP      {r4,pc}
;;;322     
                          ENDP

                  sys_mutex_free PROC
;;;324     * @param mutex the mutex to delete */
;;;325    void sys_mutex_free(sys_mutex_t *mutex) {}
00021e  4770              BX       lr
;;;326     
                          ENDP

                  sys_init PROC
;;;335     
;;;336    void sys_init(void)
000220  b510              PUSH     {r4,lr}
;;;337    {
;;;338    	lwip_sys_mutex = osMutexCreate(osMutex(lwip_sys_mutex));
000222  4866              LDR      r0,|L1.956|
000224  f7fffffe          BL       osMutexCreate
000228  4965              LDR      r1,|L1.960|
00022a  6008              STR      r0,[r1,#0]  ; lwip_sys_mutex
;;;339    	if (lwip_sys_mutex == NULL)
00022c  4608              MOV      r0,r1
00022e  6800              LDR      r0,[r0,#0]  ; lwip_sys_mutex
000230  b910              CBNZ     r0,|L1.568|
;;;340    		printf("sys_init error\n");
000232  a064              ADR      r0,|L1.964|
000234  f7fffffe          BL       __2printf
                  |L1.568|
;;;341    }
000238  bd10              POP      {r4,pc}
;;;342     
                          ENDP

                  sys_arch_protect PROC
;;;361     *---------------------------------------------------------------------------*/
;;;362    sys_prot_t sys_arch_protect(void)
00023a  b510              PUSH     {r4,lr}
;;;363    {
;;;364    	if (osMutexWait(lwip_sys_mutex, osWaitForever) != osOK)
00023c  f04f31ff          MOV      r1,#0xffffffff
000240  485f              LDR      r0,|L1.960|
000242  6800              LDR      r0,[r0,#0]  ; lwip_sys_mutex
000244  f7fffffe          BL       osMutexWait
000248  b110              CBZ      r0,|L1.592|
;;;365    		printf("sys_arch_protect error\n");
00024a  a062              ADR      r0,|L1.980|
00024c  f7fffffe          BL       __2printf
                  |L1.592|
;;;366    	return (sys_prot_t) 1;
000250  2001              MOVS     r0,#1
;;;367    }
000252  bd10              POP      {r4,pc}
;;;368     
                          ENDP

                  sys_arch_unprotect PROC
;;;379     *---------------------------------------------------------------------------*/
;;;380    void sys_arch_unprotect(sys_prot_t p)
000254  b510              PUSH     {r4,lr}
;;;381    {
000256  4604              MOV      r4,r0
;;;382    	if (osMutexRelease(lwip_sys_mutex) != osOK)
000258  4859              LDR      r0,|L1.960|
00025a  6800              LDR      r0,[r0,#0]  ; lwip_sys_mutex
00025c  f7fffffe          BL       osMutexRelease
000260  b110              CBZ      r0,|L1.616|
;;;383    		printf("sys_arch_unprotect error\n");
000262  a062              ADR      r0,|L1.1004|
000264  f7fffffe          BL       __2printf
                  |L1.616|
;;;384    }
000268  bd10              POP      {r4,pc}
;;;385     
                          ENDP

                  sys_now PROC
;;;391     *---------------------------------------------------------------------------*/
;;;392    u32_t sys_now(void)
00026a  b510              PUSH     {r4,lr}
;;;393    {
;;;394    	return osKernelSysTick();
00026c  f7fffffe          BL       osKernelSysTick
;;;395    }
000270  bd10              POP      {r4,pc}
;;;396     
                          ENDP

                  sys_thread_new PROC
;;;418     *---------------------------------------------------------------------------*/
;;;419    sys_thread_t sys_thread_new(const char *pcName,
000272  e92d47f0          PUSH     {r4-r10,lr}
;;;420                                void (*thread)(void *arg),
;;;421                                void *arg, int stacksize, int priority)
;;;422    {
000276  4681              MOV      r9,r0
000278  460d              MOV      r5,r1
00027a  4616              MOV      r6,r2
00027c  461f              MOV      r7,r3
00027e  f8dd8020          LDR      r8,[sp,#0x20]
;;;423    	sys_thread_t t;
;;;424    
;;;425    	LWIP_DEBUGF(SYS_DEBUG, ("New Thread: %s\n", pcName));
000282  bf00              NOP      
000284  bf00              NOP      
;;;426    
;;;427    	if (thread_pool_index >= SYS_THREAD_POOL_N)
000286  4860              LDR      r0,|L1.1032|
000288  6800              LDR      r0,[r0,#0]  ; thread_pool_index
00028a  280c              CMP      r0,#0xc
00028c  db02              BLT      |L1.660|
;;;428    		printf("sys_thread_new number error\n");
00028e  a05f              ADR      r0,|L1.1036|
000290  f7fffffe          BL       __2printf
                  |L1.660|
;;;429    	t = (sys_thread_t)&thread_pool[thread_pool_index];
000294  485c              LDR      r0,|L1.1032|
000296  6800              LDR      r0,[r0,#0]  ; thread_pool_index
000298  eb000080          ADD      r0,r0,r0,LSL #2
00029c  4963              LDR      r1,|L1.1068|
00029e  eb010480          ADD      r4,r1,r0,LSL #2
;;;430    	thread_pool_index++;
0002a2  4859              LDR      r0,|L1.1032|
0002a4  6800              LDR      r0,[r0,#0]  ; thread_pool_index
0002a6  1c40              ADDS     r0,r0,#1
0002a8  4957              LDR      r1,|L1.1032|
0002aa  6008              STR      r0,[r1,#0]  ; thread_pool_index
;;;431    	
;;;432    #ifdef __CMSIS_RTOS
;;;433    	t->def.pthread = (os_pthread)thread;
0002ac  6065              STR      r5,[r4,#4]
;;;434    	t->def.tpriority = (osPriority)priority;
0002ae  fa0ff188          SXTH     r1,r8
0002b2  8121              STRH     r1,[r4,#8]
;;;435    	t->def.instances = 1;
0002b4  2101              MOVS     r1,#1
0002b6  60e1              STR      r1,[r4,#0xc]
;;;436    	t->def.stacksize = stacksize;
0002b8  6127              STR      r7,[r4,#0x10]
;;;437    #endif
;;;438    	t->id = osThreadCreate(&t->def, arg);
0002ba  4631              MOV      r1,r6
0002bc  1d20              ADDS     r0,r4,#4
0002be  f7fffffe          BL       osThreadCreate
0002c2  6020              STR      r0,[r4,#0]
;;;439    	if (t->id == NULL)
0002c4  6820              LDR      r0,[r4,#0]
0002c6  b910              CBNZ     r0,|L1.718|
;;;440    		printf("sys_thread_new create error\n");
0002c8  a059              ADR      r0,|L1.1072|
0002ca  f7fffffe          BL       __2printf
                  |L1.718|
;;;441    	
;;;442    	return t;
0002ce  4620              MOV      r0,r4
;;;443    }
0002d0  e8bd87f0          POP      {r4-r10,pc}
;;;444     
                          ENDP

                  assert_printf PROC
;;;455     */
;;;456    void assert_printf(char *msg, int line, char *file)
0002d4  b570              PUSH     {r4-r6,lr}
;;;457    {
0002d6  4604              MOV      r4,r0
0002d8  460d              MOV      r5,r1
0002da  4616              MOV      r6,r2
;;;458    	if (msg)
0002dc  b134              CBZ      r4,|L1.748|
;;;459    		printf("%s:%d in file %s\n", msg, line, file);
0002de  4633              MOV      r3,r6
0002e0  462a              MOV      r2,r5
0002e2  4621              MOV      r1,r4
0002e4  a05a              ADR      r0,|L1.1104|
0002e6  f7fffffe          BL       __2printf
0002ea  e002              B        |L1.754|
                  |L1.748|
;;;460    	else
;;;461    		printf("LWIP ASSERT\n");
0002ec  a05d              ADR      r0,|L1.1124|
0002ee  f7fffffe          BL       __2printf
                  |L1.754|
;;;462    }
0002f2  bd70              POP      {r4-r6,pc}
;;;463     
                          ENDP

                  |L1.756|
0002f4  7379735f          DCB      "sys_mbox_new size error\n",0
0002f8  6d626f78
0002fc  5f6e6577
000300  2073697a
000304  65206572
000308  726f720a
00030c  00      
00030d  00                DCB      0
00030e  00                DCB      0
00030f  00                DCB      0
                  |L1.784|
000310  7379735f          DCB      "sys_mbox_free error\n",0
000314  6d626f78
000318  5f667265
00031c  65206572
000320  726f720a
000324  00      
000325  00                DCB      0
000326  00                DCB      0
000327  00                DCB      0
                  |L1.808|
000328  7379735f          DCB      "sys_mbox_post error\n",0
00032c  6d626f78
000330  5f706f73
000334  74206572
000338  726f720a
00033c  00      
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L1.832|
000340  7379735f          DCB      "sys_sem_new create error\n",0
000344  73656d5f
000348  6e657720
00034c  63726561
000350  74652065
000354  72726f72
000358  0a00    
00035a  00                DCB      0
00035b  00                DCB      0
                  |L1.860|
00035c  7379735f          DCB      "sys_timer_start error\n",0
000360  74696d65
000364  725f7374
000368  61727420
00036c  6572726f
000370  720a00  
000373  00                DCB      0
                  |L1.884|
000374  7379735f          DCB      "sys_timer_stop error\n",0
000378  74696d65
00037c  725f7374
000380  6f702065
000384  72726f72
000388  0a00    
00038a  00                DCB      0
00038b  00                DCB      0
                  |L1.908|
00038c  7379735f          DCB      "sys_mutex_lock error\n",0
000390  6d757465
000394  785f6c6f
000398  636b2065
00039c  72726f72
0003a0  0a00    
0003a2  00                DCB      0
0003a3  00                DCB      0
                  |L1.932|
0003a4  7379735f          DCB      "sys_mutex_unlock error\n",0
0003a8  6d757465
0003ac  785f756e
0003b0  6c6f636b
0003b4  20657272
0003b8  6f720a00
                  |L1.956|
                          DCD      os_mutex_def_lwip_sys_mutex
                  |L1.960|
                          DCD      lwip_sys_mutex
                  |L1.964|
0003c4  7379735f          DCB      "sys_init error\n",0
0003c8  696e6974
0003cc  20657272
0003d0  6f720a00
                  |L1.980|
0003d4  7379735f          DCB      "sys_arch_protect error\n",0
0003d8  61726368
0003dc  5f70726f
0003e0  74656374
0003e4  20657272
0003e8  6f720a00
                  |L1.1004|
0003ec  7379735f          DCB      "sys_arch_unprotect error\n",0
0003f0  61726368
0003f4  5f756e70
0003f8  726f7465
0003fc  63742065
000400  72726f72
000404  0a00    
000406  00                DCB      0
000407  00                DCB      0
                  |L1.1032|
                          DCD      thread_pool_index
                  |L1.1036|
00040c  7379735f          DCB      "sys_thread_new number error\n",0
000410  74687265
000414  61645f6e
000418  6577206e
00041c  756d6265
000420  72206572
000424  726f720a
000428  00      
000429  00                DCB      0
00042a  00                DCB      0
00042b  00                DCB      0
                  |L1.1068|
                          DCD      thread_pool
                  |L1.1072|
000430  7379735f          DCB      "sys_thread_new create error\n",0
000434  74687265
000438  61645f6e
00043c  65772063
000440  72656174
000444  65206572
000448  726f720a
00044c  00      
00044d  00                DCB      0
00044e  00                DCB      0
00044f  00                DCB      0
                  |L1.1104|
000450  25733a25          DCB      "%s:%d in file %s\n",0
000454  6420696e
000458  2066696c
00045c  65202573
000460  0a00    
000462  00                DCB      0
000463  00                DCB      0
                  |L1.1124|
000464  4c574950          DCB      "LWIP ASSERT\n",0
000468  20415353
00046c  4552540a
000470  00      
000471  00                DCB      0
000472  00                DCB      0
000473  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  os_mutex_cb_lwip_sys_mutex
                          %        16
                  thread_pool
                          %        240

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  os_mutex_def_lwip_sys_mutex
                          DCD      os_mutex_cb_lwip_sys_mutex

                          AREA ||.data||, DATA, ALIGN=2

                  lwip_sys_mutex
                          DCD      0x00000000
                  thread_pool_index
                          DCD      0x00000000
