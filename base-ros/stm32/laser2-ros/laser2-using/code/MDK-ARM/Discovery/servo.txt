; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\servo.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\servo.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\servo.crf ..\..\libraries\ptpd-2.0.0\src\dep\servo.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  initClock PROC
;;;2      
;;;3      void initClock(PtpClock *ptpClock)
000000  b510              PUSH     {r4,lr}
;;;4      {
000002  4604              MOV      r4,r0
;;;5      	DBG("initClock\n");
;;;6      
;;;7      	/* Clear vars */
;;;8      	ptpClock->Tms.seconds = ptpClock->Tms.nanoseconds = 0;
000004  2100              MOVS     r1,#0
000006  f44f704b          MOV      r0,#0x32c
00000a  5101              STR      r1,[r0,r4]
00000c  f8c41328          STR      r1,[r4,#0x328]
;;;9      	ptpClock->observedDrift = 0;  /* clears clock servo accumulator (the I term) */
000010  2000              MOVS     r0,#0
000012  f8c403c4          STR      r0,[r4,#0x3c4]
;;;10     
;;;11     	/* One way delay */
;;;12     	ptpClock->owd_filt.n = 0;
000016  f44f706b          MOV      r0,#0x3ac
00001a  5101              STR      r1,[r0,r4]
;;;13     	ptpClock->owd_filt.s = ptpClock->servo.sDelay;
00001c  f2404056          MOV      r0,#0x456
000020  5b01              LDRH     r1,[r0,r4]
000022  f44f706a          MOV      r0,#0x3a8
000026  5301              STRH     r1,[r0,r4]
;;;14     
;;;15     	/* Offset from master */
;;;16     	ptpClock->ofm_filt.n = 0;
000028  2100              MOVS     r1,#0
00002a  f44f7067          MOV      r0,#0x39c
00002e  5101              STR      r1,[r0,r4]
;;;17     	ptpClock->ofm_filt.s = ptpClock->servo.sOffset;
000030  f44f608b          MOV      r0,#0x458
000034  5b01              LDRH     r1,[r0,r4]
000036  f44f7066          MOV      r0,#0x398
00003a  5301              STRH     r1,[r0,r4]
;;;18     
;;;19     	/* Scaled log variance */
;;;20     	if (DEFAULT_PARENTS_STATS)
;;;21     	{
;;;22     		ptpClock->slv_filt.n = 0;
;;;23     		ptpClock->slv_filt.s = 6;
;;;24     		ptpClock->offsetHistory[0] = 0;
;;;25     		ptpClock->offsetHistory[1] = 0;
;;;26     	}
;;;27     
;;;28     	ptpClock->waitingForFollowUp = FALSE;
00003c  2000              MOVS     r0,#0
00003e  f884038c          STRB     r0,[r4,#0x38c]
;;;29     
;;;30     	ptpClock->waitingForPDelayRespFollowUp = FALSE;
000042  f884038d          STRB     r0,[r4,#0x38d]
;;;31     
;;;32     	ptpClock->pdelay_t1.seconds = ptpClock->pdelay_t1.nanoseconds = 0;
000046  2100              MOVS     r1,#0
000048  f44f704f          MOV      r0,#0x33c
00004c  5101              STR      r1,[r0,r4]
00004e  f8c41338          STR      r1,[r4,#0x338]
;;;33     	ptpClock->pdelay_t2.seconds = ptpClock->pdelay_t2.nanoseconds = 0;
000052  f44f7051          MOV      r0,#0x344
000056  5101              STR      r1,[r0,r4]
000058  f8c41340          STR      r1,[r4,#0x340]
;;;34     	ptpClock->pdelay_t3.seconds = ptpClock->pdelay_t3.nanoseconds = 0;
00005c  f44f7053          MOV      r0,#0x34c
000060  5101              STR      r1,[r0,r4]
000062  f8c41348          STR      r1,[r4,#0x348]
;;;35     	ptpClock->pdelay_t4.seconds = ptpClock->pdelay_t4.nanoseconds = 0;
000066  f44f7055          MOV      r0,#0x354
00006a  5101              STR      r1,[r0,r4]
00006c  f8c41350          STR      r1,[r4,#0x350]
;;;36     
;;;37     	/* Reset parent statistics */
;;;38     	ptpClock->parentDS.parentStats = FALSE;
000070  2032              MOVS     r0,#0x32
000072  5501              STRB     r1,[r0,r4]
;;;39     	ptpClock->parentDS.observedParentClockPhaseChangeRate = 0;
000074  63a1              STR      r1,[r4,#0x38]
;;;40     	ptpClock->parentDS.observedParentOffsetScaledLogVariance = 0;
000076  86a1              STRH     r1,[r4,#0x34]
;;;41     
;;;42     	/* Level clock */
;;;43     	if (!ptpClock->servo.noAdjust)
000078  f2404051          MOV      r0,#0x451
00007c  5d00              LDRB     r0,[r0,r4]
00007e  b910              CBNZ     r0,|L1.134|
;;;44     		adjFreq(0);
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       adjFreq
                  |L1.134|
;;;45     
;;;46     	netEmptyEventQ(&ptpClock->netPath);
000086  f5047073          ADD      r0,r4,#0x3cc
00008a  f7fffffe          BL       netEmptyEventQ
;;;47     }
00008e  bd10              POP      {r4,pc}
;;;48     
                          ENDP

                  order PROC
;;;49     static int32_t order(int32_t n)
000090  b510              PUSH     {r4,lr}
;;;50     {
000092  4604              MOV      r4,r0
;;;51     	if (n < 0) {
000094  2c00              CMP      r4,#0
000096  da00              BGE      |L1.154|
;;;52     		n = -n;
000098  4264              RSBS     r4,r4,#0
                  |L1.154|
;;;53     	}
;;;54     	if (n == 0) {
00009a  b90c              CBNZ     r4,|L1.160|
;;;55     		return 0;
00009c  2000              MOVS     r0,#0
                  |L1.158|
;;;56     	}
;;;57     	return floorLog2(n);
;;;58     }
00009e  bd10              POP      {r4,pc}
                  |L1.160|
0000a0  4620              MOV      r0,r4                 ;57
0000a2  f7fffffe          BL       floorLog2
0000a6  e7fa              B        |L1.158|
;;;59     
                          ENDP

                  filter PROC
;;;60     /* Exponencial smoothing */
;;;61     static void filter(int32_t * nsec_current, Filter * filt)
0000a8  e92d41f0          PUSH     {r4-r8,lr}
;;;62     {
0000ac  4606              MOV      r6,r0
0000ae  460c              MOV      r4,r1
;;;63     	int32_t s, s2;
;;;64     
;;;65     	/*
;;;66     			using floatingpoint math
;;;67     			alpha = 1/2^s
;;;68     			y[1] = x[0]
;;;69     			y[n] = alpha * x[n-1] + (1-alpha) * y[n-1]
;;;70     
;;;71     			or equivalent with integer math
;;;72     			y[1] = x[0]
;;;73     			y_sum[1] = y[1] * 2^s
;;;74     			y_sum[n] = y_sum[n-1] + x[n-1] - y[n-1]
;;;75     			y[n] = y_sum[n] / 2^s
;;;76     	*/
;;;77     
;;;78     	/* Increment number of samples */
;;;79     	filt->n++;
0000b0  68e0              LDR      r0,[r4,#0xc]
0000b2  1c40              ADDS     r0,r0,#1
0000b4  60e0              STR      r0,[r4,#0xc]
;;;80     
;;;81     	/* If it is first time, we are running filter, initialize it */
;;;82     	if (filt->n == 1)
0000b6  68e0              LDR      r0,[r4,#0xc]
0000b8  2801              CMP      r0,#1
0000ba  d105              BNE      |L1.200|
;;;83     	{
;;;84     			filt->y_prev = *nsec_current;
0000bc  6830              LDR      r0,[r6,#0]
0000be  6020              STR      r0,[r4,#0]
;;;85     			filt->y_sum = *nsec_current;
0000c0  6830              LDR      r0,[r6,#0]
0000c2  6060              STR      r0,[r4,#4]
;;;86     			filt->s_prev = 0;
0000c4  2000              MOVS     r0,#0
0000c6  8160              STRH     r0,[r4,#0xa]
                  |L1.200|
;;;87     	}
;;;88     
;;;89     	s = filt->s;
0000c8  f9b45008          LDRSH    r5,[r4,#8]
;;;90     
;;;91     	/* Speedup filter, if not 2^s > n */
;;;92     	if ((1<<s) > filt->n)
0000cc  2001              MOVS     r0,#1
0000ce  40a8              LSLS     r0,r0,r5
0000d0  68e1              LDR      r1,[r4,#0xc]
0000d2  4288              CMP      r0,r1
0000d4  dd04              BLE      |L1.224|
;;;93     	{
;;;94     		/* Lower the filter order */
;;;95     		s = order(filt->n);
0000d6  68e0              LDR      r0,[r4,#0xc]
0000d8  f7fffffe          BL       order
0000dc  4605              MOV      r5,r0
0000de  e002              B        |L1.230|
                  |L1.224|
;;;96     	}
;;;97     	else
;;;98     	{
;;;99     		/* Avoid overflowing of n */
;;;100    		filt->n = 1<<s;
0000e0  2001              MOVS     r0,#1
0000e2  40a8              LSLS     r0,r0,r5
0000e4  60e0              STR      r0,[r4,#0xc]
                  |L1.230|
;;;101    	}
;;;102    
;;;103    	/* Avoid overflowing of filter. 30 is because using signed 32bit integers */
;;;104    	s2 = 30 - order(max(filt->y_prev, *nsec_current));
0000e6  6820              LDR      r0,[r4,#0]
0000e8  6831              LDR      r1,[r6,#0]
0000ea  4288              CMP      r0,r1
0000ec  dd01              BLE      |L1.242|
0000ee  4602              MOV      r2,r0
0000f0  e000              B        |L1.244|
                  |L1.242|
0000f2  460a              MOV      r2,r1
                  |L1.244|
0000f4  4690              MOV      r8,r2
0000f6  4640              MOV      r0,r8
0000f8  f7fffffe          BL       order
0000fc  f1c0071e          RSB      r7,r0,#0x1e
;;;105    
;;;106    	/* Use the lower filter order, higher will overflow */
;;;107    	s = min(s, s2);
000100  4629              MOV      r1,r5
000102  4638              MOV      r0,r7
000104  4281              CMP      r1,r0
000106  dd01              BLE      |L1.268|
000108  4602              MOV      r2,r0
00010a  e000              B        |L1.270|
                  |L1.268|
00010c  460a              MOV      r2,r1
                  |L1.270|
00010e  4615              MOV      r5,r2
;;;108    
;;;109    	/* If the order of the filter changed, change also y_sum value */
;;;110    	if (filt->s_prev > s) {
000110  f9b4000a          LDRSH    r0,[r4,#0xa]
000114  42a8              CMP      r0,r5
000116  dd05              BLE      |L1.292|
;;;111    		filt->y_sum >>= (filt->s_prev - s);
000118  7aa1              LDRB     r1,[r4,#0xa]
00011a  1b49              SUBS     r1,r1,r5
00011c  6860              LDR      r0,[r4,#4]
00011e  4108              ASRS     r0,r0,r1
000120  6060              STR      r0,[r4,#4]
000122  e008              B        |L1.310|
                  |L1.292|
;;;112    	} else if (filt->s_prev < s) {
000124  f9b4000a          LDRSH    r0,[r4,#0xa]
000128  42a8              CMP      r0,r5
00012a  da04              BGE      |L1.310|
;;;113    		filt->y_sum <<= (s - filt->s_prev);
00012c  7aa1              LDRB     r1,[r4,#0xa]
00012e  1a69              SUBS     r1,r5,r1
000130  6860              LDR      r0,[r4,#4]
000132  4088              LSLS     r0,r0,r1
000134  6060              STR      r0,[r4,#4]
                  |L1.310|
;;;114    	}
;;;115    
;;;116    	/* Compute the filter itself */
;;;117    	filt->y_sum += *nsec_current - filt->y_prev;
000136  6830              LDR      r0,[r6,#0]
000138  6821              LDR      r1,[r4,#0]
00013a  1a40              SUBS     r0,r0,r1
00013c  6861              LDR      r1,[r4,#4]
00013e  4408              ADD      r0,r0,r1
000140  6060              STR      r0,[r4,#4]
;;;118    	filt->y_prev = filt->y_sum >> s;
000142  6860              LDR      r0,[r4,#4]
000144  4128              ASRS     r0,r0,r5
000146  6020              STR      r0,[r4,#0]
;;;119    
;;;120    	/* Save previous order of the filter */
;;;121    	filt->s_prev = s;
000148  b228              SXTH     r0,r5
00014a  8160              STRH     r0,[r4,#0xa]
;;;122    
;;;123    	DBGV("filter: %d -> %d (%d)\n", *nsec_current, filt->y_prev, s);
;;;124    
;;;125    	/* Actualize target value */
;;;126    	*nsec_current = filt->y_prev;
00014c  6820              LDR      r0,[r4,#0]
00014e  6030              STR      r0,[r6,#0]
;;;127    }
000150  e8bd81f0          POP      {r4-r8,pc}
;;;128    
                          ENDP

                  updateOffset PROC
;;;129    /* 11.2 */
;;;130    void updateOffset(PtpClock *ptpClock, const TimeInternal *syncEventIngressTimestamp,
000154  e92d41f0          PUSH     {r4-r8,lr}
;;;131    									const TimeInternal *preciseOriginTimestamp, const TimeInternal *correctionField)
;;;132    {
000158  4604              MOV      r4,r0
00015a  460e              MOV      r6,r1
00015c  4617              MOV      r7,r2
00015e  461d              MOV      r5,r3
;;;133    	DBGV("updateOffset\n");
;;;134    
;;;135    	/*  <offsetFromMaster> = <syncEventIngressTimestamp> - <preciseOriginTimestamp>
;;;136    		 - <meanPathDelay>  -  correctionField  of  Sync  message
;;;137    		 -  correctionField  of  Follow_Up message. */
;;;138    
;;;139    	/* Compute offsetFromMaster */
;;;140    	subTime(&ptpClock->Tms, syncEventIngressTimestamp, preciseOriginTimestamp);
000160  463a              MOV      r2,r7
000162  4631              MOV      r1,r6
000164  f504704a          ADD      r0,r4,#0x328
000168  f7fffffe          BL       subTime
;;;141    	subTime(&ptpClock->Tms, &ptpClock->Tms, correctionField);
00016c  462a              MOV      r2,r5
00016e  f504714a          ADD      r1,r4,#0x328
000172  4608              MOV      r0,r1
000174  f7fffffe          BL       subTime
;;;142    
;;;143    	ptpClock->currentDS.offsetFromMaster = ptpClock->Tms;
000178  f5047140          ADD      r1,r4,#0x300
00017c  6aca              LDR      r2,[r1,#0x2c]
00017e  6a89              LDR      r1,[r1,#0x28]
000180  e9c41206          STRD     r1,r2,[r4,#0x18]
;;;144    
;;;145    	switch (ptpClock->portDS.delayMechanism)
000184  206f              MOVS     r0,#0x6f
000186  5d00              LDRB     r0,[r0,r4]
000188  2801              CMP      r0,#1
00018a  d002              BEQ      |L1.402|
00018c  2802              CMP      r0,#2
00018e  d110              BNE      |L1.434|
000190  e007              B        |L1.418|
                  |L1.402|
;;;146    	{
;;;147    		case E2E:
;;;148    				subTime(&ptpClock->currentDS.offsetFromMaster, &ptpClock->currentDS.offsetFromMaster, &ptpClock->currentDS.meanPathDelay);
000192  f1040220          ADD      r2,r4,#0x20
000196  f1040118          ADD      r1,r4,#0x18
00019a  4608              MOV      r0,r1
00019c  f7fffffe          BL       subTime
;;;149    				break;
0001a0  e008              B        |L1.436|
                  |L1.418|
;;;150    
;;;151    		case P2P:
;;;152    				subTime(&ptpClock->currentDS.offsetFromMaster, &ptpClock->currentDS.offsetFromMaster, &ptpClock->portDS.peerMeanPathDelay);
0001a2  f1040264          ADD      r2,r4,#0x64
0001a6  f1040118          ADD      r1,r4,#0x18
0001aa  4608              MOV      r0,r1
0001ac  f7fffffe          BL       subTime
;;;153    				break;
0001b0  e000              B        |L1.436|
                  |L1.434|
;;;154    
;;;155    		default:
;;;156    				break;
0001b2  bf00              NOP      
                  |L1.436|
0001b4  bf00              NOP                            ;149
;;;157    	}
;;;158    
;;;159    	if (ptpClock->currentDS.offsetFromMaster.seconds != 0)
0001b6  69a0              LDR      r0,[r4,#0x18]
0001b8  b158              CBZ      r0,|L1.466|
;;;160    	{
;;;161    		if (ptpClock->portDS.portState == PTP_SLAVE)
0001ba  2062              MOVS     r0,#0x62
0001bc  5d00              LDRB     r0,[r0,r4]
0001be  2808              CMP      r0,#8
0001c0  d105              BNE      |L1.462|
;;;162    		{
;;;163    				setFlag(ptpClock->events, SYNCHRONIZATION_FAULT);
0001c2  f8d4045c          LDR      r0,[r4,#0x45c]
0001c6  f4407000          ORR      r0,r0,#0x200
0001ca  f8c4045c          STR      r0,[r4,#0x45c]
                  |L1.462|
;;;164    		}
;;;165    
;;;166    		DBGV("updateOffset: cannot filter seconds\n");
;;;167    
;;;168    		return;
;;;169    	}
;;;170    
;;;171    	/* Filter offsetFromMaster */
;;;172    	filter(&ptpClock->currentDS.offsetFromMaster.nanoseconds, &ptpClock->ofm_filt);
;;;173    
;;;174    	/* Check results */
;;;175    	if (abs(ptpClock->currentDS.offsetFromMaster.nanoseconds) < DEFAULT_CALIBRATED_OFFSET_NS)
;;;176    	{
;;;177    		if (ptpClock->portDS.portState == PTP_UNCALIBRATED)
;;;178    		{
;;;179    				setFlag(ptpClock->events, MASTER_CLOCK_SELECTED);
;;;180    		}
;;;181    	}
;;;182    	else if (abs(ptpClock->currentDS.offsetFromMaster.nanoseconds) > DEFAULT_UNCALIBRATED_OFFSET_NS)
;;;183    	{
;;;184    		if (ptpClock->portDS.portState == PTP_SLAVE)
;;;185    		{
;;;186    				setFlag(ptpClock->events, SYNCHRONIZATION_FAULT);
;;;187    		}
;;;188    	}
;;;189    }
0001ce  e8bd81f0          POP      {r4-r8,pc}
                  |L1.466|
0001d2  f5047164          ADD      r1,r4,#0x390          ;172
0001d6  f104001c          ADD      r0,r4,#0x1c           ;172
0001da  f7fffffe          BL       filter
0001de  69e0              LDR      r0,[r4,#0x1c]         ;175
0001e0  2800              CMP      r0,#0                 ;175
0001e2  db01              BLT      |L1.488|
0001e4  4601              MOV      r1,r0                 ;175
0001e6  e000              B        |L1.490|
                  |L1.488|
0001e8  4241              RSBS     r1,r0,#0              ;175
                  |L1.490|
0001ea  f2427210          MOV      r2,#0x2710            ;175
0001ee  4291              CMP      r1,r2                 ;175
0001f0  da0a              BGE      |L1.520|
0001f2  2062              MOVS     r0,#0x62              ;177
0001f4  5d00              LDRB     r0,[r0,r4]            ;177
0001f6  2807              CMP      r0,#7                 ;177
0001f8  d119              BNE      |L1.558|
0001fa  f8d4045c          LDR      r0,[r4,#0x45c]        ;179
0001fe  f4406080          ORR      r0,r0,#0x400          ;179
000202  f8c4045c          STR      r0,[r4,#0x45c]        ;179
000206  e012              B        |L1.558|
                  |L1.520|
000208  69e0              LDR      r0,[r4,#0x1c]         ;182
00020a  2800              CMP      r0,#0                 ;182
00020c  db01              BLT      |L1.530|
00020e  4601              MOV      r1,r0                 ;182
000210  e000              B        |L1.532|
                  |L1.530|
000212  4241              RSBS     r1,r0,#0              ;182
                  |L1.532|
000214  4a75              LDR      r2,|L1.1004|
000216  4291              CMP      r1,r2                 ;182
000218  dd09              BLE      |L1.558|
00021a  2062              MOVS     r0,#0x62              ;184
00021c  5d00              LDRB     r0,[r0,r4]            ;184
00021e  2808              CMP      r0,#8                 ;184
000220  d105              BNE      |L1.558|
000222  f8d4045c          LDR      r0,[r4,#0x45c]        ;186
000226  f4407000          ORR      r0,r0,#0x200          ;186
00022a  f8c4045c          STR      r0,[r4,#0x45c]        ;186
                  |L1.558|
00022e  bf00              NOP      
000230  e7cd              B        |L1.462|
;;;190    
                          ENDP

                  updateDelay PROC
;;;191    /* 11.3 */
;;;192    void updateDelay(PtpClock * ptpClock, const TimeInternal *delayEventEgressTimestamp,
000232  e92d41f0          PUSH     {r4-r8,lr}
;;;193    								 const TimeInternal *recieveTimestamp, const TimeInternal *correctionField)
;;;194    {
000236  4604              MOV      r4,r0
000238  460d              MOV      r5,r1
00023a  4616              MOV      r6,r2
00023c  461f              MOV      r7,r3
;;;195    	/* Tms valid ? */
;;;196    	if (0 == ptpClock->ofm_filt.n)
00023e  f44f7067          MOV      r0,#0x39c
000242  5900              LDR      r0,[r0,r4]
000244  b908              CBNZ     r0,|L1.586|
                  |L1.582|
;;;197    	{
;;;198    		DBGV("updateDelay: Tms is not valid");
;;;199    		return;
;;;200    	}
;;;201    
;;;202    	subTime(&ptpClock->Tsm, recieveTimestamp, delayEventEgressTimestamp);
;;;203    	subTime(&ptpClock->Tsm, &ptpClock->Tsm, correctionField);
;;;204    	addTime(&ptpClock->currentDS.meanPathDelay, &ptpClock->Tms, &ptpClock->Tsm);
;;;205    	div2Time(&ptpClock->currentDS.meanPathDelay);
;;;206    
;;;207    	/* Filter delay */
;;;208    	if (0 != ptpClock->currentDS.meanPathDelay.seconds)
;;;209    	{
;;;210    		DBGV("updateDelay: cannot filter with seconds");
;;;211    	}
;;;212    	else
;;;213    	{
;;;214    		filter(&ptpClock->currentDS.meanPathDelay.nanoseconds, &ptpClock->owd_filt);
;;;215    	}
;;;216    }
000246  e8bd81f0          POP      {r4-r8,pc}
                  |L1.586|
00024a  462a              MOV      r2,r5                 ;202
00024c  4631              MOV      r1,r6                 ;202
00024e  f504704c          ADD      r0,r4,#0x330          ;202
000252  f7fffffe          BL       subTime
000256  463a              MOV      r2,r7                 ;203
000258  f504714c          ADD      r1,r4,#0x330          ;203
00025c  4608              MOV      r0,r1                 ;203
00025e  f7fffffe          BL       subTime
000262  f504724c          ADD      r2,r4,#0x330          ;204
000266  f504714a          ADD      r1,r4,#0x328          ;204
00026a  f1040020          ADD      r0,r4,#0x20           ;204
00026e  f7fffffe          BL       addTime
000272  f1040020          ADD      r0,r4,#0x20           ;205
000276  f7fffffe          BL       div2Time
00027a  6a20              LDR      r0,[r4,#0x20]         ;208
00027c  b928              CBNZ     r0,|L1.650|
00027e  f5047168          ADD      r1,r4,#0x3a0          ;214
000282  f1040024          ADD      r0,r4,#0x24           ;214
000286  f7fffffe          BL       filter
                  |L1.650|
00028a  bf00              NOP      
00028c  e7db              B        |L1.582|
;;;217    
                          ENDP

                  updatePeerDelay PROC
;;;218    void updatePeerDelay(PtpClock *ptpClock, const TimeInternal *correctionField, bool  twoStep)
00028e  b57f              PUSH     {r0-r6,lr}
;;;219    {
000290  4604              MOV      r4,r0
000292  460d              MOV      r5,r1
000294  4616              MOV      r6,r2
;;;220    	DBGV("updatePeerDelay\n");
;;;221    
;;;222    	if (twoStep)
000296  b1a6              CBZ      r6,|L1.706|
;;;223    	{
;;;224    		TimeInternal Tab, Tba;
;;;225    		subTime(&Tab, &ptpClock->pdelay_t2 , &ptpClock->pdelay_t1);
000298  f504724e          ADD      r2,r4,#0x338
00029c  f5047150          ADD      r1,r4,#0x340
0002a0  a802              ADD      r0,sp,#8
0002a2  f7fffffe          BL       subTime
;;;226    		subTime(&Tba, &ptpClock->pdelay_t4, &ptpClock->pdelay_t3);
0002a6  f5047252          ADD      r2,r4,#0x348
0002aa  f5047154          ADD      r1,r4,#0x350
0002ae  4668              MOV      r0,sp
0002b0  f7fffffe          BL       subTime
;;;227    		addTime(&ptpClock->portDS.peerMeanPathDelay, &Tab, &Tba);
0002b4  466a              MOV      r2,sp
0002b6  a902              ADD      r1,sp,#8
0002b8  f1040064          ADD      r0,r4,#0x64
0002bc  f7fffffe          BL       addTime
;;;228    	}
0002c0  e007              B        |L1.722|
                  |L1.706|
;;;229    	else /* One step  clock */
;;;230    	{
;;;231    		subTime(&ptpClock->portDS.peerMeanPathDelay, &ptpClock->pdelay_t4, &ptpClock->pdelay_t1);
0002c2  f504724e          ADD      r2,r4,#0x338
0002c6  f5047154          ADD      r1,r4,#0x350
0002ca  f1040064          ADD      r0,r4,#0x64
0002ce  f7fffffe          BL       subTime
                  |L1.722|
;;;232    	}
;;;233    
;;;234    	subTime(&ptpClock->portDS.peerMeanPathDelay, &ptpClock->portDS.peerMeanPathDelay, correctionField);
0002d2  462a              MOV      r2,r5
0002d4  f1040164          ADD      r1,r4,#0x64
0002d8  4608              MOV      r0,r1
0002da  f7fffffe          BL       subTime
;;;235    	div2Time(&ptpClock->portDS.peerMeanPathDelay);
0002de  f1040064          ADD      r0,r4,#0x64
0002e2  f7fffffe          BL       div2Time
;;;236    
;;;237    	/* Filter delay */
;;;238    	if (ptpClock->portDS.peerMeanPathDelay.seconds != 0)
0002e6  6e60              LDR      r0,[r4,#0x64]
0002e8  b100              CBZ      r0,|L1.748|
                  |L1.746|
;;;239    	{
;;;240    		DBGV("updatePeerDelay: cannot filter with seconds");
;;;241    		return;
;;;242    	}
;;;243    	else
;;;244    	{
;;;245    		filter(&ptpClock->portDS.peerMeanPathDelay.nanoseconds, &ptpClock->owd_filt);
;;;246    	}
;;;247    }
0002ea  bd7f              POP      {r0-r6,pc}
                  |L1.748|
0002ec  f5047168          ADD      r1,r4,#0x3a0          ;245
0002f0  f1040068          ADD      r0,r4,#0x68           ;245
0002f4  f7fffffe          BL       filter
0002f8  bf00              NOP      
0002fa  e7f6              B        |L1.746|
;;;248    
                          ENDP

                  updateClock PROC
;;;249    void updateClock(PtpClock *ptpClock)
0002fc  b57c              PUSH     {r2-r6,lr}
;;;250    {
0002fe  4604              MOV      r4,r0
;;;251    	int32_t adj;
;;;252    	TimeInternal timeTmp;
;;;253    	int32_t offsetNorm;
;;;254    
;;;255    	DBGV("updateClock\n");
;;;256    
;;;257    	if (ptpClock->currentDS.offsetFromMaster.seconds != 0 || abs(ptpClock->currentDS.offsetFromMaster.nanoseconds) > MAX_ADJ_OFFSET_NS)
000300  69a1              LDR      r1,[r4,#0x18]
000302  b941              CBNZ     r1,|L1.790|
000304  69e0              LDR      r0,[r4,#0x1c]
000306  2800              CMP      r0,#0
000308  db01              BLT      |L1.782|
00030a  4601              MOV      r1,r0
00030c  e000              B        |L1.784|
                  |L1.782|
00030e  4241              RSBS     r1,r0,#0
                  |L1.784|
000310  4a37              LDR      r2,|L1.1008|
000312  4291              CMP      r1,r2
000314  dd23              BLE      |L1.862|
                  |L1.790|
;;;258    	{
;;;259    		/* if secs, reset clock or set freq adjustment to max */
;;;260    		if (!ptpClock->servo.noAdjust)
000316  f2404051          MOV      r0,#0x451
00031a  5d00              LDRB     r0,[r0,r4]
00031c  2800              CMP      r0,#0
00031e  d158              BNE      |L1.978|
;;;261    		{
;;;262    			if (!ptpClock->servo.noResetClock)
000320  f8940450          LDRB     r0,[r4,#0x450]
000324  b978              CBNZ     r0,|L1.838|
;;;263    			{
;;;264    				getTime(&timeTmp);
000326  4668              MOV      r0,sp
000328  f7fffffe          BL       getTime
;;;265    				subTime(&timeTmp, &timeTmp, &ptpClock->currentDS.offsetFromMaster);
00032c  f1040218          ADD      r2,r4,#0x18
000330  4669              MOV      r1,sp
000332  4668              MOV      r0,sp
000334  f7fffffe          BL       subTime
;;;266    				setTime(&timeTmp);
000338  4668              MOV      r0,sp
00033a  f7fffffe          BL       setTime
;;;267    				initClock(ptpClock);
00033e  4620              MOV      r0,r4
000340  f7fffffe          BL       initClock
000344  e045              B        |L1.978|
                  |L1.838|
;;;268    			}
;;;269    			else
;;;270    			{
;;;271    				adj = ptpClock->currentDS.offsetFromMaster.nanoseconds > 0 ? ADJ_FREQ_MAX : -ADJ_FREQ_MAX;
000346  69e0              LDR      r0,[r4,#0x1c]
000348  2800              CMP      r0,#0
00034a  dd02              BLE      |L1.850|
00034c  f44f20fa          MOV      r0,#0x7d000
000350  e000              B        |L1.852|
                  |L1.850|
000352  4828              LDR      r0,|L1.1012|
                  |L1.852|
000354  4606              MOV      r6,r0
;;;272    				adjFreq(-adj);
000356  4270              RSBS     r0,r6,#0
000358  f7fffffe          BL       adjFreq
00035c  e039              B        |L1.978|
                  |L1.862|
;;;273    			}
;;;274    		}
;;;275    	}
;;;276    	else
;;;277    	{
;;;278    		/* the PI controller */
;;;279    
;;;280    		/* normalize offset to 1s sync interval -> response of the servo will
;;;281    		 * be same for all sync interval values, but faster/slower
;;;282    		 * (possible lost of precision/overflow but much more stable) */
;;;283    		offsetNorm = ptpClock->currentDS.offsetFromMaster.nanoseconds;
00035e  69e5              LDR      r5,[r4,#0x1c]
;;;284    		if (ptpClock->portDS.logSyncInterval > 0)
000360  f994006e          LDRSB    r0,[r4,#0x6e]
000364  2800              CMP      r0,#0
000366  dd03              BLE      |L1.880|
;;;285    			offsetNorm >>= ptpClock->portDS.logSyncInterval;
000368  206e              MOVS     r0,#0x6e
00036a  5d00              LDRB     r0,[r0,r4]
00036c  4105              ASRS     r5,r5,r0
00036e  e007              B        |L1.896|
                  |L1.880|
;;;286    		else if (ptpClock->portDS.logSyncInterval < 0)
000370  f994006e          LDRSB    r0,[r4,#0x6e]
000374  2800              CMP      r0,#0
000376  da03              BGE      |L1.896|
;;;287    			offsetNorm <<= -ptpClock->portDS.logSyncInterval;
000378  206e              MOVS     r0,#0x6e
00037a  5d00              LDRB     r0,[r0,r4]
00037c  4240              RSBS     r0,r0,#0
00037e  4085              LSLS     r5,r5,r0
                  |L1.896|
;;;288    
;;;289    		/* the accumulator for the I component */
;;;290    		ptpClock->observedDrift += offsetNorm / ptpClock->servo.ai;
000380  f9b40454          LDRSH    r0,[r4,#0x454]
000384  fb95f0f0          SDIV     r0,r5,r0
000388  f8d413c4          LDR      r1,[r4,#0x3c4]
00038c  4408              ADD      r0,r0,r1
00038e  f8c403c4          STR      r0,[r4,#0x3c4]
;;;291    
;;;292    		/* clamp the accumulator to ADJ_FREQ_MAX for sanity */
;;;293    		if (ptpClock->observedDrift > ADJ_FREQ_MAX)
000392  f8d403c4          LDR      r0,[r4,#0x3c4]
000396  f5b02ffa          CMP      r0,#0x7d000
00039a  dd04              BLE      |L1.934|
;;;294    			ptpClock->observedDrift = ADJ_FREQ_MAX;
00039c  f44f20fa          MOV      r0,#0x7d000
0003a0  f8c403c4          STR      r0,[r4,#0x3c4]
0003a4  e007              B        |L1.950|
                  |L1.934|
;;;295    		else if (ptpClock->observedDrift < -ADJ_FREQ_MAX)
0003a6  f8d403c4          LDR      r0,[r4,#0x3c4]
0003aa  f5102ffa          CMN      r0,#0x7d000
0003ae  da02              BGE      |L1.950|
;;;296    			ptpClock->observedDrift = -ADJ_FREQ_MAX;
0003b0  4810              LDR      r0,|L1.1012|
0003b2  f8c403c4          STR      r0,[r4,#0x3c4]
                  |L1.950|
;;;297    
;;;298    		/* apply controller output as a clock tick rate adjustment */
;;;299    		if (!ptpClock->servo.noAdjust)
0003b6  f2404051          MOV      r0,#0x451
0003ba  5d00              LDRB     r0,[r0,r4]
0003bc  b948              CBNZ     r0,|L1.978|
;;;300    		{
;;;301    			adj = offsetNorm / ptpClock->servo.ap + ptpClock->observedDrift;
0003be  f9b40452          LDRSH    r0,[r4,#0x452]
0003c2  fb95f0f0          SDIV     r0,r5,r0
0003c6  f8d413c4          LDR      r1,[r4,#0x3c4]
0003ca  1846              ADDS     r6,r0,r1
;;;302    			adjFreq(-adj);
0003cc  4270              RSBS     r0,r6,#0
0003ce  f7fffffe          BL       adjFreq
                  |L1.978|
;;;303    		}
;;;304    
;;;305    		if (DEFAULT_PARENTS_STATS)
;;;306    		{
;;;307    			int a, scaledLogVariance;
;;;308    			ptpClock->parentDS.parentStats = TRUE;
;;;309    			ptpClock->parentDS.observedParentClockPhaseChangeRate = 1100 * ptpClock->observedDrift;
;;;310    
;;;311    			a = (ptpClock->offsetHistory[1] - 2 * ptpClock->offsetHistory[0] + ptpClock->currentDS.offsetFromMaster.nanoseconds);
;;;312    			ptpClock->offsetHistory[1] = ptpClock->offsetHistory[0];
;;;313    			ptpClock->offsetHistory[0] = ptpClock->currentDS.offsetFromMaster.nanoseconds;
;;;314    
;;;315    			scaledLogVariance = order(a * a) << 8;
;;;316    			filter(&scaledLogVariance, &ptpClock->slv_filt);
;;;317    			ptpClock->parentDS.observedParentOffsetScaledLogVariance = 17000 + scaledLogVariance;
;;;318    			DBGV("updateClock: observed scalled log variance: 0x%x\n", ptpClock->parentDS.observedParentOffsetScaledLogVariance);
;;;319    		}
;;;320    	}
;;;321    
;;;322    	switch (ptpClock->portDS.delayMechanism)
0003d2  206f              MOVS     r0,#0x6f
0003d4  5d00              LDRB     r0,[r0,r4]
0003d6  2801              CMP      r0,#1
0003d8  d002              BEQ      |L1.992|
0003da  2802              CMP      r0,#2
0003dc  d102              BNE      |L1.996|
0003de  e000              B        |L1.994|
                  |L1.992|
;;;323    	{
;;;324    		case E2E:
;;;325    			DBG("updateClock: one-way delay averaged (E2E): %d sec %d nsec\n",
;;;326    					ptpClock->currentDS.meanPathDelay.seconds, ptpClock->currentDS.meanPathDelay.nanoseconds);
;;;327    			break;
0003e0  e001              B        |L1.998|
                  |L1.994|
;;;328    
;;;329    		case P2P:
;;;330    			DBG("updateClock: one-way delay averaged (P2P): %d sec %d nsec\n",
;;;331    					ptpClock->portDS.peerMeanPathDelay.seconds, ptpClock->portDS.peerMeanPathDelay.nanoseconds);
;;;332    			break;
0003e2  e000              B        |L1.998|
                  |L1.996|
0003e4  bf00              NOP                            ;322
                  |L1.998|
0003e6  bf00              NOP                            ;327
;;;333    
;;;334    		default:
;;;335    			DBG("updateClock: one-way delay not computed\n");
;;;336    	}
;;;337    
;;;338    	DBG("updateClock: offset from master: %d sec %d nsec\n",
;;;339    			ptpClock->currentDS.offsetFromMaster.seconds,
;;;340    			ptpClock->currentDS.offsetFromMaster.nanoseconds);
;;;341    	DBG("updateClock: observed drift: %d\n", ptpClock->observedDrift);
;;;342    }
0003e8  bd7c              POP      {r2-r6,pc}
                          ENDP

0003ea  0000              DCW      0x0000
                  |L1.1004|
                          DCD      0x000f4240
                  |L1.1008|
                          DCD      0x05f5e100
                  |L1.1012|
                          DCD      0xfff83000

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\dep\\servo.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_servo_c_e4adb1b2____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_servo_c_e4adb1b2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_servo_c_e4adb1b2____REVSH|
#line 128
|__asm___7_servo_c_e4adb1b2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
