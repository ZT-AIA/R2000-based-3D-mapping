; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4xx_usart.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4xx_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4xx_usart.crf ..\..\libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;183      */
;;;184    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;185    {
000002  4604              MOV      r4,r0
;;;186      /* Check the parameters */
;;;187      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;188    
;;;189      if (USARTx == USART1)
000004  48f7              LDR      r0,|L1.996|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;190      {
;;;191        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;192        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  2010              MOVS     r0,#0x10
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e03e              B        |L1.154|
                  |L1.28|
;;;193      }
;;;194      else if (USARTx == USART2)
00001c  48f2              LDR      r0,|L1.1000|
00001e  4284              CMP      r4,r0
000020  d109              BNE      |L1.54|
;;;195      {
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000022  2101              MOVS     r1,#1
000024  0448              LSLS     r0,r1,#17
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;197        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  f44f3000          MOV      r0,#0x20000
000030  f7fffffe          BL       RCC_APB1PeriphResetCmd
000034  e031              B        |L1.154|
                  |L1.54|
;;;198      }
;;;199      else if (USARTx == USART3)
000036  48ed              LDR      r0,|L1.1004|
000038  4284              CMP      r4,r0
00003a  d109              BNE      |L1.80|
;;;200      {
;;;201        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  0488              LSLS     r0,r1,#18
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;202        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000044  2100              MOVS     r1,#0
000046  f44f2080          MOV      r0,#0x40000
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004e  e024              B        |L1.154|
                  |L1.80|
;;;203      }    
;;;204      else if (USARTx == UART4)
000050  48e7              LDR      r0,|L1.1008|
000052  4284              CMP      r4,r0
000054  d109              BNE      |L1.106|
;;;205      {
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000056  2101              MOVS     r1,#1
000058  04c8              LSLS     r0,r1,#19
00005a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;207        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00005e  2100              MOVS     r1,#0
000060  f44f2000          MOV      r0,#0x80000
000064  f7fffffe          BL       RCC_APB1PeriphResetCmd
000068  e017              B        |L1.154|
                  |L1.106|
;;;208      }
;;;209      else if (USARTx == UART5)
00006a  48e2              LDR      r0,|L1.1012|
00006c  4284              CMP      r4,r0
00006e  d109              BNE      |L1.132|
;;;210      {
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000070  2101              MOVS     r1,#1
000072  0508              LSLS     r0,r1,#20
000074  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000078  2100              MOVS     r1,#0
00007a  f44f1080          MOV      r0,#0x100000
00007e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000082  e00a              B        |L1.154|
                  |L1.132|
;;;213      }     
;;;214      else
;;;215      {
;;;216        if (USARTx == USART6)
000084  48dc              LDR      r0,|L1.1016|
000086  4284              CMP      r4,r0
000088  d107              BNE      |L1.154|
;;;217        { 
;;;218          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
00008a  2101              MOVS     r1,#1
00008c  2020              MOVS     r0,#0x20
00008e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;219          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
000092  2100              MOVS     r1,#0
000094  2020              MOVS     r0,#0x20
000096  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.154|
;;;220        }
;;;221      }
;;;222    }
00009a  bd10              POP      {r4,pc}
;;;223    
                          ENDP

                  USART_Init PROC
;;;232      */
;;;233    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
00009c  e92d47ff          PUSH     {r0-r10,lr}
;;;234    {
0000a0  4605              MOV      r5,r0
0000a2  460e              MOV      r6,r1
;;;235      uint32_t tmpreg = 0x00, apbclock = 0x00;
0000a4  2400              MOVS     r4,#0
0000a6  46a1              MOV      r9,r4
;;;236      uint32_t integerdivider = 0x00;
0000a8  bf00              NOP      
;;;237      uint32_t fractionaldivider = 0x00;
0000aa  46a0              MOV      r8,r4
;;;238      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;239    
;;;240      /* Check the parameters */
;;;241      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;242      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;243      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;244      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;245      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;246      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;247      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;248    
;;;249      /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;250      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
0000ac  89b0              LDRH     r0,[r6,#0xc]
0000ae  b100              CBZ      r0,|L1.178|
;;;251      {
;;;252        assert_param(IS_USART_1236_PERIPH(USARTx));
0000b0  bf00              NOP      
                  |L1.178|
;;;253      }
;;;254    
;;;255    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;256      tmpreg = USARTx->CR2;
0000b2  8a2c              LDRH     r4,[r5,#0x10]
;;;257    
;;;258      /* Clear STOP[13:12] bits */
;;;259      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
0000b4  f4245440          BIC      r4,r4,#0x3000
;;;260    
;;;261      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
;;;262          Set STOP[13:12] bits according to USART_StopBits value */
;;;263      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
0000b8  88f0              LDRH     r0,[r6,#6]
0000ba  4304              ORRS     r4,r4,r0
;;;264      
;;;265      /* Write to USART CR2 */
;;;266      USARTx->CR2 = (uint16_t)tmpreg;
0000bc  822c              STRH     r4,[r5,#0x10]
;;;267    
;;;268    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;269      tmpreg = USARTx->CR1;
0000be  89ac              LDRH     r4,[r5,#0xc]
;;;270    
;;;271      /* Clear M, PCE, PS, TE and RE bits */
;;;272      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
0000c0  f241600c          MOV      r0,#0x160c
0000c4  4384              BICS     r4,r4,r0
;;;273    
;;;274      /* Configure the USART Word Length, Parity and mode: 
;;;275         Set the M bits according to USART_WordLength value 
;;;276         Set PCE and PS bits according to USART_Parity value
;;;277         Set TE and RE bits according to USART_Mode value */
;;;278      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000c6  88b0              LDRH     r0,[r6,#4]
0000c8  8931              LDRH     r1,[r6,#8]
0000ca  4308              ORRS     r0,r0,r1
0000cc  8971              LDRH     r1,[r6,#0xa]
0000ce  4308              ORRS     r0,r0,r1
0000d0  4304              ORRS     r4,r4,r0
;;;279                USART_InitStruct->USART_Mode;
;;;280    
;;;281      /* Write to USART CR1 */
;;;282      USARTx->CR1 = (uint16_t)tmpreg;
0000d2  81ac              STRH     r4,[r5,#0xc]
;;;283    
;;;284    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;285      tmpreg = USARTx->CR3;
0000d4  8aac              LDRH     r4,[r5,#0x14]
;;;286    
;;;287      /* Clear CTSE and RTSE bits */
;;;288      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
0000d6  f4247440          BIC      r4,r4,#0x300
;;;289    
;;;290      /* Configure the USART HFC : 
;;;291          Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;292      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000da  89b0              LDRH     r0,[r6,#0xc]
0000dc  4304              ORRS     r4,r4,r0
;;;293    
;;;294      /* Write to USART CR3 */
;;;295      USARTx->CR3 = (uint16_t)tmpreg;
0000de  82ac              STRH     r4,[r5,#0x14]
;;;296    
;;;297    /*---------------------------- USART BRR Configuration -----------------------*/
;;;298      /* Configure the USART Baud Rate */
;;;299      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000e0  4668              MOV      r0,sp
0000e2  f7fffffe          BL       RCC_GetClocksFreq
;;;300    
;;;301      if ((USARTx == USART1) || (USARTx == USART6))
0000e6  48bf              LDR      r0,|L1.996|
0000e8  4285              CMP      r5,r0
0000ea  d002              BEQ      |L1.242|
0000ec  48c2              LDR      r0,|L1.1016|
0000ee  4285              CMP      r5,r0
0000f0  d102              BNE      |L1.248|
                  |L1.242|
;;;302      {
;;;303        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
0000f2  f8dd900c          LDR      r9,[sp,#0xc]
0000f6  e001              B        |L1.252|
                  |L1.248|
;;;304      }
;;;305      else
;;;306      {
;;;307        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0000f8  f8dd9008          LDR      r9,[sp,#8]
                  |L1.252|
;;;308      }
;;;309      
;;;310      /* Determine the integer part */
;;;311      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
0000fc  89a8              LDRH     r0,[r5,#0xc]
0000fe  f4004000          AND      r0,r0,#0x8000
000102  b140              CBZ      r0,|L1.278|
;;;312      {
;;;313        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;314        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
000104  eb0900c9          ADD      r0,r9,r9,LSL #3
000108  eb001009          ADD      r0,r0,r9,LSL #4
00010c  6831              LDR      r1,[r6,#0]
00010e  0049              LSLS     r1,r1,#1
000110  fbb0f7f1          UDIV     r7,r0,r1
000114  e007              B        |L1.294|
                  |L1.278|
;;;315      }
;;;316      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;317      {
;;;318        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;319        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000116  eb0900c9          ADD      r0,r9,r9,LSL #3
00011a  eb001009          ADD      r0,r0,r9,LSL #4
00011e  6831              LDR      r1,[r6,#0]
000120  0089              LSLS     r1,r1,#2
000122  fbb0f7f1          UDIV     r7,r0,r1
                  |L1.294|
;;;320      }
;;;321      tmpreg = (integerdivider / 100) << 4;
000126  2064              MOVS     r0,#0x64
000128  fbb7f0f0          UDIV     r0,r7,r0
00012c  0104              LSLS     r4,r0,#4
;;;322    
;;;323      /* Determine the fractional part */
;;;324      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
00012e  0920              LSRS     r0,r4,#4
000130  2164              MOVS     r1,#0x64
000132  fb017810          MLS      r8,r1,r0,r7
;;;325    
;;;326      /* Implement the fractional part in the register */
;;;327      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000136  89a8              LDRH     r0,[r5,#0xc]
000138  f4004000          AND      r0,r0,#0x8000
00013c  b140              CBZ      r0,|L1.336|
;;;328      {
;;;329        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
00013e  2032              MOVS     r0,#0x32
000140  eb0000c8          ADD      r0,r0,r8,LSL #3
000144  fbb0f0f1          UDIV     r0,r0,r1
000148  f0000007          AND      r0,r0,#7
00014c  4304              ORRS     r4,r4,r0
00014e  e008              B        |L1.354|
                  |L1.336|
;;;330      }
;;;331      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;332      {
;;;333        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
000150  2032              MOVS     r0,#0x32
000152  eb001008          ADD      r0,r0,r8,LSL #4
000156  2164              MOVS     r1,#0x64
000158  fbb0f0f1          UDIV     r0,r0,r1
00015c  f000000f          AND      r0,r0,#0xf
000160  4304              ORRS     r4,r4,r0
                  |L1.354|
;;;334      }
;;;335      
;;;336      /* Write to USART BRR register */
;;;337      USARTx->BRR = (uint16_t)tmpreg;
000162  812c              STRH     r4,[r5,#8]
;;;338    }
000164  e8bd87ff          POP      {r0-r10,pc}
;;;339    
                          ENDP

                  USART_StructInit PROC
;;;345      */
;;;346    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000168  f44f5116          MOV      r1,#0x2580
;;;347    {
;;;348      /* USART_InitStruct members default value */
;;;349      USART_InitStruct->USART_BaudRate = 9600;
00016c  6001              STR      r1,[r0,#0]
;;;350      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
00016e  2100              MOVS     r1,#0
000170  8081              STRH     r1,[r0,#4]
;;;351      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000172  80c1              STRH     r1,[r0,#6]
;;;352      USART_InitStruct->USART_Parity = USART_Parity_No ;
000174  8101              STRH     r1,[r0,#8]
;;;353      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000176  210c              MOVS     r1,#0xc
000178  8141              STRH     r1,[r0,#0xa]
;;;354      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
00017a  2100              MOVS     r1,#0
00017c  8181              STRH     r1,[r0,#0xc]
;;;355    }
00017e  4770              BX       lr
;;;356    
                          ENDP

                  USART_ClockInit PROC
;;;365      */
;;;366    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000180  b510              PUSH     {r4,lr}
;;;367    {
000182  4602              MOV      r2,r0
;;;368      uint32_t tmpreg = 0x00;
000184  2000              MOVS     r0,#0
;;;369      /* Check the parameters */
;;;370      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;371      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;372      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;373      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;374      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;375      
;;;376    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;377      tmpreg = USARTx->CR2;
000186  8a10              LDRH     r0,[r2,#0x10]
;;;378      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;379      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
000188  f4206070          BIC      r0,r0,#0xf00
;;;380      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;381      /* Set CLKEN bit according to USART_Clock value */
;;;382      /* Set CPOL bit according to USART_CPOL value */
;;;383      /* Set CPHA bit according to USART_CPHA value */
;;;384      /* Set LBCL bit according to USART_LastBit value */
;;;385      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00018c  880b              LDRH     r3,[r1,#0]
00018e  884c              LDRH     r4,[r1,#2]
000190  4323              ORRS     r3,r3,r4
000192  888c              LDRH     r4,[r1,#4]
000194  4323              ORRS     r3,r3,r4
000196  88cc              LDRH     r4,[r1,#6]
000198  4323              ORRS     r3,r3,r4
00019a  4318              ORRS     r0,r0,r3
;;;386                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;387      /* Write to USART CR2 */
;;;388      USARTx->CR2 = (uint16_t)tmpreg;
00019c  8210              STRH     r0,[r2,#0x10]
;;;389    }
00019e  bd10              POP      {r4,pc}
;;;390    
                          ENDP

                  USART_ClockStructInit PROC
;;;396      */
;;;397    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
0001a0  2100              MOVS     r1,#0
;;;398    {
;;;399      /* USART_ClockInitStruct members default value */
;;;400      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
0001a2  8001              STRH     r1,[r0,#0]
;;;401      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
0001a4  8041              STRH     r1,[r0,#2]
;;;402      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
0001a6  8081              STRH     r1,[r0,#4]
;;;403      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
0001a8  80c1              STRH     r1,[r0,#6]
;;;404    }
0001aa  4770              BX       lr
;;;405    
                          ENDP

                  USART_Cmd PROC
;;;413      */
;;;414    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001ac  b121              CBZ      r1,|L1.440|
;;;415    {
;;;416      /* Check the parameters */
;;;417      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;418      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;419      
;;;420      if (NewState != DISABLE)
;;;421      {
;;;422        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;423        USARTx->CR1 |= USART_CR1_UE;
0001ae  8982              LDRH     r2,[r0,#0xc]
0001b0  f4425200          ORR      r2,r2,#0x2000
0001b4  8182              STRH     r2,[r0,#0xc]
0001b6  e004              B        |L1.450|
                  |L1.440|
;;;424      }
;;;425      else
;;;426      {
;;;427        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;428        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
0001b8  8982              LDRH     r2,[r0,#0xc]
0001ba  f64d73ff          MOV      r3,#0xdfff
0001be  401a              ANDS     r2,r2,r3
0001c0  8182              STRH     r2,[r0,#0xc]
                  |L1.450|
;;;429      }
;;;430    }
0001c2  4770              BX       lr
;;;431    
                          ENDP

                  USART_SetPrescaler PROC
;;;439      */
;;;440    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
0001c4  8b02              LDRH     r2,[r0,#0x18]
;;;441    { 
;;;442      /* Check the parameters */
;;;443      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;444      
;;;445      /* Clear the USART prescaler */
;;;446      USARTx->GTPR &= USART_GTPR_GT;
0001c6  f402427f          AND      r2,r2,#0xff00
0001ca  8302              STRH     r2,[r0,#0x18]
;;;447      /* Set the USART prescaler */
;;;448      USARTx->GTPR |= USART_Prescaler;
0001cc  8b02              LDRH     r2,[r0,#0x18]
0001ce  430a              ORRS     r2,r2,r1
0001d0  8302              STRH     r2,[r0,#0x18]
;;;449    }
0001d2  4770              BX       lr
;;;450    
                          ENDP

                  USART_OverSampling8Cmd PROC
;;;460      */
;;;461    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001d4  b121              CBZ      r1,|L1.480|
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;465      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;466      
;;;467      if (NewState != DISABLE)
;;;468      {
;;;469        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;470        USARTx->CR1 |= USART_CR1_OVER8;
0001d6  8982              LDRH     r2,[r0,#0xc]
0001d8  f4424200          ORR      r2,r2,#0x8000
0001dc  8182              STRH     r2,[r0,#0xc]
0001de  e003              B        |L1.488|
                  |L1.480|
;;;471      }
;;;472      else
;;;473      {
;;;474        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;475        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
0001e0  8982              LDRH     r2,[r0,#0xc]
0001e2  f3c2020e          UBFX     r2,r2,#0,#15
0001e6  8182              STRH     r2,[r0,#0xc]
                  |L1.488|
;;;476      }
;;;477    }  
0001e8  4770              BX       lr
;;;478    
                          ENDP

                  USART_OneBitMethodCmd PROC
;;;486      */
;;;487    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001ea  b121              CBZ      r1,|L1.502|
;;;488    {
;;;489      /* Check the parameters */
;;;490      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;491      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;492      
;;;493      if (NewState != DISABLE)
;;;494      {
;;;495        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;496        USARTx->CR3 |= USART_CR3_ONEBIT;
0001ec  8a82              LDRH     r2,[r0,#0x14]
0001ee  f4426200          ORR      r2,r2,#0x800
0001f2  8282              STRH     r2,[r0,#0x14]
0001f4  e004              B        |L1.512|
                  |L1.502|
;;;497      }
;;;498      else
;;;499      {
;;;500        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;501        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
0001f6  8a82              LDRH     r2,[r0,#0x14]
0001f8  f24f73ff          MOV      r3,#0xf7ff
0001fc  401a              ANDS     r2,r2,r3
0001fe  8282              STRH     r2,[r0,#0x14]
                  |L1.512|
;;;502      }
;;;503    }
000200  4770              BX       lr
;;;504    
                          ENDP

                  USART_SendData PROC
;;;543      */
;;;544    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000202  f3c10208          UBFX     r2,r1,#0,#9
;;;545    {
;;;546      /* Check the parameters */
;;;547      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;548      assert_param(IS_USART_DATA(Data)); 
;;;549        
;;;550      /* Transmit Data */
;;;551      USARTx->DR = (Data & (uint16_t)0x01FF);
000206  8082              STRH     r2,[r0,#4]
;;;552    }
000208  4770              BX       lr
;;;553    
                          ENDP

                  USART_ReceiveData PROC
;;;559      */
;;;560    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
00020a  4601              MOV      r1,r0
;;;561    {
;;;562      /* Check the parameters */
;;;563      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;564      
;;;565      /* Receive Data */
;;;566      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
00020c  8888              LDRH     r0,[r1,#4]
00020e  f3c00008          UBFX     r0,r0,#0,#9
;;;567    }
000212  4770              BX       lr
;;;568    
                          ENDP

                  USART_SetAddress PROC
;;;610      */
;;;611    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000214  8a02              LDRH     r2,[r0,#0x10]
;;;612    {
;;;613      /* Check the parameters */
;;;614      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;615      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;616        
;;;617      /* Clear the USART address */
;;;618      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
000216  f64f73f0          MOV      r3,#0xfff0
00021a  401a              ANDS     r2,r2,r3
00021c  8202              STRH     r2,[r0,#0x10]
;;;619      /* Set the USART address node */
;;;620      USARTx->CR2 |= USART_Address;
00021e  8a02              LDRH     r2,[r0,#0x10]
000220  430a              ORRS     r2,r2,r1
000222  8202              STRH     r2,[r0,#0x10]
;;;621    }
000224  4770              BX       lr
;;;622    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;630      */
;;;631    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000226  b121              CBZ      r1,|L1.562|
;;;632    {
;;;633      /* Check the parameters */
;;;634      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;635      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;636      
;;;637      if (NewState != DISABLE)
;;;638      {
;;;639        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;640        USARTx->CR1 |= USART_CR1_RWU;
000228  8982              LDRH     r2,[r0,#0xc]
00022a  f0420202          ORR      r2,r2,#2
00022e  8182              STRH     r2,[r0,#0xc]
000230  e004              B        |L1.572|
                  |L1.562|
;;;641      }
;;;642      else
;;;643      {
;;;644        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;645        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
000232  8982              LDRH     r2,[r0,#0xc]
000234  f64f73fd          MOV      r3,#0xfffd
000238  401a              ANDS     r2,r2,r3
00023a  8182              STRH     r2,[r0,#0xc]
                  |L1.572|
;;;646      }
;;;647    }
00023c  4770              BX       lr
;;;648    /**
                          ENDP

                  USART_WakeUpConfig PROC
;;;657      */
;;;658    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
00023e  8982              LDRH     r2,[r0,#0xc]
;;;659    {
;;;660      /* Check the parameters */
;;;661      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;662      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;663      
;;;664      USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
000240  f24f73ff          MOV      r3,#0xf7ff
000244  401a              ANDS     r2,r2,r3
000246  8182              STRH     r2,[r0,#0xc]
;;;665      USARTx->CR1 |= USART_WakeUp;
000248  8982              LDRH     r2,[r0,#0xc]
00024a  430a              ORRS     r2,r2,r1
00024c  8182              STRH     r2,[r0,#0xc]
;;;666    }
00024e  4770              BX       lr
;;;667    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;726      */
;;;727    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000250  8a02              LDRH     r2,[r0,#0x10]
;;;728    {
;;;729      /* Check the parameters */
;;;730      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;731      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;732      
;;;733      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
000252  f64f73df          MOV      r3,#0xffdf
000256  401a              ANDS     r2,r2,r3
000258  8202              STRH     r2,[r0,#0x10]
;;;734      USARTx->CR2 |= USART_LINBreakDetectLength;  
00025a  8a02              LDRH     r2,[r0,#0x10]
00025c  430a              ORRS     r2,r2,r1
00025e  8202              STRH     r2,[r0,#0x10]
;;;735    }
000260  4770              BX       lr
;;;736    
                          ENDP

                  USART_LINCmd PROC
;;;744      */
;;;745    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000262  b121              CBZ      r1,|L1.622|
;;;746    {
;;;747      /* Check the parameters */
;;;748      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;749      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;750      
;;;751      if (NewState != DISABLE)
;;;752      {
;;;753        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;754        USARTx->CR2 |= USART_CR2_LINEN;
000264  8a02              LDRH     r2,[r0,#0x10]
000266  f4424280          ORR      r2,r2,#0x4000
00026a  8202              STRH     r2,[r0,#0x10]
00026c  e004              B        |L1.632|
                  |L1.622|
;;;755      }
;;;756      else
;;;757      {
;;;758        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;759        USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
00026e  8a02              LDRH     r2,[r0,#0x10]
000270  f64b73ff          MOV      r3,#0xbfff
000274  401a              ANDS     r2,r2,r3
000276  8202              STRH     r2,[r0,#0x10]
                  |L1.632|
;;;760      }
;;;761    }
000278  4770              BX       lr
;;;762    
                          ENDP

                  USART_SendBreak PROC
;;;768      */
;;;769    void USART_SendBreak(USART_TypeDef* USARTx)
00027a  8981              LDRH     r1,[r0,#0xc]
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;773      
;;;774      /* Send break characters */
;;;775      USARTx->CR1 |= USART_CR1_SBK;
00027c  f0410101          ORR      r1,r1,#1
000280  8181              STRH     r1,[r0,#0xc]
;;;776    }
000282  4770              BX       lr
;;;777    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;821      */
;;;822    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000284  b121              CBZ      r1,|L1.656|
;;;823    {
;;;824      /* Check the parameters */
;;;825      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;826      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;827      
;;;828      if (NewState != DISABLE)
;;;829      {
;;;830        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;831        USARTx->CR3 |= USART_CR3_HDSEL;
000286  8a82              LDRH     r2,[r0,#0x14]
000288  f0420208          ORR      r2,r2,#8
00028c  8282              STRH     r2,[r0,#0x14]
00028e  e004              B        |L1.666|
                  |L1.656|
;;;832      }
;;;833      else
;;;834      {
;;;835        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;836        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
000290  8a82              LDRH     r2,[r0,#0x14]
000292  f64f73f7          MOV      r3,#0xfff7
000296  401a              ANDS     r2,r2,r3
000298  8282              STRH     r2,[r0,#0x14]
                  |L1.666|
;;;837      }
;;;838    }
00029a  4770              BX       lr
;;;839    
                          ENDP

                  USART_SetGuardTime PROC
;;;906      */
;;;907    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
00029c  8b02              LDRH     r2,[r0,#0x18]
;;;908    {    
;;;909      /* Check the parameters */
;;;910      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;911      
;;;912      /* Clear the USART Guard time */
;;;913      USARTx->GTPR &= USART_GTPR_PSC;
00029e  b2d2              UXTB     r2,r2
0002a0  8302              STRH     r2,[r0,#0x18]
;;;914      /* Set the USART guard time */
;;;915      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
0002a2  8b02              LDRH     r2,[r0,#0x18]
0002a4  ea422201          ORR      r2,r2,r1,LSL #8
0002a8  8302              STRH     r2,[r0,#0x18]
;;;916    }
0002aa  4770              BX       lr
;;;917    
                          ENDP

                  USART_SmartCardCmd PROC
;;;925      */
;;;926    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002ac  b121              CBZ      r1,|L1.696|
;;;927    {
;;;928      /* Check the parameters */
;;;929      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;930      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;931      if (NewState != DISABLE)
;;;932      {
;;;933        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;934        USARTx->CR3 |= USART_CR3_SCEN;
0002ae  8a82              LDRH     r2,[r0,#0x14]
0002b0  f0420220          ORR      r2,r2,#0x20
0002b4  8282              STRH     r2,[r0,#0x14]
0002b6  e004              B        |L1.706|
                  |L1.696|
;;;935      }
;;;936      else
;;;937      {
;;;938        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;939        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
0002b8  8a82              LDRH     r2,[r0,#0x14]
0002ba  f64f73df          MOV      r3,#0xffdf
0002be  401a              ANDS     r2,r2,r3
0002c0  8282              STRH     r2,[r0,#0x14]
                  |L1.706|
;;;940      }
;;;941    }
0002c2  4770              BX       lr
;;;942    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;950      */
;;;951    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002c4  b121              CBZ      r1,|L1.720|
;;;952    {
;;;953      /* Check the parameters */
;;;954      assert_param(IS_USART_1236_PERIPH(USARTx)); 
;;;955      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;956      if (NewState != DISABLE)
;;;957      {
;;;958        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;959        USARTx->CR3 |= USART_CR3_NACK;
0002c6  8a82              LDRH     r2,[r0,#0x14]
0002c8  f0420210          ORR      r2,r2,#0x10
0002cc  8282              STRH     r2,[r0,#0x14]
0002ce  e004              B        |L1.730|
                  |L1.720|
;;;960      }
;;;961      else
;;;962      {
;;;963        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;964        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
0002d0  8a82              LDRH     r2,[r0,#0x14]
0002d2  f64f73ef          MOV      r3,#0xffef
0002d6  401a              ANDS     r2,r2,r3
0002d8  8282              STRH     r2,[r0,#0x14]
                  |L1.730|
;;;965      }
;;;966    }
0002da  4770              BX       lr
;;;967    
                          ENDP

                  USART_IrDAConfig PROC
;;;1021     */
;;;1022   void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
0002dc  8a82              LDRH     r2,[r0,#0x14]
;;;1023   {
;;;1024     /* Check the parameters */
;;;1025     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1026     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1027       
;;;1028     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
0002de  f64f73fb          MOV      r3,#0xfffb
0002e2  401a              ANDS     r2,r2,r3
0002e4  8282              STRH     r2,[r0,#0x14]
;;;1029     USARTx->CR3 |= USART_IrDAMode;
0002e6  8a82              LDRH     r2,[r0,#0x14]
0002e8  430a              ORRS     r2,r2,r1
0002ea  8282              STRH     r2,[r0,#0x14]
;;;1030   }
0002ec  4770              BX       lr
;;;1031   
                          ENDP

                  USART_IrDACmd PROC
;;;1039     */
;;;1040   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002ee  b121              CBZ      r1,|L1.762|
;;;1041   {
;;;1042     /* Check the parameters */
;;;1043     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1044     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1045       
;;;1046     if (NewState != DISABLE)
;;;1047     {
;;;1048       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1049       USARTx->CR3 |= USART_CR3_IREN;
0002f0  8a82              LDRH     r2,[r0,#0x14]
0002f2  f0420202          ORR      r2,r2,#2
0002f6  8282              STRH     r2,[r0,#0x14]
0002f8  e004              B        |L1.772|
                  |L1.762|
;;;1050     }
;;;1051     else
;;;1052     {
;;;1053       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1054       USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
0002fa  8a82              LDRH     r2,[r0,#0x14]
0002fc  f64f73fd          MOV      r3,#0xfffd
000300  401a              ANDS     r2,r2,r3
000302  8282              STRH     r2,[r0,#0x14]
                  |L1.772|
;;;1055     }
;;;1056   }
000304  4770              BX       lr
;;;1057   
                          ENDP

                  USART_DMACmd PROC
;;;1085     */
;;;1086   void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000306  b11a              CBZ      r2,|L1.784|
;;;1087   {
;;;1088     /* Check the parameters */
;;;1089     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1090     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1091     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1092   
;;;1093     if (NewState != DISABLE)
;;;1094     {
;;;1095       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1096          DMAR bits in the USART CR3 register */
;;;1097       USARTx->CR3 |= USART_DMAReq;
000308  8a83              LDRH     r3,[r0,#0x14]
00030a  430b              ORRS     r3,r3,r1
00030c  8283              STRH     r3,[r0,#0x14]
00030e  e002              B        |L1.790|
                  |L1.784|
;;;1098     }
;;;1099     else
;;;1100     {
;;;1101       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1102          DMAR bits in the USART CR3 register */
;;;1103       USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000310  8a83              LDRH     r3,[r0,#0x14]
000312  438b              BICS     r3,r3,r1
000314  8283              STRH     r3,[r0,#0x14]
                  |L1.790|
;;;1104     }
;;;1105   }
000316  4770              BX       lr
;;;1106   
                          ENDP

                  USART_ITConfig PROC
;;;1213     */
;;;1214   void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000318  b5f0              PUSH     {r4-r7,lr}
;;;1215   {
00031a  4603              MOV      r3,r0
;;;1216     uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
00031c  2400              MOVS     r4,#0
00031e  2600              MOVS     r6,#0
000320  2500              MOVS     r5,#0
;;;1217     uint32_t usartxbase = 0x00;
000322  2000              MOVS     r0,#0
;;;1218     /* Check the parameters */
;;;1219     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1220     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1221     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1222   
;;;1223     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1224     if (USART_IT == USART_IT_CTS)
000324  f640176a          MOV      r7,#0x96a
000328  42b9              CMP      r1,r7
00032a  d100              BNE      |L1.814|
;;;1225     {
;;;1226       assert_param(IS_USART_1236_PERIPH(USARTx));
00032c  bf00              NOP      
                  |L1.814|
;;;1227     } 
;;;1228       
;;;1229     usartxbase = (uint32_t)USARTx;
00032e  4618              MOV      r0,r3
;;;1230   
;;;1231     /* Get the USART register index */
;;;1232     usartreg = (((uint8_t)USART_IT) >> 0x05);
000330  f3c11442          UBFX     r4,r1,#5,#3
;;;1233   
;;;1234     /* Get the interrupt position */
;;;1235     itpos = USART_IT & IT_MASK;
000334  f001061f          AND      r6,r1,#0x1f
;;;1236     itmask = (((uint32_t)0x01) << itpos);
000338  2701              MOVS     r7,#1
00033a  fa07f506          LSL      r5,r7,r6
;;;1237       
;;;1238     if (usartreg == 0x01) /* The IT is in CR1 register */
00033e  2c01              CMP      r4,#1
000340  d101              BNE      |L1.838|
;;;1239     {
;;;1240       usartxbase += 0x0C;
000342  300c              ADDS     r0,r0,#0xc
000344  e004              B        |L1.848|
                  |L1.838|
;;;1241     }
;;;1242     else if (usartreg == 0x02) /* The IT is in CR2 register */
000346  2c02              CMP      r4,#2
000348  d101              BNE      |L1.846|
;;;1243     {
;;;1244       usartxbase += 0x10;
00034a  3010              ADDS     r0,r0,#0x10
00034c  e000              B        |L1.848|
                  |L1.846|
;;;1245     }
;;;1246     else /* The IT is in CR3 register */
;;;1247     {
;;;1248       usartxbase += 0x14; 
00034e  3014              ADDS     r0,r0,#0x14
                  |L1.848|
;;;1249     }
;;;1250     if (NewState != DISABLE)
000350  b11a              CBZ      r2,|L1.858|
;;;1251     {
;;;1252       *(__IO uint32_t*)usartxbase  |= itmask;
000352  6807              LDR      r7,[r0,#0]
000354  432f              ORRS     r7,r7,r5
000356  6007              STR      r7,[r0,#0]
000358  e002              B        |L1.864|
                  |L1.858|
;;;1253     }
;;;1254     else
;;;1255     {
;;;1256       *(__IO uint32_t*)usartxbase &= ~itmask;
00035a  6807              LDR      r7,[r0,#0]
00035c  43af              BICS     r7,r7,r5
00035e  6007              STR      r7,[r0,#0]
                  |L1.864|
;;;1257     }
;;;1258   }
000360  bdf0              POP      {r4-r7,pc}
;;;1259   
                          ENDP

                  USART_GetFlagStatus PROC
;;;1277     */
;;;1278   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000362  4602              MOV      r2,r0
;;;1279   {
;;;1280     FlagStatus bitstatus = RESET;
000364  2000              MOVS     r0,#0
;;;1281     /* Check the parameters */
;;;1282     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1283     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1284   
;;;1285     /* The CTS flag is not available for UART4 and UART5 */
;;;1286     if (USART_FLAG == USART_FLAG_CTS)
000366  f5b17f00          CMP      r1,#0x200
00036a  d100              BNE      |L1.878|
;;;1287     {
;;;1288       assert_param(IS_USART_1236_PERIPH(USARTx));
00036c  bf00              NOP      
                  |L1.878|
;;;1289     } 
;;;1290       
;;;1291     if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
00036e  8813              LDRH     r3,[r2,#0]
000370  400b              ANDS     r3,r3,r1
000372  b10b              CBZ      r3,|L1.888|
;;;1292     {
;;;1293       bitstatus = SET;
000374  2001              MOVS     r0,#1
000376  e000              B        |L1.890|
                  |L1.888|
;;;1294     }
;;;1295     else
;;;1296     {
;;;1297       bitstatus = RESET;
000378  2000              MOVS     r0,#0
                  |L1.890|
;;;1298     }
;;;1299     return bitstatus;
;;;1300   }
00037a  4770              BX       lr
;;;1301   
                          ENDP

                  USART_ClearFlag PROC
;;;1326     */
;;;1327   void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
00037c  f4017200          AND      r2,r1,#0x200
;;;1328   {
;;;1329     /* Check the parameters */
;;;1330     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1331     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1332   
;;;1333     /* The CTS flag is not available for UART4 and UART5 */
;;;1334     if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000380  f5b27f00          CMP      r2,#0x200
000384  d100              BNE      |L1.904|
;;;1335     {
;;;1336       assert_param(IS_USART_1236_PERIPH(USARTx));
000386  bf00              NOP      
                  |L1.904|
;;;1337     } 
;;;1338          
;;;1339     USARTx->SR = (uint16_t)~USART_FLAG;
000388  43ca              MVNS     r2,r1
00038a  8002              STRH     r2,[r0,#0]
;;;1340   }
00038c  4770              BX       lr
;;;1341   
                          ENDP

                  USART_GetITStatus PROC
;;;1360     */
;;;1361   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
00038e  b570              PUSH     {r4-r6,lr}
;;;1362   {
000390  4602              MOV      r2,r0
;;;1363     uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000392  2400              MOVS     r4,#0
000394  2300              MOVS     r3,#0
000396  2500              MOVS     r5,#0
;;;1364     ITStatus bitstatus = RESET;
000398  2000              MOVS     r0,#0
;;;1365     /* Check the parameters */
;;;1366     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1367     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1368   
;;;1369     /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;1370     if (USART_IT == USART_IT_CTS)
00039a  f640166a          MOV      r6,#0x96a
00039e  42b1              CMP      r1,r6
0003a0  d100              BNE      |L1.932|
;;;1371     {
;;;1372       assert_param(IS_USART_1236_PERIPH(USARTx));
0003a2  bf00              NOP      
                  |L1.932|
;;;1373     } 
;;;1374       
;;;1375     /* Get the USART register index */
;;;1376     usartreg = (((uint8_t)USART_IT) >> 0x05);
0003a4  f3c11542          UBFX     r5,r1,#5,#3
;;;1377     /* Get the interrupt position */
;;;1378     itmask = USART_IT & IT_MASK;
0003a8  f001031f          AND      r3,r1,#0x1f
;;;1379     itmask = (uint32_t)0x01 << itmask;
0003ac  2601              MOVS     r6,#1
0003ae  fa06f303          LSL      r3,r6,r3
;;;1380     
;;;1381     if (usartreg == 0x01) /* The IT  is in CR1 register */
0003b2  2d01              CMP      r5,#1
0003b4  d102              BNE      |L1.956|
;;;1382     {
;;;1383       itmask &= USARTx->CR1;
0003b6  8996              LDRH     r6,[r2,#0xc]
0003b8  4033              ANDS     r3,r3,r6
0003ba  e006              B        |L1.970|
                  |L1.956|
;;;1384     }
;;;1385     else if (usartreg == 0x02) /* The IT  is in CR2 register */
0003bc  2d02              CMP      r5,#2
0003be  d102              BNE      |L1.966|
;;;1386     {
;;;1387       itmask &= USARTx->CR2;
0003c0  8a16              LDRH     r6,[r2,#0x10]
0003c2  4033              ANDS     r3,r3,r6
0003c4  e001              B        |L1.970|
                  |L1.966|
;;;1388     }
;;;1389     else /* The IT  is in CR3 register */
;;;1390     {
;;;1391       itmask &= USARTx->CR3;
0003c6  8a96              LDRH     r6,[r2,#0x14]
0003c8  4033              ANDS     r3,r3,r6
                  |L1.970|
;;;1392     }
;;;1393     
;;;1394     bitpos = USART_IT >> 0x08;
0003ca  120c              ASRS     r4,r1,#8
;;;1395     bitpos = (uint32_t)0x01 << bitpos;
0003cc  2601              MOVS     r6,#1
0003ce  fa06f404          LSL      r4,r6,r4
;;;1396     bitpos &= USARTx->SR;
0003d2  8816              LDRH     r6,[r2,#0]
0003d4  4034              ANDS     r4,r4,r6
;;;1397     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
0003d6  b113              CBZ      r3,|L1.990|
0003d8  b10c              CBZ      r4,|L1.990|
;;;1398     {
;;;1399       bitstatus = SET;
0003da  2001              MOVS     r0,#1
0003dc  e000              B        |L1.992|
                  |L1.990|
;;;1400     }
;;;1401     else
;;;1402     {
;;;1403       bitstatus = RESET;
0003de  2000              MOVS     r0,#0
                  |L1.992|
;;;1404     }
;;;1405     
;;;1406     return bitstatus;  
;;;1407   }
0003e0  bd70              POP      {r4-r6,pc}
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      0x40011000
                  |L1.1000|
                          DCD      0x40004400
                  |L1.1004|
                          DCD      0x40004800
                  |L1.1008|
                          DCD      0x40004c00
                  |L1.1012|
                          DCD      0x40005000
                  |L1.1016|
                          DCD      0x40011400
                          ENDP

                  USART_ClearITPendingBit PROC
;;;1434     */
;;;1435   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
0003fc  b510              PUSH     {r4,lr}
;;;1436   {
;;;1437     uint16_t bitpos = 0x00, itmask = 0x00;
0003fe  2200              MOVS     r2,#0
000400  2300              MOVS     r3,#0
;;;1438     /* Check the parameters */
;;;1439     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1440     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1441   
;;;1442     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1443     if (USART_IT == USART_IT_CTS)
000402  f640146a          MOV      r4,#0x96a
000406  42a1              CMP      r1,r4
000408  d100              BNE      |L1.1036|
;;;1444     {
;;;1445       assert_param(IS_USART_1236_PERIPH(USARTx));
00040a  bf00              NOP      
                  |L1.1036|
;;;1446     } 
;;;1447       
;;;1448     bitpos = USART_IT >> 0x08;
00040c  120a              ASRS     r2,r1,#8
;;;1449     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
00040e  2401              MOVS     r4,#1
000410  4094              LSLS     r4,r4,r2
000412  b2a3              UXTH     r3,r4
;;;1450     USARTx->SR = (uint16_t)~itmask;
000414  43dc              MVNS     r4,r3
000416  8004              STRH     r4,[r0,#0]
;;;1451   }
000418  bd10              POP      {r4,pc}
;;;1452   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_usart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_usart_c_9565154b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REVSH|
#line 128
|__asm___17_stm32f4xx_usart_c_9565154b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
