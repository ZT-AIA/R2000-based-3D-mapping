; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\rt_event.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\rt_event.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\rt_event.crf ..\..\libraries\rtx-v4.73\SRC\rt_Event.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_evt_wait PROC
;;;50     
;;;51     OS_RESULT rt_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;52       /* Wait for one or more event flags with optional time-out.                */
;;;53       /* "wait_flags" identifies the flags to wait for.                          */
;;;54       /* "timeout" is the time-out limit in system ticks (0xffff if no time-out) */
;;;55       /* "and_wait" specifies the AND-ing of "wait_flags" as condition to be met */
;;;56       /* to complete the wait. (OR-ing if set to 0).                             */
;;;57       U32 block_state;
;;;58     
;;;59       if (and_wait) {
00000a  b18f              CBZ      r7,|L1.48|
;;;60         /* Check for AND-connected events */
;;;61         if ((os_tsk.run->events & wait_flags) == wait_flags) {
00000c  4858              LDR      r0,|L1.368|
00000e  6800              LDR      r0,[r0,#0]  ; os_tsk
000010  8b00              LDRH     r0,[r0,#0x18]
000012  4020              ANDS     r0,r0,r4
000014  42a0              CMP      r0,r4
000016  d109              BNE      |L1.44|
;;;62           os_tsk.run->events &= ~wait_flags;
000018  4855              LDR      r0,|L1.368|
00001a  6800              LDR      r0,[r0,#0]  ; os_tsk
00001c  8b00              LDRH     r0,[r0,#0x18]
00001e  43a0              BICS     r0,r0,r4
000020  4953              LDR      r1,|L1.368|
000022  6809              LDR      r1,[r1,#0]  ; os_tsk
000024  8308              STRH     r0,[r1,#0x18]
;;;63           return (OS_R_EVT);
000026  2002              MOVS     r0,#2
                  |L1.40|
;;;64         }
;;;65         block_state = WAIT_AND;
;;;66       }
;;;67       else {
;;;68         /* Check for OR-connected events */
;;;69         if (os_tsk.run->events & wait_flags) {
;;;70           os_tsk.run->waits = os_tsk.run->events & wait_flags;
;;;71           os_tsk.run->events &= ~wait_flags;
;;;72           return (OS_R_EVT);
;;;73         }
;;;74         block_state = WAIT_OR;
;;;75       }
;;;76       /* Task has to wait */
;;;77       os_tsk.run->waits = wait_flags;
;;;78       rt_block (timeout, (U8)block_state);
;;;79       return (OS_R_TMO);
;;;80     }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L1.44|
00002c  2506              MOVS     r5,#6                 ;65
00002e  e015              B        |L1.92|
                  |L1.48|
000030  484f              LDR      r0,|L1.368|
000032  6800              LDR      r0,[r0,#0]            ;69  ; os_tsk
000034  8b00              LDRH     r0,[r0,#0x18]         ;69
000036  4020              ANDS     r0,r0,r4              ;69
000038  b178              CBZ      r0,|L1.90|
00003a  484d              LDR      r0,|L1.368|
00003c  6800              LDR      r0,[r0,#0]            ;70  ; os_tsk
00003e  8b00              LDRH     r0,[r0,#0x18]         ;70
000040  4020              ANDS     r0,r0,r4              ;70
000042  494b              LDR      r1,|L1.368|
000044  6809              LDR      r1,[r1,#0]            ;70  ; os_tsk
000046  8348              STRH     r0,[r1,#0x1a]         ;70
000048  4849              LDR      r0,|L1.368|
00004a  6800              LDR      r0,[r0,#0]            ;71  ; os_tsk
00004c  8b00              LDRH     r0,[r0,#0x18]         ;71
00004e  43a0              BICS     r0,r0,r4              ;71
000050  4947              LDR      r1,|L1.368|
000052  6809              LDR      r1,[r1,#0]            ;71  ; os_tsk
000054  8308              STRH     r0,[r1,#0x18]         ;71
000056  2002              MOVS     r0,#2                 ;72
000058  e7e6              B        |L1.40|
                  |L1.90|
00005a  2505              MOVS     r5,#5                 ;74
                  |L1.92|
00005c  4844              LDR      r0,|L1.368|
00005e  6800              LDR      r0,[r0,#0]            ;77  ; os_tsk
000060  8344              STRH     r4,[r0,#0x1a]         ;77
000062  b2e9              UXTB     r1,r5                 ;78
000064  4630              MOV      r0,r6                 ;78
000066  f7fffffe          BL       rt_block
00006a  2001              MOVS     r0,#1                 ;79
00006c  e7dc              B        |L1.40|
;;;81     
                          ENDP

                  rt_evt_set PROC
;;;84     
;;;85     void rt_evt_set (U16 event_flags, OS_TID task_id) {
00006e  b570              PUSH     {r4-r6,lr}
000070  4605              MOV      r5,r0
000072  460e              MOV      r6,r1
;;;86       /* Set one or more event flags of a selectable task. */
;;;87       P_TCB p_tcb;
;;;88     
;;;89       p_tcb = os_active_TCB[task_id-1];
000074  1e70              SUBS     r0,r6,#1
000076  493f              LDR      r1,|L1.372|
000078  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;90       if (p_tcb == NULL) {
00007c  b904              CBNZ     r4,|L1.128|
                  |L1.126|
;;;91         return;
;;;92       }
;;;93       p_tcb->events |= event_flags;
;;;94       event_flags    = p_tcb->waits;
;;;95       /* If the task is not waiting for an event, it should not be put */
;;;96       /* to ready state. */
;;;97       if (p_tcb->state == WAIT_AND) {
;;;98         /* Check for AND-connected events */
;;;99         if ((p_tcb->events & event_flags) == event_flags) {
;;;100          goto wkup;
;;;101        }
;;;102      }
;;;103      if (p_tcb->state == WAIT_OR) {
;;;104        /* Check for OR-connected events */
;;;105        if (p_tcb->events & event_flags) {
;;;106          p_tcb->waits  &= p_tcb->events;
;;;107    wkup: p_tcb->events &= ~event_flags;
;;;108          rt_rmv_dly (p_tcb);
;;;109          p_tcb->state   = READY;
;;;110    #ifdef __CMSIS_RTOS
;;;111          rt_ret_val2(p_tcb, 0x08/*osEventSignal*/, p_tcb->waits); 
;;;112    #else
;;;113          rt_ret_val (p_tcb, OS_R_EVT);
;;;114    #endif
;;;115          rt_dispatch (p_tcb);
;;;116        }
;;;117      }
;;;118    }
00007e  bd70              POP      {r4-r6,pc}
                  |L1.128|
000080  8b20              LDRH     r0,[r4,#0x18]         ;93
000082  4328              ORRS     r0,r0,r5              ;93
000084  8320              STRH     r0,[r4,#0x18]         ;93
000086  8b65              LDRH     r5,[r4,#0x1a]         ;94
000088  7860              LDRB     r0,[r4,#1]            ;97
00008a  2806              CMP      r0,#6                 ;97
00008c  d104              BNE      |L1.152|
00008e  8b20              LDRH     r0,[r4,#0x18]         ;99
000090  4028              ANDS     r0,r0,r5              ;99
000092  42a8              CMP      r0,r5                 ;99
000094  d100              BNE      |L1.152|
000096  e00a              B        |L1.174|
                  |L1.152|
000098  7860              LDRB     r0,[r4,#1]            ;103
00009a  2805              CMP      r0,#5                 ;103
00009c  d117              BNE      |L1.206|
00009e  8b20              LDRH     r0,[r4,#0x18]         ;105
0000a0  4028              ANDS     r0,r0,r5              ;105
0000a2  b1a0              CBZ      r0,|L1.206|
0000a4  8b60              LDRH     r0,[r4,#0x1a]         ;106
0000a6  8b21              LDRH     r1,[r4,#0x18]         ;106
0000a8  4008              ANDS     r0,r0,r1              ;106
0000aa  8360              STRH     r0,[r4,#0x1a]         ;106
0000ac  bf00              NOP                            ;107
                  |L1.174|
0000ae  8b20              LDRH     r0,[r4,#0x18]         ;107
0000b0  43a8              BICS     r0,r0,r5              ;107
0000b2  8320              STRH     r0,[r4,#0x18]         ;107
0000b4  4620              MOV      r0,r4                 ;108
0000b6  f7fffffe          BL       rt_rmv_dly
0000ba  2001              MOVS     r0,#1                 ;109
0000bc  7060              STRB     r0,[r4,#1]            ;109
0000be  8b62              LDRH     r2,[r4,#0x1a]         ;111
0000c0  2108              MOVS     r1,#8                 ;111
0000c2  4620              MOV      r0,r4                 ;111
0000c4  f7fffffe          BL       rt_ret_val2
0000c8  4620              MOV      r0,r4                 ;115
0000ca  f7fffffe          BL       rt_dispatch
                  |L1.206|
0000ce  bf00              NOP      
0000d0  e7d5              B        |L1.126|
;;;119    
                          ENDP

                  rt_evt_clr PROC
;;;122    
;;;123    void rt_evt_clr (U16 clear_flags, OS_TID task_id) {
0000d2  b510              PUSH     {r4,lr}
0000d4  4602              MOV      r2,r0
;;;124      /* Clear one or more event flags (identified by "clear_flags") of a */
;;;125      /* selectable task (identified by "task"). */
;;;126      P_TCB task = os_active_TCB[task_id-1];
0000d6  1e4b              SUBS     r3,r1,#1
0000d8  4c26              LDR      r4,|L1.372|
0000da  f8540023          LDR      r0,[r4,r3,LSL #2]
;;;127    
;;;128      if (task == NULL) {
0000de  b900              CBNZ     r0,|L1.226|
                  |L1.224|
;;;129        return;
;;;130      }
;;;131      task->events &= ~clear_flags;
;;;132    }
0000e0  bd10              POP      {r4,pc}
                  |L1.226|
0000e2  8b03              LDRH     r3,[r0,#0x18]         ;131
0000e4  4393              BICS     r3,r3,r2              ;131
0000e6  8303              STRH     r3,[r0,#0x18]         ;131
0000e8  bf00              NOP      
0000ea  e7f9              B        |L1.224|
;;;133    
                          ENDP

                  isr_evt_set PROC
;;;136    
;;;137    void isr_evt_set (U16 event_flags, OS_TID task_id) {
0000ec  b570              PUSH     {r4-r6,lr}
0000ee  4604              MOV      r4,r0
0000f0  460e              MOV      r6,r1
;;;138      /* Same function as "os_evt_set", but to be called by ISRs. */
;;;139      P_TCB p_tcb = os_active_TCB[task_id-1];
0000f2  1e70              SUBS     r0,r6,#1
0000f4  491f              LDR      r1,|L1.372|
0000f6  f8515020          LDR      r5,[r1,r0,LSL #2]
;;;140    
;;;141      if (p_tcb == NULL) {
0000fa  b905              CBNZ     r5,|L1.254|
                  |L1.252|
;;;142        return;
;;;143      }
;;;144      rt_psq_enq (p_tcb, event_flags);
;;;145      rt_psh_req ();
;;;146    }
0000fc  bd70              POP      {r4-r6,pc}
                  |L1.254|
0000fe  4621              MOV      r1,r4                 ;144
000100  4628              MOV      r0,r5                 ;144
000102  f7fffffe          BL       rt_psq_enq
000106  f7fffffe          BL       rt_psh_req
00010a  bf00              NOP      
00010c  e7f6              B        |L1.252|
;;;147    
                          ENDP

                  rt_evt_get PROC
;;;150    
;;;151    U16 rt_evt_get (void) {
00010e  4818              LDR      r0,|L1.368|
;;;152      /* Get events of a running task after waiting for OR connected events. */
;;;153      return (os_tsk.run->waits);
000110  6800              LDR      r0,[r0,#0]  ; os_tsk
000112  8b40              LDRH     r0,[r0,#0x1a]
;;;154    }
000114  4770              BX       lr
;;;155    
                          ENDP

                  rt_evt_psh PROC
;;;158    
;;;159    void rt_evt_psh (P_TCB p_CB, U16 set_flags) {
000116  b570              PUSH     {r4-r6,lr}
000118  4604              MOV      r4,r0
00011a  460e              MOV      r6,r1
;;;160      /* Check if task has to be waken up */
;;;161      U16 event_flags;
;;;162    
;;;163      p_CB->events |= set_flags;
00011c  8b20              LDRH     r0,[r4,#0x18]
00011e  4330              ORRS     r0,r0,r6
000120  8320              STRH     r0,[r4,#0x18]
;;;164      event_flags = p_CB->waits;
000122  8b65              LDRH     r5,[r4,#0x1a]
;;;165      if (p_CB->state == WAIT_AND) {
000124  7860              LDRB     r0,[r4,#1]
000126  2806              CMP      r0,#6
000128  d104              BNE      |L1.308|
;;;166        /* Check for AND-connected events */
;;;167        if ((p_CB->events & event_flags) == event_flags) {
00012a  8b20              LDRH     r0,[r4,#0x18]
00012c  4028              ANDS     r0,r0,r5
00012e  42a8              CMP      r0,r5
000130  d100              BNE      |L1.308|
;;;168          goto rdy;
000132  e00a              B        |L1.330|
                  |L1.308|
;;;169        }
;;;170      }
;;;171      if (p_CB->state == WAIT_OR) {
000134  7860              LDRB     r0,[r4,#1]
000136  2805              CMP      r0,#5
000138  d118              BNE      |L1.364|
;;;172        /* Check for OR-connected events */
;;;173        if (p_CB->events & event_flags) {
00013a  8b20              LDRH     r0,[r4,#0x18]
00013c  4028              ANDS     r0,r0,r5
00013e  b1a8              CBZ      r0,|L1.364|
;;;174          p_CB->waits  &= p_CB->events;
000140  8b60              LDRH     r0,[r4,#0x1a]
000142  8b21              LDRH     r1,[r4,#0x18]
000144  4008              ANDS     r0,r0,r1
000146  8360              STRH     r0,[r4,#0x1a]
;;;175    rdy:  p_CB->events &= ~event_flags;
000148  bf00              NOP      
                  |L1.330|
00014a  8b20              LDRH     r0,[r4,#0x18]
00014c  43a8              BICS     r0,r0,r5
00014e  8320              STRH     r0,[r4,#0x18]
;;;176          rt_rmv_dly (p_CB);
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       rt_rmv_dly
;;;177          p_CB->state   = READY;
000156  2001              MOVS     r0,#1
000158  7060              STRB     r0,[r4,#1]
;;;178    #ifdef __CMSIS_RTOS
;;;179          rt_ret_val2(p_CB, 0x08/*osEventSignal*/, p_CB->waits); 
00015a  8b62              LDRH     r2,[r4,#0x1a]
00015c  2108              MOVS     r1,#8
00015e  4620              MOV      r0,r4
000160  f7fffffe          BL       rt_ret_val2
;;;180    #else
;;;181          rt_ret_val (p_CB, OS_R_EVT);
;;;182    #endif
;;;183          rt_put_prio (&os_rdy, p_CB);
000164  4621              MOV      r1,r4
000166  4804              LDR      r0,|L1.376|
000168  f7fffffe          BL       rt_put_prio
                  |L1.364|
;;;184        }
;;;185      }
;;;186    }
00016c  bd70              POP      {r4-r6,pc}
;;;187    
                          ENDP

00016e  0000              DCW      0x0000
                  |L1.368|
                          DCD      os_tsk
                  |L1.372|
                          DCD      os_active_TCB
                  |L1.376|
                          DCD      os_rdy
