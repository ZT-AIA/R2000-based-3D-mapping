; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\timestamp.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\timestamp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\timestamp.crf ..\src\timeStamp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  time_queue_trypost PROC
;;;41     //为了测试下面的时间同步的测试的方便性
;;;42     void time_queue_trypost(void)
000000  b510              PUSH     {r4,lr}
;;;43     {
;;;44     	sys_mbox_trypost(&rec_queue_time,NULL);
000002  2100              MOVS     r1,#0
000004  48fe              LDR      r0,|L1.1024|
000006  f7fffffe          BL       sys_mbox_trypost
;;;45     }
00000a  bd10              POP      {r4,pc}
;;;46     
                          ENDP

                  time_queue_fecth PROC
;;;47     void time_queue_fecth(void)
00000c  b510              PUSH     {r4,lr}
;;;48     {
;;;49     	sys_arch_mbox_fetch(&rec_queue_time,NULL,100);//等待一个延时的时间消息
00000e  2264              MOVS     r2,#0x64
000010  2100              MOVS     r1,#0
000012  48fb              LDR      r0,|L1.1024|
000014  f7fffffe          BL       sys_arch_mbox_fetch
;;;50     }
000018  bd10              POP      {r4,pc}
;;;51     
                          ENDP

                  set_timeoffset PROC
;;;53     //获取当前时间的函数将至写入timeoffset中
;;;54     void set_timeoffset(struct timeoffset *time)
00001a  b570              PUSH     {r4-r6,lr}
;;;55     {
00001c  4604              MOV      r4,r0
;;;56     	struct ptptime_t *ptptime = &(time->curtime);
00001e  4625              MOV      r5,r4
;;;57     	ETH_PTPTime_GetTime(ptptime);//获取当前的时间
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       ETH_PTPTime_GetTime
;;;58     	
;;;59     	time->to_sec = ptpClock.currentDS.offsetFromMaster.seconds;//偏移的秒数
000026  48f7              LDR      r0,|L1.1028|
000028  6980              LDR      r0,[r0,#0x18]
00002a  60e0              STR      r0,[r4,#0xc]
;;;60     	time->to_nsec = ptpClock.currentDS.offsetFromMaster.nanoseconds;//偏移的纳秒数
00002c  48f5              LDR      r0,|L1.1028|
00002e  69c0              LDR      r0,[r0,#0x1c]
000030  60a0              STR      r0,[r4,#8]
;;;61     }
000032  bd70              POP      {r4-r6,pc}
;;;62     
                          ENDP

                  datacollection_thread PROC
;;;63     //为了保持ptp的完整性，特意定义时间戳的采集线程
;;;64     void datacollection_thread(void *msg)
000034  2000              MOVS     r0,#0
;;;65     {
;;;66     	struct timeoffset *ts;
;;;67     	
;;;68     	#ifdef TICK_DELAY
;;;69     	uint32_t tick;
;;;70     	#endif
;;;71     	
;;;72     	TIME_TEST.head = TIME_TEST.tail = 0;
000036  49f4              LDR      r1,|L1.1032|
000038  f8810292          STRB     r0,[r1,#0x292]
00003c  f8810291          STRB     r0,[r1,#0x291]
;;;73     	TIME_TEST.index = 0;
000040  f8810290          STRB     r0,[r1,#0x290]
;;;74     	for(;;)
000044  bf00              NOP      
                  |L1.70|
;;;75     	{
;;;76     		#ifdef TICK_DELAY
;;;77     		tick = osKernelSysTick();
;;;78     		#endif
;;;79     		
;;;80     		if(dataflag==stopstate)
000046  48f1              LDR      r0,|L1.1036|
000048  7800              LDRB     r0,[r0,#0]  ; dataflag
00004a  b900              CBNZ     r0,|L1.78|
;;;81     			goto mmdelay;
00004c  e039              B        |L1.194|
                  |L1.78|
;;;82     		
;;;83     		if(((TIME_TEST.tail+1)&(TV_BUF_SIZE-1))!=TIME_TEST.tail)
00004e  48ee              LDR      r0,|L1.1032|
000050  f8900292          LDRB     r0,[r0,#0x292]  ; TIME_TEST
000054  1c40              ADDS     r0,r0,#1
000056  f0000003          AND      r0,r0,#3
00005a  49eb              LDR      r1,|L1.1032|
00005c  f8911292          LDRB     r1,[r1,#0x292]  ; TIME_TEST
000060  4288              CMP      r0,r1
000062  d02d              BEQ      |L1.192|
;;;84     		{
;;;85     			if(TIME_TEST.index==TV_TIMEOFFSET)
000064  48e8              LDR      r0,|L1.1032|
000066  f8900290          LDRB     r0,[r0,#0x290]  ; TIME_TEST
00006a  280a              CMP      r0,#0xa
00006c  d10f              BNE      |L1.142|
;;;86     			{
;;;87     				rt_tsk_lock();
00006e  f7fffffe          BL       rt_tsk_lock
;;;88     				TIME_TEST.index = 0;
000072  2000              MOVS     r0,#0
000074  49e4              LDR      r1,|L1.1032|
000076  f8810290          STRB     r0,[r1,#0x290]
;;;89     				TIME_TEST.tail = (TIME_TEST.tail+1)&(TV_BUF_SIZE-1);
00007a  4608              MOV      r0,r1
00007c  f8900292          LDRB     r0,[r0,#0x292]  ; TIME_TEST
000080  1c40              ADDS     r0,r0,#1
000082  f0000003          AND      r0,r0,#3
000086  f8810292          STRB     r0,[r1,#0x292]
;;;90     				rt_tsk_unlock();
00008a  f7fffffe          BL       rt_tsk_unlock
                  |L1.142|
;;;91     			}
;;;92     			//获取当前的时间
;;;93     			
;;;94     			ts = &(TIME_TEST.time[TIME_TEST.tail].offset[TIME_TEST.index++]);
00008e  48de              LDR      r0,|L1.1032|
000090  f8901290          LDRB     r1,[r0,#0x290]  ; TIME_TEST
000094  f8900290          LDRB     r0,[r0,#0x290]  ; TIME_TEST
000098  1c40              ADDS     r0,r0,#1
00009a  4adb              LDR      r2,|L1.1032|
00009c  f8820290          STRB     r0,[r2,#0x290]
0000a0  4610              MOV      r0,r2
0000a2  f8900292          LDRB     r0,[r0,#0x292]  ; TIME_TEST
0000a6  eb0002c0          ADD      r2,r0,r0,LSL #3
0000aa  eb021040          ADD      r0,r2,r0,LSL #5
0000ae  4ad6              LDR      r2,|L1.1032|
0000b0  eb020080          ADD      r0,r2,r0,LSL #2
0000b4  1d00              ADDS     r0,r0,#4
0000b6  eb001401          ADD      r4,r0,r1,LSL #4
;;;95     			set_timeoffset(ts);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       set_timeoffset
                  |L1.192|
;;;96     		}
;;;97     		
;;;98     		mmdelay:
0000c0  bf00              NOP      
                  |L1.194|
;;;99     		#ifdef TICK_DELAY
;;;100    		while(osKernelSysTick()-tick<= osKernelSysTickMicroSec(50*1000));
;;;101    		#else
;;;102    		sys_msleep(100);
0000c2  2064              MOVS     r0,#0x64
0000c4  f7fffffe          BL       osDelay
0000c8  e7bd              B        |L1.70|
;;;103    		#endif
;;;104    	}
;;;105    }
;;;106    
                          ENDP

                  timetest_callback PROC
;;;110        ip_addr_t *addr, u16_t port);*/
;;;111    void timetest_callback(void *arg,struct udp_pcb *pcb,struct pbuf *p,ip_addr_t *addr,u16_t port)
0000ca  e92d47f0          PUSH     {r4-r10,lr}
;;;112    {
0000ce  4605              MOV      r5,r0
0000d0  4689              MOV      r9,r1
0000d2  4616              MOV      r6,r2
0000d4  461f              MOV      r7,r3
0000d6  f8dd8020          LDR      r8,[sp,#0x20]
;;;113    	net_Path * netPath = (net_Path *) arg;
0000da  462c              MOV      r4,r5
;;;114    	
;;;115    	printf("timetest_callback call!\n");
0000dc  a0cc              ADR      r0,|L1.1040|
0000de  f7fffffe          BL       __2printf
;;;116    	
;;;117    	//将接收的pbuf数据存入缓冲队列
;;;118    	sys_mutex_lock(&(netPath->bufque_mutex));
0000e2  f1040028          ADD      r0,r4,#0x28
0000e6  f7fffffe          BL       sys_mutex_lock
;;;119    	//rt_tsk_lock();
;;;120    	if((netPath->tail+1)%PBUF_QUEUE_SIZE!=netPath->head)
0000ea  7861              LDRB     r1,[r4,#1]
0000ec  1c48              ADDS     r0,r1,#1
0000ee  17c1              ASRS     r1,r0,#31
0000f0  eb007191          ADD      r1,r0,r1,LSR #30
0000f4  1089              ASRS     r1,r1,#2
0000f6  eba00181          SUB      r1,r0,r1,LSL #2
0000fa  7822              LDRB     r2,[r4,#0]
0000fc  4291              CMP      r1,r2
0000fe  d00c              BEQ      |L1.282|
;;;121    	{
;;;122    		(netPath->bufque)[netPath->tail] = p;
000100  7861              LDRB     r1,[r4,#1]
000102  1d20              ADDS     r0,r4,#4
000104  f8406021          STR      r6,[r0,r1,LSL #2]
;;;123    		netPath->tail = (netPath->tail+1)&(PBUF_QUEUE_SIZE-1);
000108  7860              LDRB     r0,[r4,#1]
00010a  1c40              ADDS     r0,r0,#1
00010c  f0000003          AND      r0,r0,#3
000110  7060              STRB     r0,[r4,#1]
;;;124    		netPath->remoteip = *addr;//目的ip地址
000112  6838              LDR      r0,[r7,#0]
000114  6220              STR      r0,[r4,#0x20]
;;;125    		netPath->remoteport = port;//目的端口
000116  f8a48024          STRH     r8,[r4,#0x24]
                  |L1.282|
;;;126    	}
;;;127    	//rt_tsk_unlock();
;;;128    	sys_mutex_unlock(&(netPath->bufque_mutex));
00011a  f1040028          ADD      r0,r4,#0x28
00011e  f7fffffe          BL       sys_mutex_unlock
;;;129    	
;;;130    	sys_mbox_trypost(&rec_queue_time,NULL);//发送消息邮箱
000122  2100              MOVS     r1,#0
000124  48b6              LDR      r0,|L1.1024|
000126  f7fffffe          BL       sys_mbox_trypost
;;;131    }
00012a  e8bd87f0          POP      {r4-r10,pc}
;;;132    
                          ENDP

                  handletime PROC
;;;133    //处理接收到的报文
;;;134    void handletime(struct pbuf *p,net_Path *netpath)
00012e  b538              PUSH     {r3-r5,lr}
;;;135    {
000130  4605              MOV      r5,r0
000132  460c              MOV      r4,r1
;;;136    	struct msghead head;
;;;137    	pbuf_copy_partial(p,&head,sizeof(head),0);
000134  2300              MOVS     r3,#0
000136  2204              MOVS     r2,#4
000138  4669              MOV      r1,sp
00013a  4628              MOV      r0,r5
00013c  f7fffffe          BL       pbuf_copy_partial
;;;138    	
;;;139    	printf("head.msg_type:%d,head.msg_resp:%d\n",head.msg_type,head.msg_resp);
000140  f89d2003          LDRB     r2,[sp,#3]
000144  f89d1002          LDRB     r1,[sp,#2]
000148  a0b8              ADR      r0,|L1.1068|
00014a  f7fffffe          BL       __2printf
;;;140    	
;;;141    	switch(head.msg_type)
00014e  f89d0002          LDRB     r0,[sp,#2]
000152  2830              CMP      r0,#0x30
000154  d004              BEQ      |L1.352|
000156  283e              CMP      r0,#0x3e
000158  d003              BEQ      |L1.354|
00015a  283f              CMP      r0,#0x3f
00015c  d127              BNE      |L1.430|
00015e  e01d              B        |L1.412|
                  |L1.352|
;;;142    	{
;;;143    		case connectTest:
;;;144    		case hostRead:
000160  bf00              NOP      
                  |L1.354|
;;;145    			if(head.msg_type==hostRead)
000162  f89d0002          LDRB     r0,[sp,#2]
000166  283e              CMP      r0,#0x3e
000168  d108              BNE      |L1.380|
;;;146    			{
;;;147    				timestate.hostready = TOK;
00016a  2000              MOVS     r0,#0
00016c  49b8              LDR      r1,|L1.1104|
00016e  7008              STRB     r0,[r1,#0]
;;;148    				timestate.devreset = TERR;
000170  2001              MOVS     r0,#1
000172  7048              STRB     r0,[r1,#1]
;;;149    				dataflag = startstate;
000174  49a5              LDR      r1,|L1.1036|
000176  7008              STRB     r0,[r1,#0]
;;;150    				netpath->remote_trans_port = netpath->remoteport;
000178  8ca0              LDRH     r0,[r4,#0x24]
00017a  84e0              STRH     r0,[r4,#0x26]
                  |L1.380|
;;;151    			}
;;;152    			head.msg_resp = RESPOK;
00017c  20ff              MOVS     r0,#0xff
00017e  f88d0003          STRB     r0,[sp,#3]
;;;153    			pbuf_take(p,&head,sizeof(head));
000182  2204              MOVS     r2,#4
000184  4669              MOV      r1,sp
000186  4628              MOV      r0,r5
000188  f7fffffe          BL       pbuf_take
;;;154    			udp_sendto(netpath->udppcb,p,&(netpath->remoteip),netpath->remoteport);//应答报文
00018c  8ca3              LDRH     r3,[r4,#0x24]
00018e  f1040220          ADD      r2,r4,#0x20
000192  4629              MOV      r1,r5
000194  6960              LDR      r0,[r4,#0x14]
000196  f7fffffe          BL       udp_sendto
;;;155    			
;;;156    			break;
00019a  e009              B        |L1.432|
                  |L1.412|
;;;157    		case devReset:
;;;158    			timestate.devreset = TOK;
00019c  2000              MOVS     r0,#0
00019e  49ac              LDR      r1,|L1.1104|
0001a0  7048              STRB     r0,[r1,#1]
;;;159    			timestate.hostready = TERR;
0001a2  2001              MOVS     r0,#1
0001a4  7008              STRB     r0,[r1,#0]
;;;160    			dataflag = resetstate;
0001a6  2003              MOVS     r0,#3
0001a8  4998              LDR      r1,|L1.1036|
0001aa  7008              STRB     r0,[r1,#0]
;;;161    			break;
0001ac  e000              B        |L1.432|
                  |L1.430|
;;;162    		default:
;;;163    			break;
0001ae  bf00              NOP      
                  |L1.432|
0001b0  bf00              NOP                            ;156
;;;164    	}
;;;165    }
0001b2  bd38              POP      {r3-r5,pc}
;;;166    
                          ENDP

                  time_thread PROC
;;;168    //ptp时间测试的函数的创建为了处理接收到的数据，所以创建消息队列
;;;169    void time_thread(void *mag)
0001b4  e92d4ff0          PUSH     {r4-r11,lr}
;;;170    {
0001b8  b093              SUB      sp,sp,#0x4c
0001ba  4683              MOV      r11,r0
;;;171    	struct pbuf * p , *msgbuf,*last_pbuf,*msgpacket;
;;;172    	net_Path netPath;
;;;173    	uint8_t error;
;;;174    	static uint16_t msg_sn;
;;;175    	struct msghead * head;
;;;176    	struct msghead respreset;
;;;177    	
;;;178    	netPath.head = netPath.tail =0;
0001bc  2000              MOVS     r0,#0
0001be  f88d000d          STRB     r0,[sp,#0xd]
0001c2  f88d000c          STRB     r0,[sp,#0xc]
;;;179    	netPath.unicast.addr = 0x00000000;
0001c6  9009              STR      r0,[sp,#0x24]
;;;180    	netPath.port = TIME_TEST_PORT;
0001c8  f2427012          MOV      r0,#0x2712
0001cc  f8ad0028          STRH     r0,[sp,#0x28]
;;;181    	netPath.udppcb = udp_new();//创建udp控制块
0001d0  f7fffffe          BL       udp_new
0001d4  9008              STR      r0,[sp,#0x20]
;;;182    	
;;;183    	error=sys_mutex_new(&netPath.bufque_mutex);
0001d6  a80d              ADD      r0,sp,#0x34
0001d8  f7fffffe          BL       sys_mutex_new
0001dc  f00009ff          AND      r9,r0,#0xff
;;;184    	if(error)
0001e0  f1b90f00          CMP      r9,#0
0001e4  d005              BEQ      |L1.498|
;;;185    	{
;;;186    		printf("netPath.bufque_mutex create error.\n");
0001e6  a09b              ADR      r0,|L1.1108|
0001e8  f7fffffe          BL       __2printf
                  |L1.492|
;;;187    		return;
;;;188    	}
;;;189    	error=sys_mutex_new(&TIME_TEST.mutex);
;;;190    	if(error)
;;;191    	{
;;;192    		printf("TIME_TEST.mutex create error.\n");
;;;193    		return;
;;;194    	}
;;;195    	
;;;196    	timestate.devreset = TERR;
;;;197    	timestate.hostready = TERR;
;;;198    	
;;;199    	if(netPath.udppcb==NULL)
;;;200    	{
;;;201    		printf("time_thread alloc memp fail!\n");
;;;202    		return;
;;;203    	}
;;;204    	
;;;205    	//回调函数的注册
;;;206    	udp_recv(netPath.udppcb,timetest_callback,&netPath);
;;;207    	//端口绑定
;;;208    	udp_bind(netPath.udppcb,IP_ADDR_ANY,netPath.port);
;;;209    	
;;;210    	//创建pbuf变量用于发送存储的时间测试的量,从传输层开始分配数据
;;;211    	p = pbuf_alloc(PBUF_TRANSPORT,sizeof(struct msgtime),PBUF_ROM);
;;;212    	
;;;213    	sys_thread_new("datacollection_thread",datacollection_thread,NULL,DEFAULT_THREAD_STACKSIZE,osPriorityBelowNormal);
;;;214    	
;;;215    	for(;;)
;;;216    	{
;;;217    		while(netPath.head!=netPath.tail)//相关接收数据的处理
;;;218    		{
;;;219    			//rt_tsk_lock();
;;;220    			sys_mutex_lock(&(netPath.bufque_mutex));
;;;221    			msgbuf = netPath.bufque[netPath.head];
;;;222    			netPath.head = (netPath.head+1)%PBUF_QUEUE_SIZE;
;;;223    			sys_mutex_unlock(&(netPath.bufque_mutex));
;;;224    			//rt_tsk_unlock();
;;;225    			
;;;226    			//解析报文的头,并处理相关报文
;;;227    			handletime(msgbuf,&netPath);
;;;228    			
;;;229    			//释放接收到的报文
;;;230    			pbuf_free(msgbuf);
;;;231    		}
;;;232    		
;;;233    		if(timestate.hostready==TOK&&dataflag==startstate)
;;;234    		{
;;;235    			if(TIME_TEST.head!=TIME_TEST.tail)//此时发送的缓冲队列中的元素不为空
;;;236    			{
;;;237    				head = &(TIME_TEST.time[TIME_TEST.head].head);
;;;238    				head->msg_sn = msg_sn++;
;;;239    				head->msg_type = TIME_OFF;
;;;240    				head->msg_resp = first_middle_data;
;;;241    				p->payload = (int8_t *)&(TIME_TEST.time[TIME_TEST.head]);
;;;242    				udp_sendto(netPath.udppcb,p,&netPath.remoteip,netPath.remote_trans_port);
;;;243    				
;;;244    				//rt_tsk_lock();
;;;245    				sys_mutex_lock(&TIME_TEST.mutex);
;;;246    				TIME_TEST.head = (TIME_TEST.head+1)&(TV_BUF_SIZE-1);
;;;247    				sys_mutex_unlock(&TIME_TEST.mutex);
;;;248    				//rt_tsk_unlock();	
;;;249    			}
;;;250    		}
;;;251    		else if(timestate.devreset==TOK&&dataflag==resetstate)
;;;252    		{
;;;253    			while(TIME_TEST.head!=TIME_TEST.tail)
;;;254    			{
;;;255    				struct msghead * head = &(TIME_TEST.time[TIME_TEST.head].head);
;;;256    				head->msg_sn = msg_sn++;
;;;257    				head->msg_type = TIME_OFF;
;;;258    				head->msg_resp = first_middle_data;
;;;259    				p->payload = (int8_t *)&(TIME_TEST.time[TIME_TEST.head]);
;;;260    				udp_sendto(netPath.udppcb,p,&netPath.remoteip,netPath.remote_trans_port);
;;;261    				
;;;262    				//rt_tsk_lock();
;;;263    				sys_mutex_lock(&TIME_TEST.mutex);
;;;264    				TIME_TEST.head = (TIME_TEST.head+1)&(TV_BUF_SIZE-1);
;;;265    				sys_mutex_unlock(&TIME_TEST.mutex);
;;;266    				//rt_tsk_unlock();
;;;267    			}
;;;268    			//发送最后一个数据包
;;;269    			head = &(TIME_TEST.time[TIME_TEST.head].head);
;;;270    			head->msg_sn = msg_sn++;
;;;271    			head->msg_type = TIME_OFF;
;;;272    			head->msg_resp = last_data;
;;;273    			
;;;274    			last_pbuf = pbuf_alloc(PBUF_TRANSPORT,sizeof(struct msghead)+\
;;;275    				sizeof(struct timeoffset)*TIME_TEST.index,PBUF_POOL);
;;;276    			pbuf_take(last_pbuf,&(TIME_TEST.time[TIME_TEST.head]),\
;;;277    			sizeof(struct msghead)+sizeof(struct timeoffset)*TIME_TEST.index);
;;;278    			
;;;279    			udp_sendto(netPath.udppcb,last_pbuf,&(netPath.remoteip),netPath.remote_trans_port);
;;;280    			
;;;281    			pbuf_free(last_pbuf);
;;;282    			
;;;283    			TIME_TEST.index = 0;
;;;284    			TIME_TEST.head = TIME_TEST.tail=0;
;;;285    			timestate.hostready = TERR;
;;;286    			timestate.devreset = TERR;
;;;287    			//给上位机一个复位成功的响应
;;;288    			msgpacket = pbuf_alloc(PBUF_TRANSPORT,sizeof(struct msghead),PBUF_ROM);
;;;289    			respreset.msg_sn = msg_sn++;
;;;290    			respreset.msg_type = devReset;
;;;291    			respreset.msg_resp = RESPOK;
;;;292    			msgpacket->payload = &respreset;
;;;293    			udp_sendto(netPath.udppcb,msgpacket,&netPath.remoteip,netPath.remoteport);
;;;294    			pbuf_free(msgpacket);
;;;295    			dataflag = stopstate;
;;;296    		}
;;;297    		sys_arch_mbox_fetch(&rec_queue_time,NULL,100);
;;;298    	}
;;;299    }
0001ec  b013              ADD      sp,sp,#0x4c
0001ee  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.498|
0001f2  48a1              LDR      r0,|L1.1144|
0001f4  f7fffffe          BL       sys_mutex_new
0001f8  f00009ff          AND      r9,r0,#0xff           ;189
0001fc  f1b90f00          CMP      r9,#0                 ;190
000200  d003              BEQ      |L1.522|
000202  a09e              ADR      r0,|L1.1148|
000204  f7fffffe          BL       __2printf
000208  e7f0              B        |L1.492|
                  |L1.522|
00020a  2001              MOVS     r0,#1                 ;196
00020c  4990              LDR      r1,|L1.1104|
00020e  7048              STRB     r0,[r1,#1]            ;196
000210  7008              STRB     r0,[r1,#0]            ;197
000212  9808              LDR      r0,[sp,#0x20]         ;199
000214  b918              CBNZ     r0,|L1.542|
000216  a0a1              ADR      r0,|L1.1180|
000218  f7fffffe          BL       __2printf
00021c  e7e6              B        |L1.492|
                  |L1.542|
00021e  aa03              ADD      r2,sp,#0xc            ;206
000220  f2af1159          ADR      r1,timetest_callback + 1
000224  9808              LDR      r0,[sp,#0x20]         ;206
000226  f7fffffe          BL       udp_recv
00022a  f8bd2028          LDRH     r2,[sp,#0x28]         ;208
00022e  49a3              LDR      r1,|L1.1212|
000230  9808              LDR      r0,[sp,#0x20]         ;208
000232  f7fffffe          BL       udp_bind
000236  2201              MOVS     r2,#1                 ;211
000238  21a4              MOVS     r1,#0xa4              ;211
00023a  2000              MOVS     r0,#0                 ;211
00023c  f7fffffe          BL       pbuf_alloc
000240  4605              MOV      r5,r0                 ;211
000242  f04f30ff          MOV      r0,#0xffffffff        ;213
000246  f44f6380          MOV      r3,#0x400             ;213
00024a  2200              MOVS     r2,#0                 ;213
00024c  f2af211b          ADR      r1,datacollection_thread + 1
000250  9000              STR      r0,[sp,#0]            ;213
000252  a09b              ADR      r0,|L1.1216|
000254  f7fffffe          BL       sys_thread_new
000258  bf00              NOP                            ;215
                  |L1.602|
00025a  e01d              B        |L1.664|
                  |L1.604|
00025c  a80d              ADD      r0,sp,#0x34           ;220
00025e  f7fffffe          BL       sys_mutex_lock
000262  f89d100c          LDRB     r1,[sp,#0xc]          ;221
000266  a804              ADD      r0,sp,#0x10           ;221
000268  f8508021          LDR      r8,[r0,r1,LSL #2]     ;221
00026c  f89d100c          LDRB     r1,[sp,#0xc]          ;222
000270  1c48              ADDS     r0,r1,#1              ;222
000272  17c1              ASRS     r1,r0,#31             ;222
000274  eb007191          ADD      r1,r0,r1,LSR #30      ;222
000278  1089              ASRS     r1,r1,#2              ;222
00027a  eba00181          SUB      r1,r0,r1,LSL #2       ;222
00027e  b2c9              UXTB     r1,r1                 ;222
000280  f88d100c          STRB     r1,[sp,#0xc]          ;222
000284  a80d              ADD      r0,sp,#0x34           ;223
000286  f7fffffe          BL       sys_mutex_unlock
00028a  a903              ADD      r1,sp,#0xc            ;227
00028c  4640              MOV      r0,r8                 ;227
00028e  f7fffffe          BL       handletime
000292  4640              MOV      r0,r8                 ;230
000294  f7fffffe          BL       pbuf_free
                  |L1.664|
000298  f89d000c          LDRB     r0,[sp,#0xc]          ;217
00029c  f89d100d          LDRB     r1,[sp,#0xd]          ;217
0002a0  4288              CMP      r0,r1                 ;217
0002a2  d1db              BNE      |L1.604|
0002a4  486a              LDR      r0,|L1.1104|
0002a6  7800              LDRB     r0,[r0,#0]            ;233  ; timestate
0002a8  bbf0              CBNZ     r0,|L1.808|
0002aa  4858              LDR      r0,|L1.1036|
0002ac  7800              LDRB     r0,[r0,#0]            ;233  ; dataflag
0002ae  2801              CMP      r0,#1                 ;233
0002b0  d141              BNE      |L1.822|
0002b2  4855              LDR      r0,|L1.1032|
0002b4  f8900291          LDRB     r0,[r0,#0x291]        ;235  ; TIME_TEST
0002b8  4953              LDR      r1,|L1.1032|
0002ba  f8911292          LDRB     r1,[r1,#0x292]        ;235  ; TIME_TEST
0002be  4288              CMP      r0,r1                 ;235
0002c0  d038              BEQ      |L1.820|
0002c2  4851              LDR      r0,|L1.1032|
0002c4  f8900291          LDRB     r0,[r0,#0x291]        ;237  ; TIME_TEST
0002c8  eb0001c0          ADD      r1,r0,r0,LSL #3       ;237
0002cc  eb011040          ADD      r0,r1,r0,LSL #5       ;237
0002d0  494d              LDR      r1,|L1.1032|
0002d2  eb010480          ADD      r4,r1,r0,LSL #2       ;237
0002d6  4880              LDR      r0,|L1.1240|
0002d8  8800              LDRH     r0,[r0,#0]            ;238  ; msg_sn
0002da  8020              STRH     r0,[r4,#0]            ;238
0002dc  487e              LDR      r0,|L1.1240|
0002de  8800              LDRH     r0,[r0,#0]            ;238  ; msg_sn
0002e0  1c40              ADDS     r0,r0,#1              ;238
0002e2  497d              LDR      r1,|L1.1240|
0002e4  8008              STRH     r0,[r1,#0]            ;238
0002e6  2080              MOVS     r0,#0x80              ;239
0002e8  70a0              STRB     r0,[r4,#2]            ;239
0002ea  2001              MOVS     r0,#1                 ;240
0002ec  70e0              STRB     r0,[r4,#3]            ;240
0002ee  4846              LDR      r0,|L1.1032|
0002f0  f8900291          LDRB     r0,[r0,#0x291]        ;241  ; TIME_TEST
0002f4  eb0001c0          ADD      r1,r0,r0,LSL #3       ;241
0002f8  eb011040          ADD      r0,r1,r0,LSL #5       ;241
0002fc  4942              LDR      r1,|L1.1032|
0002fe  eb010080          ADD      r0,r1,r0,LSL #2       ;241
000302  6068              STR      r0,[r5,#4]            ;241
000304  f8bd3032          LDRH     r3,[sp,#0x32]         ;242
000308  aa0b              ADD      r2,sp,#0x2c           ;242
00030a  4629              MOV      r1,r5                 ;242
00030c  9808              LDR      r0,[sp,#0x20]         ;242
00030e  f7fffffe          BL       udp_sendto
000312  4859              LDR      r0,|L1.1144|
000314  f7fffffe          BL       sys_mutex_lock
000318  483b              LDR      r0,|L1.1032|
00031a  f8900291          LDRB     r0,[r0,#0x291]        ;246  ; TIME_TEST
00031e  1c40              ADDS     r0,r0,#1              ;246
000320  f0000003          AND      r0,r0,#3              ;246
000324  4938              LDR      r1,|L1.1032|
000326  e000              B        |L1.810|
                  |L1.808|
000328  e005              B        |L1.822|
                  |L1.810|
00032a  f8810291          STRB     r0,[r1,#0x291]        ;246
00032e  4852              LDR      r0,|L1.1144|
000330  f7fffffe          BL       sys_mutex_unlock
                  |L1.820|
000334  e123              B        |L1.1406|
                  |L1.822|
000336  4846              LDR      r0,|L1.1104|
000338  7840              LDRB     r0,[r0,#1]            ;251  ; timestate
00033a  2800              CMP      r0,#0                 ;251
00033c  d1fa              BNE      |L1.820|
00033e  4833              LDR      r0,|L1.1036|
000340  7800              LDRB     r0,[r0,#0]            ;251  ; dataflag
000342  2803              CMP      r0,#3                 ;251
000344  d1f6              BNE      |L1.820|
000346  e037              B        |L1.952|
                  |L1.840|
000348  482f              LDR      r0,|L1.1032|
00034a  f8900291          LDRB     r0,[r0,#0x291]        ;255  ; TIME_TEST
00034e  eb0001c0          ADD      r1,r0,r0,LSL #3       ;255
000352  eb011040          ADD      r0,r1,r0,LSL #5       ;255
000356  492c              LDR      r1,|L1.1032|
000358  eb010780          ADD      r7,r1,r0,LSL #2       ;255
00035c  485e              LDR      r0,|L1.1240|
00035e  8800              LDRH     r0,[r0,#0]            ;256  ; msg_sn
000360  8038              STRH     r0,[r7,#0]            ;256
000362  485d              LDR      r0,|L1.1240|
000364  8800              LDRH     r0,[r0,#0]            ;256  ; msg_sn
000366  1c40              ADDS     r0,r0,#1              ;256
000368  495b              LDR      r1,|L1.1240|
00036a  8008              STRH     r0,[r1,#0]            ;256
00036c  2080              MOVS     r0,#0x80              ;257
00036e  70b8              STRB     r0,[r7,#2]            ;257
000370  2001              MOVS     r0,#1                 ;258
000372  70f8              STRB     r0,[r7,#3]            ;258
000374  4824              LDR      r0,|L1.1032|
000376  f8900291          LDRB     r0,[r0,#0x291]        ;259  ; TIME_TEST
00037a  eb0001c0          ADD      r1,r0,r0,LSL #3       ;259
00037e  eb011040          ADD      r0,r1,r0,LSL #5       ;259
000382  4921              LDR      r1,|L1.1032|
000384  eb010080          ADD      r0,r1,r0,LSL #2       ;259
000388  6068              STR      r0,[r5,#4]            ;259
00038a  f8bd3032          LDRH     r3,[sp,#0x32]         ;260
00038e  aa0b              ADD      r2,sp,#0x2c           ;260
000390  4629              MOV      r1,r5                 ;260
000392  9808              LDR      r0,[sp,#0x20]         ;260
000394  f7fffffe          BL       udp_sendto
000398  4837              LDR      r0,|L1.1144|
00039a  f7fffffe          BL       sys_mutex_lock
00039e  481a              LDR      r0,|L1.1032|
0003a0  f8900291          LDRB     r0,[r0,#0x291]        ;264  ; TIME_TEST
0003a4  1c40              ADDS     r0,r0,#1              ;264
0003a6  f0000003          AND      r0,r0,#3              ;264
0003aa  4917              LDR      r1,|L1.1032|
0003ac  f8810291          STRB     r0,[r1,#0x291]        ;264
0003b0  4831              LDR      r0,|L1.1144|
0003b2  f7fffffe          BL       sys_mutex_unlock
0003b6  bf00              NOP                            ;267
                  |L1.952|
0003b8  4813              LDR      r0,|L1.1032|
0003ba  f8900291          LDRB     r0,[r0,#0x291]        ;253  ; TIME_TEST
0003be  4912              LDR      r1,|L1.1032|
0003c0  f8911292          LDRB     r1,[r1,#0x292]        ;253  ; TIME_TEST
0003c4  4288              CMP      r0,r1                 ;253
0003c6  d1bf              BNE      |L1.840|
0003c8  480f              LDR      r0,|L1.1032|
0003ca  f8900291          LDRB     r0,[r0,#0x291]        ;269  ; TIME_TEST
0003ce  eb0001c0          ADD      r1,r0,r0,LSL #3       ;269
0003d2  eb011040          ADD      r0,r1,r0,LSL #5       ;269
0003d6  490c              LDR      r1,|L1.1032|
0003d8  eb010480          ADD      r4,r1,r0,LSL #2       ;269
0003dc  483e              LDR      r0,|L1.1240|
0003de  8800              LDRH     r0,[r0,#0]            ;270  ; msg_sn
0003e0  8020              STRH     r0,[r4,#0]            ;270
0003e2  483d              LDR      r0,|L1.1240|
0003e4  8800              LDRH     r0,[r0,#0]            ;270  ; msg_sn
0003e6  1c40              ADDS     r0,r0,#1              ;270
0003e8  493b              LDR      r1,|L1.1240|
0003ea  8008              STRH     r0,[r1,#0]            ;270
0003ec  2080              MOVS     r0,#0x80              ;271
0003ee  70a0              STRB     r0,[r4,#2]            ;271
0003f0  2002              MOVS     r0,#2                 ;272
0003f2  70e0              STRB     r0,[r4,#3]            ;272
0003f4  4804              LDR      r0,|L1.1032|
0003f6  f8900290          LDRB     r0,[r0,#0x290]        ;274  ; TIME_TEST
0003fa  0100              LSLS     r0,r0,#4              ;274
0003fc  1d01              ADDS     r1,r0,#4              ;274
0003fe  e06d              B        |L1.1244|
                  |L1.1024|
                          DCD      rec_queue_time
                  |L1.1028|
                          DCD      ptpClock
                  |L1.1032|
                          DCD      TIME_TEST
                  |L1.1036|
                          DCD      dataflag
                  |L1.1040|
000410  74696d65          DCB      "timetest_callback call!\n",0
000414  74657374
000418  5f63616c
00041c  6c626163
000420  6b206361
000424  6c6c210a
000428  00      
000429  00                DCB      0
00042a  00                DCB      0
00042b  00                DCB      0
                  |L1.1068|
00042c  68656164          DCB      "head.msg_type:%d,head.msg_resp:%d\n",0
000430  2e6d7367
000434  5f747970
000438  653a2564
00043c  2c686561
000440  642e6d73
000444  675f7265
000448  73703a25
00044c  640a00  
00044f  00                DCB      0
                  |L1.1104|
                          DCD      timestate
                  |L1.1108|
000454  6e657450          DCB      "netPath.bufque_mutex create error.\n",0
000458  6174682e
00045c  62756671
000460  75655f6d
000464  75746578
000468  20637265
00046c  61746520
000470  6572726f
000474  722e0a00
                  |L1.1144|
                          DCD      TIME_TEST+0x294
                  |L1.1148|
00047c  54494d45          DCB      "TIME_TEST.mutex create error.\n",0
000480  5f544553
000484  542e6d75
000488  74657820
00048c  63726561
000490  74652065
000494  72726f72
000498  2e0a00  
00049b  00                DCB      0
                  |L1.1180|
00049c  74696d65          DCB      "time_thread alloc memp fail!\n",0
0004a0  5f746872
0004a4  65616420
0004a8  616c6c6f
0004ac  63206d65
0004b0  6d702066
0004b4  61696c21
0004b8  0a00    
0004ba  00                DCB      0
0004bb  00                DCB      0
                  |L1.1212|
                          DCD      ip_addr_any
                  |L1.1216|
0004c0  64617461          DCB      "datacollection_thread",0
0004c4  636f6c6c
0004c8  65637469
0004cc  6f6e5f74
0004d0  68726561
0004d4  6400    
0004d6  00                DCB      0
0004d7  00                DCB      0
                  |L1.1240|
                          DCD      msg_sn
                  |L1.1244|
0004dc  2203              MOVS     r2,#3                 ;274
0004de  2000              MOVS     r0,#0                 ;274
0004e0  f7fffffe          BL       pbuf_alloc
0004e4  4682              MOV      r10,r0                ;274
0004e6  4832              LDR      r0,|L1.1456|
0004e8  f8900290          LDRB     r0,[r0,#0x290]        ;276  ; TIME_TEST
0004ec  0100              LSLS     r0,r0,#4              ;276
0004ee  1d02              ADDS     r2,r0,#4              ;276
0004f0  482f              LDR      r0,|L1.1456|
0004f2  f8900291          LDRB     r0,[r0,#0x291]        ;276  ; TIME_TEST
0004f6  eb0003c0          ADD      r3,r0,r0,LSL #3       ;276
0004fa  eb031040          ADD      r0,r3,r0,LSL #5       ;276
0004fe  4b2c              LDR      r3,|L1.1456|
000500  eb030180          ADD      r1,r3,r0,LSL #2       ;276
000504  4650              MOV      r0,r10                ;276
000506  f7fffffe          BL       pbuf_take
00050a  f8bd3032          LDRH     r3,[sp,#0x32]         ;279
00050e  aa0b              ADD      r2,sp,#0x2c           ;279
000510  4651              MOV      r1,r10                ;279
000512  9808              LDR      r0,[sp,#0x20]         ;279
000514  f7fffffe          BL       udp_sendto
000518  4650              MOV      r0,r10                ;281
00051a  f7fffffe          BL       pbuf_free
00051e  2000              MOVS     r0,#0                 ;283
000520  4923              LDR      r1,|L1.1456|
000522  f8810290          STRB     r0,[r1,#0x290]        ;283
000526  f8810292          STRB     r0,[r1,#0x292]        ;284
00052a  f8810291          STRB     r0,[r1,#0x291]        ;284
00052e  2001              MOVS     r0,#1                 ;285
000530  4920              LDR      r1,|L1.1460|
000532  7008              STRB     r0,[r1,#0]            ;285
000534  7048              STRB     r0,[r1,#1]            ;286
000536  2201              MOVS     r2,#1                 ;288
000538  2104              MOVS     r1,#4                 ;288
00053a  2000              MOVS     r0,#0                 ;288
00053c  f7fffffe          BL       pbuf_alloc
000540  4606              MOV      r6,r0                 ;288
000542  481d              LDR      r0,|L1.1464|
000544  8800              LDRH     r0,[r0,#0]            ;289  ; msg_sn
000546  f8ad0008          STRH     r0,[sp,#8]            ;289
00054a  481b              LDR      r0,|L1.1464|
00054c  8800              LDRH     r0,[r0,#0]            ;289  ; msg_sn
00054e  1c40              ADDS     r0,r0,#1              ;289
000550  4919              LDR      r1,|L1.1464|
000552  8008              STRH     r0,[r1,#0]            ;289
000554  203f              MOVS     r0,#0x3f              ;290
000556  f88d000a          STRB     r0,[sp,#0xa]          ;290
00055a  20ff              MOVS     r0,#0xff              ;291
00055c  f88d000b          STRB     r0,[sp,#0xb]          ;291
000560  a802              ADD      r0,sp,#8              ;292
000562  6070              STR      r0,[r6,#4]            ;292
000564  f8bd3030          LDRH     r3,[sp,#0x30]         ;293
000568  aa0b              ADD      r2,sp,#0x2c           ;293
00056a  4631              MOV      r1,r6                 ;293
00056c  9808              LDR      r0,[sp,#0x20]         ;293
00056e  f7fffffe          BL       udp_sendto
000572  4630              MOV      r0,r6                 ;294
000574  f7fffffe          BL       pbuf_free
000578  2000              MOVS     r0,#0                 ;295
00057a  4910              LDR      r1,|L1.1468|
00057c  7008              STRB     r0,[r1,#0]            ;295
                  |L1.1406|
00057e  2264              MOVS     r2,#0x64              ;297
000580  2100              MOVS     r1,#0                 ;297
000582  480f              LDR      r0,|L1.1472|
000584  f7fffffe          BL       sys_arch_mbox_fetch
000588  e667              B        |L1.602|
;;;300    
                          ENDP

                  time_init PROC
;;;301    void time_init(void)
00058a  b508              PUSH     {r3,lr}
;;;302    {
;;;303    	if(sys_mbox_new(&rec_queue_time,8))
00058c  2108              MOVS     r1,#8
00058e  480c              LDR      r0,|L1.1472|
000590  f7fffffe          BL       sys_mbox_new
000594  b110              CBZ      r0,|L1.1436|
;;;304    	{
;;;305    		printf("create rec_queue_time fail!\n");
000596  a00b              ADR      r0,|L1.1476|
000598  f7fffffe          BL       __2printf
                  |L1.1436|
;;;306    	}
;;;307    	sys_thread_new("time_thread",time_thread,NULL,DEFAULT_THREAD_STACKSIZE*2,osPriorityAboveNormal);//创建线程
00059c  2001              MOVS     r0,#1
00059e  02c3              LSLS     r3,r0,#11
0005a0  2200              MOVS     r2,#0
0005a2  f2af31ef          ADR      r1,time_thread + 1
0005a6  9000              STR      r0,[sp,#0]
0005a8  a00e              ADR      r0,|L1.1508|
0005aa  f7fffffe          BL       sys_thread_new
;;;308    }
0005ae  bd08              POP      {r3,pc}
;;;309    
                          ENDP

                  |L1.1456|
                          DCD      TIME_TEST
                  |L1.1460|
                          DCD      timestate
                  |L1.1464|
                          DCD      msg_sn
                  |L1.1468|
                          DCD      dataflag
                  |L1.1472|
                          DCD      rec_queue_time
                  |L1.1476|
0005c4  63726561          DCB      "create rec_queue_time fail!\n",0
0005c8  74652072
0005cc  65635f71
0005d0  75657565
0005d4  5f74696d
0005d8  65206661
0005dc  696c210a
0005e0  00      
0005e1  00                DCB      0
0005e2  00                DCB      0
0005e3  00                DCB      0
                  |L1.1508|
0005e4  74696d65          DCB      "time_thread",0
0005e8  5f746872
0005ec  65616400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  TIME_TEST
                          %        684
                  rec_queue_time
                          %        92

                          AREA ||.data||, DATA, ALIGN=1

                  timestate
000000  0000              DCB      0x00,0x00
                  dataflag
000002  0000              DCB      0x00,0x00
                  msg_sn
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\timeStamp.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_timeStamp_c_dataflag____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_timeStamp_c_dataflag____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_timeStamp_c_dataflag____REVSH|
#line 128
|__asm___11_timeStamp_c_dataflag____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
