; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\api_lib.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\api_lib.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\api_lib.crf ..\..\libraries\lwip-1.4.1\src\api\api_lib.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  netconn_new_with_proto_and_callback PROC
;;;67     struct netconn*
;;;68     netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
000000  b5f0              PUSH     {r4-r7,lr}
;;;69     {
000002  b087              SUB      sp,sp,#0x1c
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;70       struct netconn *conn;
;;;71       struct api_msg msg;
;;;72     
;;;73       conn = netconn_alloc(t, callback);
00000a  4631              MOV      r1,r6
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       netconn_alloc
000012  4604              MOV      r4,r0
;;;74       if (conn != NULL) {
000014  b1fc              CBZ      r4,|L1.86|
;;;75         msg.function = do_newconn;
000016  48f8              LDR      r0,|L1.1016|
000018  9001              STR      r0,[sp,#4]
;;;76         msg.msg.msg.n.proto = proto;
00001a  f88d5010          STRB     r5,[sp,#0x10]
;;;77         msg.msg.conn = conn;
00001e  9402              STR      r4,[sp,#8]
;;;78         if (TCPIP_APIMSG(&msg) != ERR_OK) {
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       tcpip_apimsg
000026  b1b0              CBZ      r0,|L1.86|
;;;79           LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
000028  bf00              NOP      
00002a  bf00              NOP      
;;;80           LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;81           LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
000030  bf00              NOP      
000032  bf00              NOP      
;;;82     #if LWIP_TCP
;;;83           LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
000034  bf00              NOP      
000036  bf00              NOP      
;;;84     #endif /* LWIP_TCP */
;;;85           sys_sem_free(&conn->op_completed);
000038  f104000c          ADD      r0,r4,#0xc
00003c  f7fffffe          BL       sys_sem_free
;;;86           sys_mbox_free(&conn->recvmbox);
000040  f104001c          ADD      r0,r4,#0x1c
000044  f7fffffe          BL       sys_mbox_free
;;;87           memp_free(MEMP_NETCONN, conn);
000048  4621              MOV      r1,r4
00004a  2006              MOVS     r0,#6
00004c  f7fffffe          BL       memp_free
;;;88           return NULL;
000050  2000              MOVS     r0,#0
                  |L1.82|
;;;89         }
;;;90       }
;;;91       return conn;
;;;92     }
000052  b007              ADD      sp,sp,#0x1c
000054  bdf0              POP      {r4-r7,pc}
                  |L1.86|
000056  4620              MOV      r0,r4                 ;91
000058  e7fb              B        |L1.82|
;;;93     
                          ENDP

                  netconn_delete PROC
;;;102    err_t
;;;103    netconn_delete(struct netconn *conn)
00005a  b510              PUSH     {r4,lr}
;;;104    {
00005c  b086              SUB      sp,sp,#0x18
00005e  4604              MOV      r4,r0
;;;105      struct api_msg msg;
;;;106    
;;;107      /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
;;;108      if (conn == NULL) {
000060  b914              CBNZ     r4,|L1.104|
;;;109        return ERR_OK;
000062  2000              MOVS     r0,#0
                  |L1.100|
;;;110      }
;;;111    
;;;112      msg.function = do_delconn;
;;;113      msg.msg.conn = conn;
;;;114      tcpip_apimsg(&msg);
;;;115    
;;;116      netconn_free(conn);
;;;117    
;;;118      /* don't care for return value of do_delconn since it only calls void functions */
;;;119    
;;;120      return ERR_OK;
;;;121    }
000064  b006              ADD      sp,sp,#0x18
000066  bd10              POP      {r4,pc}
                  |L1.104|
000068  48e4              LDR      r0,|L1.1020|
00006a  9000              STR      r0,[sp,#0]            ;112
00006c  9401              STR      r4,[sp,#4]            ;113
00006e  4668              MOV      r0,sp                 ;114
000070  f7fffffe          BL       tcpip_apimsg
000074  4620              MOV      r0,r4                 ;116
000076  f7fffffe          BL       netconn_free
00007a  2000              MOVS     r0,#0                 ;120
00007c  e7f2              B        |L1.100|
;;;122    
                          ENDP

                  netconn_getaddr PROC
;;;134    err_t
;;;135    netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
00007e  e92d43f0          PUSH     {r4-r9,lr}
;;;136    {
000082  b087              SUB      sp,sp,#0x1c
000084  4604              MOV      r4,r0
000086  460d              MOV      r5,r1
000088  4616              MOV      r6,r2
00008a  4698              MOV      r8,r3
;;;137      struct api_msg msg;
;;;138      err_t err;
;;;139    
;;;140      LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
00008c  bf00              NOP      
00008e  b924              CBNZ     r4,|L1.154|
000090  f06f000d          MVN      r0,#0xd
                  |L1.148|
;;;141      LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
;;;142      LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
;;;143    
;;;144      msg.function = do_getaddr;
;;;145      msg.msg.conn = conn;
;;;146      msg.msg.msg.ad.ipaddr = addr;
;;;147      msg.msg.msg.ad.port = port;
;;;148      msg.msg.msg.ad.local = local;
;;;149      err = TCPIP_APIMSG(&msg);
;;;150    
;;;151      NETCONN_SET_SAFE_ERR(conn, err);
;;;152      return err;
;;;153    }
000094  b007              ADD      sp,sp,#0x1c
000096  e8bd83f0          POP      {r4-r9,pc}
                  |L1.154|
00009a  bf00              NOP                            ;140
00009c  bf00              NOP                            ;141
00009e  b915              CBNZ     r5,|L1.166|
0000a0  f06f000d          MVN      r0,#0xd               ;141
0000a4  e7f6              B        |L1.148|
                  |L1.166|
0000a6  bf00              NOP                            ;141
0000a8  bf00              NOP                            ;142
0000aa  b916              CBNZ     r6,|L1.178|
0000ac  f06f000d          MVN      r0,#0xd               ;142
0000b0  e7f0              B        |L1.148|
                  |L1.178|
0000b2  bf00              NOP                            ;142
0000b4  48d2              LDR      r0,|L1.1024|
0000b6  9001              STR      r0,[sp,#4]            ;144
0000b8  9402              STR      r4,[sp,#8]            ;145
0000ba  9504              STR      r5,[sp,#0x10]         ;146
0000bc  9605              STR      r6,[sp,#0x14]         ;147
0000be  f88d8018          STRB     r8,[sp,#0x18]         ;148
0000c2  a801              ADD      r0,sp,#4              ;149
0000c4  f7fffffe          BL       tcpip_apimsg
0000c8  4607              MOV      r7,r0                 ;149
0000ca  bf00              NOP                            ;151
0000cc  f7fffffe          BL       sys_arch_protect
0000d0  4681              MOV      r9,r0                 ;151
0000d2  f9940008          LDRSB    r0,[r4,#8]            ;151
0000d6  f1100f09          CMN      r0,#9                 ;151
0000da  db00              BLT      |L1.222|
0000dc  7227              STRB     r7,[r4,#8]            ;151
                  |L1.222|
0000de  4648              MOV      r0,r9                 ;151
0000e0  f7fffffe          BL       sys_arch_unprotect
0000e4  bf00              NOP                            ;151
0000e6  4638              MOV      r0,r7                 ;152
0000e8  e7d4              B        |L1.148|
;;;154    
                          ENDP

                  netconn_bind PROC
;;;165    err_t
;;;166    netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
0000ea  e92d41f0          PUSH     {r4-r8,lr}
;;;167    {
0000ee  b086              SUB      sp,sp,#0x18
0000f0  4604              MOV      r4,r0
0000f2  460e              MOV      r6,r1
0000f4  4617              MOV      r7,r2
;;;168      struct api_msg msg;
;;;169      err_t err;
;;;170    
;;;171      LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
0000f6  bf00              NOP      
0000f8  b924              CBNZ     r4,|L1.260|
0000fa  f06f000d          MVN      r0,#0xd
                  |L1.254|
;;;172    
;;;173      msg.function = do_bind;
;;;174      msg.msg.conn = conn;
;;;175      msg.msg.msg.bc.ipaddr = addr;
;;;176      msg.msg.msg.bc.port = port;
;;;177      err = TCPIP_APIMSG(&msg);
;;;178    
;;;179      NETCONN_SET_SAFE_ERR(conn, err);
;;;180      return err;
;;;181    }
0000fe  b006              ADD      sp,sp,#0x18
000100  e8bd81f0          POP      {r4-r8,pc}
                  |L1.260|
000104  bf00              NOP                            ;171
000106  48bf              LDR      r0,|L1.1028|
000108  9000              STR      r0,[sp,#0]            ;173
00010a  9401              STR      r4,[sp,#4]            ;174
00010c  9603              STR      r6,[sp,#0xc]          ;175
00010e  f8ad7010          STRH     r7,[sp,#0x10]         ;176
000112  4668              MOV      r0,sp                 ;177
000114  f7fffffe          BL       tcpip_apimsg
000118  4605              MOV      r5,r0                 ;177
00011a  bf00              NOP                            ;179
00011c  f7fffffe          BL       sys_arch_protect
000120  4680              MOV      r8,r0                 ;179
000122  f9940008          LDRSB    r0,[r4,#8]            ;179
000126  f1100f09          CMN      r0,#9                 ;179
00012a  db00              BLT      |L1.302|
00012c  7225              STRB     r5,[r4,#8]            ;179
                  |L1.302|
00012e  4640              MOV      r0,r8                 ;179
000130  f7fffffe          BL       sys_arch_unprotect
000134  bf00              NOP                            ;179
000136  4628              MOV      r0,r5                 ;180
000138  e7e1              B        |L1.254|
;;;182    
                          ENDP

                  netconn_connect PROC
;;;191    err_t
;;;192    netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
00013a  e92d41f0          PUSH     {r4-r8,lr}
;;;193    {
00013e  b086              SUB      sp,sp,#0x18
000140  4604              MOV      r4,r0
000142  460e              MOV      r6,r1
000144  4617              MOV      r7,r2
;;;194      struct api_msg msg;
;;;195      err_t err;
;;;196    
;;;197      LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
000146  bf00              NOP      
000148  b924              CBNZ     r4,|L1.340|
00014a  f06f000d          MVN      r0,#0xd
                  |L1.334|
;;;198    
;;;199      msg.function = do_connect;
;;;200      msg.msg.conn = conn;
;;;201      msg.msg.msg.bc.ipaddr = addr;
;;;202      msg.msg.msg.bc.port = port;
;;;203      /* This is the only function which need to not block tcpip_thread */
;;;204      err = tcpip_apimsg(&msg);
;;;205    
;;;206      NETCONN_SET_SAFE_ERR(conn, err);
;;;207      return err;
;;;208    }
00014e  b006              ADD      sp,sp,#0x18
000150  e8bd81f0          POP      {r4-r8,pc}
                  |L1.340|
000154  bf00              NOP                            ;197
000156  48ac              LDR      r0,|L1.1032|
000158  9000              STR      r0,[sp,#0]            ;199
00015a  9401              STR      r4,[sp,#4]            ;200
00015c  9603              STR      r6,[sp,#0xc]          ;201
00015e  f8ad7010          STRH     r7,[sp,#0x10]         ;202
000162  4668              MOV      r0,sp                 ;204
000164  f7fffffe          BL       tcpip_apimsg
000168  4605              MOV      r5,r0                 ;204
00016a  bf00              NOP                            ;206
00016c  f7fffffe          BL       sys_arch_protect
000170  4680              MOV      r8,r0                 ;206
000172  f9940008          LDRSB    r0,[r4,#8]            ;206
000176  f1100f09          CMN      r0,#9                 ;206
00017a  db00              BLT      |L1.382|
00017c  7225              STRB     r5,[r4,#8]            ;206
                  |L1.382|
00017e  4640              MOV      r0,r8                 ;206
000180  f7fffffe          BL       sys_arch_unprotect
000184  bf00              NOP                            ;206
000186  4628              MOV      r0,r5                 ;207
000188  e7e1              B        |L1.334|
;;;209    
                          ENDP

                  netconn_disconnect PROC
;;;216    err_t
;;;217    netconn_disconnect(struct netconn *conn)
00018a  b570              PUSH     {r4-r6,lr}
;;;218    {
00018c  b086              SUB      sp,sp,#0x18
00018e  4604              MOV      r4,r0
;;;219      struct api_msg msg;
;;;220      err_t err;
;;;221    
;;;222      LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
000190  bf00              NOP      
000192  b91c              CBNZ     r4,|L1.412|
000194  f06f000d          MVN      r0,#0xd
                  |L1.408|
;;;223    
;;;224      msg.function = do_disconnect;
;;;225      msg.msg.conn = conn;
;;;226      err = TCPIP_APIMSG(&msg);
;;;227    
;;;228      NETCONN_SET_SAFE_ERR(conn, err);
;;;229      return err;
;;;230    }
000198  b006              ADD      sp,sp,#0x18
00019a  bd70              POP      {r4-r6,pc}
                  |L1.412|
00019c  bf00              NOP                            ;222
00019e  489b              LDR      r0,|L1.1036|
0001a0  9000              STR      r0,[sp,#0]            ;224
0001a2  9401              STR      r4,[sp,#4]            ;225
0001a4  4668              MOV      r0,sp                 ;226
0001a6  f7fffffe          BL       tcpip_apimsg
0001aa  4605              MOV      r5,r0                 ;226
0001ac  bf00              NOP                            ;228
0001ae  f7fffffe          BL       sys_arch_protect
0001b2  4606              MOV      r6,r0                 ;228
0001b4  f9940008          LDRSB    r0,[r4,#8]            ;228
0001b8  f1100f09          CMN      r0,#9                 ;228
0001bc  db00              BLT      |L1.448|
0001be  7225              STRB     r5,[r4,#8]            ;228
                  |L1.448|
0001c0  4630              MOV      r0,r6                 ;228
0001c2  f7fffffe          BL       sys_arch_unprotect
0001c6  bf00              NOP                            ;228
0001c8  4628              MOV      r0,r5                 ;229
0001ca  e7e5              B        |L1.408|
;;;231    
                          ENDP

                  netconn_listen_with_backlog PROC
;;;240    err_t
;;;241    netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
0001cc  b5f0              PUSH     {r4-r7,lr}
;;;242    {
0001ce  b087              SUB      sp,sp,#0x1c
0001d0  4604              MOV      r4,r0
0001d2  460e              MOV      r6,r1
;;;243    #if LWIP_TCP
;;;244      struct api_msg msg;
;;;245      err_t err;
;;;246    
;;;247      /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
;;;248      LWIP_UNUSED_ARG(backlog);
;;;249    
;;;250      LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
0001d4  bf00              NOP      
0001d6  b91c              CBNZ     r4,|L1.480|
0001d8  f06f000d          MVN      r0,#0xd
                  |L1.476|
;;;251    
;;;252      msg.function = do_listen;
;;;253      msg.msg.conn = conn;
;;;254    #if TCP_LISTEN_BACKLOG
;;;255      msg.msg.msg.lb.backlog = backlog;
;;;256    #endif /* TCP_LISTEN_BACKLOG */
;;;257      err = TCPIP_APIMSG(&msg);
;;;258    
;;;259      NETCONN_SET_SAFE_ERR(conn, err);
;;;260      return err;
;;;261    #else /* LWIP_TCP */
;;;262      LWIP_UNUSED_ARG(conn);
;;;263      LWIP_UNUSED_ARG(backlog);
;;;264      return ERR_ARG;
;;;265    #endif /* LWIP_TCP */
;;;266    }
0001dc  b007              ADD      sp,sp,#0x1c
0001de  bdf0              POP      {r4-r7,pc}
                  |L1.480|
0001e0  bf00              NOP                            ;250
0001e2  488b              LDR      r0,|L1.1040|
0001e4  9001              STR      r0,[sp,#4]            ;252
0001e6  9402              STR      r4,[sp,#8]            ;253
0001e8  f88d6010          STRB     r6,[sp,#0x10]         ;255
0001ec  a801              ADD      r0,sp,#4              ;257
0001ee  f7fffffe          BL       tcpip_apimsg
0001f2  4605              MOV      r5,r0                 ;257
0001f4  bf00              NOP                            ;259
0001f6  f7fffffe          BL       sys_arch_protect
0001fa  4607              MOV      r7,r0                 ;259
0001fc  f9940008          LDRSB    r0,[r4,#8]            ;259
000200  f1100f09          CMN      r0,#9                 ;259
000204  db00              BLT      |L1.520|
000206  7225              STRB     r5,[r4,#8]            ;259
                  |L1.520|
000208  4638              MOV      r0,r7                 ;259
00020a  f7fffffe          BL       sys_arch_unprotect
00020e  bf00              NOP                            ;259
000210  4628              MOV      r0,r5                 ;260
000212  e7e3              B        |L1.476|
;;;267    
                          ENDP

                  netconn_accept PROC
;;;276    err_t
;;;277    netconn_accept(struct netconn *conn, struct netconn **new_conn)
000214  b5f0              PUSH     {r4-r7,lr}
;;;278    {
000216  b087              SUB      sp,sp,#0x1c
000218  4604              MOV      r4,r0
00021a  460d              MOV      r5,r1
;;;279    #if LWIP_TCP
;;;280      struct netconn *newconn;
;;;281      err_t err;
;;;282    #if TCP_LISTEN_BACKLOG
;;;283      struct api_msg msg;
;;;284    #endif /* TCP_LISTEN_BACKLOG */
;;;285    
;;;286      LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
00021c  bf00              NOP      
00021e  b91d              CBNZ     r5,|L1.552|
000220  f06f000d          MVN      r0,#0xd
                  |L1.548|
;;;287      *new_conn = NULL;
;;;288      LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
;;;289      LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
;;;290    
;;;291      err = conn->last_err;
;;;292      if (ERR_IS_FATAL(err)) {
;;;293        /* don't recv on fatal errors: this might block the application task
;;;294           waiting on acceptmbox forever! */
;;;295        return err;
;;;296      }
;;;297    
;;;298    #if LWIP_SO_RCVTIMEO
;;;299      if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
;;;300        NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
;;;301        return ERR_TIMEOUT;
;;;302      }
;;;303    #else
;;;304      sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
;;;305    #endif /* LWIP_SO_RCVTIMEO*/
;;;306      /* Register event with callback */
;;;307      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
;;;308    
;;;309      if (newconn == NULL) {
;;;310        /* connection has been aborted */
;;;311        NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
;;;312        return ERR_ABRT;
;;;313      }
;;;314    #if TCP_LISTEN_BACKLOG
;;;315      /* Let the stack know that we have accepted the connection. */
;;;316      msg.function = do_recv;
;;;317      msg.msg.conn = conn;
;;;318      /* don't care for the return value of do_recv */
;;;319      TCPIP_APIMSG(&msg);
;;;320    #endif /* TCP_LISTEN_BACKLOG */
;;;321    
;;;322      *new_conn = newconn;
;;;323      /* don't set conn->last_err: it's only ERR_OK, anyway */
;;;324      return ERR_OK;
;;;325    #else /* LWIP_TCP */
;;;326      LWIP_UNUSED_ARG(conn);
;;;327      LWIP_UNUSED_ARG(new_conn);
;;;328      return ERR_ARG;
;;;329    #endif /* LWIP_TCP */
;;;330    }
000224  b007              ADD      sp,sp,#0x1c
000226  bdf0              POP      {r4-r7,pc}
                  |L1.552|
000228  bf00              NOP                            ;286
00022a  2000              MOVS     r0,#0                 ;287
00022c  6028              STR      r0,[r5,#0]            ;287
00022e  bf00              NOP                            ;288
000230  b914              CBNZ     r4,|L1.568|
000232  f06f000d          MVN      r0,#0xd               ;288
000236  e7f5              B        |L1.548|
                  |L1.568|
000238  bf00              NOP                            ;288
00023a  bf00              NOP                            ;289
00023c  6fa0              LDR      r0,[r4,#0x78]         ;289
00023e  b108              CBZ      r0,|L1.580|
000240  2001              MOVS     r0,#1                 ;289
000242  e000              B        |L1.582|
                  |L1.580|
000244  2000              MOVS     r0,#0                 ;289
                  |L1.582|
000246  b910              CBNZ     r0,|L1.590|
000248  f06f000d          MVN      r0,#0xd               ;289
00024c  e7ea              B        |L1.548|
                  |L1.590|
00024e  bf00              NOP                            ;289
000250  f9946008          LDRSB    r6,[r4,#8]            ;291
000254  f1160f09          CMN      r6,#9                 ;292
000258  da01              BGE      |L1.606|
00025a  4630              MOV      r0,r6                 ;295
00025c  e7e2              B        |L1.548|
                  |L1.606|
00025e  2200              MOVS     r2,#0                 ;304
000260  a906              ADD      r1,sp,#0x18           ;304
000262  f1040078          ADD      r0,r4,#0x78           ;304
000266  f7fffffe          BL       sys_arch_mbox_fetch
00026a  f8d400e4          LDR      r0,[r4,#0xe4]         ;307
00026e  b128              CBZ      r0,|L1.636|
000270  2200              MOVS     r2,#0                 ;307
000272  2101              MOVS     r1,#1                 ;307
000274  4620              MOV      r0,r4                 ;307
000276  f8d430e4          LDR      r3,[r4,#0xe4]         ;307
00027a  4798              BLX      r3                    ;307
                  |L1.636|
00027c  9806              LDR      r0,[sp,#0x18]         ;309
00027e  b988              CBNZ     r0,|L1.676|
000280  bf00              NOP                            ;311
000282  f7fffffe          BL       sys_arch_protect
000286  4607              MOV      r7,r0                 ;311
000288  f9940008          LDRSB    r0,[r4,#8]            ;311
00028c  f1100f09          CMN      r0,#9                 ;311
000290  db01              BLT      |L1.662|
000292  20f6              MOVS     r0,#0xf6              ;311
000294  7220              STRB     r0,[r4,#8]            ;311
                  |L1.662|
000296  4638              MOV      r0,r7                 ;311
000298  f7fffffe          BL       sys_arch_unprotect
00029c  bf00              NOP                            ;311
00029e  f06f0009          MVN      r0,#9                 ;312
0002a2  e7bf              B        |L1.548|
                  |L1.676|
0002a4  485b              LDR      r0,|L1.1044|
0002a6  9000              STR      r0,[sp,#0]            ;316
0002a8  9401              STR      r4,[sp,#4]            ;317
0002aa  4668              MOV      r0,sp                 ;319
0002ac  f7fffffe          BL       tcpip_apimsg
0002b0  9806              LDR      r0,[sp,#0x18]         ;322
0002b2  6028              STR      r0,[r5,#0]            ;322
0002b4  2000              MOVS     r0,#0                 ;324
0002b6  e7b5              B        |L1.548|
;;;331    
                          ENDP

                  netconn_recv_data PROC
;;;341    static err_t
;;;342    netconn_recv_data(struct netconn *conn, void **new_buf)
0002b8  e92d41f0          PUSH     {r4-r8,lr}
;;;343    {
0002bc  b088              SUB      sp,sp,#0x20
0002be  4604              MOV      r4,r0
0002c0  460d              MOV      r5,r1
;;;344      void *buf = NULL;
0002c2  2000              MOVS     r0,#0
0002c4  9007              STR      r0,[sp,#0x1c]
;;;345      u16_t len;
;;;346      err_t err;
;;;347    #if LWIP_TCP
;;;348      struct api_msg msg;
;;;349    #endif /* LWIP_TCP */
;;;350    
;;;351      LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
0002c6  bf00              NOP      
0002c8  b925              CBNZ     r5,|L1.724|
0002ca  f06f000d          MVN      r0,#0xd
                  |L1.718|
;;;352      *new_buf = NULL;
;;;353      LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
;;;354      LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
;;;355    
;;;356      err = conn->last_err;
;;;357      if (ERR_IS_FATAL(err)) {
;;;358        /* don't recv on fatal errors: this might block the application task
;;;359           waiting on recvmbox forever! */
;;;360        /* @todo: this does not allow us to fetch data that has been put into recvmbox
;;;361           before the fatal error occurred - is that a problem? */
;;;362        return err;
;;;363      }
;;;364    
;;;365    #if LWIP_SO_RCVTIMEO
;;;366      if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
;;;367        NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
;;;368        return ERR_TIMEOUT;
;;;369      }
;;;370    #else
;;;371      sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
;;;372    #endif /* LWIP_SO_RCVTIMEO*/
;;;373    
;;;374    #if LWIP_TCP
;;;375    #if (LWIP_UDP || LWIP_RAW)
;;;376      if (conn->type == NETCONN_TCP)
;;;377    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;378      {
;;;379        if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
;;;380          /* Let the stack know that we have taken the data. */
;;;381          /* TODO: Speedup: Don't block and wait for the answer here
;;;382             (to prevent multiple thread-switches). */
;;;383          msg.function = do_recv;
;;;384          msg.msg.conn = conn;
;;;385          if (buf != NULL) {
;;;386            msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
;;;387          } else {
;;;388            msg.msg.msg.r.len = 1;
;;;389          }
;;;390          /* don't care for the return value of do_recv */
;;;391          TCPIP_APIMSG(&msg);
;;;392        }
;;;393    
;;;394        /* If we are closed, we indicate that we no longer wish to use the socket */
;;;395        if (buf == NULL) {
;;;396          API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
;;;397          /* Avoid to lose any previous error code */
;;;398          NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
;;;399          return ERR_CLSD;
;;;400        }
;;;401        len = ((struct pbuf *)buf)->tot_len;
;;;402      }
;;;403    #endif /* LWIP_TCP */
;;;404    #if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
;;;405      else
;;;406    #endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
;;;407    #if (LWIP_UDP || LWIP_RAW)
;;;408      {
;;;409        LWIP_ASSERT("buf != NULL", buf != NULL);
;;;410        len = netbuf_len((struct netbuf *)buf);
;;;411      }
;;;412    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;413    
;;;414    #if LWIP_SO_RCVBUF
;;;415      SYS_ARCH_DEC(conn->recv_avail, len);
;;;416    #endif /* LWIP_SO_RCVBUF */
;;;417      /* Register event with callback */
;;;418      API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
;;;419    
;;;420      LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));
;;;421    
;;;422      *new_buf = buf;
;;;423      /* don't set conn->last_err: it's only ERR_OK, anyway */
;;;424      return ERR_OK;
;;;425    }
0002ce  b008              ADD      sp,sp,#0x20
0002d0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.724|
0002d4  bf00              NOP                            ;351
0002d6  2000              MOVS     r0,#0                 ;352
0002d8  6028              STR      r0,[r5,#0]            ;352
0002da  bf00              NOP                            ;353
0002dc  b914              CBNZ     r4,|L1.740|
0002de  f06f000d          MVN      r0,#0xd               ;353
0002e2  e7f4              B        |L1.718|
                  |L1.740|
0002e4  bf00              NOP                            ;353
0002e6  bf00              NOP                            ;354
0002e8  69e0              LDR      r0,[r4,#0x1c]         ;354
0002ea  b108              CBZ      r0,|L1.752|
0002ec  2001              MOVS     r0,#1                 ;354
0002ee  e000              B        |L1.754|
                  |L1.752|
0002f0  2000              MOVS     r0,#0                 ;354
                  |L1.754|
0002f2  b910              CBNZ     r0,|L1.762|
0002f4  f06f000c          MVN      r0,#0xc               ;354
0002f8  e7e9              B        |L1.718|
                  |L1.762|
0002fa  bf00              NOP                            ;354
0002fc  f9947008          LDRSB    r7,[r4,#8]            ;356
000300  f1170f09          CMN      r7,#9                 ;357
000304  da01              BGE      |L1.778|
000306  4638              MOV      r0,r7                 ;362
000308  e7e1              B        |L1.718|
                  |L1.778|
00030a  2200              MOVS     r2,#0                 ;371
00030c  a907              ADD      r1,sp,#0x1c           ;371
00030e  f104001c          ADD      r0,r4,#0x1c           ;371
000312  f7fffffe          BL       sys_arch_mbox_fetch
000316  7820              LDRB     r0,[r4,#0]            ;376
000318  2810              CMP      r0,#0x10              ;376
00031a  d134              BNE      |L1.902|
00031c  f89400d8          LDRB     r0,[r4,#0xd8]         ;379
000320  f0000008          AND      r0,r0,#8              ;379
000324  b108              CBZ      r0,|L1.810|
000326  9807              LDR      r0,[sp,#0x1c]         ;379
000328  b968              CBNZ     r0,|L1.838|
                  |L1.810|
00032a  483a              LDR      r0,|L1.1044|
00032c  9001              STR      r0,[sp,#4]            ;383
00032e  9402              STR      r4,[sp,#8]            ;384
000330  9807              LDR      r0,[sp,#0x1c]         ;385
000332  b118              CBZ      r0,|L1.828|
000334  9807              LDR      r0,[sp,#0x1c]         ;386
000336  8901              LDRH     r1,[r0,#8]            ;386
000338  9104              STR      r1,[sp,#0x10]         ;386
00033a  e001              B        |L1.832|
                  |L1.828|
00033c  2101              MOVS     r1,#1                 ;388
00033e  9104              STR      r1,[sp,#0x10]         ;388
                  |L1.832|
000340  a801              ADD      r0,sp,#4              ;391
000342  f7fffffe          BL       tcpip_apimsg
                  |L1.838|
000346  9807              LDR      r0,[sp,#0x1c]         ;395
000348  b9d0              CBNZ     r0,|L1.896|
00034a  f8d400e4          LDR      r0,[r4,#0xe4]         ;396
00034e  b128              CBZ      r0,|L1.860|
000350  2200              MOVS     r2,#0                 ;396
000352  2101              MOVS     r1,#1                 ;396
000354  4620              MOV      r0,r4                 ;396
000356  f8d430e4          LDR      r3,[r4,#0xe4]         ;396
00035a  4798              BLX      r3                    ;396
                  |L1.860|
00035c  bf00              NOP                            ;398
00035e  f7fffffe          BL       sys_arch_protect
000362  4680              MOV      r8,r0                 ;398
000364  f9940008          LDRSB    r0,[r4,#8]            ;398
000368  f1100f09          CMN      r0,#9                 ;398
00036c  db01              BLT      |L1.882|
00036e  20f4              MOVS     r0,#0xf4              ;398
000370  7220              STRB     r0,[r4,#8]            ;398
                  |L1.882|
000372  4640              MOV      r0,r8                 ;398
000374  f7fffffe          BL       sys_arch_unprotect
000378  bf00              NOP                            ;398
00037a  f06f000b          MVN      r0,#0xb               ;399
00037e  e7a6              B        |L1.718|
                  |L1.896|
000380  9807              LDR      r0,[sp,#0x1c]         ;401
000382  8906              LDRH     r6,[r0,#8]            ;401
000384  e004              B        |L1.912|
                  |L1.902|
000386  bf00              NOP                            ;409
000388  bf00              NOP                            ;409
00038a  9807              LDR      r0,[sp,#0x1c]         ;410
00038c  6800              LDR      r0,[r0,#0]            ;410
00038e  8906              LDRH     r6,[r0,#8]            ;410
                  |L1.912|
000390  f8d400e4          LDR      r0,[r4,#0xe4]         ;418
000394  b128              CBZ      r0,|L1.930|
000396  4632              MOV      r2,r6                 ;418
000398  2101              MOVS     r1,#1                 ;418
00039a  4620              MOV      r0,r4                 ;418
00039c  f8d430e4          LDR      r3,[r4,#0xe4]         ;418
0003a0  4798              BLX      r3                    ;418
                  |L1.930|
0003a2  bf00              NOP                            ;420
0003a4  bf00              NOP                            ;420
0003a6  9807              LDR      r0,[sp,#0x1c]         ;422
0003a8  6028              STR      r0,[r5,#0]            ;422
0003aa  2000              MOVS     r0,#0                 ;424
0003ac  e78f              B        |L1.718|
;;;426    
                          ENDP

                  netconn_recv_tcp_pbuf PROC
;;;436    err_t
;;;437    netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
0003ae  b570              PUSH     {r4-r6,lr}
;;;438    {
0003b0  4604              MOV      r4,r0
0003b2  460d              MOV      r5,r1
;;;439      LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
0003b4  bf00              NOP      
0003b6  b114              CBZ      r4,|L1.958|
0003b8  7820              LDRB     r0,[r4,#0]
0003ba  2810              CMP      r0,#0x10
0003bc  d002              BEQ      |L1.964|
                  |L1.958|
0003be  f06f000d          MVN      r0,#0xd
                  |L1.962|
;;;440                 netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);
;;;441    
;;;442      return netconn_recv_data(conn, (void **)new_buf);
;;;443    }
0003c2  bd70              POP      {r4-r6,pc}
                  |L1.964|
0003c4  bf00              NOP                            ;439
0003c6  4629              MOV      r1,r5                 ;442
0003c8  4620              MOV      r0,r4                 ;442
0003ca  f7fffffe          BL       netconn_recv_data
0003ce  e7f8              B        |L1.962|
;;;444    
                          ENDP

                  netconn_recv PROC
;;;453    err_t
;;;454    netconn_recv(struct netconn *conn, struct netbuf **new_buf)
0003d0  e92d43f8          PUSH     {r3-r9,lr}
;;;455    {
0003d4  4605              MOV      r5,r0
0003d6  460e              MOV      r6,r1
;;;456    #if LWIP_TCP
;;;457      struct netbuf *buf = NULL;
0003d8  2400              MOVS     r4,#0
;;;458      err_t err;
;;;459    #endif /* LWIP_TCP */
;;;460    
;;;461      LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
0003da  bf00              NOP      
0003dc  b91e              CBNZ     r6,|L1.998|
0003de  f06f000d          MVN      r0,#0xd
                  |L1.994|
;;;462      *new_buf = NULL;
;;;463      LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
;;;464      LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
;;;465    
;;;466    #if LWIP_TCP
;;;467    #if (LWIP_UDP || LWIP_RAW)
;;;468      if (conn->type == NETCONN_TCP)
;;;469    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;470      {
;;;471        struct pbuf *p = NULL;
;;;472        /* This is not a listening netconn, since recvmbox is set */
;;;473    
;;;474        buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
;;;475        if (buf == NULL) {
;;;476          NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
;;;477          return ERR_MEM;
;;;478        }
;;;479    
;;;480        err = netconn_recv_data(conn, (void **)&p);
;;;481        if (err != ERR_OK) {
;;;482          memp_free(MEMP_NETBUF, buf);
;;;483          return err;
;;;484        }
;;;485        LWIP_ASSERT("p != NULL", p != NULL);
;;;486    
;;;487        buf->p = p;
;;;488        buf->ptr = p;
;;;489        buf->port = 0;
;;;490        ip_addr_set_any(&buf->addr);
;;;491        *new_buf = buf;
;;;492        /* don't set conn->last_err: it's only ERR_OK, anyway */
;;;493        return ERR_OK;
;;;494      }
;;;495    #endif /* LWIP_TCP */
;;;496    #if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
;;;497      else
;;;498    #endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
;;;499      {
;;;500    #if (LWIP_UDP || LWIP_RAW)
;;;501        return netconn_recv_data(conn, (void **)new_buf);
;;;502    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;503      }
;;;504    }
0003e2  e8bd83f8          POP      {r3-r9,pc}
                  |L1.998|
0003e6  bf00              NOP                            ;461
0003e8  2000              MOVS     r0,#0                 ;462
0003ea  6030              STR      r0,[r6,#0]            ;462
0003ec  bf00              NOP                            ;463
0003ee  b99d              CBNZ     r5,|L1.1048|
0003f0  f06f000d          MVN      r0,#0xd               ;463
0003f4  e7f5              B        |L1.994|
0003f6  0000              DCW      0x0000
                  |L1.1016|
                          DCD      do_newconn
                  |L1.1020|
                          DCD      do_delconn
                  |L1.1024|
                          DCD      do_getaddr
                  |L1.1028|
                          DCD      do_bind
                  |L1.1032|
                          DCD      do_connect
                  |L1.1036|
                          DCD      do_disconnect
                  |L1.1040|
                          DCD      do_listen
                  |L1.1044|
                          DCD      do_recv
                  |L1.1048|
000418  bf00              NOP                            ;463
00041a  bf00              NOP                            ;464
00041c  69e8              LDR      r0,[r5,#0x1c]         ;464
00041e  b108              CBZ      r0,|L1.1060|
000420  2001              MOVS     r0,#1                 ;464
000422  e000              B        |L1.1062|
                  |L1.1060|
000424  2000              MOVS     r0,#0                 ;464
                  |L1.1062|
000426  b910              CBNZ     r0,|L1.1070|
000428  f06f000c          MVN      r0,#0xc               ;464
00042c  e7d9              B        |L1.994|
                  |L1.1070|
00042e  bf00              NOP                            ;464
000430  7828              LDRB     r0,[r5,#0]            ;468
000432  2810              CMP      r0,#0x10              ;468
000434  d12f              BNE      |L1.1174|
000436  2000              MOVS     r0,#0                 ;471
000438  9000              STR      r0,[sp,#0]            ;471
00043a  2005              MOVS     r0,#5                 ;474
00043c  f7fffffe          BL       memp_malloc
000440  4604              MOV      r4,r0                 ;474
000442  b98c              CBNZ     r4,|L1.1128|
000444  bf00              NOP                            ;476
000446  f7fffffe          BL       sys_arch_protect
00044a  4680              MOV      r8,r0                 ;476
00044c  f9950008          LDRSB    r0,[r5,#8]            ;476
000450  f1100f09          CMN      r0,#9                 ;476
000454  db01              BLT      |L1.1114|
000456  20ff              MOVS     r0,#0xff              ;476
000458  7228              STRB     r0,[r5,#8]            ;476
                  |L1.1114|
00045a  4640              MOV      r0,r8                 ;476
00045c  f7fffffe          BL       sys_arch_unprotect
000460  bf00              NOP                            ;476
000462  f04f30ff          MOV      r0,#0xffffffff        ;477
000466  e7bc              B        |L1.994|
                  |L1.1128|
000468  4669              MOV      r1,sp                 ;480
00046a  4628              MOV      r0,r5                 ;480
00046c  f7fffffe          BL       netconn_recv_data
000470  4607              MOV      r7,r0                 ;480
000472  b12f              CBZ      r7,|L1.1152|
000474  4621              MOV      r1,r4                 ;482
000476  2005              MOVS     r0,#5                 ;482
000478  f7fffffe          BL       memp_free
00047c  4638              MOV      r0,r7                 ;483
00047e  e7b0              B        |L1.994|
                  |L1.1152|
000480  bf00              NOP                            ;485
000482  bf00              NOP                            ;485
000484  9800              LDR      r0,[sp,#0]            ;487
000486  6020              STR      r0,[r4,#0]            ;487
000488  9800              LDR      r0,[sp,#0]            ;488
00048a  6060              STR      r0,[r4,#4]            ;488
00048c  2000              MOVS     r0,#0                 ;489
00048e  81a0              STRH     r0,[r4,#0xc]          ;489
000490  60a0              STR      r0,[r4,#8]            ;490
000492  6034              STR      r4,[r6,#0]            ;491
000494  e7a5              B        |L1.994|
                  |L1.1174|
000496  4631              MOV      r1,r6                 ;501
000498  4628              MOV      r0,r5                 ;501
00049a  f7fffffe          BL       netconn_recv_data
00049e  e7a0              B        |L1.994|
;;;505    
                          ENDP

                  netconn_recved PROC
;;;516    void
;;;517    netconn_recved(struct netconn *conn, u32_t length)
0004a0  b530              PUSH     {r4,r5,lr}
;;;518    {
0004a2  b087              SUB      sp,sp,#0x1c
0004a4  4604              MOV      r4,r0
0004a6  460d              MOV      r5,r1
;;;519    #if LWIP_TCP
;;;520      if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
0004a8  b17c              CBZ      r4,|L1.1226|
0004aa  7820              LDRB     r0,[r4,#0]
0004ac  2810              CMP      r0,#0x10
0004ae  d10c              BNE      |L1.1226|
;;;521          (netconn_get_noautorecved(conn))) {
0004b0  f89400d8          LDRB     r0,[r4,#0xd8]
0004b4  f0000008          AND      r0,r0,#8
0004b8  b138              CBZ      r0,|L1.1226|
;;;522        struct api_msg msg;
;;;523        /* Let the stack know that we have taken the data. */
;;;524        /* TODO: Speedup: Don't block and wait for the answer here
;;;525           (to prevent multiple thread-switches). */
;;;526        msg.function = do_recv;
0004ba  487f              LDR      r0,|L1.1720|
0004bc  9001              STR      r0,[sp,#4]
;;;527        msg.msg.conn = conn;
0004be  9402              STR      r4,[sp,#8]
;;;528        msg.msg.msg.r.len = length;
0004c0  9504              STR      r5,[sp,#0x10]
;;;529        /* don't care for the return value of do_recv */
;;;530        TCPIP_APIMSG(&msg);
0004c2  a801              ADD      r0,sp,#4
0004c4  f7fffffe          BL       tcpip_apimsg
;;;531      }
0004c8  bf00              NOP      
                  |L1.1226|
;;;532    #else /* LWIP_TCP */
;;;533      LWIP_UNUSED_ARG(conn);
;;;534      LWIP_UNUSED_ARG(length);
;;;535    #endif /* LWIP_TCP */
;;;536    }
0004ca  b007              ADD      sp,sp,#0x1c
0004cc  bd30              POP      {r4,r5,pc}
;;;537    
                          ENDP

                  netconn_send PROC
;;;566    err_t
;;;567    netconn_send(struct netconn *conn, struct netbuf *buf)
0004ce  b5f0              PUSH     {r4-r7,lr}
;;;568    {
0004d0  b087              SUB      sp,sp,#0x1c
0004d2  4604              MOV      r4,r0
0004d4  460e              MOV      r6,r1
;;;569      struct api_msg msg;
;;;570      err_t err;
;;;571    
;;;572      LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
0004d6  bf00              NOP      
0004d8  b91c              CBNZ     r4,|L1.1250|
0004da  f06f000d          MVN      r0,#0xd
                  |L1.1246|
;;;573    
;;;574      LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
;;;575      msg.function = do_send;
;;;576      msg.msg.conn = conn;
;;;577      msg.msg.msg.b = buf;
;;;578      err = TCPIP_APIMSG(&msg);
;;;579    
;;;580      NETCONN_SET_SAFE_ERR(conn, err);
;;;581      return err;
;;;582    }
0004de  b007              ADD      sp,sp,#0x1c
0004e0  bdf0              POP      {r4-r7,pc}
                  |L1.1250|
0004e2  bf00              NOP                            ;572
0004e4  bf00              NOP                            ;574
0004e6  bf00              NOP                            ;574
0004e8  4874              LDR      r0,|L1.1724|
0004ea  9001              STR      r0,[sp,#4]            ;575
0004ec  9402              STR      r4,[sp,#8]            ;576
0004ee  9604              STR      r6,[sp,#0x10]         ;577
0004f0  a801              ADD      r0,sp,#4              ;578
0004f2  f7fffffe          BL       tcpip_apimsg
0004f6  4605              MOV      r5,r0                 ;578
0004f8  bf00              NOP                            ;580
0004fa  f7fffffe          BL       sys_arch_protect
0004fe  4607              MOV      r7,r0                 ;580
000500  f9940008          LDRSB    r0,[r4,#8]            ;580
000504  f1100f09          CMN      r0,#9                 ;580
000508  db00              BLT      |L1.1292|
00050a  7225              STRB     r5,[r4,#8]            ;580
                  |L1.1292|
00050c  4638              MOV      r0,r7                 ;580
00050e  f7fffffe          BL       sys_arch_unprotect
000512  bf00              NOP                            ;580
000514  4628              MOV      r0,r5                 ;581
000516  e7e2              B        |L1.1246|
;;;583    
                          ENDP

                  netconn_sendto PROC
;;;548    err_t
;;;549    netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
000518  e92d41f0          PUSH     {r4-r8,lr}
;;;550    {
00051c  4607              MOV      r7,r0
00051e  460c              MOV      r4,r1
000520  4615              MOV      r5,r2
000522  461e              MOV      r6,r3
;;;551      if (buf != NULL) {
000524  b15c              CBZ      r4,|L1.1342|
;;;552        ip_addr_set(&buf->addr, addr);
000526  b90d              CBNZ     r5,|L1.1324|
000528  2000              MOVS     r0,#0
00052a  e000              B        |L1.1326|
                  |L1.1324|
00052c  6828              LDR      r0,[r5,#0]
                  |L1.1326|
00052e  60a0              STR      r0,[r4,#8]
;;;553        buf->port = port;
000530  81a6              STRH     r6,[r4,#0xc]
;;;554        return netconn_send(conn, buf);
000532  4621              MOV      r1,r4
000534  4638              MOV      r0,r7
000536  f7fffffe          BL       netconn_send
                  |L1.1338|
;;;555      }
;;;556      return ERR_VAL;
;;;557    }
00053a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1342|
00053e  f06f0005          MVN      r0,#5                 ;556
000542  e7fa              B        |L1.1338|
;;;558    
                          ENDP

                  netconn_write_partly PROC
;;;597    err_t
;;;598    netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
000544  e92d4ff0          PUSH     {r4-r11,lr}
;;;599                         u8_t apiflags, size_t *bytes_written)
;;;600    {
000548  b087              SUB      sp,sp,#0x1c
00054a  4604              MOV      r4,r0
00054c  4689              MOV      r9,r1
00054e  4615              MOV      r5,r2
000550  4698              MOV      r8,r3
000552  9e10              LDR      r6,[sp,#0x40]
;;;601      struct api_msg msg;
;;;602      err_t err;
;;;603      u8_t dontblock;
;;;604    
;;;605      LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
000554  bf00              NOP      
000556  b924              CBNZ     r4,|L1.1378|
000558  f06f000d          MVN      r0,#0xd
                  |L1.1372|
;;;606      LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
;;;607      if (size == 0) {
;;;608        return ERR_OK;
;;;609      }
;;;610      dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
;;;611      if (dontblock && !bytes_written) {
;;;612        /* This implies netconn_write() cannot be used for non-blocking send, since
;;;613           it has no way to return the number of bytes written. */
;;;614        return ERR_VAL;
;;;615      }
;;;616    
;;;617      /* non-blocking write sends as much  */
;;;618      msg.function = do_write;
;;;619      msg.msg.conn = conn;
;;;620      msg.msg.msg.w.dataptr = dataptr;
;;;621      msg.msg.msg.w.apiflags = apiflags;
;;;622      msg.msg.msg.w.len = size;
;;;623    #if LWIP_SO_SNDTIMEO
;;;624      if (conn->send_timeout != 0) {
;;;625        /* get the time we started, which is later compared to
;;;626            sys_now() + conn->send_timeout */
;;;627        msg.msg.msg.w.time_started = sys_now();
;;;628      } else {
;;;629        msg.msg.msg.w.time_started = 0;
;;;630      }
;;;631    #endif /* LWIP_SO_SNDTIMEO */
;;;632    
;;;633      /* For locking the core: this _can_ be delayed on low memory/low send buffer,
;;;634         but if it is, this is done inside api_msg.c:do_write(), so we can use the
;;;635         non-blocking version here. */
;;;636      err = TCPIP_APIMSG(&msg);
;;;637      if ((err == ERR_OK) && (bytes_written != NULL)) {
;;;638        if (dontblock
;;;639    #if LWIP_SO_SNDTIMEO
;;;640            || (conn->send_timeout != 0)
;;;641    #endif /* LWIP_SO_SNDTIMEO */
;;;642           ) {
;;;643          /* nonblocking write: maybe the data has been sent partly */
;;;644          *bytes_written = msg.msg.msg.w.len;
;;;645        } else {
;;;646          /* blocking call succeeded: all data has been sent if it */
;;;647          *bytes_written = size;
;;;648        }
;;;649      }
;;;650    
;;;651      NETCONN_SET_SAFE_ERR(conn, err);
;;;652      return err;
;;;653    }
00055c  b007              ADD      sp,sp,#0x1c
00055e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1378|
000562  bf00              NOP                            ;605
000564  bf00              NOP                            ;606
000566  7820              LDRB     r0,[r4,#0]            ;606
000568  2810              CMP      r0,#0x10              ;606
00056a  d002              BEQ      |L1.1394|
00056c  f06f0005          MVN      r0,#5                 ;606
000570  e7f4              B        |L1.1372|
                  |L1.1394|
000572  bf00              NOP                            ;606
000574  b90d              CBNZ     r5,|L1.1402|
000576  2000              MOVS     r0,#0                 ;608
000578  e7f0              B        |L1.1372|
                  |L1.1402|
00057a  f89400d8          LDRB     r0,[r4,#0xd8]         ;610
00057e  f0000002          AND      r0,r0,#2              ;610
000582  b910              CBNZ     r0,|L1.1418|
000584  f0080004          AND      r0,r8,#4              ;610
000588  b108              CBZ      r0,|L1.1422|
                  |L1.1418|
00058a  2001              MOVS     r0,#1                 ;610
00058c  e000              B        |L1.1424|
                  |L1.1422|
00058e  2000              MOVS     r0,#0                 ;610
                  |L1.1424|
000590  4682              MOV      r10,r0                ;610
000592  f1ba0f00          CMP      r10,#0                ;611
000596  d003              BEQ      |L1.1440|
000598  b916              CBNZ     r6,|L1.1440|
00059a  f06f0005          MVN      r0,#5                 ;614
00059e  e7dd              B        |L1.1372|
                  |L1.1440|
0005a0  4847              LDR      r0,|L1.1728|
0005a2  9001              STR      r0,[sp,#4]            ;618
0005a4  9402              STR      r4,[sp,#8]            ;619
0005a6  f8cd9010          STR      r9,[sp,#0x10]         ;620
0005aa  f88d8018          STRB     r8,[sp,#0x18]         ;621
0005ae  9505              STR      r5,[sp,#0x14]         ;622
0005b0  a801              ADD      r0,sp,#4              ;636
0005b2  f7fffffe          BL       tcpip_apimsg
0005b6  4607              MOV      r7,r0                 ;636
0005b8  b93f              CBNZ     r7,|L1.1482|
0005ba  b136              CBZ      r6,|L1.1482|
0005bc  f1ba0f00          CMP      r10,#0                ;638
0005c0  d002              BEQ      |L1.1480|
0005c2  9805              LDR      r0,[sp,#0x14]         ;644
0005c4  6030              STR      r0,[r6,#0]            ;644
0005c6  e000              B        |L1.1482|
                  |L1.1480|
0005c8  6035              STR      r5,[r6,#0]            ;647
                  |L1.1482|
0005ca  bf00              NOP                            ;651
0005cc  f7fffffe          BL       sys_arch_protect
0005d0  4683              MOV      r11,r0                ;651
0005d2  f9940008          LDRSB    r0,[r4,#8]            ;651
0005d6  f1100f09          CMN      r0,#9                 ;651
0005da  db00              BLT      |L1.1502|
0005dc  7227              STRB     r7,[r4,#8]            ;651
                  |L1.1502|
0005de  4658              MOV      r0,r11                ;651
0005e0  f7fffffe          BL       sys_arch_unprotect
0005e4  bf00              NOP                            ;651
0005e6  4638              MOV      r0,r7                 ;652
0005e8  e7b8              B        |L1.1372|
;;;654    
                          ENDP

                  netconn_close_shutdown PROC
;;;662    static err_t
;;;663    netconn_close_shutdown(struct netconn *conn, u8_t how)
0005ea  b5f0              PUSH     {r4-r7,lr}
;;;664    {
0005ec  b087              SUB      sp,sp,#0x1c
0005ee  4604              MOV      r4,r0
0005f0  460e              MOV      r6,r1
;;;665      struct api_msg msg;
;;;666      err_t err;
;;;667    
;;;668      LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
0005f2  bf00              NOP      
0005f4  b91c              CBNZ     r4,|L1.1534|
0005f6  f06f000d          MVN      r0,#0xd
                  |L1.1530|
;;;669    
;;;670      msg.function = do_close;
;;;671      msg.msg.conn = conn;
;;;672      /* shutting down both ends is the same as closing */
;;;673      msg.msg.msg.sd.shut = how;
;;;674      /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
;;;675         don't use TCPIP_APIMSG here */
;;;676      err = tcpip_apimsg(&msg);
;;;677    
;;;678      NETCONN_SET_SAFE_ERR(conn, err);
;;;679      return err;
;;;680    }
0005fa  b007              ADD      sp,sp,#0x1c
0005fc  bdf0              POP      {r4-r7,pc}
                  |L1.1534|
0005fe  bf00              NOP                            ;668
000600  4830              LDR      r0,|L1.1732|
000602  9001              STR      r0,[sp,#4]            ;670
000604  9402              STR      r4,[sp,#8]            ;671
000606  f88d6010          STRB     r6,[sp,#0x10]         ;673
00060a  a801              ADD      r0,sp,#4              ;676
00060c  f7fffffe          BL       tcpip_apimsg
000610  4605              MOV      r5,r0                 ;676
000612  bf00              NOP                            ;678
000614  f7fffffe          BL       sys_arch_protect
000618  4607              MOV      r7,r0                 ;678
00061a  f9940008          LDRSB    r0,[r4,#8]            ;678
00061e  f1100f09          CMN      r0,#9                 ;678
000622  db00              BLT      |L1.1574|
000624  7225              STRB     r5,[r4,#8]            ;678
                  |L1.1574|
000626  4638              MOV      r0,r7                 ;678
000628  f7fffffe          BL       sys_arch_unprotect
00062c  bf00              NOP                            ;678
00062e  4628              MOV      r0,r5                 ;679
000630  e7e3              B        |L1.1530|
;;;681    
                          ENDP

                  netconn_close PROC
;;;688    err_t
;;;689    netconn_close(struct netconn *conn)
000632  b510              PUSH     {r4,lr}
;;;690    {
000634  4604              MOV      r4,r0
;;;691      /* shutting down both ends is the same as closing */
;;;692      return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
000636  2103              MOVS     r1,#3
000638  4620              MOV      r0,r4
00063a  f7fffffe          BL       netconn_close_shutdown
;;;693    }
00063e  bd10              POP      {r4,pc}
;;;694    
                          ENDP

                  netconn_shutdown PROC
;;;701    err_t
;;;702    netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
000640  b570              PUSH     {r4-r6,lr}
;;;703    {
000642  4606              MOV      r6,r0
000644  460c              MOV      r4,r1
000646  4615              MOV      r5,r2
;;;704      return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
000648  b10c              CBZ      r4,|L1.1614|
00064a  2001              MOVS     r0,#1
00064c  e000              B        |L1.1616|
                  |L1.1614|
00064e  2000              MOVS     r0,#0
                  |L1.1616|
000650  b10d              CBZ      r5,|L1.1622|
000652  2202              MOVS     r2,#2
000654  e000              B        |L1.1624|
                  |L1.1622|
000656  2200              MOVS     r2,#0
                  |L1.1624|
000658  ea400102          ORR      r1,r0,r2
00065c  4630              MOV      r0,r6
00065e  f7fffffe          BL       netconn_close_shutdown
;;;705    }
000662  bd70              POP      {r4-r6,pc}
;;;706    
                          ENDP

                  netconn_join_leave_group PROC
;;;718    err_t
;;;719    netconn_join_leave_group(struct netconn *conn,
000664  e92d43f0          PUSH     {r4-r9,lr}
;;;720                             ip_addr_t *multiaddr,
;;;721                             ip_addr_t *netif_addr,
;;;722                             enum netconn_igmp join_or_leave)
;;;723    {
000668  b087              SUB      sp,sp,#0x1c
00066a  4604              MOV      r4,r0
00066c  460e              MOV      r6,r1
00066e  4617              MOV      r7,r2
000670  4698              MOV      r8,r3
;;;724      struct api_msg msg;
;;;725      err_t err;
;;;726    
;;;727      LWIP_ERROR("netconn_join_leave_group: invalid conn",  (conn != NULL), return ERR_ARG;);
000672  bf00              NOP      
000674  b924              CBNZ     r4,|L1.1664|
000676  f06f000d          MVN      r0,#0xd
                  |L1.1658|
;;;728    
;;;729      msg.function = do_join_leave_group;
;;;730      msg.msg.conn = conn;
;;;731      msg.msg.msg.jl.multiaddr = multiaddr;
;;;732      msg.msg.msg.jl.netif_addr = netif_addr;
;;;733      msg.msg.msg.jl.join_or_leave = join_or_leave;
;;;734      err = TCPIP_APIMSG(&msg);
;;;735    
;;;736      NETCONN_SET_SAFE_ERR(conn, err);
;;;737      return err;
;;;738    }
00067a  b007              ADD      sp,sp,#0x1c
00067c  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1664|
000680  bf00              NOP                            ;727
000682  4811              LDR      r0,|L1.1736|
000684  9001              STR      r0,[sp,#4]            ;729
000686  9402              STR      r4,[sp,#8]            ;730
000688  9604              STR      r6,[sp,#0x10]         ;731
00068a  9705              STR      r7,[sp,#0x14]         ;732
00068c  f88d8018          STRB     r8,[sp,#0x18]         ;733
000690  a801              ADD      r0,sp,#4              ;734
000692  f7fffffe          BL       tcpip_apimsg
000696  4605              MOV      r5,r0                 ;734
000698  bf00              NOP                            ;736
00069a  f7fffffe          BL       sys_arch_protect
00069e  4681              MOV      r9,r0                 ;736
0006a0  f9940008          LDRSB    r0,[r4,#8]            ;736
0006a4  f1100f09          CMN      r0,#9                 ;736
0006a8  db00              BLT      |L1.1708|
0006aa  7225              STRB     r5,[r4,#8]            ;736
                  |L1.1708|
0006ac  4648              MOV      r0,r9                 ;736
0006ae  f7fffffe          BL       sys_arch_unprotect
0006b2  bf00              NOP                            ;736
0006b4  4628              MOV      r0,r5                 ;737
0006b6  e7e0              B        |L1.1658|
;;;739    #endif /* LWIP_IGMP */
                          ENDP

                  |L1.1720|
                          DCD      do_recv
                  |L1.1724|
                          DCD      do_send
                  |L1.1728|
                          DCD      do_write
                  |L1.1732|
                          DCD      do_close
                  |L1.1736|
                          DCD      do_join_leave_group
