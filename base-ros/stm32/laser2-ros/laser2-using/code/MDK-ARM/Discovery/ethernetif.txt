; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\ethernetif.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\ethernetif.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\ethernetif.crf ..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch\ethernetif.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETH_PTPSubSecond2NanoSecond PROC
;;;100    
;;;101    u32_t ETH_PTPSubSecond2NanoSecond(u32_t SubSecondValue)
000000  b530              PUSH     {r4,r5,lr}
;;;102    {
000002  4603              MOV      r3,r0
;;;103      uint64_t val = SubSecondValue * 1000000000ll;
000004  48fe              LDR      r0,|L1.1024|
000006  fba31000          UMULL    r1,r0,r3,r0
00000a  4602              MOV      r2,r0
;;;104      val >>=31;
00000c  0fc8              LSRS     r0,r1,#31
00000e  ea400142          ORR      r1,r0,r2,LSL #1
;;;105      return val;
000012  4608              MOV      r0,r1
;;;106    }
000014  bd30              POP      {r4,r5,pc}
;;;107    
                          ENDP

                  ETH_PTPNanoSecond2SubSecond PROC
;;;108    
;;;109    u32_t ETH_PTPNanoSecond2SubSecond(u32_t SubSecondValue)
000016  b570              PUSH     {r4-r6,lr}
;;;110    {
000018  4604              MOV      r4,r0
;;;111      uint64_t val = SubSecondValue * 0x80000000ll;
00001a  f04f4000          MOV      r0,#0x80000000
00001e  fba45000          UMULL    r5,r0,r4,r0
000022  4606              MOV      r6,r0
;;;112      val /= 1000000000;
000024  4af6              LDR      r2,|L1.1024|
000026  2300              MOVS     r3,#0
000028  4628              MOV      r0,r5
00002a  4631              MOV      r1,r6
00002c  f7fffffe          BL       __aeabi_uldivmod
000030  4605              MOV      r5,r0
;;;113      return val;
000032  4628              MOV      r0,r5
;;;114    }
000034  bd70              POP      {r4-r6,pc}
;;;115    
                          ENDP

                  ETH_PTPTime_GetTime PROC
;;;116    
;;;117    void ETH_PTPTime_GetTime(struct ptptime_t * timestamp)
000036  b570              PUSH     {r4-r6,lr}
;;;118    {
000038  4604              MOV      r4,r0
;;;119      timestamp->tv_nsec = ETH_PTPSubSecond2NanoSecond(ETH_GetPTPRegister(ETH_PTPTSLR));
00003a  f240700c          MOV      r0,#0x70c
00003e  f7fffffe          BL       ETH_GetPTPRegister
000042  4605              MOV      r5,r0
000044  f7fffffe          BL       ETH_PTPSubSecond2NanoSecond
000048  6060              STR      r0,[r4,#4]
;;;120      timestamp->tv_sec = ETH_GetPTPRegister(ETH_PTPTSHR);
00004a  f44f60e1          MOV      r0,#0x708
00004e  f7fffffe          BL       ETH_GetPTPRegister
000052  6020              STR      r0,[r4,#0]
;;;121    }
000054  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP

                  low_level_input PROC
;;;276     */
;;;277    static struct pbuf * low_level_input(struct netif *netif)
000056  e92d4ff0          PUSH     {r4-r11,lr}
;;;278    {
00005a  b087              SUB      sp,sp,#0x1c
;;;279      struct pbuf *p=NULL, *q;
00005c  2600              MOVS     r6,#0
;;;280      u16_t len;
;;;281      uint32_t i =0;
00005e  2000              MOVS     r0,#0
000060  9006              STR      r0,[sp,#0x18]
;;;282      FrameTypeDef frame;
;;;283      u8 *buffer;
;;;284      __IO ETH_DMADESCTypeDef *DMARxNextDesc;
;;;285    	uint32_t bufferoffset = 0;
000062  2400              MOVS     r4,#0
;;;286    	uint32_t payloadoffset = 0;
000064  4683              MOV      r11,r0
;;;287    	uint32_t byteslefttocopy = 0;
000066  4680              MOV      r8,r0
;;;288      
;;;289      
;;;290      /* Get received frame */
;;;291      frame = ETH_Get_Received_Frame_interrupt();
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       ETH_Get_Received_Frame_interrupt
00006e  e89d0007          LDM      sp,{r0-r2}
000072  ab03              ADD      r3,sp,#0xc
000074  c307              STM      r3!,{r0-r2}
;;;292      
;;;293      /* check that frame has no error */
;;;294      if ((frame.descriptor->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET)
000076  9805              LDR      r0,[sp,#0x14]
000078  6800              LDR      r0,[r0,#0]
00007a  f4004000          AND      r0,r0,#0x8000
00007e  2800              CMP      r0,#0
000080  d149              BNE      |L1.278|
;;;295      {
;;;296        
;;;297        /* Obtain the size of the packet and put it into the "len" variable. */
;;;298        len = frame.length;
000082  9803              LDR      r0,[sp,#0xc]
000084  fa1ff980          UXTH     r9,r0
;;;299        buffer = (u8 *)frame.buffer;
000088  f8dda010          LDR      r10,[sp,#0x10]
;;;300    
;;;301        /* We allocate a pbuf chain of pbufs from the pool. */
;;;302    		if(len>0)
00008c  f1b90f00          CMP      r9,#0
000090  dd05              BLE      |L1.158|
;;;303        {
;;;304    			p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
000092  2203              MOVS     r2,#3
000094  4649              MOV      r1,r9
000096  4610              MOV      r0,r2
000098  f7fffffe          BL       pbuf_alloc
00009c  4606              MOV      r6,r0
                  |L1.158|
;;;305    		}
;;;306     
;;;307        /* Copy received frame from ethernet driver buffer to stack buffer */
;;;308        if (p != NULL)
00009e  2e00              CMP      r6,#0
0000a0  d039              BEQ      |L1.278|
;;;309        { 
;;;310    			DMARxNextDesc = frame.descriptor;
0000a2  9f05              LDR      r7,[sp,#0x14]
;;;311    			bufferoffset = 0;
0000a4  2400              MOVS     r4,#0
;;;312    			for(q = p; q != NULL; q = q->next)
0000a6  4635              MOV      r5,r6
0000a8  e02b              B        |L1.258|
                  |L1.170|
;;;313    			{
;;;314    				byteslefttocopy = q->len;
0000aa  f8b5800a          LDRH     r8,[r5,#0xa]
;;;315    				payloadoffset = 0;
0000ae  f04f0b00          MOV      r11,#0
;;;316    
;;;317    				/* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
;;;318    				while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
0000b2  e016              B        |L1.226|
                  |L1.180|
;;;319    				{
;;;320    					/* Copy data to pbuf*/
;;;321    					memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
0000b4  f24053f4          MOV      r3,#0x5f4
0000b8  1b1a              SUBS     r2,r3,r4
0000ba  eb0a0104          ADD      r1,r10,r4
0000be  686b              LDR      r3,[r5,#4]
0000c0  eb03000b          ADD      r0,r3,r11
0000c4  f7fffffe          BL       __aeabi_memcpy
;;;322    
;;;323    					/* Point to next descriptor */
;;;324    					DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
0000c8  68ff              LDR      r7,[r7,#0xc]
;;;325    					buffer = (unsigned char *)(DMARxNextDesc->Buffer1Addr);
0000ca  f8d7a008          LDR      r10,[r7,#8]
;;;326    
;;;327    					byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
0000ce  f24050f4          MOV      r0,#0x5f4
0000d2  1b00              SUBS     r0,r0,r4
0000d4  eba80800          SUB      r8,r8,r0
;;;328    					payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
0000d8  f24050f4          MOV      r0,#0x5f4
0000dc  1b00              SUBS     r0,r0,r4
0000de  4483              ADD      r11,r11,r0
;;;329    					bufferoffset = 0;
0000e0  2400              MOVS     r4,#0
                  |L1.226|
0000e2  eb080004          ADD      r0,r8,r4              ;318
0000e6  f24051f4          MOV      r1,#0x5f4             ;318
0000ea  4288              CMP      r0,r1                 ;318
0000ec  d8e2              BHI      |L1.180|
;;;330    				}
;;;331    
;;;332    				/* Copy remaining data in pbuf */
;;;333    				memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), byteslefttocopy);
0000ee  eb0a0104          ADD      r1,r10,r4
0000f2  686a              LDR      r2,[r5,#4]
0000f4  eb02000b          ADD      r0,r2,r11
0000f8  4642              MOV      r2,r8
0000fa  f7fffffe          BL       __aeabi_memcpy
;;;334    				bufferoffset = bufferoffset + byteslefttocopy;
0000fe  4444              ADD      r4,r4,r8
000100  682d              LDR      r5,[r5,#0]            ;312
                  |L1.258|
000102  2d00              CMP      r5,#0                 ;312
000104  d1d1              BNE      |L1.170|
;;;335    			}
;;;336    
;;;337    #if LWIP_PTP
;;;338    			{
;;;339    				p->time_sec = frame.descriptor->TimeStampHigh;
000106  9805              LDR      r0,[sp,#0x14]
000108  69c0              LDR      r0,[r0,#0x1c]
00010a  6130              STR      r0,[r6,#0x10]
;;;340    				p->time_nsec = ETH_PTPSubSecond2NanoSecond(frame.descriptor->TimeStampLow);
00010c  9905              LDR      r1,[sp,#0x14]
00010e  6988              LDR      r0,[r1,#0x18]
000110  f7fffffe          BL       ETH_PTPSubSecond2NanoSecond
000114  6170              STR      r0,[r6,#0x14]
                  |L1.278|
;;;341    			}
;;;342    #endif
;;;343        }
;;;344      }
;;;345      
;;;346      /* Release descriptors to DMA */
;;;347      /* Check if received frame with multiple DMA buffer segments */
;;;348      if (DMA_RX_FRAME_infos->Seg_Count > 1)
000116  48bb              LDR      r0,|L1.1028|
000118  6800              LDR      r0,[r0,#0]  ; DMA_RX_FRAME_infos
00011a  6880              LDR      r0,[r0,#8]
00011c  2801              CMP      r0,#1
00011e  d903              BLS      |L1.296|
;;;349      {
;;;350        DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
000120  48b8              LDR      r0,|L1.1028|
000122  6800              LDR      r0,[r0,#0]  ; DMA_RX_FRAME_infos
000124  6807              LDR      r7,[r0,#0]
000126  e000              B        |L1.298|
                  |L1.296|
;;;351      }
;;;352      else
;;;353      {
;;;354        DMARxNextDesc = frame.descriptor;
000128  9f05              LDR      r7,[sp,#0x14]
                  |L1.298|
;;;355      }
;;;356      
;;;357      /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
;;;358      for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
00012a  2000              MOVS     r0,#0
00012c  9006              STR      r0,[sp,#0x18]
00012e  e006              B        |L1.318|
                  |L1.304|
;;;359      {  
;;;360        DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
000130  f04f4000          MOV      r0,#0x80000000
000134  6038              STR      r0,[r7,#0]
;;;361        DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
000136  68ff              LDR      r7,[r7,#0xc]
000138  9806              LDR      r0,[sp,#0x18]         ;358
00013a  1c40              ADDS     r0,r0,#1              ;358
00013c  9006              STR      r0,[sp,#0x18]         ;358
                  |L1.318|
00013e  48b1              LDR      r0,|L1.1028|
000140  6800              LDR      r0,[r0,#0]            ;358  ; DMA_RX_FRAME_infos
000142  6881              LDR      r1,[r0,#8]            ;358
000144  9806              LDR      r0,[sp,#0x18]         ;358
000146  4281              CMP      r1,r0                 ;358
000148  d8f2              BHI      |L1.304|
;;;362      }
;;;363      
;;;364      /* Clear Segment_Count */
;;;365      DMA_RX_FRAME_infos->Seg_Count =0;
00014a  2000              MOVS     r0,#0
00014c  49ad              LDR      r1,|L1.1028|
00014e  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
000150  6088              STR      r0,[r1,#8]
;;;366      
;;;367      
;;;368      /* When Rx Buffer unavailable flag is set: clear it and resume reception */
;;;369      if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
000152  48ad              LDR      r0,|L1.1032|
000154  6940              LDR      r0,[r0,#0x14]
000156  f0000080          AND      r0,r0,#0x80
00015a  b120              CBZ      r0,|L1.358|
;;;370      {
;;;371        /* Clear RBUS ETHERNET DMA flag */
;;;372        ETH->DMASR = ETH_DMASR_RBUS;
00015c  2080              MOVS     r0,#0x80
00015e  49aa              LDR      r1,|L1.1032|
000160  6148              STR      r0,[r1,#0x14]
;;;373          
;;;374        /* Resume DMA reception */
;;;375        ETH->DMARPDR = 0;
000162  2000              MOVS     r0,#0
000164  6088              STR      r0,[r1,#8]
                  |L1.358|
;;;376      }
;;;377      return p;
000166  4630              MOV      r0,r6
;;;378    }
000168  b007              ADD      sp,sp,#0x1c
00016a  e8bd8ff0          POP      {r4-r11,pc}
;;;379    
                          ENDP

                  ethernetif_input PROC
;;;389     */
;;;390    void ethernetif_input(void * pvParameters)
00016e  bf00              NOP      
                  |L1.368|
;;;391    {
;;;392      struct pbuf *p;
;;;393      
;;;394      for( ;; )
;;;395      {
;;;396    		if (sys_arch_sem_wait(&s_xRxSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT) != SYS_ARCH_TIMEOUT)
000170  2164              MOVS     r1,#0x64
000172  48a6              LDR      r0,|L1.1036|
000174  f7fffffe          BL       sys_arch_sem_wait
000178  1c40              ADDS     r0,r0,#1
00017a  2800              CMP      r0,#0
00017c  d0f8              BEQ      |L1.368|
;;;397        {
;;;398    			do
00017e  bf00              NOP      
                  |L1.384|
;;;399    			{
;;;400    				p = low_level_input(s_pxNetIf);
000180  48a3              LDR      r0,|L1.1040|
000182  6800              LDR      r0,[r0,#0]  ; s_pxNetIf
000184  f7fffffe          BL       low_level_input
000188  4604              MOV      r4,r0
;;;401    				if (p != NULL)
00018a  b15c              CBZ      r4,|L1.420|
;;;402    				{
;;;403    					if (s_pxNetIf->input(p, s_pxNetIf) != ERR_OK)
00018c  48a0              LDR      r0,|L1.1040|
00018e  6800              LDR      r0,[r0,#0]  ; s_pxNetIf
000190  6902              LDR      r2,[r0,#0x10]
000192  489f              LDR      r0,|L1.1040|
000194  6801              LDR      r1,[r0,#0]  ; s_pxNetIf
000196  4620              MOV      r0,r4
000198  4790              BLX      r2
00019a  b118              CBZ      r0,|L1.420|
;;;404    					{
;;;405    						pbuf_free(p);
00019c  4620              MOV      r0,r4
00019e  f7fffffe          BL       pbuf_free
;;;406    						p=NULL;
0001a2  2400              MOVS     r4,#0
                  |L1.420|
;;;407    					}
;;;408    				}
;;;409    			} while (p != NULL);			
0001a4  2c00              CMP      r4,#0
0001a6  d1eb              BNE      |L1.384|
0001a8  e7e2              B        |L1.368|
;;;410        }
;;;411      }
;;;412    }  
;;;413          
                          ENDP

                  ETH_PTPStart PROC
;;;469    *******************************************************************************/
;;;470    static void ETH_PTPStart(uint32_t UpdateMethod)
0001aa  b510              PUSH     {r4,lr}
;;;471    {
0001ac  4604              MOV      r4,r0
;;;472      /* Check the parameters */
;;;473      assert_param(IS_ETH_PTP_UPDATE(UpdateMethod));
;;;474    
;;;475      /* Mask the Time stamp trigger interrupt by setting bit 9 in the MACIMR register. */
;;;476      ETH_MACITConfig(ETH_MAC_IT_TST, DISABLE);
0001ae  2100              MOVS     r1,#0
0001b0  f44f7000          MOV      r0,#0x200
0001b4  f7fffffe          BL       ETH_MACITConfig
;;;477    
;;;478      /* Program Time stamp register bit 0 to enable time stamping. */
;;;479      ETH_PTPTimeStampCmd(ENABLE);
0001b8  2001              MOVS     r0,#1
0001ba  f7fffffe          BL       ETH_PTPTimeStampCmd
;;;480    
;;;481      /* Program the Subsecond increment register based on the PTP clock frequency. */
;;;482      ETH_SetPTPSubSecondIncrement(ADJ_FREQ_BASE_INCREMENT); /* to achieve 20 ns accuracy, the value is ~ 43 */
0001be  202b              MOVS     r0,#0x2b
0001c0  f7fffffe          BL       ETH_SetPTPSubSecondIncrement
;;;483    
;;;484      if (UpdateMethod == ETH_PTP_FineUpdate)
0001c4  2c01              CMP      r4,#1
0001c6  d10a              BNE      |L1.478|
;;;485    	{
;;;486        /* If you are using the Fine correction method, program the Time stamp addend register
;;;487         * and set Time stamp control register bit 5 (addend register update). */
;;;488        ETH_SetPTPTimeStampAddend(ADJ_FREQ_BASE_ADDEND);
0001c8  4892              LDR      r0,|L1.1044|
0001ca  f7fffffe          BL       ETH_SetPTPTimeStampAddend
;;;489        ETH_EnablePTPTimeStampAddend();
0001ce  f7fffffe          BL       ETH_EnablePTPTimeStampAddend
;;;490    
;;;491        /* Poll the Time stamp control register until bit 5 is cleared. */
;;;492        while(ETH_GetPTPFlagStatus(ETH_PTP_FLAG_TSARU) == SET);
0001d2  bf00              NOP      
                  |L1.468|
0001d4  2020              MOVS     r0,#0x20
0001d6  f7fffffe          BL       ETH_GetPTPFlagStatus
0001da  2801              CMP      r0,#1
0001dc  d0fa              BEQ      |L1.468|
                  |L1.478|
;;;493      }
;;;494    
;;;495      /* To select the Fine correction method (if required),
;;;496       * program Time stamp control register  bit 1. */
;;;497      ETH_PTPUpdateMethodConfig(UpdateMethod);
0001de  4620              MOV      r0,r4
0001e0  f7fffffe          BL       ETH_PTPUpdateMethodConfig
;;;498    
;;;499      /* Program the Time stamp high update and Time stamp low update registers
;;;500       * with the appropriate time value. */
;;;501      ETH_SetPTPTimeStampUpdate(ETH_PTP_PositiveTime, 0, 0);
0001e4  2200              MOVS     r2,#0
0001e6  4611              MOV      r1,r2
0001e8  4610              MOV      r0,r2
0001ea  f7fffffe          BL       ETH_SetPTPTimeStampUpdate
;;;502    
;;;503      /* Set Time stamp control register bit 2 (Time stamp init). */
;;;504      ETH_InitializePTPTimeStamp();
0001ee  f7fffffe          BL       ETH_InitializePTPTimeStamp
;;;505    
;;;506    	/* The enhanced descriptor format is enabled and the descriptor size is
;;;507    	 * increased to 32 bytes (8 DWORDS). This is required when time stamping 
;;;508    	 * is activated above. */
;;;509    	ETH_EnhancedDescriptorCmd(ENABLE);
0001f2  2001              MOVS     r0,#1
0001f4  f7fffffe          BL       ETH_EnhancedDescriptorCmd
;;;510    	
;;;511      /* The Time stamp counter starts operation as soon as it is initialized
;;;512       * with the value written in the Time stamp update register. */
;;;513    }
0001f8  bd10              POP      {r4,pc}
;;;514    
                          ENDP

                  low_level_init PROC
;;;130     */
;;;131    static void low_level_init(struct netif *netif)
0001fa  b538              PUSH     {r3-r5,lr}
;;;132    {
0001fc  4604              MOV      r4,r0
;;;133      uint32_t i;
;;;134     
;;;135      /* set netif MAC hardware address length */
;;;136      netif->hwaddr_len = ETHARP_HWADDR_LEN;
0001fe  2006              MOVS     r0,#6
000200  f8840026          STRB     r0,[r4,#0x26]
;;;137    	
;;;138      /* set netif MAC hardware address */
;;;139      netif->hwaddr[0] =  MAC_ADDR0;
000204  2060              MOVS     r0,#0x60
000206  f8840027          STRB     r0,[r4,#0x27]
;;;140      netif->hwaddr[1] =  MAC_ADDR1;
00020a  21eb              MOVS     r1,#0xeb
00020c  2028              MOVS     r0,#0x28
00020e  5501              STRB     r1,[r0,r4]
;;;141      netif->hwaddr[2] =  MAC_ADDR2;
000210  2169              MOVS     r1,#0x69
000212  2029              MOVS     r0,#0x29
000214  5501              STRB     r1,[r0,r4]
;;;142      netif->hwaddr[3] =  MAC_ADDR3;
000216  21ce              MOVS     r1,#0xce
000218  202a              MOVS     r0,#0x2a
00021a  5501              STRB     r1,[r0,r4]
;;;143      netif->hwaddr[4] =  MAC_ADDR4;
00021c  2161              MOVS     r1,#0x61
00021e  202b              MOVS     r0,#0x2b
000220  5501              STRB     r1,[r0,r4]
;;;144      netif->hwaddr[5] =  MAC_ADDR5;
000222  211a              MOVS     r1,#0x1a
000224  202c              MOVS     r0,#0x2c
000226  5501              STRB     r1,[r0,r4]
;;;145      
;;;146      /* set netif maximum transfer unit */
;;;147      netif->mtu = 1500;
000228  f24050dc          MOV      r0,#0x5dc
00022c  f8240f24          STRH     r0,[r4,#0x24]!
;;;148    
;;;149      /* Accept broadcast address and ARP traffic */
;;;150      netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
000230  2022              MOVS     r0,#0x22
000232  7260              STRB     r0,[r4,#9]
;;;151    
;;;152    #ifdef LWIP_IGMP
;;;153    	/* Accept multicast traffic. */
;;;154    	netif->flags |= NETIF_FLAG_IGMP;
000234  7a60              LDRB     r0,[r4,#9]
000236  f0400080          ORR      r0,r0,#0x80
00023a  7260              STRB     r0,[r4,#9]
00023c  3c24              SUBS     r4,r4,#0x24
;;;155    #endif
;;;156      
;;;157      s_pxNetIf = netif;
00023e  4874              LDR      r0,|L1.1040|
000240  6004              STR      r4,[r0,#0]  ; s_pxNetIf
;;;158     
;;;159      /* Create semaphores for managing ethernet resources. */
;;;160    	sys_sem_new(&s_xRxSemaphore, 0);
000242  2100              MOVS     r1,#0
000244  4871              LDR      r0,|L1.1036|
000246  f7fffffe          BL       sys_sem_new
;;;161    	sys_sem_new(&s_xTxSemaphore, 1);
00024a  2101              MOVS     r1,#1
00024c  4872              LDR      r0,|L1.1048|
00024e  f7fffffe          BL       sys_sem_new
;;;162    
;;;163      /* Initialize MAC address in ethernet MAC */ 
;;;164      ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 
000252  f1040127          ADD      r1,r4,#0x27
000256  2000              MOVS     r0,#0
000258  f7fffffe          BL       ETH_MACAddressConfig
;;;165      
;;;166      /* Initialize Tx Descriptors list: Chain Mode */
;;;167      ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
00025c  2205              MOVS     r2,#5
00025e  496f              LDR      r1,|L1.1052|
000260  486f              LDR      r0,|L1.1056|
000262  f7fffffe          BL       ETH_DMATxDescChainInit
;;;168    
;;;169      /* Initialize Rx Descriptors list: Chain Mode  */
;;;170      ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
000266  2205              MOVS     r2,#5
000268  496e              LDR      r1,|L1.1060|
00026a  486f              LDR      r0,|L1.1064|
00026c  f7fffffe          BL       ETH_DMARxDescChainInit
;;;171      
;;;172      /* Enable Ethernet Rx interrrupt */
;;;173      { 
;;;174        for(i=0; i<ETH_RXBUFNB; i++)
000270  2500              MOVS     r5,#0
000272  e006              B        |L1.642|
                  |L1.628|
;;;175        {
;;;176          ETH_DMARxDescReceiveITConfig(&DMARxDscrTab[i], ENABLE);
000274  496c              LDR      r1,|L1.1064|
000276  eb011045          ADD      r0,r1,r5,LSL #5
00027a  2101              MOVS     r1,#1
00027c  f7fffffe          BL       ETH_DMARxDescReceiveITConfig
000280  1c6d              ADDS     r5,r5,#1              ;174
                  |L1.642|
000282  2d05              CMP      r5,#5                 ;174
000284  d3f6              BCC      |L1.628|
;;;177        }
;;;178      }
;;;179    
;;;180    #ifdef CHECKSUM_BY_HARDWARE
;;;181      /* Enable the checksum insertion for the Tx frames */
;;;182      {
;;;183        for(i=0; i<ETH_TXBUFNB; i++)
000286  2500              MOVS     r5,#0
000288  e007              B        |L1.666|
                  |L1.650|
;;;184        {
;;;185          ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
00028a  4965              LDR      r1,|L1.1056|
00028c  eb011045          ADD      r0,r1,r5,LSL #5
000290  f44f0140          MOV      r1,#0xc00000
000294  f7fffffe          BL       ETH_DMATxDescChecksumInsertionConfig
000298  1c6d              ADDS     r5,r5,#1              ;183
                  |L1.666|
00029a  2d05              CMP      r5,#5                 ;183
00029c  d3f5              BCC      |L1.650|
;;;186        }
;;;187      } 
;;;188    #endif
;;;189    
;;;190    #if LWIP_PTP
;;;191      /* Enable PTP Timestamping */
;;;192      ETH_PTPStart(ETH_PTP_FineUpdate);
00029e  2001              MOVS     r0,#1
0002a0  f7fffffe          BL       ETH_PTPStart
;;;193      /* ETH_PTPStart(ETH_PTP_CoarseUpdate); */
;;;194    #endif
;;;195      
;;;196      /* Create the task that handles the ETH_MAC */
;;;197    	sys_thread_new((const char *) "Eth_if", ethernetif_input, NULL, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
0002a4  2003              MOVS     r0,#3
0002a6  f44f73af          MOV      r3,#0x15e
0002aa  2200              MOVS     r2,#0
0002ac  495f              LDR      r1,|L1.1068|
0002ae  9000              STR      r0,[sp,#0]
0002b0  a05f              ADR      r0,|L1.1072|
0002b2  f7fffffe          BL       sys_thread_new
;;;198      
;;;199      /* Enable MAC and DMA transmission and reception */
;;;200      ETH_Start();   
0002b6  f7fffffe          BL       ETH_Start
;;;201    }
0002ba  bd38              POP      {r3-r5,pc}
;;;202    
                          ENDP

                  low_level_output PROC
;;;218     */
;;;219    static err_t low_level_output(struct netif *netif, struct pbuf *p)
0002bc  e92d47fc          PUSH     {r2-r10,lr}
;;;220    {
0002c0  4681              MOV      r9,r0
0002c2  460d              MOV      r5,r1
;;;221      struct pbuf *q;
;;;222    	err_t retval = ERR_OK;
0002c4  f04f0800          MOV      r8,#0
;;;223      uint32_t l = 0;
0002c8  2600              MOVS     r6,#0
;;;224      u8 *buffer ;
;;;225    #if LWIP_PTP
;;;226    	ETH_TimeStamp timeStamp;
;;;227    #endif
;;;228    
;;;229    	/* Take the ethernet mutex before sending the ethernet packet. */
;;;230    	if (sys_arch_sem_wait(&s_xTxSemaphore, netifGUARD_BLOCK_TIME))
0002ca  21fa              MOVS     r1,#0xfa
0002cc  4852              LDR      r0,|L1.1048|
0002ce  f7fffffe          BL       sys_arch_sem_wait
0002d2  b300              CBZ      r0,|L1.790|
;;;231      {
;;;232    		/* Point to the DMA descriptor buffer. */
;;;233        buffer = (u8 *)(DMATxDescToSet->Buffer1Addr);
0002d4  4858              LDR      r0,|L1.1080|
0002d6  6800              LDR      r0,[r0,#0]  ; DMATxDescToSet
0002d8  6887              LDR      r7,[r0,#8]
;;;234    
;;;235    		/* Fill in the DMA descriptor buffer. */
;;;236        for (q = p; q != NULL; q = q->next) 
0002da  462c              MOV      r4,r5
0002dc  e007              B        |L1.750|
                  |L1.734|
;;;237        {
;;;238          memcpy((u8_t*)&buffer[l], (u8_t *)q->payload, q->len);
0002de  8962              LDRH     r2,[r4,#0xa]
0002e0  19b8              ADDS     r0,r7,r6
0002e2  6861              LDR      r1,[r4,#4]
0002e4  f7fffffe          BL       __aeabi_memcpy
;;;239          l = l + q->len;
0002e8  8960              LDRH     r0,[r4,#0xa]
0002ea  4406              ADD      r6,r6,r0
0002ec  6824              LDR      r4,[r4,#0]            ;236
                  |L1.750|
0002ee  2c00              CMP      r4,#0                 ;236
0002f0  d1f5              BNE      |L1.734|
;;;240        }
;;;241    
;;;242    #if LWIP_PTP
;;;243    		/* Transmit the packet filling in the packet timestamp. */
;;;244    		if (ETH_Prepare_Transmit_Descriptors_TimeStamp(l, &timeStamp) != ETH_SUCCESS)
0002f2  b2b0              UXTH     r0,r6
0002f4  4669              MOV      r1,sp
0002f6  f7fffffe          BL       ETH_Prepare_Transmit_Descriptors_TimeStamp
0002fa  2801              CMP      r0,#1
0002fc  d002              BEQ      |L1.772|
;;;245    		{
;;;246    			retval = ERR_IF;
0002fe  f06f080e          MVN      r8,#0xe
000302  e005              B        |L1.784|
                  |L1.772|
;;;247    		}
;;;248    		else
;;;249    		{
;;;250    			/* Fill in the time stamp information. */
;;;251    			p->time_sec = timeStamp.TimeStampHigh;
000304  9801              LDR      r0,[sp,#4]
000306  6128              STR      r0,[r5,#0x10]
;;;252    			p->time_nsec = ETH_PTPSubSecond2NanoSecond(timeStamp.TimeStampLow);
000308  9800              LDR      r0,[sp,#0]
00030a  f7fffffe          BL       ETH_PTPSubSecond2NanoSecond
00030e  6168              STR      r0,[r5,#0x14]
                  |L1.784|
;;;253    		}
;;;254    #else
;;;255    		/* Transmit the packet. */
;;;256        if (ETH_Prepare_Transmit_Descriptors(l) != ETH_SUCCESS)
;;;257    		{
;;;258    			retval = ERR_IF;
;;;259    		}
;;;260    #endif
;;;261    
;;;262    		/* Release the ethernet mutex. */
;;;263    		sys_sem_signal(&s_xTxSemaphore);
000310  4841              LDR      r0,|L1.1048|
000312  f7fffffe          BL       sys_sem_signal
                  |L1.790|
;;;264      }
;;;265      return retval;
000316  4640              MOV      r0,r8
;;;266    }
000318  e8bd87fc          POP      {r2-r10,pc}
;;;267    
                          ENDP

                  arp_timer PROC
;;;451    
;;;452    static void arp_timer(void *arg)
00031c  b510              PUSH     {r4,lr}
;;;453    {
00031e  4604              MOV      r4,r0
;;;454      etharp_tmr();
000320  f7fffffe          BL       etharp_tmr
;;;455      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
000324  2200              MOVS     r2,#0
000326  4945              LDR      r1,|L1.1084|
000328  f2413088          MOV      r0,#0x1388
00032c  f7fffffe          BL       sys_timeout
;;;456    }
000330  bd10              POP      {r4,pc}
;;;457    
                          ENDP

                  ethernetif_init PROC
;;;426     */
;;;427    err_t ethernetif_init(struct netif *netif)
000332  b510              PUSH     {r4,lr}
;;;428    {
000334  4604              MOV      r4,r0
;;;429      LWIP_ASSERT("netif != NULL", (netif != NULL));
000336  bf00              NOP      
000338  bf00              NOP      
;;;430    
;;;431    #if LWIP_NETIF_HOSTNAME
;;;432      /* Initialize interface hostname */
;;;433      netif->hostname = "lwip";
;;;434    #endif /* LWIP_NETIF_HOSTNAME */
;;;435    
;;;436      netif->name[0] = IFNAME0;
00033a  2073              MOVS     r0,#0x73
00033c  f884002e          STRB     r0,[r4,#0x2e]
;;;437      netif->name[1] = IFNAME1;
000340  2174              MOVS     r1,#0x74
000342  202f              MOVS     r0,#0x2f
000344  5501              STRB     r1,[r0,r4]
;;;438    
;;;439      netif->output = etharp_output;
000346  483e              LDR      r0,|L1.1088|
000348  6160              STR      r0,[r4,#0x14]
;;;440      netif->linkoutput = low_level_output;
00034a  483e              LDR      r0,|L1.1092|
00034c  61a0              STR      r0,[r4,#0x18]
;;;441    
;;;442      /* initialize the hardware */
;;;443      low_level_init(netif);
00034e  4620              MOV      r0,r4
000350  f7fffffe          BL       low_level_init
;;;444      
;;;445      etharp_init();
;;;446      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
000354  2200              MOVS     r2,#0
000356  4939              LDR      r1,|L1.1084|
000358  f2413088          MOV      r0,#0x1388
00035c  f7fffffe          BL       sys_timeout
;;;447    
;;;448      return ERR_OK;
000360  2000              MOVS     r0,#0
;;;449    }
000362  bd10              POP      {r4,pc}
;;;450    
                          ENDP

                  ETH_PTPTime_AdjFreq PROC
;;;521    *******************************************************************************/
;;;522    void ETH_PTPTime_AdjFreq(int32_t Adj)
000364  e92d41f0          PUSH     {r4-r8,lr}
;;;523    {
000368  4604              MOV      r4,r0
;;;524    	uint32_t addend;
;;;525    	
;;;526    	/* calculate the rate by which you want to speed up or slow down the system time
;;;527    		 increments */
;;;528     
;;;529    	/* precise */
;;;530    	/*
;;;531    	int64_t addend;
;;;532    	addend = Adj;
;;;533    	addend *= ADJ_FREQ_BASE_ADDEND;
;;;534    	addend /= 1000000000-Adj;
;;;535    	addend += ADJ_FREQ_BASE_ADDEND;
;;;536    	*/
;;;537    
;;;538    	/* 32bit estimation
;;;539    	ADJ_LIMIT = ((1l<<63)/275/ADJ_FREQ_BASE_ADDEND) = 11258181 = 11 258 ppm*/
;;;540    	if( Adj > 5120000) Adj = 5120000;
00036a  4837              LDR      r0,|L1.1096|
00036c  4284              CMP      r4,r0
00036e  dd00              BLE      |L1.882|
000370  4604              MOV      r4,r0
                  |L1.882|
;;;541    	if( Adj < -5120000) Adj = -5120000;
000372  4835              LDR      r0,|L1.1096|
000374  4240              RSBS     r0,r0,#0
000376  4284              CMP      r4,r0
000378  da00              BGE      |L1.892|
00037a  4604              MOV      r4,r0
                  |L1.892|
;;;542    
;;;543    	addend = ((((275LL * Adj)>>8) * (ADJ_FREQ_BASE_ADDEND>>24))>>6) + ADJ_FREQ_BASE_ADDEND;
00037c  f2401013          MOV      r0,#0x113
000380  fb800104          SMULL    r0,r1,r0,r4
000384  0a00              LSRS     r0,r0,#8
000386  ea406001          ORR      r0,r0,r1,LSL #24
00038a  120b              ASRS     r3,r1,#8
00038c  224c              MOVS     r2,#0x4c
00038e  2600              MOVS     r6,#0
000390  fba01702          UMULL    r1,r7,r0,r2
000394  fb037202          MLA      r2,r3,r2,r7
000398  fb002006          MLA      r0,r0,r6,r2
00039c  0682              LSLS     r2,r0,#26
00039e  ea421091          ORR      r0,r2,r1,LSR #6
0003a2  491c              LDR      r1,|L1.1044|
0003a4  1845              ADDS     r5,r0,r1
;;;544    	
;;;545    	/* Reprogram the Time stamp addend register with new Rate value and set ETH_TPTSCR */
;;;546    	ETH_SetPTPTimeStampAddend((uint32_t)addend);
0003a6  4628              MOV      r0,r5
0003a8  f7fffffe          BL       ETH_SetPTPTimeStampAddend
;;;547    	ETH_EnablePTPTimeStampAddend();
0003ac  f7fffffe          BL       ETH_EnablePTPTimeStampAddend
;;;548    }
0003b0  e8bd81f0          POP      {r4-r8,pc}
;;;549    
                          ENDP

                  ETH_PTPTime_UpdateOffset PROC
;;;556    *******************************************************************************/
;;;557    void ETH_PTPTime_UpdateOffset(struct ptptime_t * timeoffset)
0003b4  e92d47f0          PUSH     {r4-r10,lr}
;;;558    {
0003b8  4604              MOV      r4,r0
;;;559    	uint32_t Sign;
;;;560    	uint32_t SecondValue;
;;;561    	uint32_t NanoSecondValue;
;;;562    	uint32_t SubSecondValue;
;;;563    	uint32_t addend;
;;;564    
;;;565    	/* determine sign and correct Second and Nanosecond values */
;;;566    	if(timeoffset->tv_sec < 0 || (timeoffset->tv_sec == 0 && timeoffset->tv_nsec < 0))
0003ba  6820              LDR      r0,[r4,#0]
0003bc  2800              CMP      r0,#0
0003be  db04              BLT      |L1.970|
0003c0  6820              LDR      r0,[r4,#0]
0003c2  b948              CBNZ     r0,|L1.984|
0003c4  6860              LDR      r0,[r4,#4]
0003c6  2800              CMP      r0,#0
0003c8  da06              BGE      |L1.984|
                  |L1.970|
;;;567    	{
;;;568    		Sign = ETH_PTP_NegativeTime;
0003ca  f04f4500          MOV      r5,#0x80000000
;;;569    		SecondValue = -timeoffset->tv_sec;
0003ce  6820              LDR      r0,[r4,#0]
0003d0  4246              RSBS     r6,r0,#0
;;;570    		NanoSecondValue = -timeoffset->tv_nsec;
0003d2  6860              LDR      r0,[r4,#4]
0003d4  4247              RSBS     r7,r0,#0
0003d6  e002              B        |L1.990|
                  |L1.984|
;;;571    	}
;;;572    	else
;;;573    	{
;;;574    		Sign = ETH_PTP_PositiveTime;
0003d8  2500              MOVS     r5,#0
;;;575    		SecondValue = timeoffset->tv_sec;
0003da  6826              LDR      r6,[r4,#0]
;;;576    		NanoSecondValue = timeoffset->tv_nsec;
0003dc  6867              LDR      r7,[r4,#4]
                  |L1.990|
;;;577    	}
;;;578    
;;;579    	/* convert nanosecond to subseconds */
;;;580    	SubSecondValue = ETH_PTPNanoSecond2SubSecond(NanoSecondValue);
0003de  4638              MOV      r0,r7
0003e0  f7fffffe          BL       ETH_PTPNanoSecond2SubSecond
0003e4  4681              MOV      r9,r0
;;;581    
;;;582    	/* read old addend register value*/
;;;583    	addend = ETH_GetPTPRegister(ETH_PTPTSAR);
0003e6  f44f60e3          MOV      r0,#0x718
0003ea  f7fffffe          BL       ETH_GetPTPRegister
0003ee  4680              MOV      r8,r0
;;;584    
;;;585    	while(ETH_GetPTPFlagStatus(ETH_PTP_FLAG_TSSTU) == SET);
0003f0  bf00              NOP      
                  |L1.1010|
0003f2  2008              MOVS     r0,#8
0003f4  f7fffffe          BL       ETH_GetPTPFlagStatus
0003f8  2801              CMP      r0,#1
0003fa  d0fa              BEQ      |L1.1010|
;;;586    	while(ETH_GetPTPFlagStatus(ETH_PTP_FLAG_TSSTI) == SET);
0003fc  bf00              NOP      
                  |L1.1022|
0003fe  e025              B        |L1.1100|
                  |L1.1024|
                          DCD      0x3b9aca00
                  |L1.1028|
                          DCD      DMA_RX_FRAME_infos
                  |L1.1032|
                          DCD      0x40029000
                  |L1.1036|
                          DCD      s_xRxSemaphore
                  |L1.1040|
                          DCD      s_pxNetIf
                  |L1.1044|
                          DCD      0x4c19ef00
                  |L1.1048|
                          DCD      s_xTxSemaphore
                  |L1.1052|
                          DCD      Tx_Buff
                  |L1.1056|
                          DCD      DMATxDscrTab
                  |L1.1060|
                          DCD      Rx_Buff
                  |L1.1064|
                          DCD      DMARxDscrTab
                  |L1.1068|
                          DCD      ethernetif_input
                  |L1.1072|
000430  4574685f          DCB      "Eth_if",0
000434  696600  
000437  00                DCB      0
                  |L1.1080|
                          DCD      DMATxDescToSet
                  |L1.1084|
                          DCD      arp_timer
                  |L1.1088|
                          DCD      etharp_output
                  |L1.1092|
                          DCD      low_level_output
                  |L1.1096|
                          DCD      0x004e2000
                  |L1.1100|
00044c  2004              MOVS     r0,#4
00044e  f7fffffe          BL       ETH_GetPTPFlagStatus
000452  2801              CMP      r0,#1
000454  d0d3              BEQ      |L1.1022|
;;;587    
;;;588    	/* Write the offset (positive or negative) in the Time stamp update high and low registers. */
;;;589    	ETH_SetPTPTimeStampUpdate(Sign, SecondValue, SubSecondValue);
000456  464a              MOV      r2,r9
000458  4631              MOV      r1,r6
00045a  4628              MOV      r0,r5
00045c  f7fffffe          BL       ETH_SetPTPTimeStampUpdate
;;;590    
;;;591    	/* Set bit 3 (TSSTU) in the Time stamp control register. */
;;;592    	ETH_EnablePTPTimeStampUpdate();
000460  f7fffffe          BL       ETH_EnablePTPTimeStampUpdate
;;;593    
;;;594    	/* The value in the Time stamp update registers is added to or subtracted from the system */
;;;595    	/* time when the TSSTU bit is cleared. */
;;;596    	while(ETH_GetPTPFlagStatus(ETH_PTP_FLAG_TSSTU) == SET);      
000464  bf00              NOP      
                  |L1.1126|
000466  2008              MOVS     r0,#8
000468  f7fffffe          BL       ETH_GetPTPFlagStatus
00046c  2801              CMP      r0,#1
00046e  d0fa              BEQ      |L1.1126|
;;;597    
;;;598    	/* Write back old addend register value. */
;;;599    	ETH_SetPTPTimeStampAddend(addend);
000470  4640              MOV      r0,r8
000472  f7fffffe          BL       ETH_SetPTPTimeStampAddend
;;;600    	ETH_EnablePTPTimeStampAddend();
000476  f7fffffe          BL       ETH_EnablePTPTimeStampAddend
;;;601    }
00047a  e8bd87f0          POP      {r4-r10,pc}
;;;602    
                          ENDP

                  ETH_PTPTime_SetTime PROC
;;;609    *******************************************************************************/
;;;610    void ETH_PTPTime_SetTime(struct ptptime_t * timestamp)
00047e  e92d41f0          PUSH     {r4-r8,lr}
;;;611    {
000482  4604              MOV      r4,r0
;;;612    	uint32_t Sign;
;;;613    	uint32_t SecondValue;
;;;614    	uint32_t NanoSecondValue;
;;;615    	uint32_t SubSecondValue;
;;;616    
;;;617    	/* determine sign and correct Second and Nanosecond values */
;;;618    	if(timestamp->tv_sec < 0 || (timestamp->tv_sec == 0 && timestamp->tv_nsec < 0))
000484  6820              LDR      r0,[r4,#0]
000486  2800              CMP      r0,#0
000488  db04              BLT      |L1.1172|
00048a  6820              LDR      r0,[r4,#0]
00048c  b948              CBNZ     r0,|L1.1186|
00048e  6860              LDR      r0,[r4,#4]
000490  2800              CMP      r0,#0
000492  da06              BGE      |L1.1186|
                  |L1.1172|
;;;619    	{
;;;620    		Sign = ETH_PTP_NegativeTime;
000494  f04f4500          MOV      r5,#0x80000000
;;;621    		SecondValue = -timestamp->tv_sec;
000498  6820              LDR      r0,[r4,#0]
00049a  4246              RSBS     r6,r0,#0
;;;622    		NanoSecondValue = -timestamp->tv_nsec;
00049c  6860              LDR      r0,[r4,#4]
00049e  4247              RSBS     r7,r0,#0
0004a0  e002              B        |L1.1192|
                  |L1.1186|
;;;623    	}
;;;624    	else
;;;625    	{
;;;626    		Sign = ETH_PTP_PositiveTime;
0004a2  2500              MOVS     r5,#0
;;;627    		SecondValue = timestamp->tv_sec;
0004a4  6826              LDR      r6,[r4,#0]
;;;628    		NanoSecondValue = timestamp->tv_nsec;
0004a6  6867              LDR      r7,[r4,#4]
                  |L1.1192|
;;;629    	}
;;;630    
;;;631    	/* convert nanosecond to subseconds */
;;;632    	SubSecondValue = ETH_PTPNanoSecond2SubSecond(NanoSecondValue);
0004a8  4638              MOV      r0,r7
0004aa  f7fffffe          BL       ETH_PTPNanoSecond2SubSecond
0004ae  4680              MOV      r8,r0
;;;633    
;;;634    	/* Write the offset (positive or negative) in the Time stamp update high and low registers. */
;;;635    	ETH_SetPTPTimeStampUpdate(Sign, SecondValue, SubSecondValue);
0004b0  4642              MOV      r2,r8
0004b2  4631              MOV      r1,r6
0004b4  4628              MOV      r0,r5
0004b6  f7fffffe          BL       ETH_SetPTPTimeStampUpdate
;;;636    	/* Set Time stamp control register bit 2 (Time stamp init). */
;;;637    	ETH_InitializePTPTimeStamp();
0004ba  f7fffffe          BL       ETH_InitializePTPTimeStamp
;;;638    	/* The Time stamp counter starts operation as soon as it is initialized
;;;639    	 * with the value written in the Time stamp update register. */
;;;640    	while(ETH_GetPTPFlagStatus(ETH_PTP_FLAG_TSSTI) == SET);
0004be  bf00              NOP      
                  |L1.1216|
0004c0  2004              MOVS     r0,#4
0004c2  f7fffffe          BL       ETH_GetPTPFlagStatus
0004c6  2801              CMP      r0,#1
0004c8  d0fa              BEQ      |L1.1216|
;;;641    }
0004ca  e8bd81f0          POP      {r4-r8,pc}
;;;642    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_xRxSemaphore
                          %        16
                  s_xTxSemaphore
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  s_pxNetIf
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\lwip-1.4.1\\port\\STM32F4x7\\arch\\ethernetif.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8bb85f79____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_ethernetif_c_8bb85f79____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8bb85f79____REVSH|
#line 128
|__asm___12_ethernetif_c_8bb85f79____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
