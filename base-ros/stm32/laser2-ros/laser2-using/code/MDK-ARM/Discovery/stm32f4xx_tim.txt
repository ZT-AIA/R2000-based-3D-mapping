; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4xx_tim.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4xx_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4xx_tim.crf ..\..\libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;199      */
;;;200    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;201    {
000002  4604              MOV      r4,r0
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;204     
;;;205      if (TIMx == TIM1)
000004  48fe              LDR      r0,|L1.1024|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;206      {
;;;207        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;208        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e09d              B        |L1.344|
                  |L1.28|
;;;209      } 
;;;210      else if (TIMx == TIM2) 
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L1.52|
;;;211      {     
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e091              B        |L1.344|
                  |L1.52|
;;;214      }  
;;;215      else if (TIMx == TIM3)
000034  48f3              LDR      r0,|L1.1028|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L1.76|
;;;216      { 
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e085              B        |L1.344|
                  |L1.76|
;;;219      }  
;;;220      else if (TIMx == TIM4)
00004c  48ee              LDR      r0,|L1.1032|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L1.100|
;;;221      { 
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e079              B        |L1.344|
                  |L1.100|
;;;224      }  
;;;225      else if (TIMx == TIM5)
000064  48e9              LDR      r0,|L1.1036|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L1.124|
;;;226      {      
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e06d              B        |L1.344|
                  |L1.124|
;;;229      }  
;;;230      else if (TIMx == TIM6)  
00007c  48e4              LDR      r0,|L1.1040|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L1.148|
;;;231      {    
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e061              B        |L1.344|
                  |L1.148|
;;;234      }  
;;;235      else if (TIMx == TIM7)
000094  48df              LDR      r0,|L1.1044|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L1.172|
;;;236      {      
;;;237        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;238        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e055              B        |L1.344|
                  |L1.172|
;;;239      }  
;;;240      else if (TIMx == TIM8)
0000ac  48da              LDR      r0,|L1.1048|
0000ae  4284              CMP      r4,r0
0000b0  d108              BNE      |L1.196|
;;;241      {      
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  2002              MOVS     r0,#2
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;243        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000ba  2100              MOVS     r1,#0
0000bc  2002              MOVS     r0,#2
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000c2  e049              B        |L1.344|
                  |L1.196|
;;;244      }  
;;;245      else if (TIMx == TIM9)
0000c4  48d5              LDR      r0,|L1.1052|
0000c6  4284              CMP      r4,r0
0000c8  d109              BNE      |L1.222|
;;;246      {      
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  0408              LSLS     r0,r1,#16
0000ce  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;248        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000d2  2100              MOVS     r1,#0
0000d4  f44f3080          MOV      r0,#0x10000
0000d8  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000dc  e03c              B        |L1.344|
                  |L1.222|
;;;249       }  
;;;250      else if (TIMx == TIM10)
0000de  48d0              LDR      r0,|L1.1056|
0000e0  4284              CMP      r4,r0
0000e2  d109              BNE      |L1.248|
;;;251      {      
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  0448              LSLS     r0,r1,#17
0000e8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;253        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000ec  2100              MOVS     r1,#0
0000ee  f44f3000          MOV      r0,#0x20000
0000f2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000f6  e02f              B        |L1.344|
                  |L1.248|
;;;254      }  
;;;255      else if (TIMx == TIM11) 
0000f8  48ca              LDR      r0,|L1.1060|
0000fa  4284              CMP      r4,r0
0000fc  d109              BNE      |L1.274|
;;;256      {     
;;;257        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  0488              LSLS     r0,r1,#18
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;258        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
000106  2100              MOVS     r1,#0
000108  f44f2080          MOV      r0,#0x40000
00010c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000110  e022              B        |L1.344|
                  |L1.274|
;;;259      }  
;;;260      else if (TIMx == TIM12)
000112  48c5              LDR      r0,|L1.1064|
000114  4284              CMP      r4,r0
000116  d108              BNE      |L1.298|
;;;261      {      
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000118  2101              MOVS     r1,#1
00011a  2040              MOVS     r0,#0x40
00011c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;263        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000120  2100              MOVS     r1,#0
000122  2040              MOVS     r0,#0x40
000124  f7fffffe          BL       RCC_APB1PeriphResetCmd
000128  e016              B        |L1.344|
                  |L1.298|
;;;264      }  
;;;265      else if (TIMx == TIM13) 
00012a  48c0              LDR      r0,|L1.1068|
00012c  4284              CMP      r4,r0
00012e  d108              BNE      |L1.322|
;;;266      {       
;;;267        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
000130  2101              MOVS     r1,#1
000132  2080              MOVS     r0,#0x80
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;268        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  2080              MOVS     r0,#0x80
00013c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000140  e00a              B        |L1.344|
                  |L1.322|
;;;269      }  
;;;270      else
;;;271      { 
;;;272        if (TIMx == TIM14) 
000142  48bb              LDR      r0,|L1.1072|
000144  4284              CMP      r4,r0
000146  d107              BNE      |L1.344|
;;;273        {     
;;;274          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000148  2101              MOVS     r1,#1
00014a  1580              ASRS     r0,r0,#22
00014c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;275          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
000150  2100              MOVS     r1,#0
000152  15a0              ASRS     r0,r4,#22
000154  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.344|
;;;276        }   
;;;277      }
;;;278    }
000158  bd10              POP      {r4,pc}
;;;279    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;287      */
;;;288    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
00015a  2200              MOVS     r2,#0
;;;289    {
;;;290      uint16_t tmpcr1 = 0;
;;;291    
;;;292      /* Check the parameters */
;;;293      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;294      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;295      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;296    
;;;297      tmpcr1 = TIMx->CR1;  
00015c  8802              LDRH     r2,[r0,#0]
;;;298    
;;;299      if((TIMx == TIM1) || (TIMx == TIM8)||
00015e  4ba8              LDR      r3,|L1.1024|
000160  4298              CMP      r0,r3
000162  d00e              BEQ      |L1.386|
000164  4bac              LDR      r3,|L1.1048|
000166  4298              CMP      r0,r3
000168  d00b              BEQ      |L1.386|
;;;300         (TIMx == TIM2) || (TIMx == TIM3)||
00016a  f1b04f80          CMP      r0,#0x40000000
00016e  d008              BEQ      |L1.386|
000170  4ba4              LDR      r3,|L1.1028|
000172  4298              CMP      r0,r3
000174  d005              BEQ      |L1.386|
;;;301         (TIMx == TIM4) || (TIMx == TIM5)) 
000176  4ba4              LDR      r3,|L1.1032|
000178  4298              CMP      r0,r3
00017a  d002              BEQ      |L1.386|
00017c  4ba3              LDR      r3,|L1.1036|
00017e  4298              CMP      r0,r3
000180  d104              BNE      |L1.396|
                  |L1.386|
;;;302      {
;;;303        /* Select the Counter Mode */
;;;304        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000182  f64f738f          MOV      r3,#0xff8f
000186  401a              ANDS     r2,r2,r3
;;;305        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
000188  884b              LDRH     r3,[r1,#2]
00018a  431a              ORRS     r2,r2,r3
                  |L1.396|
;;;306      }
;;;307     
;;;308      if((TIMx != TIM6) && (TIMx != TIM7))
00018c  4ba0              LDR      r3,|L1.1040|
00018e  4298              CMP      r0,r3
000190  d007              BEQ      |L1.418|
000192  4ba0              LDR      r3,|L1.1044|
000194  4298              CMP      r0,r3
000196  d004              BEQ      |L1.418|
;;;309      {
;;;310        /* Set the clock division */
;;;311        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
000198  f64f43ff          MOV      r3,#0xfcff
00019c  401a              ANDS     r2,r2,r3
;;;312        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
00019e  890b              LDRH     r3,[r1,#8]
0001a0  431a              ORRS     r2,r2,r3
                  |L1.418|
;;;313      }
;;;314    
;;;315      TIMx->CR1 = tmpcr1;
0001a2  8002              STRH     r2,[r0,#0]
;;;316    
;;;317      /* Set the Autoreload value */
;;;318      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0001a4  684b              LDR      r3,[r1,#4]
0001a6  62c3              STR      r3,[r0,#0x2c]
;;;319     
;;;320      /* Set the Prescaler value */
;;;321      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0001a8  880b              LDRH     r3,[r1,#0]
0001aa  8503              STRH     r3,[r0,#0x28]
;;;322        
;;;323      if ((TIMx == TIM1) || (TIMx == TIM8))  
0001ac  4b94              LDR      r3,|L1.1024|
0001ae  4298              CMP      r0,r3
0001b0  d002              BEQ      |L1.440|
0001b2  4b99              LDR      r3,|L1.1048|
0001b4  4298              CMP      r0,r3
0001b6  d101              BNE      |L1.444|
                  |L1.440|
;;;324      {
;;;325        /* Set the Repetition Counter value */
;;;326        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
0001b8  7a8b              LDRB     r3,[r1,#0xa]
0001ba  8603              STRH     r3,[r0,#0x30]
                  |L1.444|
;;;327      }
;;;328    
;;;329      /* Generate an update event to reload the Prescaler 
;;;330         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;331      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
0001bc  2301              MOVS     r3,#1
0001be  8283              STRH     r3,[r0,#0x14]
;;;332    }
0001c0  4770              BX       lr
;;;333    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;339      */
;;;340    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0001c2  f04f31ff          MOV      r1,#0xffffffff
;;;341    {
;;;342      /* Set the default configuration */
;;;343      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
0001c6  6041              STR      r1,[r0,#4]
;;;344      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
0001c8  2100              MOVS     r1,#0
0001ca  8001              STRH     r1,[r0,#0]
;;;345      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
0001cc  8101              STRH     r1,[r0,#8]
;;;346      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
0001ce  8041              STRH     r1,[r0,#2]
;;;347      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
0001d0  7281              STRB     r1,[r0,#0xa]
;;;348    }
0001d2  4770              BX       lr
;;;349    
                          ENDP

                  TIM_PrescalerConfig PROC
;;;359      */
;;;360    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
0001d4  8501              STRH     r1,[r0,#0x28]
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;364      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;365      /* Set the Prescaler value */
;;;366      TIMx->PSC = Prescaler;
;;;367      /* Set or reset the UG Bit */
;;;368      TIMx->EGR = TIM_PSCReloadMode;
0001d6  8282              STRH     r2,[r0,#0x14]
;;;369    }
0001d8  4770              BX       lr
;;;370    
                          ENDP

                  TIM_CounterModeConfig PROC
;;;382      */
;;;383    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
0001da  460a              MOV      r2,r1
;;;384    {
;;;385      uint16_t tmpcr1 = 0;
0001dc  2100              MOVS     r1,#0
;;;386    
;;;387      /* Check the parameters */
;;;388      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;389      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;390    
;;;391      tmpcr1 = TIMx->CR1;
0001de  8801              LDRH     r1,[r0,#0]
;;;392    
;;;393      /* Reset the CMS and DIR Bits */
;;;394      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
0001e0  f64f738f          MOV      r3,#0xff8f
0001e4  4019              ANDS     r1,r1,r3
;;;395    
;;;396      /* Set the Counter Mode */
;;;397      tmpcr1 |= TIM_CounterMode;
0001e6  4311              ORRS     r1,r1,r2
;;;398    
;;;399      /* Write to TIMx CR1 register */
;;;400      TIMx->CR1 = tmpcr1;
0001e8  8001              STRH     r1,[r0,#0]
;;;401    }
0001ea  4770              BX       lr
;;;402    
                          ENDP

                  TIM_SetCounter PROC
;;;408      */
;;;409    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
0001ec  6241              STR      r1,[r0,#0x24]
;;;410    {
;;;411      /* Check the parameters */
;;;412       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;413    
;;;414      /* Set the Counter Register value */
;;;415      TIMx->CNT = Counter;
;;;416    }
0001ee  4770              BX       lr
;;;417    
                          ENDP

                  TIM_SetAutoreload PROC
;;;423      */
;;;424    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
0001f0  62c1              STR      r1,[r0,#0x2c]
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;428      
;;;429      /* Set the Autoreload Register value */
;;;430      TIMx->ARR = Autoreload;
;;;431    }
0001f2  4770              BX       lr
;;;432    
                          ENDP

                  TIM_GetCounter PROC
;;;437      */
;;;438    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
0001f4  4601              MOV      r1,r0
;;;439    {
;;;440      /* Check the parameters */
;;;441      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;442    
;;;443      /* Get the Counter Register value */
;;;444      return TIMx->CNT;
0001f6  6a48              LDR      r0,[r1,#0x24]
;;;445    }
0001f8  4770              BX       lr
;;;446    
                          ENDP

                  TIM_GetPrescaler PROC
;;;451      */
;;;452    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
0001fa  4601              MOV      r1,r0
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;456    
;;;457      /* Get the Prescaler Register value */
;;;458      return TIMx->PSC;
0001fc  8d08              LDRH     r0,[r1,#0x28]
;;;459    }
0001fe  4770              BX       lr
;;;460    
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;467      */
;;;468    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000200  b121              CBZ      r1,|L1.524|
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473    
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Set the Update Disable Bit */
;;;477        TIMx->CR1 |= TIM_CR1_UDIS;
000202  8802              LDRH     r2,[r0,#0]
000204  f0420202          ORR      r2,r2,#2
000208  8002              STRH     r2,[r0,#0]
00020a  e004              B        |L1.534|
                  |L1.524|
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Reset the Update Disable Bit */
;;;482        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
00020c  8802              LDRH     r2,[r0,#0]
00020e  f64f73fd          MOV      r3,#0xfffd
000212  401a              ANDS     r2,r2,r3
000214  8002              STRH     r2,[r0,#0]
                  |L1.534|
;;;483      }
;;;484    }
000216  4770              BX       lr
;;;485    
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;496      */
;;;497    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000218  b121              CBZ      r1,|L1.548|
;;;498    {
;;;499      /* Check the parameters */
;;;500      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;501      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;502    
;;;503      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;504      {
;;;505        /* Set the URS Bit */
;;;506        TIMx->CR1 |= TIM_CR1_URS;
00021a  8802              LDRH     r2,[r0,#0]
00021c  f0420204          ORR      r2,r2,#4
000220  8002              STRH     r2,[r0,#0]
000222  e004              B        |L1.558|
                  |L1.548|
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Reset the URS Bit */
;;;511        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
000224  8802              LDRH     r2,[r0,#0]
000226  f64f73fb          MOV      r3,#0xfffb
00022a  401a              ANDS     r2,r2,r3
00022c  8002              STRH     r2,[r0,#0]
                  |L1.558|
;;;512      }
;;;513    }
00022e  4770              BX       lr
;;;514    
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;521      */
;;;522    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000230  b121              CBZ      r1,|L1.572|
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527    
;;;528      if (NewState != DISABLE)
;;;529      {
;;;530        /* Set the ARR Preload Bit */
;;;531        TIMx->CR1 |= TIM_CR1_ARPE;
000232  8802              LDRH     r2,[r0,#0]
000234  f0420280          ORR      r2,r2,#0x80
000238  8002              STRH     r2,[r0,#0]
00023a  e004              B        |L1.582|
                  |L1.572|
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Reset the ARR Preload Bit */
;;;536        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
00023c  8802              LDRH     r2,[r0,#0]
00023e  f64f737f          MOV      r3,#0xff7f
000242  401a              ANDS     r2,r2,r3
000244  8002              STRH     r2,[r0,#0]
                  |L1.582|
;;;537      }
;;;538    }
000246  4770              BX       lr
;;;539    
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;548      */
;;;549    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000248  8802              LDRH     r2,[r0,#0]
;;;550    {
;;;551      /* Check the parameters */
;;;552      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;553      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;554    
;;;555      /* Reset the OPM Bit */
;;;556      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
00024a  f64f73f7          MOV      r3,#0xfff7
00024e  401a              ANDS     r2,r2,r3
000250  8002              STRH     r2,[r0,#0]
;;;557    
;;;558      /* Configure the OPM Mode */
;;;559      TIMx->CR1 |= TIM_OPMode;
000252  8802              LDRH     r2,[r0,#0]
000254  430a              ORRS     r2,r2,r1
000256  8002              STRH     r2,[r0,#0]
;;;560    }
000258  4770              BX       lr
;;;561    
                          ENDP

                  TIM_SetClockDivision PROC
;;;571      */
;;;572    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
00025a  8802              LDRH     r2,[r0,#0]
;;;573    {
;;;574      /* Check the parameters */
;;;575      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;576      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;577    
;;;578      /* Reset the CKD Bits */
;;;579      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
00025c  f64f43ff          MOV      r3,#0xfcff
000260  401a              ANDS     r2,r2,r3
000262  8002              STRH     r2,[r0,#0]
;;;580    
;;;581      /* Set the CKD value */
;;;582      TIMx->CR1 |= TIM_CKD;
000264  8802              LDRH     r2,[r0,#0]
000266  430a              ORRS     r2,r2,r1
000268  8002              STRH     r2,[r0,#0]
;;;583    }
00026a  4770              BX       lr
;;;584    
                          ENDP

                  TIM_Cmd PROC
;;;591      */
;;;592    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
00026c  b121              CBZ      r1,|L1.632|
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;596      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;597      
;;;598      if (NewState != DISABLE)
;;;599      {
;;;600        /* Enable the TIM Counter */
;;;601        TIMx->CR1 |= TIM_CR1_CEN;
00026e  8802              LDRH     r2,[r0,#0]
000270  f0420201          ORR      r2,r2,#1
000274  8002              STRH     r2,[r0,#0]
000276  e004              B        |L1.642|
                  |L1.632|
;;;602      }
;;;603      else
;;;604      {
;;;605        /* Disable the TIM Counter */
;;;606        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
000278  8802              LDRH     r2,[r0,#0]
00027a  f64f73fe          MOV      r3,#0xfffe
00027e  401a              ANDS     r2,r2,r3
000280  8002              STRH     r2,[r0,#0]
                  |L1.642|
;;;607      }
;;;608    }
000282  4770              BX       lr
;;;609    /**
                          ENDP

                  TIM_OC1Init PROC
;;;670      */
;;;671    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000284  b570              PUSH     {r4-r6,lr}
;;;672    {
;;;673      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000286  2400              MOVS     r4,#0
000288  2200              MOVS     r2,#0
00028a  2300              MOVS     r3,#0
;;;674       
;;;675      /* Check the parameters */
;;;676      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;677      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;678      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;679      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;680    
;;;681      /* Disable the Channel 1: Reset the CC1E Bit */
;;;682      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
00028c  8c05              LDRH     r5,[r0,#0x20]
00028e  f64f76fe          MOV      r6,#0xfffe
000292  4035              ANDS     r5,r5,r6
000294  8405              STRH     r5,[r0,#0x20]
;;;683      
;;;684      /* Get the TIMx CCER register value */
;;;685      tmpccer = TIMx->CCER;
000296  8c02              LDRH     r2,[r0,#0x20]
;;;686      /* Get the TIMx CR2 register value */
;;;687      tmpcr2 =  TIMx->CR2;
000298  8883              LDRH     r3,[r0,#4]
;;;688      
;;;689      /* Get the TIMx CCMR1 register value */
;;;690      tmpccmrx = TIMx->CCMR1;
00029a  8b04              LDRH     r4,[r0,#0x18]
;;;691        
;;;692      /* Reset the Output Compare Mode Bits */
;;;693      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
00029c  f64f758f          MOV      r5,#0xff8f
0002a0  402c              ANDS     r4,r4,r5
;;;694      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
0002a2  1eb5              SUBS     r5,r6,#2
0002a4  402c              ANDS     r4,r4,r5
;;;695      /* Select the Output Compare Mode */
;;;696      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
0002a6  880d              LDRH     r5,[r1,#0]
0002a8  432c              ORRS     r4,r4,r5
;;;697      
;;;698      /* Reset the Output Polarity level */
;;;699      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
0002aa  1e75              SUBS     r5,r6,#1
0002ac  402a              ANDS     r2,r2,r5
;;;700      /* Set the Output Compare Polarity */
;;;701      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
0002ae  898d              LDRH     r5,[r1,#0xc]
0002b0  432a              ORRS     r2,r2,r5
;;;702      
;;;703      /* Set the Output State */
;;;704      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
0002b2  884d              LDRH     r5,[r1,#2]
0002b4  432a              ORRS     r2,r2,r5
;;;705        
;;;706      if((TIMx == TIM1) || (TIMx == TIM8))
0002b6  4d52              LDR      r5,|L1.1024|
0002b8  42a8              CMP      r0,r5
0002ba  d002              BEQ      |L1.706|
0002bc  4d56              LDR      r5,|L1.1048|
0002be  42a8              CMP      r0,r5
0002c0  d113              BNE      |L1.746|
                  |L1.706|
;;;707      {
;;;708        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;709        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;710        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;711        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;712        
;;;713        /* Reset the Output N Polarity level */
;;;714        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
0002c2  f64f75f7          MOV      r5,#0xfff7
0002c6  402a              ANDS     r2,r2,r5
;;;715        /* Set the Output N Polarity */
;;;716        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
0002c8  89cd              LDRH     r5,[r1,#0xe]
0002ca  432a              ORRS     r2,r2,r5
;;;717        /* Reset the Output N State */
;;;718        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
0002cc  f64f75fb          MOV      r5,#0xfffb
0002d0  402a              ANDS     r2,r2,r5
;;;719        
;;;720        /* Set the Output N State */
;;;721        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
0002d2  888d              LDRH     r5,[r1,#4]
0002d4  432a              ORRS     r2,r2,r5
;;;722        /* Reset the Output Compare and Output Compare N IDLE State */
;;;723        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
0002d6  f64f65ff          MOV      r5,#0xfeff
0002da  402b              ANDS     r3,r3,r5
;;;724        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
0002dc  f64f55ff          MOV      r5,#0xfdff
0002e0  402b              ANDS     r3,r3,r5
;;;725        /* Set the Output Idle state */
;;;726        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
0002e2  8a0d              LDRH     r5,[r1,#0x10]
0002e4  432b              ORRS     r3,r3,r5
;;;727        /* Set the Output N Idle state */
;;;728        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
0002e6  8a4d              LDRH     r5,[r1,#0x12]
0002e8  432b              ORRS     r3,r3,r5
                  |L1.746|
;;;729      }
;;;730      /* Write to TIMx CR2 */
;;;731      TIMx->CR2 = tmpcr2;
0002ea  8083              STRH     r3,[r0,#4]
;;;732      
;;;733      /* Write to TIMx CCMR1 */
;;;734      TIMx->CCMR1 = tmpccmrx;
0002ec  8304              STRH     r4,[r0,#0x18]
;;;735      
;;;736      /* Set the Capture Compare Register value */
;;;737      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
0002ee  688d              LDR      r5,[r1,#8]
0002f0  6345              STR      r5,[r0,#0x34]
;;;738      
;;;739      /* Write to TIMx CCER */
;;;740      TIMx->CCER = tmpccer;
0002f2  8402              STRH     r2,[r0,#0x20]
;;;741    }
0002f4  bd70              POP      {r4-r6,pc}
;;;742    
                          ENDP

                  TIM_OC2Init PROC
;;;751      */
;;;752    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0002f6  b570              PUSH     {r4-r6,lr}
;;;753    {
;;;754      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0002f8  2400              MOVS     r4,#0
0002fa  2200              MOVS     r2,#0
0002fc  2300              MOVS     r3,#0
;;;755       
;;;756      /* Check the parameters */
;;;757      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;758      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;759      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;760      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;761    
;;;762      /* Disable the Channel 2: Reset the CC2E Bit */
;;;763      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
0002fe  8c05              LDRH     r5,[r0,#0x20]
000300  f64f76ef          MOV      r6,#0xffef
000304  4035              ANDS     r5,r5,r6
000306  8405              STRH     r5,[r0,#0x20]
;;;764      
;;;765      /* Get the TIMx CCER register value */  
;;;766      tmpccer = TIMx->CCER;
000308  8c02              LDRH     r2,[r0,#0x20]
;;;767      /* Get the TIMx CR2 register value */
;;;768      tmpcr2 =  TIMx->CR2;
00030a  8883              LDRH     r3,[r0,#4]
;;;769      
;;;770      /* Get the TIMx CCMR1 register value */
;;;771      tmpccmrx = TIMx->CCMR1;
00030c  8b04              LDRH     r4,[r0,#0x18]
;;;772        
;;;773      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;774      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
00030e  f64875ff          MOV      r5,#0x8fff
000312  402c              ANDS     r4,r4,r5
;;;775      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
000314  f64f45ff          MOV      r5,#0xfcff
000318  402c              ANDS     r4,r4,r5
;;;776      
;;;777      /* Select the Output Compare Mode */
;;;778      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00031a  880d              LDRH     r5,[r1,#0]
00031c  f64f76ff          MOV      r6,#0xffff
000320  ea062505          AND      r5,r6,r5,LSL #8
000324  432c              ORRS     r4,r4,r5
;;;779      
;;;780      /* Reset the Output Polarity level */
;;;781      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
000326  f64f75df          MOV      r5,#0xffdf
00032a  402a              ANDS     r2,r2,r5
;;;782      /* Set the Output Compare Polarity */
;;;783      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
00032c  898d              LDRH     r5,[r1,#0xc]
00032e  ea061505          AND      r5,r6,r5,LSL #4
000332  432a              ORRS     r2,r2,r5
;;;784      
;;;785      /* Set the Output State */
;;;786      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000334  884d              LDRH     r5,[r1,#2]
000336  ea061505          AND      r5,r6,r5,LSL #4
00033a  432a              ORRS     r2,r2,r5
;;;787        
;;;788      if((TIMx == TIM1) || (TIMx == TIM8))
00033c  4d30              LDR      r5,|L1.1024|
00033e  42a8              CMP      r0,r5
000340  d002              BEQ      |L1.840|
000342  4d35              LDR      r5,|L1.1048|
000344  42a8              CMP      r0,r5
000346  d11d              BNE      |L1.900|
                  |L1.840|
;;;789      {
;;;790        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;791        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;792        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;793        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;794        
;;;795        /* Reset the Output N Polarity level */
;;;796        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000348  f64f757f          MOV      r5,#0xff7f
00034c  402a              ANDS     r2,r2,r5
;;;797        /* Set the Output N Polarity */
;;;798        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
00034e  89cd              LDRH     r5,[r1,#0xe]
000350  f64f76ff          MOV      r6,#0xffff
000354  ea061505          AND      r5,r6,r5,LSL #4
000358  432a              ORRS     r2,r2,r5
;;;799        /* Reset the Output N State */
;;;800        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
00035a  f64f75bf          MOV      r5,#0xffbf
00035e  402a              ANDS     r2,r2,r5
;;;801        
;;;802        /* Set the Output N State */
;;;803        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000360  888d              LDRH     r5,[r1,#4]
000362  ea061505          AND      r5,r6,r5,LSL #4
000366  432a              ORRS     r2,r2,r5
;;;804        /* Reset the Output Compare and Output Compare N IDLE State */
;;;805        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
000368  f64f35ff          MOV      r5,#0xfbff
00036c  402b              ANDS     r3,r3,r5
;;;806        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
00036e  f24f75ff          MOV      r5,#0xf7ff
000372  402b              ANDS     r3,r3,r5
;;;807        /* Set the Output Idle state */
;;;808        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000374  8a0d              LDRH     r5,[r1,#0x10]
000376  ea060585          AND      r5,r6,r5,LSL #2
00037a  432b              ORRS     r3,r3,r5
;;;809        /* Set the Output N Idle state */
;;;810        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
00037c  8a4d              LDRH     r5,[r1,#0x12]
00037e  ea060585          AND      r5,r6,r5,LSL #2
000382  432b              ORRS     r3,r3,r5
                  |L1.900|
;;;811      }
;;;812      /* Write to TIMx CR2 */
;;;813      TIMx->CR2 = tmpcr2;
000384  8083              STRH     r3,[r0,#4]
;;;814      
;;;815      /* Write to TIMx CCMR1 */
;;;816      TIMx->CCMR1 = tmpccmrx;
000386  8304              STRH     r4,[r0,#0x18]
;;;817      
;;;818      /* Set the Capture Compare Register value */
;;;819      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000388  688d              LDR      r5,[r1,#8]
00038a  6385              STR      r5,[r0,#0x38]
;;;820      
;;;821      /* Write to TIMx CCER */
;;;822      TIMx->CCER = tmpccer;
00038c  8402              STRH     r2,[r0,#0x20]
;;;823    }
00038e  bd70              POP      {r4-r6,pc}
;;;824    
                          ENDP

                  TIM_OC3Init PROC
;;;832      */
;;;833    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000390  b570              PUSH     {r4-r6,lr}
;;;834    {
;;;835      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000392  2400              MOVS     r4,#0
000394  2200              MOVS     r2,#0
000396  2300              MOVS     r3,#0
;;;836       
;;;837      /* Check the parameters */
;;;838      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;839      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;840      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;841      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;842    
;;;843      /* Disable the Channel 3: Reset the CC2E Bit */
;;;844      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
000398  8c05              LDRH     r5,[r0,#0x20]
00039a  f64f66ff          MOV      r6,#0xfeff
00039e  4035              ANDS     r5,r5,r6
0003a0  8405              STRH     r5,[r0,#0x20]
;;;845      
;;;846      /* Get the TIMx CCER register value */
;;;847      tmpccer = TIMx->CCER;
0003a2  8c02              LDRH     r2,[r0,#0x20]
;;;848      /* Get the TIMx CR2 register value */
;;;849      tmpcr2 =  TIMx->CR2;
0003a4  8883              LDRH     r3,[r0,#4]
;;;850      
;;;851      /* Get the TIMx CCMR2 register value */
;;;852      tmpccmrx = TIMx->CCMR2;
0003a6  8b84              LDRH     r4,[r0,#0x1c]
;;;853        
;;;854      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;855      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
0003a8  f64f758f          MOV      r5,#0xff8f
0003ac  402c              ANDS     r4,r4,r5
;;;856      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
0003ae  f64f75fc          MOV      r5,#0xfffc
0003b2  402c              ANDS     r4,r4,r5
;;;857      /* Select the Output Compare Mode */
;;;858      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
0003b4  880d              LDRH     r5,[r1,#0]
0003b6  432c              ORRS     r4,r4,r5
;;;859      
;;;860      /* Reset the Output Polarity level */
;;;861      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
0003b8  f64f55ff          MOV      r5,#0xfdff
0003bc  402a              ANDS     r2,r2,r5
;;;862      /* Set the Output Compare Polarity */
;;;863      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
0003be  898d              LDRH     r5,[r1,#0xc]
0003c0  f64f76ff          MOV      r6,#0xffff
0003c4  ea062505          AND      r5,r6,r5,LSL #8
0003c8  432a              ORRS     r2,r2,r5
;;;864      
;;;865      /* Set the Output State */
;;;866      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
0003ca  884d              LDRH     r5,[r1,#2]
0003cc  ea062505          AND      r5,r6,r5,LSL #8
0003d0  432a              ORRS     r2,r2,r5
;;;867        
;;;868      if((TIMx == TIM1) || (TIMx == TIM8))
0003d2  4d0b              LDR      r5,|L1.1024|
0003d4  42a8              CMP      r0,r5
0003d6  d002              BEQ      |L1.990|
0003d8  4d0f              LDR      r5,|L1.1048|
0003da  42a8              CMP      r0,r5
0003dc  d138              BNE      |L1.1104|
                  |L1.990|
;;;869      {
;;;870        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;871        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;872        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;873        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;874        
;;;875        /* Reset the Output N Polarity level */
;;;876        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
0003de  f24f75ff          MOV      r5,#0xf7ff
0003e2  402a              ANDS     r2,r2,r5
;;;877        /* Set the Output N Polarity */
;;;878        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
0003e4  89cd              LDRH     r5,[r1,#0xe]
0003e6  f64f76ff          MOV      r6,#0xffff
0003ea  ea062505          AND      r5,r6,r5,LSL #8
0003ee  432a              ORRS     r2,r2,r5
;;;879        /* Reset the Output N State */
;;;880        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
0003f0  f64f35ff          MOV      r5,#0xfbff
0003f4  402a              ANDS     r2,r2,r5
;;;881        
;;;882        /* Set the Output N State */
;;;883        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
0003f6  888d              LDRH     r5,[r1,#4]
0003f8  ea062505          AND      r5,r6,r5,LSL #8
0003fc  432a              ORRS     r2,r2,r5
;;;884        /* Reset the Output Compare and Output Compare N IDLE State */
;;;885        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
0003fe  e019              B        |L1.1076|
                  |L1.1024|
                          DCD      0x40010000
                  |L1.1028|
                          DCD      0x40000400
                  |L1.1032|
                          DCD      0x40000800
                  |L1.1036|
                          DCD      0x40000c00
                  |L1.1040|
                          DCD      0x40001000
                  |L1.1044|
                          DCD      0x40001400
                  |L1.1048|
                          DCD      0x40010400
                  |L1.1052|
                          DCD      0x40014000
                  |L1.1056|
                          DCD      0x40014400
                  |L1.1060|
                          DCD      0x40014800
                  |L1.1064|
                          DCD      0x40001800
                  |L1.1068|
                          DCD      0x40001c00
                  |L1.1072|
                          DCD      0x40002000
                  |L1.1076|
000434  f64e75ff          MOV      r5,#0xefff
000438  402b              ANDS     r3,r3,r5
;;;886        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
00043a  f64d75ff          MOV      r5,#0xdfff
00043e  402b              ANDS     r3,r3,r5
;;;887        /* Set the Output Idle state */
;;;888        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000440  8a0d              LDRH     r5,[r1,#0x10]
000442  ea061505          AND      r5,r6,r5,LSL #4
000446  432b              ORRS     r3,r3,r5
;;;889        /* Set the Output N Idle state */
;;;890        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000448  8a4d              LDRH     r5,[r1,#0x12]
00044a  ea061505          AND      r5,r6,r5,LSL #4
00044e  432b              ORRS     r3,r3,r5
                  |L1.1104|
;;;891      }
;;;892      /* Write to TIMx CR2 */
;;;893      TIMx->CR2 = tmpcr2;
000450  8083              STRH     r3,[r0,#4]
;;;894      
;;;895      /* Write to TIMx CCMR2 */
;;;896      TIMx->CCMR2 = tmpccmrx;
000452  8384              STRH     r4,[r0,#0x1c]
;;;897      
;;;898      /* Set the Capture Compare Register value */
;;;899      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000454  688d              LDR      r5,[r1,#8]
000456  63c5              STR      r5,[r0,#0x3c]
;;;900      
;;;901      /* Write to TIMx CCER */
;;;902      TIMx->CCER = tmpccer;
000458  8402              STRH     r2,[r0,#0x20]
;;;903    }
00045a  bd70              POP      {r4-r6,pc}
;;;904    
                          ENDP

                  TIM_OC4Init PROC
;;;912      */
;;;913    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00045c  b570              PUSH     {r4-r6,lr}
;;;914    {
;;;915      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00045e  2200              MOVS     r2,#0
000460  2300              MOVS     r3,#0
000462  2400              MOVS     r4,#0
;;;916       
;;;917      /* Check the parameters */
;;;918      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;919      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;920      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;921      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;922    
;;;923      /* Disable the Channel 4: Reset the CC4E Bit */
;;;924      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000464  8c05              LDRH     r5,[r0,#0x20]
000466  f64e76ff          MOV      r6,#0xefff
00046a  4035              ANDS     r5,r5,r6
00046c  8405              STRH     r5,[r0,#0x20]
;;;925      
;;;926      /* Get the TIMx CCER register value */
;;;927      tmpccer = TIMx->CCER;
00046e  8c03              LDRH     r3,[r0,#0x20]
;;;928      /* Get the TIMx CR2 register value */
;;;929      tmpcr2 =  TIMx->CR2;
000470  8884              LDRH     r4,[r0,#4]
;;;930      
;;;931      /* Get the TIMx CCMR2 register value */
;;;932      tmpccmrx = TIMx->CCMR2;
000472  8b82              LDRH     r2,[r0,#0x1c]
;;;933        
;;;934      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;935      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
000474  f64875ff          MOV      r5,#0x8fff
000478  402a              ANDS     r2,r2,r5
;;;936      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
00047a  f64f45ff          MOV      r5,#0xfcff
00047e  402a              ANDS     r2,r2,r5
;;;937      
;;;938      /* Select the Output Compare Mode */
;;;939      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000480  880d              LDRH     r5,[r1,#0]
000482  f64f76ff          MOV      r6,#0xffff
000486  ea062505          AND      r5,r6,r5,LSL #8
00048a  432a              ORRS     r2,r2,r5
;;;940      
;;;941      /* Reset the Output Polarity level */
;;;942      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
00048c  f64d75ff          MOV      r5,#0xdfff
000490  402b              ANDS     r3,r3,r5
;;;943      /* Set the Output Compare Polarity */
;;;944      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000492  898d              LDRH     r5,[r1,#0xc]
000494  ea063505          AND      r5,r6,r5,LSL #12
000498  432b              ORRS     r3,r3,r5
;;;945      
;;;946      /* Set the Output State */
;;;947      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00049a  884d              LDRH     r5,[r1,#2]
00049c  ea063505          AND      r5,r6,r5,LSL #12
0004a0  432b              ORRS     r3,r3,r5
;;;948      
;;;949      if((TIMx == TIM1) || (TIMx == TIM8))
0004a2  4dfe              LDR      r5,|L1.2204|
0004a4  42a8              CMP      r0,r5
0004a6  d002              BEQ      |L1.1198|
0004a8  4dfd              LDR      r5,|L1.2208|
0004aa  42a8              CMP      r0,r5
0004ac  d108              BNE      |L1.1216|
                  |L1.1198|
;;;950      {
;;;951        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;952        /* Reset the Output Compare IDLE State */
;;;953        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
0004ae  f64b75ff          MOV      r5,#0xbfff
0004b2  402c              ANDS     r4,r4,r5
;;;954        /* Set the Output Idle state */
;;;955        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0004b4  8a0d              LDRH     r5,[r1,#0x10]
0004b6  f64f76ff          MOV      r6,#0xffff
0004ba  ea061585          AND      r5,r6,r5,LSL #6
0004be  432c              ORRS     r4,r4,r5
                  |L1.1216|
;;;956      }
;;;957      /* Write to TIMx CR2 */
;;;958      TIMx->CR2 = tmpcr2;
0004c0  8084              STRH     r4,[r0,#4]
;;;959      
;;;960      /* Write to TIMx CCMR2 */  
;;;961      TIMx->CCMR2 = tmpccmrx;
0004c2  8382              STRH     r2,[r0,#0x1c]
;;;962        
;;;963      /* Set the Capture Compare Register value */
;;;964      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0004c4  688d              LDR      r5,[r1,#8]
0004c6  6405              STR      r5,[r0,#0x40]
;;;965      
;;;966      /* Write to TIMx CCER */
;;;967      TIMx->CCER = tmpccer;
0004c8  8403              STRH     r3,[r0,#0x20]
;;;968    }
0004ca  bd70              POP      {r4-r6,pc}
;;;969    
                          ENDP

                  TIM_OCStructInit PROC
;;;975      */
;;;976    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
0004cc  2100              MOVS     r1,#0
;;;977    {
;;;978      /* Set the default configuration */
;;;979      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
0004ce  8001              STRH     r1,[r0,#0]
;;;980      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
0004d0  8041              STRH     r1,[r0,#2]
;;;981      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
0004d2  8081              STRH     r1,[r0,#4]
;;;982      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
0004d4  6081              STR      r1,[r0,#8]
;;;983      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
0004d6  8181              STRH     r1,[r0,#0xc]
;;;984      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
0004d8  81c1              STRH     r1,[r0,#0xe]
;;;985      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
0004da  8201              STRH     r1,[r0,#0x10]
;;;986      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
0004dc  8241              STRH     r1,[r0,#0x12]
;;;987    }
0004de  4770              BX       lr
;;;988    
                          ENDP

                  TIM_SelectOCxM PROC
;;;1011     */
;;;1012   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
0004e0  b570              PUSH     {r4-r6,lr}
;;;1013   {
0004e2  4603              MOV      r3,r0
;;;1014     uint32_t tmp = 0;
0004e4  2000              MOVS     r0,#0
;;;1015     uint16_t tmp1 = 0;
0004e6  2400              MOVS     r4,#0
;;;1016   
;;;1017     /* Check the parameters */
;;;1018     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1019     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1020     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1021   
;;;1022     tmp = (uint32_t) TIMx;
0004e8  4618              MOV      r0,r3
;;;1023     tmp += CCMR_OFFSET;
0004ea  3018              ADDS     r0,r0,#0x18
;;;1024   
;;;1025     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
0004ec  2501              MOVS     r5,#1
0004ee  408d              LSLS     r5,r5,r1
0004f0  b2ac              UXTH     r4,r5
;;;1026   
;;;1027     /* Disable the Channel: Reset the CCxE Bit */
;;;1028     TIMx->CCER &= (uint16_t) ~tmp1;
0004f2  8c1d              LDRH     r5,[r3,#0x20]
0004f4  43a5              BICS     r5,r5,r4
0004f6  841d              STRH     r5,[r3,#0x20]
;;;1029   
;;;1030     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
0004f8  b109              CBZ      r1,|L1.1278|
0004fa  2908              CMP      r1,#8
0004fc  d10a              BNE      |L1.1300|
                  |L1.1278|
;;;1031     {
;;;1032       tmp += (TIM_Channel>>1);
0004fe  eb000061          ADD      r0,r0,r1,ASR #1
;;;1033   
;;;1034       /* Reset the OCxM bits in the CCMRx register */
;;;1035       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
000502  6805              LDR      r5,[r0,#0]
000504  f64f768f          MOV      r6,#0xff8f
000508  4035              ANDS     r5,r5,r6
00050a  6005              STR      r5,[r0,#0]
;;;1036      
;;;1037       /* Configure the OCxM bits in the CCMRx register */
;;;1038       *(__IO uint32_t *) tmp |= TIM_OCMode;
00050c  6805              LDR      r5,[r0,#0]
00050e  4315              ORRS     r5,r5,r2
000510  6005              STR      r5,[r0,#0]
000512  e00f              B        |L1.1332|
                  |L1.1300|
;;;1039     }
;;;1040     else
;;;1041     {
;;;1042       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000514  1f0d              SUBS     r5,r1,#4
000516  f3c5054e          UBFX     r5,r5,#1,#15
00051a  4428              ADD      r0,r0,r5
;;;1043   
;;;1044       /* Reset the OCxM bits in the CCMRx register */
;;;1045       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
00051c  6805              LDR      r5,[r0,#0]
00051e  f64876ff          MOV      r6,#0x8fff
000522  4035              ANDS     r5,r5,r6
000524  6005              STR      r5,[r0,#0]
;;;1046       
;;;1047       /* Configure the OCxM bits in the CCMRx register */
;;;1048       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000526  6805              LDR      r5,[r0,#0]
000528  f64f76ff          MOV      r6,#0xffff
00052c  ea062602          AND      r6,r6,r2,LSL #8
000530  4335              ORRS     r5,r5,r6
000532  6005              STR      r5,[r0,#0]
                  |L1.1332|
;;;1049     }
;;;1050   }
000534  bd70              POP      {r4-r6,pc}
;;;1051   
                          ENDP

                  TIM_SetCompare1 PROC
;;;1057     */
;;;1058   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000536  6341              STR      r1,[r0,#0x34]
;;;1059   {
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1062   
;;;1063     /* Set the Capture Compare1 Register value */
;;;1064     TIMx->CCR1 = Compare1;
;;;1065   }
000538  4770              BX       lr
;;;1066   
                          ENDP

                  TIM_SetCompare2 PROC
;;;1073     */
;;;1074   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
00053a  6381              STR      r1,[r0,#0x38]
;;;1075   {
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1078   
;;;1079     /* Set the Capture Compare2 Register value */
;;;1080     TIMx->CCR2 = Compare2;
;;;1081   }
00053c  4770              BX       lr
;;;1082   
                          ENDP

                  TIM_SetCompare3 PROC
;;;1088     */
;;;1089   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
00053e  63c1              STR      r1,[r0,#0x3c]
;;;1090   {
;;;1091     /* Check the parameters */
;;;1092     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1093   
;;;1094     /* Set the Capture Compare3 Register value */
;;;1095     TIMx->CCR3 = Compare3;
;;;1096   }
000540  4770              BX       lr
;;;1097   
                          ENDP

                  TIM_SetCompare4 PROC
;;;1103     */
;;;1104   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000542  6401              STR      r1,[r0,#0x40]
;;;1105   {
;;;1106     /* Check the parameters */
;;;1107     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1108   
;;;1109     /* Set the Capture Compare4 Register value */
;;;1110     TIMx->CCR4 = Compare4;
;;;1111   }
000544  4770              BX       lr
;;;1112   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1121     */
;;;1122   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000546  460a              MOV      r2,r1
;;;1123   {
;;;1124     uint16_t tmpccmr1 = 0;
000548  2100              MOVS     r1,#0
;;;1125   
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1128     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1129     tmpccmr1 = TIMx->CCMR1;
00054a  8b01              LDRH     r1,[r0,#0x18]
;;;1130   
;;;1131     /* Reset the OC1M Bits */
;;;1132     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
00054c  f64f738f          MOV      r3,#0xff8f
000550  4019              ANDS     r1,r1,r3
;;;1133   
;;;1134     /* Configure The Forced output Mode */
;;;1135     tmpccmr1 |= TIM_ForcedAction;
000552  4311              ORRS     r1,r1,r2
;;;1136   
;;;1137     /* Write to TIMx CCMR1 register */
;;;1138     TIMx->CCMR1 = tmpccmr1;
000554  8301              STRH     r1,[r0,#0x18]
;;;1139   }
000556  4770              BX       lr
;;;1140   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1150     */
;;;1151   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000558  460a              MOV      r2,r1
;;;1152   {
;;;1153     uint16_t tmpccmr1 = 0;
00055a  2100              MOVS     r1,#0
;;;1154   
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1157     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1158     tmpccmr1 = TIMx->CCMR1;
00055c  8b01              LDRH     r1,[r0,#0x18]
;;;1159   
;;;1160     /* Reset the OC2M Bits */
;;;1161     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
00055e  f64873ff          MOV      r3,#0x8fff
000562  4019              ANDS     r1,r1,r3
;;;1162   
;;;1163     /* Configure The Forced output Mode */
;;;1164     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000564  f64f73ff          MOV      r3,#0xffff
000568  ea032302          AND      r3,r3,r2,LSL #8
00056c  4319              ORRS     r1,r1,r3
;;;1165   
;;;1166     /* Write to TIMx CCMR1 register */
;;;1167     TIMx->CCMR1 = tmpccmr1;
00056e  8301              STRH     r1,[r0,#0x18]
;;;1168   }
000570  4770              BX       lr
;;;1169   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1178     */
;;;1179   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000572  460a              MOV      r2,r1
;;;1180   {
;;;1181     uint16_t tmpccmr2 = 0;
000574  2100              MOVS     r1,#0
;;;1182   
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1185     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1186   
;;;1187     tmpccmr2 = TIMx->CCMR2;
000576  8b81              LDRH     r1,[r0,#0x1c]
;;;1188   
;;;1189     /* Reset the OC1M Bits */
;;;1190     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000578  f64f738f          MOV      r3,#0xff8f
00057c  4019              ANDS     r1,r1,r3
;;;1191   
;;;1192     /* Configure The Forced output Mode */
;;;1193     tmpccmr2 |= TIM_ForcedAction;
00057e  4311              ORRS     r1,r1,r2
;;;1194   
;;;1195     /* Write to TIMx CCMR2 register */
;;;1196     TIMx->CCMR2 = tmpccmr2;
000580  8381              STRH     r1,[r0,#0x1c]
;;;1197   }
000582  4770              BX       lr
;;;1198   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1207     */
;;;1208   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000584  460a              MOV      r2,r1
;;;1209   {
;;;1210     uint16_t tmpccmr2 = 0;
000586  2100              MOVS     r1,#0
;;;1211   
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1214     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1215     tmpccmr2 = TIMx->CCMR2;
000588  8b81              LDRH     r1,[r0,#0x1c]
;;;1216   
;;;1217     /* Reset the OC2M Bits */
;;;1218     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
00058a  f64873ff          MOV      r3,#0x8fff
00058e  4019              ANDS     r1,r1,r3
;;;1219   
;;;1220     /* Configure The Forced output Mode */
;;;1221     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000590  f64f73ff          MOV      r3,#0xffff
000594  ea032302          AND      r3,r3,r2,LSL #8
000598  4319              ORRS     r1,r1,r3
;;;1222   
;;;1223     /* Write to TIMx CCMR2 register */
;;;1224     TIMx->CCMR2 = tmpccmr2;
00059a  8381              STRH     r1,[r0,#0x1c]
;;;1225   }
00059c  4770              BX       lr
;;;1226   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1235     */
;;;1236   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
00059e  460a              MOV      r2,r1
;;;1237   {
;;;1238     uint16_t tmpccmr1 = 0;
0005a0  2100              MOVS     r1,#0
;;;1239   
;;;1240     /* Check the parameters */
;;;1241     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1242     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1243   
;;;1244     tmpccmr1 = TIMx->CCMR1;
0005a2  8b01              LDRH     r1,[r0,#0x18]
;;;1245   
;;;1246     /* Reset the OC1PE Bit */
;;;1247     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
0005a4  f64f73f7          MOV      r3,#0xfff7
0005a8  4019              ANDS     r1,r1,r3
;;;1248   
;;;1249     /* Enable or Disable the Output Compare Preload feature */
;;;1250     tmpccmr1 |= TIM_OCPreload;
0005aa  4311              ORRS     r1,r1,r2
;;;1251   
;;;1252     /* Write to TIMx CCMR1 register */
;;;1253     TIMx->CCMR1 = tmpccmr1;
0005ac  8301              STRH     r1,[r0,#0x18]
;;;1254   }
0005ae  4770              BX       lr
;;;1255   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1265     */
;;;1266   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0005b0  460a              MOV      r2,r1
;;;1267   {
;;;1268     uint16_t tmpccmr1 = 0;
0005b2  2100              MOVS     r1,#0
;;;1269   
;;;1270     /* Check the parameters */
;;;1271     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1272     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1273   
;;;1274     tmpccmr1 = TIMx->CCMR1;
0005b4  8b01              LDRH     r1,[r0,#0x18]
;;;1275   
;;;1276     /* Reset the OC2PE Bit */
;;;1277     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
0005b6  f24f73ff          MOV      r3,#0xf7ff
0005ba  4019              ANDS     r1,r1,r3
;;;1278   
;;;1279     /* Enable or Disable the Output Compare Preload feature */
;;;1280     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
0005bc  f64f73ff          MOV      r3,#0xffff
0005c0  ea032302          AND      r3,r3,r2,LSL #8
0005c4  4319              ORRS     r1,r1,r3
;;;1281   
;;;1282     /* Write to TIMx CCMR1 register */
;;;1283     TIMx->CCMR1 = tmpccmr1;
0005c6  8301              STRH     r1,[r0,#0x18]
;;;1284   }
0005c8  4770              BX       lr
;;;1285   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1294     */
;;;1295   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0005ca  460a              MOV      r2,r1
;;;1296   {
;;;1297     uint16_t tmpccmr2 = 0;
0005cc  2100              MOVS     r1,#0
;;;1298   
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1301     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1302   
;;;1303     tmpccmr2 = TIMx->CCMR2;
0005ce  8b81              LDRH     r1,[r0,#0x1c]
;;;1304   
;;;1305     /* Reset the OC3PE Bit */
;;;1306     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
0005d0  f64f73f7          MOV      r3,#0xfff7
0005d4  4019              ANDS     r1,r1,r3
;;;1307   
;;;1308     /* Enable or Disable the Output Compare Preload feature */
;;;1309     tmpccmr2 |= TIM_OCPreload;
0005d6  4311              ORRS     r1,r1,r2
;;;1310   
;;;1311     /* Write to TIMx CCMR2 register */
;;;1312     TIMx->CCMR2 = tmpccmr2;
0005d8  8381              STRH     r1,[r0,#0x1c]
;;;1313   }
0005da  4770              BX       lr
;;;1314   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1323     */
;;;1324   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0005dc  460a              MOV      r2,r1
;;;1325   {
;;;1326     uint16_t tmpccmr2 = 0;
0005de  2100              MOVS     r1,#0
;;;1327   
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1330     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1331   
;;;1332     tmpccmr2 = TIMx->CCMR2;
0005e0  8b81              LDRH     r1,[r0,#0x1c]
;;;1333   
;;;1334     /* Reset the OC4PE Bit */
;;;1335     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
0005e2  f24f73ff          MOV      r3,#0xf7ff
0005e6  4019              ANDS     r1,r1,r3
;;;1336   
;;;1337     /* Enable or Disable the Output Compare Preload feature */
;;;1338     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
0005e8  f64f73ff          MOV      r3,#0xffff
0005ec  ea032302          AND      r3,r3,r2,LSL #8
0005f0  4319              ORRS     r1,r1,r3
;;;1339   
;;;1340     /* Write to TIMx CCMR2 register */
;;;1341     TIMx->CCMR2 = tmpccmr2;
0005f2  8381              STRH     r1,[r0,#0x1c]
;;;1342   }
0005f4  4770              BX       lr
;;;1343   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1352     */
;;;1353   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0005f6  460a              MOV      r2,r1
;;;1354   {
;;;1355     uint16_t tmpccmr1 = 0;
0005f8  2100              MOVS     r1,#0
;;;1356   
;;;1357     /* Check the parameters */
;;;1358     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1359     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1360   
;;;1361     /* Get the TIMx CCMR1 register value */
;;;1362     tmpccmr1 = TIMx->CCMR1;
0005fa  8b01              LDRH     r1,[r0,#0x18]
;;;1363   
;;;1364     /* Reset the OC1FE Bit */
;;;1365     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
0005fc  f64f73fb          MOV      r3,#0xfffb
000600  4019              ANDS     r1,r1,r3
;;;1366   
;;;1367     /* Enable or Disable the Output Compare Fast Bit */
;;;1368     tmpccmr1 |= TIM_OCFast;
000602  4311              ORRS     r1,r1,r2
;;;1369   
;;;1370     /* Write to TIMx CCMR1 */
;;;1371     TIMx->CCMR1 = tmpccmr1;
000604  8301              STRH     r1,[r0,#0x18]
;;;1372   }
000606  4770              BX       lr
;;;1373   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1383     */
;;;1384   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000608  460a              MOV      r2,r1
;;;1385   {
;;;1386     uint16_t tmpccmr1 = 0;
00060a  2100              MOVS     r1,#0
;;;1387   
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1390     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1391   
;;;1392     /* Get the TIMx CCMR1 register value */
;;;1393     tmpccmr1 = TIMx->CCMR1;
00060c  8b01              LDRH     r1,[r0,#0x18]
;;;1394   
;;;1395     /* Reset the OC2FE Bit */
;;;1396     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
00060e  f64f33ff          MOV      r3,#0xfbff
000612  4019              ANDS     r1,r1,r3
;;;1397   
;;;1398     /* Enable or Disable the Output Compare Fast Bit */
;;;1399     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000614  f64f73ff          MOV      r3,#0xffff
000618  ea032302          AND      r3,r3,r2,LSL #8
00061c  4319              ORRS     r1,r1,r3
;;;1400   
;;;1401     /* Write to TIMx CCMR1 */
;;;1402     TIMx->CCMR1 = tmpccmr1;
00061e  8301              STRH     r1,[r0,#0x18]
;;;1403   }
000620  4770              BX       lr
;;;1404   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1413     */
;;;1414   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000622  460a              MOV      r2,r1
;;;1415   {
;;;1416     uint16_t tmpccmr2 = 0;
000624  2100              MOVS     r1,#0
;;;1417     
;;;1418     /* Check the parameters */
;;;1419     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1420     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1421   
;;;1422     /* Get the TIMx CCMR2 register value */
;;;1423     tmpccmr2 = TIMx->CCMR2;
000626  8b81              LDRH     r1,[r0,#0x1c]
;;;1424   
;;;1425     /* Reset the OC3FE Bit */
;;;1426     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000628  f64f73fb          MOV      r3,#0xfffb
00062c  4019              ANDS     r1,r1,r3
;;;1427   
;;;1428     /* Enable or Disable the Output Compare Fast Bit */
;;;1429     tmpccmr2 |= TIM_OCFast;
00062e  4311              ORRS     r1,r1,r2
;;;1430   
;;;1431     /* Write to TIMx CCMR2 */
;;;1432     TIMx->CCMR2 = tmpccmr2;
000630  8381              STRH     r1,[r0,#0x1c]
;;;1433   }
000632  4770              BX       lr
;;;1434   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1443     */
;;;1444   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000634  460a              MOV      r2,r1
;;;1445   {
;;;1446     uint16_t tmpccmr2 = 0;
000636  2100              MOVS     r1,#0
;;;1447   
;;;1448     /* Check the parameters */
;;;1449     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1450     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1451   
;;;1452     /* Get the TIMx CCMR2 register value */
;;;1453     tmpccmr2 = TIMx->CCMR2;
000638  8b81              LDRH     r1,[r0,#0x1c]
;;;1454   
;;;1455     /* Reset the OC4FE Bit */
;;;1456     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
00063a  f64f33ff          MOV      r3,#0xfbff
00063e  4019              ANDS     r1,r1,r3
;;;1457   
;;;1458     /* Enable or Disable the Output Compare Fast Bit */
;;;1459     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000640  f64f73ff          MOV      r3,#0xffff
000644  ea032302          AND      r3,r3,r2,LSL #8
000648  4319              ORRS     r1,r1,r3
;;;1460   
;;;1461     /* Write to TIMx CCMR2 */
;;;1462     TIMx->CCMR2 = tmpccmr2;
00064a  8381              STRH     r1,[r0,#0x1c]
;;;1463   }
00064c  4770              BX       lr
;;;1464   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1473     */
;;;1474   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
00064e  460a              MOV      r2,r1
;;;1475   {
;;;1476     uint16_t tmpccmr1 = 0;
000650  2100              MOVS     r1,#0
;;;1477   
;;;1478     /* Check the parameters */
;;;1479     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1480     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1481   
;;;1482     tmpccmr1 = TIMx->CCMR1;
000652  8b01              LDRH     r1,[r0,#0x18]
;;;1483   
;;;1484     /* Reset the OC1CE Bit */
;;;1485     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000654  f64f737f          MOV      r3,#0xff7f
000658  4019              ANDS     r1,r1,r3
;;;1486   
;;;1487     /* Enable or Disable the Output Compare Clear Bit */
;;;1488     tmpccmr1 |= TIM_OCClear;
00065a  4311              ORRS     r1,r1,r2
;;;1489   
;;;1490     /* Write to TIMx CCMR1 register */
;;;1491     TIMx->CCMR1 = tmpccmr1;
00065c  8301              STRH     r1,[r0,#0x18]
;;;1492   }
00065e  4770              BX       lr
;;;1493   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1503     */
;;;1504   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000660  460a              MOV      r2,r1
;;;1505   {
;;;1506     uint16_t tmpccmr1 = 0;
000662  2100              MOVS     r1,#0
;;;1507   
;;;1508     /* Check the parameters */
;;;1509     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1510     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1511   
;;;1512     tmpccmr1 = TIMx->CCMR1;
000664  8b01              LDRH     r1,[r0,#0x18]
;;;1513   
;;;1514     /* Reset the OC2CE Bit */
;;;1515     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
000666  f3c1010e          UBFX     r1,r1,#0,#15
;;;1516   
;;;1517     /* Enable or Disable the Output Compare Clear Bit */
;;;1518     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00066a  f64f73ff          MOV      r3,#0xffff
00066e  ea032302          AND      r3,r3,r2,LSL #8
000672  4319              ORRS     r1,r1,r3
;;;1519   
;;;1520     /* Write to TIMx CCMR1 register */
;;;1521     TIMx->CCMR1 = tmpccmr1;
000674  8301              STRH     r1,[r0,#0x18]
;;;1522   }
000676  4770              BX       lr
;;;1523   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1532     */
;;;1533   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000678  460a              MOV      r2,r1
;;;1534   {
;;;1535     uint16_t tmpccmr2 = 0;
00067a  2100              MOVS     r1,#0
;;;1536   
;;;1537     /* Check the parameters */
;;;1538     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1539     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1540   
;;;1541     tmpccmr2 = TIMx->CCMR2;
00067c  8b81              LDRH     r1,[r0,#0x1c]
;;;1542   
;;;1543     /* Reset the OC3CE Bit */
;;;1544     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
00067e  f64f737f          MOV      r3,#0xff7f
000682  4019              ANDS     r1,r1,r3
;;;1545   
;;;1546     /* Enable or Disable the Output Compare Clear Bit */
;;;1547     tmpccmr2 |= TIM_OCClear;
000684  4311              ORRS     r1,r1,r2
;;;1548   
;;;1549     /* Write to TIMx CCMR2 register */
;;;1550     TIMx->CCMR2 = tmpccmr2;
000686  8381              STRH     r1,[r0,#0x1c]
;;;1551   }
000688  4770              BX       lr
;;;1552   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1561     */
;;;1562   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
00068a  460a              MOV      r2,r1
;;;1563   {
;;;1564     uint16_t tmpccmr2 = 0;
00068c  2100              MOVS     r1,#0
;;;1565   
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1568     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1569   
;;;1570     tmpccmr2 = TIMx->CCMR2;
00068e  8b81              LDRH     r1,[r0,#0x1c]
;;;1571   
;;;1572     /* Reset the OC4CE Bit */
;;;1573     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
000690  f3c1010e          UBFX     r1,r1,#0,#15
;;;1574   
;;;1575     /* Enable or Disable the Output Compare Clear Bit */
;;;1576     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000694  f64f73ff          MOV      r3,#0xffff
000698  ea032302          AND      r3,r3,r2,LSL #8
00069c  4319              ORRS     r1,r1,r3
;;;1577   
;;;1578     /* Write to TIMx CCMR2 register */
;;;1579     TIMx->CCMR2 = tmpccmr2;
00069e  8381              STRH     r1,[r0,#0x1c]
;;;1580   }
0006a0  4770              BX       lr
;;;1581   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1590     */
;;;1591   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0006a2  460a              MOV      r2,r1
;;;1592   {
;;;1593     uint16_t tmpccer = 0;
0006a4  2100              MOVS     r1,#0
;;;1594   
;;;1595     /* Check the parameters */
;;;1596     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1597     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1598   
;;;1599     tmpccer = TIMx->CCER;
0006a6  8c01              LDRH     r1,[r0,#0x20]
;;;1600   
;;;1601     /* Set or Reset the CC1P Bit */
;;;1602     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
0006a8  f64f73fd          MOV      r3,#0xfffd
0006ac  4019              ANDS     r1,r1,r3
;;;1603     tmpccer |= TIM_OCPolarity;
0006ae  4311              ORRS     r1,r1,r2
;;;1604   
;;;1605     /* Write to TIMx CCER register */
;;;1606     TIMx->CCER = tmpccer;
0006b0  8401              STRH     r1,[r0,#0x20]
;;;1607   }
0006b2  4770              BX       lr
;;;1608   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1617     */
;;;1618   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0006b4  460a              MOV      r2,r1
;;;1619   {
;;;1620     uint16_t tmpccer = 0;
0006b6  2100              MOVS     r1,#0
;;;1621     /* Check the parameters */
;;;1622     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1623     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1624      
;;;1625     tmpccer = TIMx->CCER;
0006b8  8c01              LDRH     r1,[r0,#0x20]
;;;1626   
;;;1627     /* Set or Reset the CC1NP Bit */
;;;1628     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
0006ba  f64f73f7          MOV      r3,#0xfff7
0006be  4019              ANDS     r1,r1,r3
;;;1629     tmpccer |= TIM_OCNPolarity;
0006c0  4311              ORRS     r1,r1,r2
;;;1630   
;;;1631     /* Write to TIMx CCER register */
;;;1632     TIMx->CCER = tmpccer;
0006c2  8401              STRH     r1,[r0,#0x20]
;;;1633   }
0006c4  4770              BX       lr
;;;1634   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1644     */
;;;1645   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0006c6  460a              MOV      r2,r1
;;;1646   {
;;;1647     uint16_t tmpccer = 0;
0006c8  2100              MOVS     r1,#0
;;;1648   
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1651     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1652   
;;;1653     tmpccer = TIMx->CCER;
0006ca  8c01              LDRH     r1,[r0,#0x20]
;;;1654   
;;;1655     /* Set or Reset the CC2P Bit */
;;;1656     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
0006cc  f64f73df          MOV      r3,#0xffdf
0006d0  4019              ANDS     r1,r1,r3
;;;1657     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
0006d2  f64f73ff          MOV      r3,#0xffff
0006d6  ea031302          AND      r3,r3,r2,LSL #4
0006da  4319              ORRS     r1,r1,r3
;;;1658   
;;;1659     /* Write to TIMx CCER register */
;;;1660     TIMx->CCER = tmpccer;
0006dc  8401              STRH     r1,[r0,#0x20]
;;;1661   }
0006de  4770              BX       lr
;;;1662   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1671     */
;;;1672   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0006e0  460a              MOV      r2,r1
;;;1673   {
;;;1674     uint16_t tmpccer = 0;
0006e2  2100              MOVS     r1,#0
;;;1675   
;;;1676     /* Check the parameters */
;;;1677     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1678     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1679     
;;;1680     tmpccer = TIMx->CCER;
0006e4  8c01              LDRH     r1,[r0,#0x20]
;;;1681   
;;;1682     /* Set or Reset the CC2NP Bit */
;;;1683     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
0006e6  f64f737f          MOV      r3,#0xff7f
0006ea  4019              ANDS     r1,r1,r3
;;;1684     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
0006ec  f64f73ff          MOV      r3,#0xffff
0006f0  ea031302          AND      r3,r3,r2,LSL #4
0006f4  4319              ORRS     r1,r1,r3
;;;1685   
;;;1686     /* Write to TIMx CCER register */
;;;1687     TIMx->CCER = tmpccer;
0006f6  8401              STRH     r1,[r0,#0x20]
;;;1688   }
0006f8  4770              BX       lr
;;;1689   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1698     */
;;;1699   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0006fa  460a              MOV      r2,r1
;;;1700   {
;;;1701     uint16_t tmpccer = 0;
0006fc  2100              MOVS     r1,#0
;;;1702   
;;;1703     /* Check the parameters */
;;;1704     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1705     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1706   
;;;1707     tmpccer = TIMx->CCER;
0006fe  8c01              LDRH     r1,[r0,#0x20]
;;;1708   
;;;1709     /* Set or Reset the CC3P Bit */
;;;1710     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000700  f64f53ff          MOV      r3,#0xfdff
000704  4019              ANDS     r1,r1,r3
;;;1711     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000706  f64f73ff          MOV      r3,#0xffff
00070a  ea032302          AND      r3,r3,r2,LSL #8
00070e  4319              ORRS     r1,r1,r3
;;;1712   
;;;1713     /* Write to TIMx CCER register */
;;;1714     TIMx->CCER = tmpccer;
000710  8401              STRH     r1,[r0,#0x20]
;;;1715   }
000712  4770              BX       lr
;;;1716   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1725     */
;;;1726   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000714  460a              MOV      r2,r1
;;;1727   {
;;;1728     uint16_t tmpccer = 0;
000716  2100              MOVS     r1,#0
;;;1729    
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1733       
;;;1734     tmpccer = TIMx->CCER;
000718  8c01              LDRH     r1,[r0,#0x20]
;;;1735   
;;;1736     /* Set or Reset the CC3NP Bit */
;;;1737     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
00071a  f24f73ff          MOV      r3,#0xf7ff
00071e  4019              ANDS     r1,r1,r3
;;;1738     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000720  f64f73ff          MOV      r3,#0xffff
000724  ea032302          AND      r3,r3,r2,LSL #8
000728  4319              ORRS     r1,r1,r3
;;;1739   
;;;1740     /* Write to TIMx CCER register */
;;;1741     TIMx->CCER = tmpccer;
00072a  8401              STRH     r1,[r0,#0x20]
;;;1742   }
00072c  4770              BX       lr
;;;1743   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1752     */
;;;1753   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00072e  460a              MOV      r2,r1
;;;1754   {
;;;1755     uint16_t tmpccer = 0;
000730  2100              MOVS     r1,#0
;;;1756   
;;;1757     /* Check the parameters */
;;;1758     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1759     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1760   
;;;1761     tmpccer = TIMx->CCER;
000732  8c01              LDRH     r1,[r0,#0x20]
;;;1762   
;;;1763     /* Set or Reset the CC4P Bit */
;;;1764     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000734  f64d73ff          MOV      r3,#0xdfff
000738  4019              ANDS     r1,r1,r3
;;;1765     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00073a  f64f73ff          MOV      r3,#0xffff
00073e  ea033302          AND      r3,r3,r2,LSL #12
000742  4319              ORRS     r1,r1,r3
;;;1766   
;;;1767     /* Write to TIMx CCER register */
;;;1768     TIMx->CCER = tmpccer;
000744  8401              STRH     r1,[r0,#0x20]
;;;1769   }
000746  4770              BX       lr
;;;1770   
                          ENDP

                  TIM_CCxCmd PROC
;;;1783     */
;;;1784   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000748  b530              PUSH     {r4,r5,lr}
;;;1785   {
;;;1786     uint16_t tmp = 0;
00074a  2300              MOVS     r3,#0
;;;1787   
;;;1788     /* Check the parameters */
;;;1789     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1790     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1791     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1792   
;;;1793     tmp = CCER_CCE_SET << TIM_Channel;
00074c  2401              MOVS     r4,#1
00074e  408c              LSLS     r4,r4,r1
000750  b2a3              UXTH     r3,r4
;;;1794   
;;;1795     /* Reset the CCxE Bit */
;;;1796     TIMx->CCER &= (uint16_t)~ tmp;
000752  8c04              LDRH     r4,[r0,#0x20]
000754  439c              BICS     r4,r4,r3
000756  8404              STRH     r4,[r0,#0x20]
;;;1797   
;;;1798     /* Set or reset the CCxE Bit */ 
;;;1799     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000758  8c04              LDRH     r4,[r0,#0x20]
00075a  fa02f501          LSL      r5,r2,r1
00075e  b2ad              UXTH     r5,r5
000760  432c              ORRS     r4,r4,r5
000762  8404              STRH     r4,[r0,#0x20]
;;;1800   }
000764  bd30              POP      {r4,r5,pc}
;;;1801   
                          ENDP

                  TIM_CCxNCmd PROC
;;;1813     */
;;;1814   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000766  b530              PUSH     {r4,r5,lr}
;;;1815   {
;;;1816     uint16_t tmp = 0;
000768  2300              MOVS     r3,#0
;;;1817   
;;;1818     /* Check the parameters */
;;;1819     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1820     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1821     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1822   
;;;1823     tmp = CCER_CCNE_SET << TIM_Channel;
00076a  2404              MOVS     r4,#4
00076c  408c              LSLS     r4,r4,r1
00076e  b2a3              UXTH     r3,r4
;;;1824   
;;;1825     /* Reset the CCxNE Bit */
;;;1826     TIMx->CCER &= (uint16_t) ~tmp;
000770  8c04              LDRH     r4,[r0,#0x20]
000772  439c              BICS     r4,r4,r3
000774  8404              STRH     r4,[r0,#0x20]
;;;1827   
;;;1828     /* Set or reset the CCxNE Bit */ 
;;;1829     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000776  8c04              LDRH     r4,[r0,#0x20]
000778  fa02f501          LSL      r5,r2,r1
00077c  b2ad              UXTH     r5,r5
00077e  432c              ORRS     r4,r4,r5
000780  8404              STRH     r4,[r0,#0x20]
;;;1830   }
000782  bd30              POP      {r4,r5,pc}
;;;1831   /**
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2163     */
;;;2164   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000784  8b82              LDRH     r2,[r0,#0x1c]
;;;2165   {  
;;;2166     /* Check the parameters */
;;;2167     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2168     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2169   
;;;2170     /* Reset the IC4PSC Bits */
;;;2171     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000786  f24f33ff          MOV      r3,#0xf3ff
00078a  401a              ANDS     r2,r2,r3
00078c  8382              STRH     r2,[r0,#0x1c]
;;;2172   
;;;2173     /* Set the IC4PSC value */
;;;2174     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00078e  8b82              LDRH     r2,[r0,#0x1c]
000790  f64f73ff          MOV      r3,#0xffff
000794  ea032301          AND      r3,r3,r1,LSL #8
000798  431a              ORRS     r2,r2,r3
00079a  8382              STRH     r2,[r0,#0x1c]
;;;2175   }
00079c  4770              BX       lr
;;;2176   /**
                          ENDP

                  TI4_Config PROC
;;;3320     */
;;;3321   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00079e  b5f0              PUSH     {r4-r7,lr}
;;;3322                          uint16_t TIM_ICFilter)
;;;3323   {
0007a0  460c              MOV      r4,r1
0007a2  4615              MOV      r5,r2
;;;3324     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
0007a4  2100              MOVS     r1,#0
0007a6  2200              MOVS     r2,#0
0007a8  2600              MOVS     r6,#0
;;;3325   
;;;3326     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3327     TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
0007aa  8c07              LDRH     r7,[r0,#0x20]
0007ac  f64e7cff          MOV      r12,#0xefff
0007b0  ea07070c          AND      r7,r7,r12
0007b4  8407              STRH     r7,[r0,#0x20]
;;;3328     tmpccmr2 = TIMx->CCMR2;
0007b6  8b81              LDRH     r1,[r0,#0x1c]
;;;3329     tmpccer = TIMx->CCER;
0007b8  8c02              LDRH     r2,[r0,#0x20]
;;;3330     tmp = (uint16_t)(TIM_ICPolarity << 12);
0007ba  f64f77ff          MOV      r7,#0xffff
0007be  ea073604          AND      r6,r7,r4,LSL #12
;;;3331   
;;;3332     /* Select the Input and set the filter */
;;;3333     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
0007c2  f64047ff          MOV      r7,#0xcff
0007c6  4039              ANDS     r1,r1,r7
;;;3334     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
0007c8  f64f77ff          MOV      r7,#0xffff
0007cc  ea072705          AND      r7,r7,r5,LSL #8
0007d0  4339              ORRS     r1,r1,r7
;;;3335     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
0007d2  f64f77ff          MOV      r7,#0xffff
0007d6  ea073703          AND      r7,r7,r3,LSL #12
0007da  4339              ORRS     r1,r1,r7
;;;3336   
;;;3337     /* Select the Polarity and set the CC4E Bit */
;;;3338     tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
0007dc  f64577ff          MOV      r7,#0x5fff
0007e0  403a              ANDS     r2,r2,r7
;;;3339     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
0007e2  f4465780          ORR      r7,r6,#0x1000
0007e6  433a              ORRS     r2,r2,r7
;;;3340   
;;;3341     /* Write to TIMx CCMR2 and CCER registers */
;;;3342     TIMx->CCMR2 = tmpccmr2;
0007e8  8381              STRH     r1,[r0,#0x1c]
;;;3343     TIMx->CCER = tmpccer ;
0007ea  8402              STRH     r2,[r0,#0x20]
;;;3344   }
0007ec  bdf0              POP      {r4-r7,pc}
;;;3345   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2139     */
;;;2140   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0007ee  8b82              LDRH     r2,[r0,#0x1c]
;;;2141   {
;;;2142     /* Check the parameters */
;;;2143     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2144     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2145   
;;;2146     /* Reset the IC3PSC Bits */
;;;2147     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
0007f0  f64f73f3          MOV      r3,#0xfff3
0007f4  401a              ANDS     r2,r2,r3
0007f6  8382              STRH     r2,[r0,#0x1c]
;;;2148   
;;;2149     /* Set the IC3PSC value */
;;;2150     TIMx->CCMR2 |= TIM_ICPSC;
0007f8  8b82              LDRH     r2,[r0,#0x1c]
0007fa  430a              ORRS     r2,r2,r1
0007fc  8382              STRH     r2,[r0,#0x1c]
;;;2151   }
0007fe  4770              BX       lr
;;;2152   
                          ENDP

                  TI3_Config PROC
;;;3279     */
;;;3280   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000800  b5f0              PUSH     {r4-r7,lr}
;;;3281                          uint16_t TIM_ICFilter)
;;;3282   {
000802  460c              MOV      r4,r1
000804  4615              MOV      r5,r2
;;;3283     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000806  2100              MOVS     r1,#0
000808  2200              MOVS     r2,#0
00080a  2600              MOVS     r6,#0
;;;3284   
;;;3285     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3286     TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
00080c  8c07              LDRH     r7,[r0,#0x20]
00080e  f64f6cff          MOV      r12,#0xfeff
000812  ea07070c          AND      r7,r7,r12
000816  8407              STRH     r7,[r0,#0x20]
;;;3287     tmpccmr2 = TIMx->CCMR2;
000818  8b81              LDRH     r1,[r0,#0x1c]
;;;3288     tmpccer = TIMx->CCER;
00081a  8c02              LDRH     r2,[r0,#0x20]
;;;3289     tmp = (uint16_t)(TIM_ICPolarity << 8);
00081c  f64f77ff          MOV      r7,#0xffff
000820  ea072604          AND      r6,r7,r4,LSL #8
;;;3290   
;;;3291     /* Select the Input and set the filter */
;;;3292     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
000824  f64f770c          MOV      r7,#0xff0c
000828  4039              ANDS     r1,r1,r7
;;;3293     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00082a  f64f77ff          MOV      r7,#0xffff
00082e  ea071703          AND      r7,r7,r3,LSL #4
000832  432f              ORRS     r7,r7,r5
000834  4339              ORRS     r1,r1,r7
;;;3294   
;;;3295     /* Select the Polarity and set the CC3E Bit */
;;;3296     tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000836  f24f57ff          MOV      r7,#0xf5ff
00083a  403a              ANDS     r2,r2,r7
;;;3297     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
00083c  f4467780          ORR      r7,r6,#0x100
000840  433a              ORRS     r2,r2,r7
;;;3298   
;;;3299     /* Write to TIMx CCMR2 and CCER registers */
;;;3300     TIMx->CCMR2 = tmpccmr2;
000842  8381              STRH     r1,[r0,#0x1c]
;;;3301     TIMx->CCER = tmpccer;
000844  8402              STRH     r2,[r0,#0x20]
;;;3302   }
000846  bdf0              POP      {r4-r7,pc}
;;;3303   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2115     */
;;;2116   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000848  8b02              LDRH     r2,[r0,#0x18]
;;;2117   {
;;;2118     /* Check the parameters */
;;;2119     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2120     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2121   
;;;2122     /* Reset the IC2PSC Bits */
;;;2123     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
00084a  f24f33ff          MOV      r3,#0xf3ff
00084e  401a              ANDS     r2,r2,r3
000850  8302              STRH     r2,[r0,#0x18]
;;;2124   
;;;2125     /* Set the IC2PSC value */
;;;2126     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000852  8b02              LDRH     r2,[r0,#0x18]
000854  f64f73ff          MOV      r3,#0xffff
000858  ea032301          AND      r3,r3,r1,LSL #8
00085c  431a              ORRS     r2,r2,r3
00085e  8302              STRH     r2,[r0,#0x18]
;;;2127   }
000860  4770              BX       lr
;;;2128   
                          ENDP

                  TI2_Config PROC
;;;3237     */
;;;3238   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000862  b5f0              PUSH     {r4-r7,lr}
;;;3239                          uint16_t TIM_ICFilter)
;;;3240   {
000864  460c              MOV      r4,r1
000866  4615              MOV      r5,r2
;;;3241     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000868  2100              MOVS     r1,#0
00086a  2200              MOVS     r2,#0
00086c  2600              MOVS     r6,#0
;;;3242   
;;;3243     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3244     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
00086e  8c07              LDRH     r7,[r0,#0x20]
000870  f64f7cef          MOV      r12,#0xffef
000874  ea07070c          AND      r7,r7,r12
000878  8407              STRH     r7,[r0,#0x20]
;;;3245     tmpccmr1 = TIMx->CCMR1;
00087a  8b01              LDRH     r1,[r0,#0x18]
;;;3246     tmpccer = TIMx->CCER;
00087c  8c02              LDRH     r2,[r0,#0x20]
;;;3247     tmp = (uint16_t)(TIM_ICPolarity << 4);
00087e  f64f77ff          MOV      r7,#0xffff
000882  ea071604          AND      r6,r7,r4,LSL #4
;;;3248   
;;;3249     /* Select the Input and set the filter */
;;;3250     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000886  f64047ff          MOV      r7,#0xcff
00088a  4039              ANDS     r1,r1,r7
;;;3251     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00088c  f64f77ff          MOV      r7,#0xffff
000890  ea073703          AND      r7,r7,r3,LSL #12
000894  4339              ORRS     r1,r1,r7
;;;3252     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000896  f64f77ff          MOV      r7,#0xffff
00089a  e003              B        |L1.2212|
                  |L1.2204|
                          DCD      0x40010000
                  |L1.2208|
                          DCD      0x40010400
                  |L1.2212|
0008a4  ea072705          AND      r7,r7,r5,LSL #8
0008a8  4339              ORRS     r1,r1,r7
;;;3253   
;;;3254     /* Select the Polarity and set the CC2E Bit */
;;;3255     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
0008aa  f64f775f          MOV      r7,#0xff5f
0008ae  403a              ANDS     r2,r2,r7
;;;3256     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
0008b0  f0460710          ORR      r7,r6,#0x10
0008b4  433a              ORRS     r2,r2,r7
;;;3257   
;;;3258     /* Write to TIMx CCMR1 and CCER registers */
;;;3259     TIMx->CCMR1 = tmpccmr1 ;
0008b6  8301              STRH     r1,[r0,#0x18]
;;;3260     TIMx->CCER = tmpccer;
0008b8  8402              STRH     r2,[r0,#0x20]
;;;3261   }
0008ba  bdf0              POP      {r4-r7,pc}
;;;3262   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2090     */
;;;2091   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0008bc  8b02              LDRH     r2,[r0,#0x18]
;;;2092   {
;;;2093     /* Check the parameters */
;;;2094     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2095     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2096   
;;;2097     /* Reset the IC1PSC Bits */
;;;2098     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
0008be  f64f73f3          MOV      r3,#0xfff3
0008c2  401a              ANDS     r2,r2,r3
0008c4  8302              STRH     r2,[r0,#0x18]
;;;2099   
;;;2100     /* Set the IC1PSC value */
;;;2101     TIMx->CCMR1 |= TIM_ICPSC;
0008c6  8b02              LDRH     r2,[r0,#0x18]
0008c8  430a              ORRS     r2,r2,r1
0008ca  8302              STRH     r2,[r0,#0x18]
;;;2102   }
0008cc  4770              BX       lr
;;;2103   
                          ENDP

                  TI1_Config PROC
;;;3196     */
;;;3197   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0008ce  b5f0              PUSH     {r4-r7,lr}
;;;3198                          uint16_t TIM_ICFilter)
;;;3199   {
0008d0  460c              MOV      r4,r1
0008d2  4615              MOV      r5,r2
;;;3200     uint16_t tmpccmr1 = 0, tmpccer = 0;
0008d4  2100              MOVS     r1,#0
0008d6  2200              MOVS     r2,#0
;;;3201   
;;;3202     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3203     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
0008d8  8c06              LDRH     r6,[r0,#0x20]
0008da  f64f77fe          MOV      r7,#0xfffe
0008de  403e              ANDS     r6,r6,r7
0008e0  8406              STRH     r6,[r0,#0x20]
;;;3204     tmpccmr1 = TIMx->CCMR1;
0008e2  8b01              LDRH     r1,[r0,#0x18]
;;;3205     tmpccer = TIMx->CCER;
0008e4  8c02              LDRH     r2,[r0,#0x20]
;;;3206   
;;;3207     /* Select the Input and set the filter */
;;;3208     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
0008e6  f64f760c          MOV      r6,#0xff0c
0008ea  4031              ANDS     r1,r1,r6
;;;3209     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
0008ec  1c7e              ADDS     r6,r7,#1
0008ee  ea061603          AND      r6,r6,r3,LSL #4
0008f2  432e              ORRS     r6,r6,r5
0008f4  4331              ORRS     r1,r1,r6
;;;3210   
;;;3211     /* Select the Polarity and set the CC1E Bit */
;;;3212     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
0008f6  f64f76f5          MOV      r6,#0xfff5
0008fa  4032              ANDS     r2,r2,r6
;;;3213     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
0008fc  f0440601          ORR      r6,r4,#1
000900  4332              ORRS     r2,r2,r6
;;;3214   
;;;3215     /* Write to TIMx CCMR1 and CCER registers */
;;;3216     TIMx->CCMR1 = tmpccmr1;
000902  8301              STRH     r1,[r0,#0x18]
;;;3217     TIMx->CCER = tmpccer;
000904  8402              STRH     r2,[r0,#0x20]
;;;3218   }
000906  bdf0              POP      {r4-r7,pc}
;;;3219   
                          ENDP

                  TIM_ICInit PROC
;;;1895     */
;;;1896   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000908  b570              PUSH     {r4-r6,lr}
;;;1897   {
00090a  4605              MOV      r5,r0
00090c  460c              MOV      r4,r1
;;;1898     /* Check the parameters */
;;;1899     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1900     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1901     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1902     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1903     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1904     
;;;1905     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00090e  8820              LDRH     r0,[r4,#0]
000910  b950              CBNZ     r0,|L1.2344|
;;;1906     {
;;;1907       /* TI1 Configuration */
;;;1908       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000912  8923              LDRH     r3,[r4,#8]
000914  88a2              LDRH     r2,[r4,#4]
000916  8861              LDRH     r1,[r4,#2]
000918  4628              MOV      r0,r5
00091a  f7fffffe          BL       TI1_Config
;;;1909                  TIM_ICInitStruct->TIM_ICSelection,
;;;1910                  TIM_ICInitStruct->TIM_ICFilter);
;;;1911       /* Set the Input Capture Prescaler value */
;;;1912       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00091e  88e1              LDRH     r1,[r4,#6]
000920  4628              MOV      r0,r5
000922  f7fffffe          BL       TIM_SetIC1Prescaler
000926  e025              B        |L1.2420|
                  |L1.2344|
;;;1913     }
;;;1914     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000928  8820              LDRH     r0,[r4,#0]
00092a  2804              CMP      r0,#4
00092c  d10a              BNE      |L1.2372|
;;;1915     {
;;;1916       /* TI2 Configuration */
;;;1917       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1918       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00092e  8923              LDRH     r3,[r4,#8]
000930  88a2              LDRH     r2,[r4,#4]
000932  8861              LDRH     r1,[r4,#2]
000934  4628              MOV      r0,r5
000936  f7fffffe          BL       TI2_Config
;;;1919                  TIM_ICInitStruct->TIM_ICSelection,
;;;1920                  TIM_ICInitStruct->TIM_ICFilter);
;;;1921       /* Set the Input Capture Prescaler value */
;;;1922       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00093a  88e1              LDRH     r1,[r4,#6]
00093c  4628              MOV      r0,r5
00093e  f7fffffe          BL       TIM_SetIC2Prescaler
000942  e017              B        |L1.2420|
                  |L1.2372|
;;;1923     }
;;;1924     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000944  8820              LDRH     r0,[r4,#0]
000946  2808              CMP      r0,#8
000948  d10a              BNE      |L1.2400|
;;;1925     {
;;;1926       /* TI3 Configuration */
;;;1927       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1928       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
00094a  8923              LDRH     r3,[r4,#8]
00094c  88a2              LDRH     r2,[r4,#4]
00094e  8861              LDRH     r1,[r4,#2]
000950  4628              MOV      r0,r5
000952  f7fffffe          BL       TI3_Config
;;;1929                  TIM_ICInitStruct->TIM_ICSelection,
;;;1930                  TIM_ICInitStruct->TIM_ICFilter);
;;;1931       /* Set the Input Capture Prescaler value */
;;;1932       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000956  88e1              LDRH     r1,[r4,#6]
000958  4628              MOV      r0,r5
00095a  f7fffffe          BL       TIM_SetIC3Prescaler
00095e  e009              B        |L1.2420|
                  |L1.2400|
;;;1933     }
;;;1934     else
;;;1935     {
;;;1936       /* TI4 Configuration */
;;;1937       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1938       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000960  8923              LDRH     r3,[r4,#8]
000962  88a2              LDRH     r2,[r4,#4]
000964  8861              LDRH     r1,[r4,#2]
000966  4628              MOV      r0,r5
000968  f7fffffe          BL       TI4_Config
;;;1939                  TIM_ICInitStruct->TIM_ICSelection,
;;;1940                  TIM_ICInitStruct->TIM_ICFilter);
;;;1941       /* Set the Input Capture Prescaler value */
;;;1942       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00096c  88e1              LDRH     r1,[r4,#6]
00096e  4628              MOV      r0,r5
000970  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L1.2420|
;;;1943     }
;;;1944   }
000974  bd70              POP      {r4-r6,pc}
;;;1945   
                          ENDP

                  TIM_ICStructInit PROC
;;;1951     */
;;;1952   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000976  2100              MOVS     r1,#0
;;;1953   {
;;;1954     /* Set the default configuration */
;;;1955     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000978  8001              STRH     r1,[r0,#0]
;;;1956     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
00097a  8041              STRH     r1,[r0,#2]
;;;1957     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
00097c  2101              MOVS     r1,#1
00097e  8081              STRH     r1,[r0,#4]
;;;1958     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
000980  2100              MOVS     r1,#0
000982  80c1              STRH     r1,[r0,#6]
;;;1959     TIM_ICInitStruct->TIM_ICFilter = 0x00;
000984  8101              STRH     r1,[r0,#8]
;;;1960   }
000986  4770              BX       lr
;;;1961   
                          ENDP

                  TIM_PWMIConfig PROC
;;;1970     */
;;;1971   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000988  e92d41f0          PUSH     {r4-r8,lr}
;;;1972   {
00098c  4605              MOV      r5,r0
00098e  460c              MOV      r4,r1
;;;1973     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000990  2600              MOVS     r6,#0
;;;1974     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
000992  2701              MOVS     r7,#1
;;;1975   
;;;1976     /* Check the parameters */
;;;1977     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1978   
;;;1979     /* Select the Opposite Input Polarity */
;;;1980     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000994  8860              LDRH     r0,[r4,#2]
000996  b908              CBNZ     r0,|L1.2460|
;;;1981     {
;;;1982       icoppositepolarity = TIM_ICPolarity_Falling;
000998  2602              MOVS     r6,#2
00099a  e000              B        |L1.2462|
                  |L1.2460|
;;;1983     }
;;;1984     else
;;;1985     {
;;;1986       icoppositepolarity = TIM_ICPolarity_Rising;
00099c  2600              MOVS     r6,#0
                  |L1.2462|
;;;1987     }
;;;1988     /* Select the Opposite Input */
;;;1989     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
00099e  88a0              LDRH     r0,[r4,#4]
0009a0  2801              CMP      r0,#1
0009a2  d101              BNE      |L1.2472|
;;;1990     {
;;;1991       icoppositeselection = TIM_ICSelection_IndirectTI;
0009a4  2702              MOVS     r7,#2
0009a6  e000              B        |L1.2474|
                  |L1.2472|
;;;1992     }
;;;1993     else
;;;1994     {
;;;1995       icoppositeselection = TIM_ICSelection_DirectTI;
0009a8  2701              MOVS     r7,#1
                  |L1.2474|
;;;1996     }
;;;1997     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
0009aa  8820              LDRH     r0,[r4,#0]
0009ac  b9a0              CBNZ     r0,|L1.2520|
;;;1998     {
;;;1999       /* TI1 Configuration */
;;;2000       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0009ae  8923              LDRH     r3,[r4,#8]
0009b0  88a2              LDRH     r2,[r4,#4]
0009b2  8861              LDRH     r1,[r4,#2]
0009b4  4628              MOV      r0,r5
0009b6  f7fffffe          BL       TI1_Config
;;;2001                  TIM_ICInitStruct->TIM_ICFilter);
;;;2002       /* Set the Input Capture Prescaler value */
;;;2003       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0009ba  88e1              LDRH     r1,[r4,#6]
0009bc  4628              MOV      r0,r5
0009be  f7fffffe          BL       TIM_SetIC1Prescaler
;;;2004       /* TI2 Configuration */
;;;2005       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
0009c2  8923              LDRH     r3,[r4,#8]
0009c4  463a              MOV      r2,r7
0009c6  4631              MOV      r1,r6
0009c8  4628              MOV      r0,r5
0009ca  f7fffffe          BL       TI2_Config
;;;2006       /* Set the Input Capture Prescaler value */
;;;2007       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0009ce  88e1              LDRH     r1,[r4,#6]
0009d0  4628              MOV      r0,r5
0009d2  f7fffffe          BL       TIM_SetIC2Prescaler
0009d6  e013              B        |L1.2560|
                  |L1.2520|
;;;2008     }
;;;2009     else
;;;2010     { 
;;;2011       /* TI2 Configuration */
;;;2012       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0009d8  8923              LDRH     r3,[r4,#8]
0009da  88a2              LDRH     r2,[r4,#4]
0009dc  8861              LDRH     r1,[r4,#2]
0009de  4628              MOV      r0,r5
0009e0  f7fffffe          BL       TI2_Config
;;;2013                  TIM_ICInitStruct->TIM_ICFilter);
;;;2014       /* Set the Input Capture Prescaler value */
;;;2015       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0009e4  88e1              LDRH     r1,[r4,#6]
0009e6  4628              MOV      r0,r5
0009e8  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2016       /* TI1 Configuration */
;;;2017       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
0009ec  8923              LDRH     r3,[r4,#8]
0009ee  463a              MOV      r2,r7
0009f0  4631              MOV      r1,r6
0009f2  4628              MOV      r0,r5
0009f4  f7fffffe          BL       TI1_Config
;;;2018       /* Set the Input Capture Prescaler value */
;;;2019       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0009f8  88e1              LDRH     r1,[r4,#6]
0009fa  4628              MOV      r0,r5
0009fc  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L1.2560|
;;;2020     }
;;;2021   }
000a00  e8bd81f0          POP      {r4-r8,pc}
;;;2022   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2027     */
;;;2028   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000a04  4601              MOV      r1,r0
;;;2029   {
;;;2030     /* Check the parameters */
;;;2031     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2032   
;;;2033     /* Get the Capture 1 Register value */
;;;2034     return TIMx->CCR1;
000a06  6b48              LDR      r0,[r1,#0x34]
;;;2035   }
000a08  4770              BX       lr
;;;2036   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2042     */
;;;2043   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000a0a  4601              MOV      r1,r0
;;;2044   {
;;;2045     /* Check the parameters */
;;;2046     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2047   
;;;2048     /* Get the Capture 2 Register value */
;;;2049     return TIMx->CCR2;
000a0c  6b88              LDR      r0,[r1,#0x38]
;;;2050   }
000a0e  4770              BX       lr
;;;2051   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2056     */
;;;2057   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000a10  4601              MOV      r1,r0
;;;2058   {
;;;2059     /* Check the parameters */
;;;2060     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2061   
;;;2062     /* Get the Capture 3 Register value */
;;;2063     return TIMx->CCR3;
000a12  6bc8              LDR      r0,[r1,#0x3c]
;;;2064   }
000a14  4770              BX       lr
;;;2065   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2070     */
;;;2071   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000a16  4601              MOV      r1,r0
;;;2072   {
;;;2073     /* Check the parameters */
;;;2074     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2075   
;;;2076     /* Get the Capture 4 Register value */
;;;2077     return TIMx->CCR4;
000a18  6c08              LDR      r0,[r1,#0x40]
;;;2078   }
000a1a  4770              BX       lr
;;;2079   
                          ENDP

                  TIM_BDTRConfig PROC
;;;2216     */
;;;2217   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000a1c  880a              LDRH     r2,[r1,#0]
;;;2218   {
;;;2219     /* Check the parameters */
;;;2220     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2221     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2222     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2223     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2224     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2225     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2226     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2227   
;;;2228     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2229        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2230     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000a1e  884b              LDRH     r3,[r1,#2]
000a20  431a              ORRS     r2,r2,r3
000a22  888b              LDRH     r3,[r1,#4]
000a24  431a              ORRS     r2,r2,r3
000a26  88cb              LDRH     r3,[r1,#6]
000a28  431a              ORRS     r2,r2,r3
000a2a  890b              LDRH     r3,[r1,#8]
000a2c  431a              ORRS     r2,r2,r3
000a2e  894b              LDRH     r3,[r1,#0xa]
000a30  431a              ORRS     r2,r2,r3
000a32  898b              LDRH     r3,[r1,#0xc]
000a34  431a              ORRS     r2,r2,r3
000a36  f8a02044          STRH     r2,[r0,#0x44]
;;;2231                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2232                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2233                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2234   }
000a3a  4770              BX       lr
;;;2235   
                          ENDP

                  TIM_BDTRStructInit PROC
;;;2241     */
;;;2242   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000a3c  2100              MOVS     r1,#0
;;;2243   {
;;;2244     /* Set the default configuration */
;;;2245     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000a3e  8001              STRH     r1,[r0,#0]
;;;2246     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000a40  8041              STRH     r1,[r0,#2]
;;;2247     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000a42  8081              STRH     r1,[r0,#4]
;;;2248     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000a44  80c1              STRH     r1,[r0,#6]
;;;2249     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
000a46  8101              STRH     r1,[r0,#8]
;;;2250     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
000a48  8141              STRH     r1,[r0,#0xa]
;;;2251     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
000a4a  8181              STRH     r1,[r0,#0xc]
;;;2252   }
000a4c  4770              BX       lr
;;;2253   
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;2260     */
;;;2261   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000a4e  b131              CBZ      r1,|L1.2654|
;;;2262   {
;;;2263     /* Check the parameters */
;;;2264     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266   
;;;2267     if (NewState != DISABLE)
;;;2268     {
;;;2269       /* Enable the TIM Main Output */
;;;2270       TIMx->BDTR |= TIM_BDTR_MOE;
000a50  f8b02044          LDRH     r2,[r0,#0x44]
000a54  f4424200          ORR      r2,r2,#0x8000
000a58  f8a02044          STRH     r2,[r0,#0x44]
000a5c  e005              B        |L1.2666|
                  |L1.2654|
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable the TIM Main Output */
;;;2275       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000a5e  f8b02044          LDRH     r2,[r0,#0x44]
000a62  f3c2020e          UBFX     r2,r2,#0,#15
000a66  f8a02044          STRH     r2,[r0,#0x44]
                  |L1.2666|
;;;2276     }  
;;;2277   }
000a6a  4770              BX       lr
;;;2278   
                          ENDP

                  TIM_SelectCOM PROC
;;;2285     */
;;;2286   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000a6c  b121              CBZ      r1,|L1.2680|
;;;2287   {
;;;2288     /* Check the parameters */
;;;2289     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2290     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2291   
;;;2292     if (NewState != DISABLE)
;;;2293     {
;;;2294       /* Set the COM Bit */
;;;2295       TIMx->CR2 |= TIM_CR2_CCUS;
000a6e  8882              LDRH     r2,[r0,#4]
000a70  f0420204          ORR      r2,r2,#4
000a74  8082              STRH     r2,[r0,#4]
000a76  e004              B        |L1.2690|
                  |L1.2680|
;;;2296     }
;;;2297     else
;;;2298     {
;;;2299       /* Reset the COM Bit */
;;;2300       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000a78  8882              LDRH     r2,[r0,#4]
000a7a  f64f73fb          MOV      r3,#0xfffb
000a7e  401a              ANDS     r2,r2,r3
000a80  8082              STRH     r2,[r0,#4]
                  |L1.2690|
;;;2301     }
;;;2302   }
000a82  4770              BX       lr
;;;2303   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;2310     */
;;;2311   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000a84  b121              CBZ      r1,|L1.2704|
;;;2312   { 
;;;2313     /* Check the parameters */
;;;2314     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2315     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2316     if (NewState != DISABLE)
;;;2317     {
;;;2318       /* Set the CCPC Bit */
;;;2319       TIMx->CR2 |= TIM_CR2_CCPC;
000a86  8882              LDRH     r2,[r0,#4]
000a88  f0420201          ORR      r2,r2,#1
000a8c  8082              STRH     r2,[r0,#4]
000a8e  e004              B        |L1.2714|
                  |L1.2704|
;;;2320     }
;;;2321     else
;;;2322     {
;;;2323       /* Reset the CCPC Bit */
;;;2324       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
000a90  8882              LDRH     r2,[r0,#4]
000a92  f64f73fe          MOV      r3,#0xfffe
000a96  401a              ANDS     r2,r2,r3
000a98  8082              STRH     r2,[r0,#4]
                  |L1.2714|
;;;2325     }
;;;2326   }
000a9a  4770              BX       lr
;;;2327   /**
                          ENDP

                  TIM_ITConfig PROC
;;;2367     */
;;;2368   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000a9c  b11a              CBZ      r2,|L1.2726|
;;;2369   {  
;;;2370     /* Check the parameters */
;;;2371     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2372     assert_param(IS_TIM_IT(TIM_IT));
;;;2373     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2374     
;;;2375     if (NewState != DISABLE)
;;;2376     {
;;;2377       /* Enable the Interrupt sources */
;;;2378       TIMx->DIER |= TIM_IT;
000a9e  8983              LDRH     r3,[r0,#0xc]
000aa0  430b              ORRS     r3,r3,r1
000aa2  8183              STRH     r3,[r0,#0xc]
000aa4  e002              B        |L1.2732|
                  |L1.2726|
;;;2379     }
;;;2380     else
;;;2381     {
;;;2382       /* Disable the Interrupt sources */
;;;2383       TIMx->DIER &= (uint16_t)~TIM_IT;
000aa6  8983              LDRH     r3,[r0,#0xc]
000aa8  438b              BICS     r3,r3,r1
000aaa  8183              STRH     r3,[r0,#0xc]
                  |L1.2732|
;;;2384     }
;;;2385   }
000aac  4770              BX       lr
;;;2386   
                          ENDP

                  TIM_GenerateEvent PROC
;;;2405     */
;;;2406   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000aae  8281              STRH     r1,[r0,#0x14]
;;;2407   { 
;;;2408     /* Check the parameters */
;;;2409     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2410     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2411    
;;;2412     /* Set the event sources */
;;;2413     TIMx->EGR = TIM_EventSource;
;;;2414   }
000ab0  4770              BX       lr
;;;2415   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2438     */
;;;2439   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000ab2  4602              MOV      r2,r0
;;;2440   { 
;;;2441     ITStatus bitstatus = RESET;  
000ab4  2000              MOVS     r0,#0
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2444     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2445   
;;;2446     
;;;2447     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000ab6  8a13              LDRH     r3,[r2,#0x10]
000ab8  400b              ANDS     r3,r3,r1
000aba  b10b              CBZ      r3,|L1.2752|
;;;2448     {
;;;2449       bitstatus = SET;
000abc  2001              MOVS     r0,#1
000abe  e000              B        |L1.2754|
                  |L1.2752|
;;;2450     }
;;;2451     else
;;;2452     {
;;;2453       bitstatus = RESET;
000ac0  2000              MOVS     r0,#0
                  |L1.2754|
;;;2454     }
;;;2455     return bitstatus;
;;;2456   }
000ac2  4770              BX       lr
;;;2457   
                          ENDP

                  TIM_ClearFlag PROC
;;;2480     */
;;;2481   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000ac4  43ca              MVNS     r2,r1
;;;2482   {  
;;;2483     /* Check the parameters */
;;;2484     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2485      
;;;2486     /* Clear the flags */
;;;2487     TIMx->SR = (uint16_t)~TIM_FLAG;
000ac6  8202              STRH     r2,[r0,#0x10]
;;;2488   }
000ac8  4770              BX       lr
;;;2489   
                          ENDP

                  TIM_GetITStatus PROC
;;;2508     */
;;;2509   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000aca  b530              PUSH     {r4,r5,lr}
;;;2510   {
000acc  4602              MOV      r2,r0
;;;2511     ITStatus bitstatus = RESET;  
000ace  2000              MOVS     r0,#0
;;;2512     uint16_t itstatus = 0x0, itenable = 0x0;
000ad0  2300              MOVS     r3,#0
000ad2  2400              MOVS     r4,#0
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2515     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2516      
;;;2517     itstatus = TIMx->SR & TIM_IT;
000ad4  8a15              LDRH     r5,[r2,#0x10]
000ad6  ea050301          AND      r3,r5,r1
;;;2518     
;;;2519     itenable = TIMx->DIER & TIM_IT;
000ada  8995              LDRH     r5,[r2,#0xc]
000adc  ea050401          AND      r4,r5,r1
;;;2520     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000ae0  b113              CBZ      r3,|L1.2792|
000ae2  b10c              CBZ      r4,|L1.2792|
;;;2521     {
;;;2522       bitstatus = SET;
000ae4  2001              MOVS     r0,#1
000ae6  e000              B        |L1.2794|
                  |L1.2792|
;;;2523     }
;;;2524     else
;;;2525     {
;;;2526       bitstatus = RESET;
000ae8  2000              MOVS     r0,#0
                  |L1.2794|
;;;2527     }
;;;2528     return bitstatus;
;;;2529   }
000aea  bd30              POP      {r4,r5,pc}
;;;2530   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2549     */
;;;2550   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000aec  43ca              MVNS     r2,r1
;;;2551   {
;;;2552     /* Check the parameters */
;;;2553     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2554   
;;;2555     /* Clear the IT pending Bit */
;;;2556     TIMx->SR = (uint16_t)~TIM_IT;
000aee  8202              STRH     r2,[r0,#0x10]
;;;2557   }
000af0  4770              BX       lr
;;;2558   
                          ENDP

                  TIM_DMAConfig PROC
;;;2586     */
;;;2587   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000af2  ea410302          ORR      r3,r1,r2
;;;2588   {
;;;2589     /* Check the parameters */
;;;2590     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2591     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2592     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2593   
;;;2594     /* Set the DMA Base and the DMA Burst Length */
;;;2595     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000af6  f8a03048          STRH     r3,[r0,#0x48]
;;;2596   }
000afa  4770              BX       lr
;;;2597   
                          ENDP

                  TIM_DMACmd PROC
;;;2613     */
;;;2614   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000afc  b11a              CBZ      r2,|L1.2822|
;;;2615   { 
;;;2616     /* Check the parameters */
;;;2617     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2618     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2619     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2620     
;;;2621     if (NewState != DISABLE)
;;;2622     {
;;;2623       /* Enable the DMA sources */
;;;2624       TIMx->DIER |= TIM_DMASource; 
000afe  8983              LDRH     r3,[r0,#0xc]
000b00  430b              ORRS     r3,r3,r1
000b02  8183              STRH     r3,[r0,#0xc]
000b04  e002              B        |L1.2828|
                  |L1.2822|
;;;2625     }
;;;2626     else
;;;2627     {
;;;2628       /* Disable the DMA sources */
;;;2629       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000b06  8983              LDRH     r3,[r0,#0xc]
000b08  438b              BICS     r3,r3,r1
000b0a  8183              STRH     r3,[r0,#0xc]
                  |L1.2828|
;;;2630     }
;;;2631   }
000b0c  4770              BX       lr
;;;2632   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;2639     */
;;;2640   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000b0e  b121              CBZ      r1,|L1.2842|
;;;2641   {
;;;2642     /* Check the parameters */
;;;2643     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2644     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2645   
;;;2646     if (NewState != DISABLE)
;;;2647     {
;;;2648       /* Set the CCDS Bit */
;;;2649       TIMx->CR2 |= TIM_CR2_CCDS;
000b10  8882              LDRH     r2,[r0,#4]
000b12  f0420208          ORR      r2,r2,#8
000b16  8082              STRH     r2,[r0,#4]
000b18  e004              B        |L1.2852|
                  |L1.2842|
;;;2650     }
;;;2651     else
;;;2652     {
;;;2653       /* Reset the CCDS Bit */
;;;2654       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
000b1a  8882              LDRH     r2,[r0,#4]
000b1c  f64f73f7          MOV      r3,#0xfff7
000b20  401a              ANDS     r2,r2,r3
000b22  8082              STRH     r2,[r0,#4]
                  |L1.2852|
;;;2655     }
;;;2656   }
000b24  4770              BX       lr
;;;2657   /**
                          ENDP

                  TIM_InternalClockConfig PROC
;;;2678     */
;;;2679   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000b26  8901              LDRH     r1,[r0,#8]
;;;2680   {
;;;2681     /* Check the parameters */
;;;2682     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2683   
;;;2684     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2685     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000b28  f64f72f8          MOV      r2,#0xfff8
000b2c  4011              ANDS     r1,r1,r2
000b2e  8101              STRH     r1,[r0,#8]
;;;2686   }
000b30  4770              BX       lr
;;;2687   
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;2884     */
;;;2885   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000b32  460a              MOV      r2,r1
;;;2886   {
;;;2887     uint16_t tmpsmcr = 0;
000b34  2100              MOVS     r1,#0
;;;2888   
;;;2889     /* Check the parameters */
;;;2890     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2891     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2892   
;;;2893     /* Get the TIMx SMCR register value */
;;;2894     tmpsmcr = TIMx->SMCR;
000b36  8901              LDRH     r1,[r0,#8]
;;;2895   
;;;2896     /* Reset the TS Bits */
;;;2897     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000b38  f64f738f          MOV      r3,#0xff8f
000b3c  4019              ANDS     r1,r1,r3
;;;2898   
;;;2899     /* Set the Input Trigger source */
;;;2900     tmpsmcr |= TIM_InputTriggerSource;
000b3e  4311              ORRS     r1,r1,r2
;;;2901   
;;;2902     /* Write to TIMx SMCR */
;;;2903     TIMx->SMCR = tmpsmcr;
000b40  8101              STRH     r1,[r0,#8]
;;;2904   }
000b42  4770              BX       lr
;;;2905   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;2699     */
;;;2700   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000b44  b530              PUSH     {r4,r5,lr}
;;;2701   {
000b46  4604              MOV      r4,r0
000b48  460d              MOV      r5,r1
;;;2702     /* Check the parameters */
;;;2703     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2704     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2705   
;;;2706     /* Select the Internal Trigger */
;;;2707     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000b4a  4629              MOV      r1,r5
000b4c  4620              MOV      r0,r4
000b4e  f7fffffe          BL       TIM_SelectInputTrigger
;;;2708   
;;;2709     /* Select the External clock mode1 */
;;;2710     TIMx->SMCR |= TIM_SlaveMode_External1;
000b52  8920              LDRH     r0,[r4,#8]
000b54  f0400007          ORR      r0,r0,#7
000b58  8120              STRH     r0,[r4,#8]
;;;2711   }
000b5a  bd30              POP      {r4,r5,pc}
;;;2712   
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;2729     */
;;;2730   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000b5c  e92d41f0          PUSH     {r4-r8,lr}
;;;2731                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2732   {
000b60  4604              MOV      r4,r0
000b62  460d              MOV      r5,r1
000b64  4616              MOV      r6,r2
000b66  461f              MOV      r7,r3
;;;2733     /* Check the parameters */
;;;2734     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2735     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2736     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2737   
;;;2738     /* Configure the Timer Input Clock Source */
;;;2739     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000b68  2d60              CMP      r5,#0x60
000b6a  d106              BNE      |L1.2938|
;;;2740     {
;;;2741       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000b6c  463b              MOV      r3,r7
000b6e  2201              MOVS     r2,#1
000b70  4631              MOV      r1,r6
000b72  4620              MOV      r0,r4
000b74  f7fffffe          BL       TI2_Config
000b78  e005              B        |L1.2950|
                  |L1.2938|
;;;2742     }
;;;2743     else
;;;2744     {
;;;2745       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000b7a  463b              MOV      r3,r7
000b7c  2201              MOVS     r2,#1
000b7e  4631              MOV      r1,r6
000b80  4620              MOV      r0,r4
000b82  f7fffffe          BL       TI1_Config
                  |L1.2950|
;;;2746     }
;;;2747     /* Select the Trigger source */
;;;2748     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000b86  4629              MOV      r1,r5
000b88  4620              MOV      r0,r4
000b8a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2749     /* Select the External clock mode1 */
;;;2750     TIMx->SMCR |= TIM_SlaveMode_External1;
000b8e  8920              LDRH     r0,[r4,#8]
000b90  f0400007          ORR      r0,r0,#7
000b94  8120              STRH     r0,[r4,#8]
;;;2751   }
000b96  e8bd81f0          POP      {r4-r8,pc}
;;;2752   
                          ENDP

                  TIM_ETRConfig PROC
;;;3004     */
;;;3005   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000b9a  b530              PUSH     {r4,r5,lr}
;;;3006                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3007   {
000b9c  460c              MOV      r4,r1
;;;3008     uint16_t tmpsmcr = 0;
000b9e  2100              MOVS     r1,#0
;;;3009   
;;;3010     /* Check the parameters */
;;;3011     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3012     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3013     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3014     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3015   
;;;3016     tmpsmcr = TIMx->SMCR;
000ba0  8901              LDRH     r1,[r0,#8]
;;;3017   
;;;3018     /* Reset the ETR Bits */
;;;3019     tmpsmcr &= SMCR_ETR_MASK;
000ba2  b2c9              UXTB     r1,r1
;;;3020   
;;;3021     /* Set the Prescaler, the Filter value and the Polarity */
;;;3022     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000ba4  f64f75ff          MOV      r5,#0xffff
000ba8  ea052503          AND      r5,r5,r3,LSL #8
000bac  4315              ORRS     r5,r5,r2
000bae  4325              ORRS     r5,r5,r4
000bb0  4329              ORRS     r1,r1,r5
;;;3023   
;;;3024     /* Write to TIMx SMCR */
;;;3025     TIMx->SMCR = tmpsmcr;
000bb2  8101              STRH     r1,[r0,#8]
;;;3026   }
000bb4  bd30              POP      {r4,r5,pc}
;;;3027   /**
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;2769     */
;;;2770   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000bb6  e92d41f0          PUSH     {r4-r8,lr}
;;;2771                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2772   {
000bba  4605              MOV      r5,r0
000bbc  460e              MOV      r6,r1
000bbe  4617              MOV      r7,r2
000bc0  4698              MOV      r8,r3
;;;2773     uint16_t tmpsmcr = 0;
000bc2  2400              MOVS     r4,#0
;;;2774   
;;;2775     /* Check the parameters */
;;;2776     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2777     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2778     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2779     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2780     /* Configure the ETR Clock source */
;;;2781     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000bc4  4643              MOV      r3,r8
000bc6  463a              MOV      r2,r7
000bc8  4631              MOV      r1,r6
000bca  4628              MOV      r0,r5
000bcc  f7fffffe          BL       TIM_ETRConfig
;;;2782     
;;;2783     /* Get the TIMx SMCR register value */
;;;2784     tmpsmcr = TIMx->SMCR;
000bd0  892c              LDRH     r4,[r5,#8]
;;;2785   
;;;2786     /* Reset the SMS Bits */
;;;2787     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000bd2  f64f70f8          MOV      r0,#0xfff8
000bd6  4004              ANDS     r4,r4,r0
;;;2788   
;;;2789     /* Select the External clock mode1 */
;;;2790     tmpsmcr |= TIM_SlaveMode_External1;
000bd8  f0440407          ORR      r4,r4,#7
;;;2791   
;;;2792     /* Select the Trigger selection : ETRF */
;;;2793     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000bdc  f64f708f          MOV      r0,#0xff8f
000be0  4004              ANDS     r4,r4,r0
;;;2794     tmpsmcr |= TIM_TS_ETRF;
000be2  f0440470          ORR      r4,r4,#0x70
;;;2795   
;;;2796     /* Write to TIMx SMCR */
;;;2797     TIMx->SMCR = tmpsmcr;
000be6  812c              STRH     r4,[r5,#8]
;;;2798   }
000be8  e8bd81f0          POP      {r4-r8,pc}
;;;2799   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;2816     */
;;;2817   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000bec  b5f0              PUSH     {r4-r7,lr}
;;;2818                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2819   {
000bee  4604              MOV      r4,r0
000bf0  460d              MOV      r5,r1
000bf2  4616              MOV      r6,r2
000bf4  461f              MOV      r7,r3
;;;2820     /* Check the parameters */
;;;2821     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2822     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2823     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2824     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2825   
;;;2826     /* Configure the ETR Clock source */
;;;2827     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000bf6  463b              MOV      r3,r7
000bf8  4632              MOV      r2,r6
000bfa  4629              MOV      r1,r5
000bfc  4620              MOV      r0,r4
000bfe  f7fffffe          BL       TIM_ETRConfig
;;;2828   
;;;2829     /* Enable the External clock mode2 */
;;;2830     TIMx->SMCR |= TIM_SMCR_ECE;
000c02  8920              LDRH     r0,[r4,#8]
000c04  f4404080          ORR      r0,r0,#0x4000
000c08  8120              STRH     r0,[r4,#8]
;;;2831   }
000c0a  bdf0              POP      {r4-r7,pc}
;;;2832   /**
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2927     */
;;;2928   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000c0c  8882              LDRH     r2,[r0,#4]
;;;2929   {
;;;2930     /* Check the parameters */
;;;2931     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2932     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2933   
;;;2934     /* Reset the MMS Bits */
;;;2935     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000c0e  f64f738f          MOV      r3,#0xff8f
000c12  401a              ANDS     r2,r2,r3
000c14  8082              STRH     r2,[r0,#4]
;;;2936     /* Select the TRGO source */
;;;2937     TIMx->CR2 |=  TIM_TRGOSource;
000c16  8882              LDRH     r2,[r0,#4]
000c18  430a              ORRS     r2,r2,r1
000c1a  8082              STRH     r2,[r0,#4]
;;;2938   }
000c1c  4770              BX       lr
;;;2939   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2951     */
;;;2952   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000c1e  8902              LDRH     r2,[r0,#8]
;;;2953   {
;;;2954     /* Check the parameters */
;;;2955     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2956     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2957   
;;;2958     /* Reset the SMS Bits */
;;;2959     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000c20  f64f73f8          MOV      r3,#0xfff8
000c24  401a              ANDS     r2,r2,r3
000c26  8102              STRH     r2,[r0,#8]
;;;2960   
;;;2961     /* Select the Slave Mode */
;;;2962     TIMx->SMCR |= TIM_SlaveMode;
000c28  8902              LDRH     r2,[r0,#8]
000c2a  430a              ORRS     r2,r2,r1
000c2c  8102              STRH     r2,[r0,#8]
;;;2963   }
000c2e  4770              BX       lr
;;;2964   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2974     */
;;;2975   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000c30  8902              LDRH     r2,[r0,#8]
;;;2976   {
;;;2977     /* Check the parameters */
;;;2978     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2979     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2980   
;;;2981     /* Reset the MSM Bit */
;;;2982     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000c32  f64f737f          MOV      r3,#0xff7f
000c36  401a              ANDS     r2,r2,r3
000c38  8102              STRH     r2,[r0,#8]
;;;2983     
;;;2984     /* Set or Reset the MSM Bit */
;;;2985     TIMx->SMCR |= TIM_MasterSlaveMode;
000c3a  8902              LDRH     r2,[r0,#8]
000c3c  430a              ORRS     r2,r2,r1
000c3e  8102              STRH     r2,[r0,#8]
;;;2986   }
000c40  4770              BX       lr
;;;2987   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;3062     */
;;;3063   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000c42  b5f0              PUSH     {r4-r7,lr}
;;;3064                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3065   {
000c44  460c              MOV      r4,r1
000c46  4615              MOV      r5,r2
000c48  461e              MOV      r6,r3
;;;3066     uint16_t tmpsmcr = 0;
000c4a  2100              MOVS     r1,#0
;;;3067     uint16_t tmpccmr1 = 0;
000c4c  2200              MOVS     r2,#0
;;;3068     uint16_t tmpccer = 0;
000c4e  2300              MOVS     r3,#0
;;;3069       
;;;3070     /* Check the parameters */
;;;3071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3072     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3073     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3074     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3075   
;;;3076     /* Get the TIMx SMCR register value */
;;;3077     tmpsmcr = TIMx->SMCR;
000c50  8901              LDRH     r1,[r0,#8]
;;;3078   
;;;3079     /* Get the TIMx CCMR1 register value */
;;;3080     tmpccmr1 = TIMx->CCMR1;
000c52  8b02              LDRH     r2,[r0,#0x18]
;;;3081   
;;;3082     /* Get the TIMx CCER register value */
;;;3083     tmpccer = TIMx->CCER;
000c54  8c03              LDRH     r3,[r0,#0x20]
;;;3084   
;;;3085     /* Set the encoder Mode */
;;;3086     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000c56  f64f77f8          MOV      r7,#0xfff8
000c5a  4039              ANDS     r1,r1,r7
;;;3087     tmpsmcr |= TIM_EncoderMode;
000c5c  4321              ORRS     r1,r1,r4
;;;3088   
;;;3089     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3090     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
000c5e  f64f47fc          MOV      r7,#0xfcfc
000c62  403a              ANDS     r2,r2,r7
;;;3091     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000c64  f2401701          MOV      r7,#0x101
000c68  433a              ORRS     r2,r2,r7
;;;3092   
;;;3093     /* Set the TI1 and the TI2 Polarities */
;;;3094     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
000c6a  f64f77dd          MOV      r7,#0xffdd
000c6e  403b              ANDS     r3,r3,r7
;;;3095     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
000c70  f64f77ff          MOV      r7,#0xffff
000c74  ea071706          AND      r7,r7,r6,LSL #4
000c78  432f              ORRS     r7,r7,r5
000c7a  433b              ORRS     r3,r3,r7
;;;3096   
;;;3097     /* Write to TIMx SMCR */
;;;3098     TIMx->SMCR = tmpsmcr;
000c7c  8101              STRH     r1,[r0,#8]
;;;3099   
;;;3100     /* Write to TIMx CCMR1 */
;;;3101     TIMx->CCMR1 = tmpccmr1;
000c7e  8302              STRH     r2,[r0,#0x18]
;;;3102   
;;;3103     /* Write to TIMx CCER */
;;;3104     TIMx->CCER = tmpccer;
000c80  8403              STRH     r3,[r0,#0x20]
;;;3105   }
000c82  bdf0              POP      {r4-r7,pc}
;;;3106   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;3114     */
;;;3115   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000c84  b121              CBZ      r1,|L1.3216|
;;;3116   {
;;;3117     /* Check the parameters */
;;;3118     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3119     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3120   
;;;3121     if (NewState != DISABLE)
;;;3122     {
;;;3123       /* Set the TI1S Bit */
;;;3124       TIMx->CR2 |= TIM_CR2_TI1S;
000c86  8882              LDRH     r2,[r0,#4]
000c88  f0420280          ORR      r2,r2,#0x80
000c8c  8082              STRH     r2,[r0,#4]
000c8e  e004              B        |L1.3226|
                  |L1.3216|
;;;3125     }
;;;3126     else
;;;3127     {
;;;3128       /* Reset the TI1S Bit */
;;;3129       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000c90  8882              LDRH     r2,[r0,#4]
000c92  f64f737f          MOV      r3,#0xff7f
000c96  401a              ANDS     r2,r2,r3
000c98  8082              STRH     r2,[r0,#4]
                  |L1.3226|
;;;3130     }
;;;3131   }
000c9a  4770              BX       lr
;;;3132   /**
                          ENDP

                  TIM_RemapConfig PROC
;;;3165     */
;;;3166   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000c9c  f8a01050          STRH     r1,[r0,#0x50]
;;;3167   {
;;;3168    /* Check the parameters */
;;;3169     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3170     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3171   
;;;3172     /* Set the Timer remapping configuration */
;;;3173     TIMx->OR =  TIM_Remap;
;;;3174   }
000ca0  4770              BX       lr
;;;3175   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_tim.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f4xx_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
