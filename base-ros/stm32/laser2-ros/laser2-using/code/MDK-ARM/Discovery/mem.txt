; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\mem.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\mem.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\mem.crf ..\..\libraries\lwip-1.4.1\src\core\mem.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000000  b530              PUSH     {r4,r5,lr}
;;;237    {
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000002  bf00              NOP      
000004  bf00              NOP      
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
000006  bf00              NOP      
000008  bf00              NOP      
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
00000e  bf00              NOP      
000010  bf00              NOP      
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
000012  8803              LDRH     r3,[r0,#0]
000014  4cd6              LDR      r4,|L1.880|
000016  6824              LDR      r4,[r4,#0]  ; ram
000018  1919              ADDS     r1,r3,r4
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
00001a  4288              CMP      r0,r1
00001c  d015              BEQ      |L1.74|
00001e  790b              LDRB     r3,[r1,#4]
000020  b99b              CBNZ     r3,|L1.74|
000022  4bd4              LDR      r3,|L1.884|
000024  681b              LDR      r3,[r3,#0]  ; ram_end
000026  4299              CMP      r1,r3
000028  d00f              BEQ      |L1.74|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
00002a  4bd3              LDR      r3,|L1.888|
00002c  681b              LDR      r3,[r3,#0]  ; lfree
00002e  428b              CMP      r3,r1
000030  d101              BNE      |L1.54|
;;;252          lfree = mem;
000032  4bd1              LDR      r3,|L1.888|
000034  6018              STR      r0,[r3,#0]  ; lfree
                  |L1.54|
;;;253        }
;;;254        mem->next = nmem->next;
000036  880b              LDRH     r3,[r1,#0]
000038  8003              STRH     r3,[r0,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
00003a  4bcd              LDR      r3,|L1.880|
00003c  881b              LDRH     r3,[r3,#0]  ; ram
00003e  1ac3              SUBS     r3,r0,r3
000040  880c              LDRH     r4,[r1,#0]
000042  4dcb              LDR      r5,|L1.880|
000044  682d              LDR      r5,[r5,#0]  ; ram
000046  442c              ADD      r4,r4,r5
000048  8063              STRH     r3,[r4,#2]
                  |L1.74|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
00004a  8843              LDRH     r3,[r0,#2]
00004c  4cc8              LDR      r4,|L1.880|
00004e  6824              LDR      r4,[r4,#0]  ; ram
000050  191a              ADDS     r2,r3,r4
;;;260      if (pmem != mem && pmem->used == 0) {
000052  4282              CMP      r2,r0
000054  d011              BEQ      |L1.122|
000056  7913              LDRB     r3,[r2,#4]
000058  b97b              CBNZ     r3,|L1.122|
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
00005a  4bc7              LDR      r3,|L1.888|
00005c  681b              LDR      r3,[r3,#0]  ; lfree
00005e  4283              CMP      r3,r0
000060  d101              BNE      |L1.102|
;;;263          lfree = pmem;
000062  4bc5              LDR      r3,|L1.888|
000064  601a              STR      r2,[r3,#0]  ; lfree
                  |L1.102|
;;;264        }
;;;265        pmem->next = mem->next;
000066  8803              LDRH     r3,[r0,#0]
000068  8013              STRH     r3,[r2,#0]
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
00006a  4bc1              LDR      r3,|L1.880|
00006c  881b              LDRH     r3,[r3,#0]  ; ram
00006e  1ad3              SUBS     r3,r2,r3
000070  8804              LDRH     r4,[r0,#0]
000072  4dbf              LDR      r5,|L1.880|
000074  682d              LDR      r5,[r5,#0]  ; ram
000076  442c              ADD      r4,r4,r5
000078  8063              STRH     r3,[r4,#2]
                  |L1.122|
;;;267      }
;;;268    }
00007a  bd30              POP      {r4,r5,pc}
;;;269    
                          ENDP

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
00007c  b510              PUSH     {r4,lr}
;;;275    {
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
00007e  bf00              NOP      
000080  bf00              NOP      
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000082  48be              LDR      r0,|L1.892|
000084  f0200003          BIC      r0,r0,#3
000088  49b9              LDR      r1,|L1.880|
00008a  6008              STR      r0,[r1,#0]  ; ram
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
00008c  4608              MOV      r0,r1
00008e  6804              LDR      r4,[r0,#0]  ; ram
;;;285      mem->next = MEM_SIZE_ALIGNED;
000090  f44f5080          MOV      r0,#0x1000
000094  8020              STRH     r0,[r4,#0]
;;;286      mem->prev = 0;
000096  2000              MOVS     r0,#0
000098  8060              STRH     r0,[r4,#2]
;;;287      mem->used = 0;
00009a  7120              STRB     r0,[r4,#4]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
00009c  4608              MOV      r0,r1
00009e  6800              LDR      r0,[r0,#0]  ; ram
0000a0  f5005080          ADD      r0,r0,#0x1000
0000a4  49b3              LDR      r1,|L1.884|
0000a6  6008              STR      r0,[r1,#0]  ; ram_end
;;;290      ram_end->used = 1;
0000a8  2001              MOVS     r0,#1
0000aa  6809              LDR      r1,[r1,#0]  ; ram_end
0000ac  7108              STRB     r0,[r1,#4]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
0000ae  0300              LSLS     r0,r0,#12
0000b0  49b0              LDR      r1,|L1.884|
0000b2  6809              LDR      r1,[r1,#0]  ; ram_end
0000b4  8008              STRH     r0,[r1,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
0000b6  49af              LDR      r1,|L1.884|
0000b8  6809              LDR      r1,[r1,#0]  ; ram_end
0000ba  8048              STRH     r0,[r1,#2]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
0000bc  48ac              LDR      r0,|L1.880|
0000be  6800              LDR      r0,[r0,#0]  ; ram
0000c0  49ad              LDR      r1,|L1.888|
0000c2  6008              STR      r0,[r1,#0]  ; lfree
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
0000c4  48ae              LDR      r0,|L1.896|
0000c6  f7fffffe          BL       sys_mutex_new
0000ca  b108              CBZ      r0,|L1.208|
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
0000cc  bf00              NOP      
0000ce  bf00              NOP      
                  |L1.208|
;;;301      }
;;;302    }
0000d0  bd10              POP      {r4,pc}
;;;303    
                          ENDP

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
0000d2  b570              PUSH     {r4-r6,lr}
;;;312    {
0000d4  4604              MOV      r4,r0
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
0000d6  b914              CBNZ     r4,|L1.222|
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
0000d8  bf00              NOP      
0000da  bf00              NOP      
                  |L1.220|
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
;;;342    
;;;343      if (mem < lfree) {
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
0000dc  bd70              POP      {r4-r6,pc}
                  |L1.222|
0000de  bf00              NOP                            ;320
0000e0  bf00              NOP                            ;320
0000e2  bf00              NOP                            ;322
0000e4  bf00              NOP                            ;322
0000e6  48a2              LDR      r0,|L1.880|
0000e8  6800              LDR      r0,[r0,#0]            ;325  ; ram
0000ea  4284              CMP      r4,r0                 ;325
0000ec  d303              BCC      |L1.246|
0000ee  48a1              LDR      r0,|L1.884|
0000f0  6800              LDR      r0,[r0,#0]            ;325  ; ram_end
0000f2  4284              CMP      r4,r0                 ;325
0000f4  d308              BCC      |L1.264|
                  |L1.246|
0000f6  bf00              NOP                            ;327
0000f8  bf00              NOP                            ;327
0000fa  f7fffffe          BL       sys_arch_protect
0000fe  4606              MOV      r6,r0                 ;329
000100  4630              MOV      r0,r6                 ;331
000102  f7fffffe          BL       sys_arch_unprotect
000106  e7e9              B        |L1.220|
                  |L1.264|
000108  489d              LDR      r0,|L1.896|
00010a  f7fffffe          BL       sys_mutex_lock
00010e  f1a40508          SUB      r5,r4,#8              ;337
000112  bf00              NOP                            ;339
000114  bf00              NOP                            ;339
000116  2000              MOVS     r0,#0                 ;341
000118  7128              STRB     r0,[r5,#4]            ;341
00011a  4897              LDR      r0,|L1.888|
00011c  6800              LDR      r0,[r0,#0]            ;343  ; lfree
00011e  4285              CMP      r5,r0                 ;343
000120  d201              BCS      |L1.294|
000122  4895              LDR      r0,|L1.888|
000124  6005              STR      r5,[r0,#0]            ;345  ; lfree
                  |L1.294|
000126  4628              MOV      r0,r5                 ;351
000128  f7fffffe          BL       plug_holes
00012c  4894              LDR      r0,|L1.896|
00012e  f7fffffe          BL       sys_mutex_unlock
000132  bf00              NOP      
000134  e7d2              B        |L1.220|
;;;357    
                          ENDP

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
000136  e92d5ff0          PUSH     {r4-r12,lr}
;;;370    {
00013a  4681              MOV      r9,r0
00013c  460d              MOV      r5,r1
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
00013e  1ce8              ADDS     r0,r5,#3
000140  f0200003          BIC      r0,r0,#3
000144  b285              UXTH     r5,r0
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
000146  2d0c              CMP      r5,#0xc
000148  da00              BGE      |L1.332|
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
00014a  250c              MOVS     r5,#0xc
                  |L1.332|
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
00014c  f5b55f80          CMP      r5,#0x1000
000150  dd02              BLE      |L1.344|
;;;387        return NULL;
000152  2000              MOVS     r0,#0
                  |L1.340|
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
;;;400        return rmem;
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;409      if (newsize > size) {
;;;410        /* not supported */
;;;411        return NULL;
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
000154  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.344|
000158  bf00              NOP                            ;390
00015a  bf00              NOP                            ;390
00015c  4884              LDR      r0,|L1.880|
00015e  6800              LDR      r0,[r0,#0]            ;393  ; ram
000160  4581              CMP      r9,r0                 ;393
000162  d303              BCC      |L1.364|
000164  4883              LDR      r0,|L1.884|
000166  6800              LDR      r0,[r0,#0]            ;393  ; ram_end
000168  4581              CMP      r9,r0                 ;393
00016a  d309              BCC      |L1.384|
                  |L1.364|
00016c  bf00              NOP                            ;395
00016e  bf00              NOP                            ;395
000170  f7fffffe          BL       sys_arch_protect
000174  4683              MOV      r11,r0                ;397
000176  4658              MOV      r0,r11                ;399
000178  f7fffffe          BL       sys_arch_unprotect
00017c  4648              MOV      r0,r9                 ;400
00017e  e7e9              B        |L1.340|
                  |L1.384|
000180  f1a90708          SUB      r7,r9,#8              ;403
000184  487a              LDR      r0,|L1.880|
000186  8800              LDRH     r0,[r0,#0]            ;405  ; ram
000188  1a38              SUBS     r0,r7,r0              ;405
00018a  fa1ff880          UXTH     r8,r0                 ;405
00018e  8838              LDRH     r0,[r7,#0]            ;407
000190  eba00008          SUB      r0,r0,r8              ;407
000194  3808              SUBS     r0,r0,#8              ;407
000196  fa1ffa80          UXTH     r10,r0                ;407
00019a  bf00              NOP                            ;408
00019c  bf00              NOP                            ;408
00019e  4555              CMP      r5,r10                ;409
0001a0  dd01              BLE      |L1.422|
0001a2  2000              MOVS     r0,#0                 ;411
0001a4  e7d6              B        |L1.340|
                  |L1.422|
0001a6  4555              CMP      r5,r10                ;413
0001a8  d101              BNE      |L1.430|
0001aa  4648              MOV      r0,r9                 ;415
0001ac  e7d2              B        |L1.340|
                  |L1.430|
0001ae  4874              LDR      r0,|L1.896|
0001b0  f7fffffe          BL       sys_mutex_lock
0001b4  8838              LDRH     r0,[r7,#0]            ;421
0001b6  496e              LDR      r1,|L1.880|
0001b8  6809              LDR      r1,[r1,#0]            ;421  ; ram
0001ba  1844              ADDS     r4,r0,r1              ;421
0001bc  7920              LDRB     r0,[r4,#4]            ;422
0001be  bb00              CBNZ     r0,|L1.514|
0001c0  8820              LDRH     r0,[r4,#0]            ;426
0001c2  f1080108          ADD      r1,r8,#8              ;428
0001c6  4429              ADD      r1,r1,r5              ;428
0001c8  b28e              UXTH     r6,r1                 ;428
0001ca  496b              LDR      r1,|L1.888|
0001cc  6809              LDR      r1,[r1,#0]            ;429  ; lfree
0001ce  42a1              CMP      r1,r4                 ;429
0001d0  d104              BNE      |L1.476|
0001d2  4967              LDR      r1,|L1.880|
0001d4  6809              LDR      r1,[r1,#0]            ;430  ; ram
0001d6  4431              ADD      r1,r1,r6              ;430
0001d8  4a67              LDR      r2,|L1.888|
0001da  6011              STR      r1,[r2,#0]            ;430  ; lfree
                  |L1.476|
0001dc  4964              LDR      r1,|L1.880|
0001de  6809              LDR      r1,[r1,#0]            ;432  ; ram
0001e0  198c              ADDS     r4,r1,r6              ;432
0001e2  2100              MOVS     r1,#0                 ;433
0001e4  7121              STRB     r1,[r4,#4]            ;433
0001e6  8020              STRH     r0,[r4,#0]            ;435
0001e8  f8a48002          STRH     r8,[r4,#2]            ;437
0001ec  803e              STRH     r6,[r7,#0]            ;439
0001ee  8821              LDRH     r1,[r4,#0]            ;443
0001f0  f5b15f80          CMP      r1,#0x1000            ;443
0001f4  d004              BEQ      |L1.512|
0001f6  8821              LDRH     r1,[r4,#0]            ;444
0001f8  4a5d              LDR      r2,|L1.880|
0001fa  6812              LDR      r2,[r2,#0]            ;444  ; ram
0001fc  4411              ADD      r1,r1,r2              ;444
0001fe  804e              STRH     r6,[r1,#2]            ;444
                  |L1.512|
000200  e020              B        |L1.580|
                  |L1.514|
000202  f1050014          ADD      r0,r5,#0x14           ;448
000206  4550              CMP      r0,r10                ;448
000208  d81c              BHI      |L1.580|
00020a  f1080008          ADD      r0,r8,#8              ;456
00020e  4428              ADD      r0,r0,r5              ;456
000210  b286              UXTH     r6,r0                 ;456
000212  4857              LDR      r0,|L1.880|
000214  6800              LDR      r0,[r0,#0]            ;457  ; ram
000216  1984              ADDS     r4,r0,r6              ;457
000218  4857              LDR      r0,|L1.888|
00021a  6800              LDR      r0,[r0,#0]            ;458  ; lfree
00021c  4284              CMP      r4,r0                 ;458
00021e  d201              BCS      |L1.548|
000220  4855              LDR      r0,|L1.888|
000222  6004              STR      r4,[r0,#0]            ;459  ; lfree
                  |L1.548|
000224  2000              MOVS     r0,#0                 ;461
000226  7120              STRB     r0,[r4,#4]            ;461
000228  8838              LDRH     r0,[r7,#0]            ;462
00022a  8020              STRH     r0,[r4,#0]            ;462
00022c  f8a48002          STRH     r8,[r4,#2]            ;463
000230  803e              STRH     r6,[r7,#0]            ;464
000232  8820              LDRH     r0,[r4,#0]            ;465
000234  f5b05f80          CMP      r0,#0x1000            ;465
000238  d004              BEQ      |L1.580|
00023a  8820              LDRH     r0,[r4,#0]            ;466
00023c  494c              LDR      r1,|L1.880|
00023e  6809              LDR      r1,[r1,#0]            ;466  ; ram
000240  4408              ADD      r0,r0,r1              ;466
000242  8046              STRH     r6,[r0,#2]            ;466
                  |L1.580|
000244  484e              LDR      r0,|L1.896|
000246  f7fffffe          BL       sys_mutex_unlock
00024a  4648              MOV      r0,r9                 ;481
00024c  e782              B        |L1.340|
;;;483    
                          ENDP

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
00024e  e92d41f0          PUSH     {r4-r8,lr}
;;;495    {
000252  4605              MOV      r5,r0
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
000254  b915              CBNZ     r5,|L1.604|
;;;504        return NULL;
000256  2000              MOVS     r0,#0
                  |L1.600|
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
;;;517        return NULL;
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
000258  e8bd81f0          POP      {r4-r8,pc}
                  |L1.604|
00025c  1ce8              ADDS     r0,r5,#3              ;509
00025e  f0200003          BIC      r0,r0,#3              ;509
000262  b285              UXTH     r5,r0                 ;509
000264  2d0c              CMP      r5,#0xc               ;511
000266  da00              BGE      |L1.618|
000268  250c              MOVS     r5,#0xc               ;513
                  |L1.618|
00026a  f5b55f80          CMP      r5,#0x1000            ;516
00026e  dd01              BLE      |L1.628|
000270  2000              MOVS     r0,#0                 ;517
000272  e7f1              B        |L1.600|
                  |L1.628|
000274  4842              LDR      r0,|L1.896|
000276  f7fffffe          BL       sys_mutex_lock
00027a  483f              LDR      r0,|L1.888|
00027c  8800              LDRH     r0,[r0,#0]            ;532  ; lfree
00027e  493c              LDR      r1,|L1.880|
000280  8809              LDRH     r1,[r1,#0]            ;532  ; ram
000282  1a40              SUBS     r0,r0,r1              ;532
000284  b286              UXTH     r6,r0                 ;532
000286  e057              B        |L1.824|
                  |L1.648|
000288  4839              LDR      r0,|L1.880|
00028a  6800              LDR      r0,[r0,#0]            ;534  ; ram
00028c  1984              ADDS     r4,r0,r6              ;534
00028e  7920              LDRB     r0,[r4,#4]            ;548
000290  2800              CMP      r0,#0                 ;548
000292  d14e              BNE      |L1.818|
000294  8821              LDRH     r1,[r4,#0]            ;549
000296  f1060008          ADD      r0,r6,#8              ;549
00029a  1a08              SUBS     r0,r1,r0              ;549
00029c  42a8              CMP      r0,r5                 ;549
00029e  d348              BCC      |L1.818|
0002a0  8821              LDRH     r1,[r4,#0]            ;553
0002a2  f1060008          ADD      r0,r6,#8              ;553
0002a6  1a09              SUBS     r1,r1,r0              ;553
0002a8  f1050014          ADD      r0,r5,#0x14           ;553
0002ac  4281              CMP      r1,r0                 ;553
0002ae  d31c              BCC      |L1.746|
0002b0  f1060008          ADD      r0,r6,#8              ;564
0002b4  4428              ADD      r0,r0,r5              ;564
0002b6  fa1ff880          UXTH     r8,r0                 ;564
0002ba  482d              LDR      r0,|L1.880|
0002bc  6800              LDR      r0,[r0,#0]            ;566  ; ram
0002be  eb000708          ADD      r7,r0,r8              ;566
0002c2  2000              MOVS     r0,#0                 ;567
0002c4  7138              STRB     r0,[r7,#4]            ;567
0002c6  8820              LDRH     r0,[r4,#0]            ;568
0002c8  8038              STRH     r0,[r7,#0]            ;568
0002ca  807e              STRH     r6,[r7,#2]            ;569
0002cc  f8a48000          STRH     r8,[r4,#0]            ;571
0002d0  2001              MOVS     r0,#1                 ;572
0002d2  7120              STRB     r0,[r4,#4]            ;572
0002d4  8838              LDRH     r0,[r7,#0]            ;574
0002d6  f5b05f80          CMP      r0,#0x1000            ;574
0002da  d008              BEQ      |L1.750|
0002dc  8838              LDRH     r0,[r7,#0]            ;575
0002de  4924              LDR      r1,|L1.880|
0002e0  6809              LDR      r1,[r1,#0]            ;575  ; ram
0002e2  4408              ADD      r0,r0,r1              ;575
0002e4  f8a08002          STRH     r8,[r0,#2]            ;575
0002e8  e001              B        |L1.750|
                  |L1.746|
0002ea  2001              MOVS     r0,#1                 ;586
0002ec  7120              STRB     r0,[r4,#4]            ;586
                  |L1.750|
0002ee  4822              LDR      r0,|L1.888|
0002f0  6800              LDR      r0,[r0,#0]            ;592  ; lfree
0002f2  4284              CMP      r4,r0                 ;592
0002f4  d111              BNE      |L1.794|
0002f6  4920              LDR      r1,|L1.888|
0002f8  6808              LDR      r0,[r1,#0]            ;593  ; lfree
0002fa  e003              B        |L1.772|
                  |L1.764|
0002fc  8801              LDRH     r1,[r0,#0]            ;607
0002fe  4a1c              LDR      r2,|L1.880|
000300  6812              LDR      r2,[r2,#0]            ;607  ; ram
000302  1888              ADDS     r0,r1,r2              ;607
                  |L1.772|
000304  7901              LDRB     r1,[r0,#4]            ;595
000306  b119              CBZ      r1,|L1.784|
000308  491a              LDR      r1,|L1.884|
00030a  6809              LDR      r1,[r1,#0]            ;595  ; ram_end
00030c  4288              CMP      r0,r1                 ;595
00030e  d1f5              BNE      |L1.764|
                  |L1.784|
000310  4919              LDR      r1,|L1.888|
000312  6008              STR      r0,[r1,#0]            ;609  ; lfree
000314  bf00              NOP                            ;610
000316  bf00              NOP                            ;610
000318  bf00              NOP                            ;611
                  |L1.794|
00031a  4819              LDR      r0,|L1.896|
00031c  f7fffffe          BL       sys_mutex_unlock
000320  bf00              NOP                            ;614
000322  bf00              NOP                            ;614
000324  bf00              NOP                            ;616
000326  bf00              NOP                            ;616
000328  bf00              NOP                            ;618
00032a  bf00              NOP                            ;618
00032c  f1040008          ADD      r0,r4,#8              ;621
000330  e792              B        |L1.600|
                  |L1.818|
000332  480f              LDR      r0,|L1.880|
000334  6800              LDR      r0,[r0,#0]            ;533  ; ram
000336  5b86              LDRH     r6,[r0,r6]            ;533
                  |L1.824|
000338  f5c55080          RSB      r0,r5,#0x1000         ;532
00033c  42b0              CMP      r0,r6                 ;532
00033e  dca3              BGT      |L1.648|
000340  bf00              NOP                            ;628
000342  bf00              NOP                            ;628
000344  480e              LDR      r0,|L1.896|
000346  f7fffffe          BL       sys_mutex_unlock
00034a  2000              MOVS     r0,#0                 ;632
00034c  e784              B        |L1.600|
;;;634    
                          ENDP

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
00034e  b570              PUSH     {r4-r6,lr}
;;;647    {
000350  4604              MOV      r4,r0
000352  460d              MOV      r5,r1
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
000354  fb04f105          MUL      r1,r4,r5
000358  b288              UXTH     r0,r1
00035a  f7fffffe          BL       mem_malloc
00035e  4606              MOV      r6,r0
;;;652      if (p) {
000360  b126              CBZ      r6,|L1.876|
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
000362  fb04f105          MUL      r1,r4,r5
000366  4630              MOV      r0,r6
000368  f7fffffe          BL       __aeabi_memclr
                  |L1.876|
;;;655      }
;;;656      return p;
00036c  4630              MOV      r0,r6
;;;657    }
00036e  bd70              POP      {r4-r6,pc}
;;;658    
                          ENDP

                  |L1.880|
                          DCD      ||ram||
                  |L1.884|
                          DCD      ram_end
                  |L1.888|
                          DCD      lfree
                  |L1.892|
                          DCD      ram_heap+0x3
                  |L1.896|
                          DCD      mem_mutex

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ram_heap
                          %        4116
                  mem_mutex
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
