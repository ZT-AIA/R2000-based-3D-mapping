; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\main.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\main.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\main.crf ..\src\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  led4 PROC
;;;76     
;;;77     void led4(void *arg)
000000  e005              B        |L1.14|
                  |L1.2|
;;;78     {
;;;79     	while(1)
;;;80     	{
;;;81     		STM_EVAL_LEDToggle(LED4);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       STM_EVAL_LEDToggle
;;;82     		sys_msleep(250);
000008  20fa              MOVS     r0,#0xfa
00000a  f7fffffe          BL       osDelay
                  |L1.14|
00000e  e7f8              B        |L1.2|
;;;83     		//printf("led4\n");
;;;84     	}
;;;85     }
;;;86     
                          ENDP

                  led3 PROC
;;;87     void led3(void *arg)
000010  e005              B        |L1.30|
                  |L1.18|
;;;88     {
;;;89     	while(1)
;;;90     	{
;;;91     		STM_EVAL_LEDToggle(LED3);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       STM_EVAL_LEDToggle
;;;92     		sys_msleep(250);
000018  20fa              MOVS     r0,#0xfa
00001a  f7fffffe          BL       osDelay
                  |L1.30|
00001e  e7f8              B        |L1.18|
;;;93     	}
;;;94     }
;;;95     
                          ENDP

                  LCD_LED_Init PROC
;;;327      */
;;;328    void LCD_LED_Init(void)
000020  b510              PUSH     {r4,lr}
;;;329    {
;;;330      STM_EVAL_LEDInit(LED4);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       STM_EVAL_LEDInit
;;;331    	STM_EVAL_LEDInit(LED3);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       STM_EVAL_LEDInit
;;;332    
;;;333    #ifdef USE_LCD
;;;334      /* Initialize the STM324xG-EVAL's LCD */
;;;335      STM32f4_Discovery_LCD_Init();
;;;336    
;;;337      /* Clear the LCD */
;;;338      LCD_Clear(Black);
;;;339    
;;;340      /* Set the LCD Back Color */
;;;341      LCD_SetBackColor(Black);
;;;342    
;;;343      /* Set the LCD Text Color */
;;;344      LCD_SetTextColor(White);
;;;345    
;;;346      /* Display message on the LCD*/
;;;347      LCD_DisplayStringLine(Line0, (uint8_t*)MESSAGE1);
;;;348      LCD_DisplayStringLine(Line1, (uint8_t*)MESSAGE2);
;;;349      LCD_DisplayStringLine(Line2, (uint8_t*)MESSAGE3);
;;;350      LCD_DisplayStringLine(Line3, (uint8_t*)MESSAGE4); 
;;;351    #endif
;;;352    }
00002e  bd10              POP      {r4,pc}
;;;353    
                          ENDP

                  UART3_Init PROC
;;;275    
;;;276    void UART3_Init(void)
000030  b500              PUSH     {lr}
;;;277    {
000032  b087              SUB      sp,sp,#0x1c
;;;278    	/***************************************
;;;279    	*初始化串口3，主要用于调试的所用
;;;280    	****************************************/
;;;281    	USART_InitTypeDef USART_InitStructure;
;;;282    	GPIO_InitTypeDef GPIO_InitStructure;		
;;;283    	
;;;284    	/* 第1步：配置GPIO */
;;;285    	/* TX = PD8  RX = PD9 */
;;;286    	/* 打开GPIO时钟 */
;;;287    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
000034  2101              MOVS     r1,#1
000036  2008              MOVS     r0,#8
000038  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;288    
;;;289    	/*打开UART时钟*/
;;;290    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  0488              LSLS     r0,r1,#18
000040  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;291    	
;;;292    	/* 配置 USART Tx 为复用功能 */
;;;293    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000044  2000              MOVS     r0,#0
000046  f88d000a          STRB     r0,[sp,#0xa]
;;;294    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
00004a  2001              MOVS     r0,#1
00004c  f88d000b          STRB     r0,[sp,#0xb]
;;;295    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
000050  2002              MOVS     r0,#2
000052  f88d0008          STRB     r0,[sp,#8]
;;;296    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000056  0200              LSLS     r0,r0,#8
000058  9001              STR      r0,[sp,#4]
;;;297    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00005a  2002              MOVS     r0,#2
00005c  f88d0009          STRB     r0,[sp,#9]
;;;298    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000060  a901              ADD      r1,sp,#4
000062  4868              LDR      r0,|L1.516|
000064  f7fffffe          BL       GPIO_Init
;;;299    	/* 配置 USART Rx 为复用功能 */
;;;300    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000068  f44f6080          MOV      r0,#0x400
00006c  9001              STR      r0,[sp,#4]
;;;301    	GPIO_Init(GPIOD, &GPIO_InitStructure);
00006e  a901              ADD      r1,sp,#4
000070  4864              LDR      r0,|L1.516|
000072  f7fffffe          BL       GPIO_Init
;;;302    	/*将PD8映射为USART3_TX*/
;;;303    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_USART3);
000076  2207              MOVS     r2,#7
000078  2108              MOVS     r1,#8
00007a  4862              LDR      r0,|L1.516|
00007c  f7fffffe          BL       GPIO_PinAFConfig
;;;304    	/*将 PD9 映射为 USART3_RX */
;;;305    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_USART3);
000080  2207              MOVS     r2,#7
000082  2109              MOVS     r1,#9
000084  485f              LDR      r0,|L1.516|
000086  f7fffffe          BL       GPIO_PinAFConfig
;;;306    	
;;;307      //USARTx configured as follows: 
;;;308    	//921600 baud, 8 Bits, 1 Stop, No Parity, 
;;;309    	//No Flow Control, Receive and Transmit Enabled.
;;;310    	//USART_StructInit(&USART_InitStructure);
;;;311      USART_InitStructure.USART_BaudRate = 921600;
00008a  f44f2061          MOV      r0,#0xe1000
00008e  9003              STR      r0,[sp,#0xc]
;;;312      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000090  2000              MOVS     r0,#0
000092  f8ad0010          STRH     r0,[sp,#0x10]
;;;313      USART_InitStructure.USART_StopBits = USART_StopBits_1;
000096  f8ad0012          STRH     r0,[sp,#0x12]
;;;314      USART_InitStructure.USART_Parity = USART_Parity_No;
00009a  f8ad0014          STRH     r0,[sp,#0x14]
;;;315      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00009e  f8ad0018          STRH     r0,[sp,#0x18]
;;;316      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000a2  200c              MOVS     r0,#0xc
0000a4  f8ad0016          STRH     r0,[sp,#0x16]
;;;317    	USART_Init(USART3,&USART_InitStructure);
0000a8  a903              ADD      r1,sp,#0xc
0000aa  4857              LDR      r0,|L1.520|
0000ac  f7fffffe          BL       USART_Init
;;;318    	USART_Cmd(USART3,ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  4855              LDR      r0,|L1.520|
0000b4  f7fffffe          BL       USART_Cmd
;;;319      //Output a message using printf function.
;;;320      printf("\nUSART Initialized\n");
0000b8  a054              ADR      r0,|L1.524|
0000ba  f7fffffe          BL       __2printf
;;;321    }
0000be  b007              ADD      sp,sp,#0x1c
0000c0  bd00              POP      {pc}
;;;322    
                          ENDP

                  main PROC
;;;100      */
;;;101    int main(void)
0000c2  b508              PUSH     {r3,lr}
;;;102    {
;;;103      /*!< At this stage the microcontroller clock setting is already configured to 
;;;104           168 MHz, this is done through SystemInit() function which is called from
;;;105           startup file (startup_stm32f4xx.s) before to branch to application main.
;;;106           To reconfigure the default setting of SystemInit() function, refer to
;;;107           system_stm32f4xx.c file
;;;108         */
;;;109    	sys_msleep(100);
0000c4  2064              MOVS     r0,#0x64
0000c6  f7fffffe          BL       osDelay
;;;110     	/* Initialize UART */
;;;111    	//UART_Init();
;;;112    	UART3_Init();
0000ca  f7fffffe          BL       UART3_Init
;;;113    
;;;114    	/* Initialize LCD and Leds */
;;;115    	LCD_LED_Init();
0000ce  f7fffffe          BL       LCD_LED_Init
;;;116    
;;;117    	/* Configure ethernet (GPIOs, clocks, MAC, DMA) */ 
;;;118    	ETH_BSP_Config();
0000d2  f7fffffe          BL       ETH_BSP_Config
;;;119        
;;;120    	/* Initilaize the LwIP stack */
;;;121    	LwIP_Init();
0000d6  f7fffffe          BL       LwIP_Init
;;;122      
;;;123    	/* Initialize the PTP daemon. */
;;;124    	ptpd_init();
0000da  f7fffffe          BL       ptpd_init
;;;125    
;;;126    	/* Initialize telnet shell server. */
;;;127    	//telnet_shell_init();
;;;128    	
;;;129    	//打开时间戳的测试
;;;130    	time_init();
0000de  f7fffffe          BL       time_init
;;;131    	
;;;132    	//接收来自惯导的数据
;;;133    	//NavgationProcess_Init();
;;;134    	
;;;135    	//点云转发
;;;136    	laserCloud_Init();
0000e2  f7fffffe          BL       laserCloud_Init
;;;137    
;;;138    	sys_thread_new("JOB1",led4,NULL,DEFAULT_THREAD_STACKSIZE,-1);
0000e6  f04f30ff          MOV      r0,#0xffffffff
0000ea  f44f6380          MOV      r3,#0x400
0000ee  2200              MOVS     r2,#0
0000f0  f2af01f3          ADR      r1,led4 + 1
0000f4  9000              STR      r0,[sp,#0]
0000f6  a04a              ADR      r0,|L1.544|
0000f8  f7fffffe          BL       sys_thread_new
;;;139      //sys_thread_new("JOB2",led3,NULL,DEFAULT_THREAD_STACKSIZE,-1);
;;;140    
;;;141    #ifdef USE_DHCP
;;;142      /* Start DHCP Client */
;;;143    	sys_thread_new("DHCP", LwIP_DHCP_task, NULL, DEFAULT_THREAD_STACKSIZE, DHCP_TASK_PRIO);
;;;144    #endif
;;;145    	osKernelStart();
0000fc  f7fffffe          BL       osKernelStart
;;;146    	for ( ;; )
000100  bf00              NOP      
                  |L1.258|
;;;147    	{
;;;148    		/* Toggle LED4 each 250ms */
;;;149    		//STM_EVAL_LEDToggle(LED4);
;;;150    		sys_msleep(20);
000102  2014              MOVS     r0,#0x14
000104  f7fffffe          BL       osDelay
000108  e7fb              B        |L1.258|
;;;151    	}	
;;;152    }
;;;153    
                          ENDP

                  UART_Init PROC
;;;199      */
;;;200    void UART_Init(void)
00010a  b51f              PUSH     {r0-r4,lr}
;;;201    {
;;;202    	USART_InitTypeDef USART_InitStructure;
;;;203    
;;;204      //USARTx configured as follows: 
;;;205    	//921600 baud, 8 Bits, 1 Stop, No Parity, 
;;;206    	//No Flow Control, Receive and Transmit Enabled.
;;;207    	USART_StructInit(&USART_InitStructure);
00010c  4668              MOV      r0,sp
00010e  f7fffffe          BL       USART_StructInit
;;;208      USART_InitStructure.USART_BaudRate = 921600;
000112  f44f2061          MOV      r0,#0xe1000
000116  9000              STR      r0,[sp,#0]
;;;209      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000118  2000              MOVS     r0,#0
00011a  f8ad0004          STRH     r0,[sp,#4]
;;;210      USART_InitStructure.USART_StopBits = USART_StopBits_1;
00011e  f8ad0006          STRH     r0,[sp,#6]
;;;211      USART_InitStructure.USART_Parity = USART_Parity_No;
000122  f8ad0008          STRH     r0,[sp,#8]
;;;212      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000126  f8ad000c          STRH     r0,[sp,#0xc]
;;;213      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00012a  200c              MOVS     r0,#0xc
00012c  f8ad000a          STRH     r0,[sp,#0xa]
;;;214      STM_EVAL_COMInit(COM2, &USART_InitStructure);//原来是COM1
000130  4669              MOV      r1,sp
000132  2001              MOVS     r0,#1
000134  f7fffffe          BL       STM_EVAL_COMInit
;;;215    
;;;216      //Output a message using printf function.
;;;217      printf("\nUSART Initialized\n");
000138  a034              ADR      r0,|L1.524|
00013a  f7fffffe          BL       __2printf
;;;218    }
00013e  bd1f              POP      {r0-r4,pc}
;;;219    
                          ENDP

                  UART1_Init PROC
;;;220    void UART1_Init(void)
000140  b500              PUSH     {lr}
;;;221    {
000142  b087              SUB      sp,sp,#0x1c
;;;222    	/***************************************
;;;223    	*初始化串口1，主要用于调试的所用
;;;224    	****************************************/
;;;225    	USART_InitTypeDef USART_InitStructure;
;;;226    	GPIO_InitTypeDef GPIO_InitStructure;
;;;227    	
;;;228    	/* 第1步：配置GPIO */
;;;229    	/* TX = PA9  RX = PA10 */
;;;230    	/* 打开GPIO时钟 */
;;;231    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000144  2101              MOVS     r1,#1
000146  4608              MOV      r0,r1
000148  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;232    	//RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;233    
;;;234    	/*打开UART时钟*/
;;;235    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00014c  2101              MOVS     r1,#1
00014e  2010              MOVS     r0,#0x10
000150  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;236    	/*将PA9,PB6映射为USART1_TX*/
;;;237    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000154  2207              MOVS     r2,#7
000156  2109              MOVS     r1,#9
000158  4833              LDR      r0,|L1.552|
00015a  f7fffffe          BL       GPIO_PinAFConfig
;;;238    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1);
;;;239      /*将 PA10,PB7 映射为 USART1_RX */
;;;240    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
00015e  2207              MOVS     r2,#7
000160  210a              MOVS     r1,#0xa
000162  4831              LDR      r0,|L1.552|
000164  f7fffffe          BL       GPIO_PinAFConfig
;;;241    	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);
;;;242    	
;;;243    	/* 配置 USART Tx 为复用功能 */
;;;244    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000168  2000              MOVS     r0,#0
00016a  f88d000a          STRB     r0,[sp,#0xa]
;;;245    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
00016e  2001              MOVS     r0,#1
000170  f88d000b          STRB     r0,[sp,#0xb]
;;;246    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
000174  2002              MOVS     r0,#2
000176  f88d0008          STRB     r0,[sp,#8]
;;;247    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00017a  f88d0009          STRB     r0,[sp,#9]
;;;248    
;;;249    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00017e  0200              LSLS     r0,r0,#8
000180  9001              STR      r0,[sp,#4]
;;;250    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000182  a901              ADD      r1,sp,#4
000184  4828              LDR      r0,|L1.552|
000186  f7fffffe          BL       GPIO_Init
;;;251    	
;;;252    	/* 配置 USART Rx 为复用功能 */
;;;253    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00018a  f44f6080          MOV      r0,#0x400
00018e  9001              STR      r0,[sp,#4]
;;;254    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000190  a901              ADD      r1,sp,#4
000192  4825              LDR      r0,|L1.552|
000194  f7fffffe          BL       GPIO_Init
;;;255    	
;;;256    	//配置USART Tx,Rx
;;;257    	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;
;;;258    	//GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;259    	
;;;260      //USARTx configured as follows: 
;;;261    	//921600 baud, 8 Bits, 1 Stop, No Parity, 
;;;262    	//No Flow Control, Receive and Transmit Enabled.
;;;263    	USART_StructInit(&USART_InitStructure);
000198  a803              ADD      r0,sp,#0xc
00019a  f7fffffe          BL       USART_StructInit
;;;264      USART_InitStructure.USART_BaudRate = 921600;
00019e  f44f2061          MOV      r0,#0xe1000
0001a2  9003              STR      r0,[sp,#0xc]
;;;265      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001a4  2000              MOVS     r0,#0
0001a6  f8ad0010          STRH     r0,[sp,#0x10]
;;;266      USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001aa  f8ad0012          STRH     r0,[sp,#0x12]
;;;267      USART_InitStructure.USART_Parity = USART_Parity_No;
0001ae  f8ad0014          STRH     r0,[sp,#0x14]
;;;268      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0001b2  f8ad0018          STRH     r0,[sp,#0x18]
;;;269      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001b6  200c              MOVS     r0,#0xc
0001b8  f8ad0016          STRH     r0,[sp,#0x16]
;;;270    	USART_Init(USART1,&USART_InitStructure);
0001bc  a903              ADD      r1,sp,#0xc
0001be  481b              LDR      r0,|L1.556|
0001c0  f7fffffe          BL       USART_Init
;;;271    	USART_Cmd(USART1,ENABLE);
0001c4  2101              MOVS     r1,#1
0001c6  4819              LDR      r0,|L1.556|
0001c8  f7fffffe          BL       USART_Cmd
;;;272      //Output a message using printf function.
;;;273      printf("\nUSART Initialized\n");
0001cc  a00f              ADR      r0,|L1.524|
0001ce  f7fffffe          BL       __2printf
;;;274    }
0001d2  b007              ADD      sp,sp,#0x1c
0001d4  bd00              POP      {pc}
;;;275    
                          ENDP

                  fputc PROC
;;;358      */
;;;359    int fputc(int ch, FILE *f)
0001d6  b570              PUSH     {r4-r6,lr}
;;;360    {
0001d8  4604              MOV      r4,r0
0001da  460d              MOV      r5,r1
;;;361    	/* Send a CRLF for each LF. */
;;;362    	if (ch == '\n') fputc('\r', f);
0001dc  2c0a              CMP      r4,#0xa
0001de  d103              BNE      |L1.488|
0001e0  4629              MOV      r1,r5
0001e2  200d              MOVS     r0,#0xd
0001e4  f7fffffe          BL       fputc
                  |L1.488|
;;;363    
;;;364    	/* Send the character. */
;;;365      //USART_SendData(EVAL_COM2, (uint8_t) ch);
;;;366    	USART_SendData(USART3, (uint8_t) ch);
0001e8  b2e1              UXTB     r1,r4
0001ea  4807              LDR      r0,|L1.520|
0001ec  f7fffffe          BL       USART_SendData
;;;367    
;;;368      /* Loop until the end of transmission. */
;;;369      //while (USART_GetFlagStatus(EVAL_COM2, USART_FLAG_TC) == RESET);
;;;370    	while (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){}
0001f0  bf00              NOP      
                  |L1.498|
0001f2  2140              MOVS     r1,#0x40
0001f4  4804              LDR      r0,|L1.520|
0001f6  f7fffffe          BL       USART_GetFlagStatus
0001fa  2800              CMP      r0,#0
0001fc  d0f9              BEQ      |L1.498|
;;;371    
;;;372      return ch;
0001fe  4620              MOV      r0,r4
;;;373    }
000200  bd70              POP      {r4-r6,pc}
;;;374    
                          ENDP

000202  0000              DCW      0x0000
                  |L1.516|
                          DCD      0x40020c00
                  |L1.520|
                          DCD      0x40004800
                  |L1.524|
00020c  0a555341          DCB      "\nUSART Initialized\n",0
000210  52542049
000214  6e697469
000218  616c697a
00021c  65640a00
                  |L1.544|
000220  4a4f4231          DCB      "JOB1",0
000224  00      
000225  00                DCB      0
000226  00                DCB      0
000227  00                DCB      0
                  |L1.552|
                          DCD      0x40020000
                  |L1.556|
                          DCD      0x40011000

;*** Start embedded assembler ***

#line 1 "..\\src\\main.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_led4____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_led4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_led4____REVSH|
#line 128
|__asm___6_main_c_led4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
