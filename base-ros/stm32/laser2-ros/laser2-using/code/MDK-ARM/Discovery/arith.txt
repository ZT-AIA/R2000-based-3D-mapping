; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\arith.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\arith.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\arith.crf ..\..\libraries\ptpd-2.0.0\src\arith.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  scaledNanosecondsToInternalTime PROC
;;;4      
;;;5      void scaledNanosecondsToInternalTime(const int64_t *scaledNanoseconds, TimeInternal *internal)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;6      {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
;;;7      	int sign;
;;;8      	int64_t nanoseconds = *scaledNanoseconds;
000008  e9d85600          LDRD     r5,r6,[r8,#0]
;;;9      
;;;10     	/* Determine sign of result big integer number */
;;;11     	if (nanoseconds < 0)
00000c  2100              MOVS     r1,#0
00000e  4608              MOV      r0,r1
000010  1a69              SUBS     r1,r5,r1
000012  eb760000          SBCS     r0,r6,r0
000016  da06              BGE      |L1.38|
;;;12     	{
;;;13     		nanoseconds = -nanoseconds;
000018  2300              MOVS     r3,#0
00001a  ebd50503          RSBS     r5,r5,r3
00001e  eb630606          SBC      r6,r3,r6
;;;14     		sign = -1;
000022  1e5c              SUBS     r4,r3,#1
000024  e000              B        |L1.40|
                  |L1.38|
;;;15     	}
;;;16     	else
;;;17     	{
;;;18     		sign = 1;
000026  2401              MOVS     r4,#1
                  |L1.40|
;;;19     	}
;;;20     
;;;21     	/* fractional nanoseconds are excluded (see 5.3.2) */
;;;22     	nanoseconds >>= 16;
000028  0c28              LSRS     r0,r5,#16
00002a  ea404506          ORR      r5,r0,r6,LSL #16
00002e  1436              ASRS     r6,r6,#16
;;;23     	internal->seconds = sign * (nanoseconds / 1000000000);
000030  4a5a              LDR      r2,|L1.412|
000032  2300              MOVS     r3,#0
000034  4628              MOV      r0,r5
000036  4631              MOV      r1,r6
000038  f7fffffe          BL       __aeabi_ldivmod
00003c  fba00104          UMULL    r0,r1,r0,r4
000040  6038              STR      r0,[r7,#0]
;;;24     	internal->nanoseconds = sign * (nanoseconds % 1000000000);
000042  4a56              LDR      r2,|L1.412|
000044  2300              MOVS     r3,#0
000046  4628              MOV      r0,r5
000048  4631              MOV      r1,r6
00004a  f7fffffe          BL       __aeabi_ldivmod
00004e  fba20104          UMULL    r0,r1,r2,r4
000052  6078              STR      r0,[r7,#4]
;;;25     }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;26     
                          ENDP

                  fromInternalTime PROC
;;;27     void fromInternalTime(const TimeInternal *internal, Timestamp *external)
000058  6802              LDR      r2,[r0,#0]
;;;28     {
;;;29     	/* fromInternalTime is only used to convert time given by the system to a timestamp
;;;30     	 * As a consequence, no negative value can normally be found in (internal)
;;;31     	 * Note that offsets are also represented with TimeInternal structure, and can be negative,
;;;32     	 * but offset are never convert into Timestamp so there is no problem here.*/
;;;33     	if ((internal->seconds & ~INT_MAX) || (internal->nanoseconds & ~INT_MAX))
00005a  f0024200          AND      r2,r2,#0x80000000
00005e  b91a              CBNZ     r2,|L1.104|
000060  6842              LDR      r2,[r0,#4]
000062  f0024200          AND      r2,r2,#0x80000000
000066  b102              CBZ      r2,|L1.106|
                  |L1.104|
;;;34     	{
;;;35     		DBG("Negative value canno't be converted into timestamp \n");
;;;36     		return;
;;;37     	}
;;;38     	else
;;;39     	{
;;;40     		external->secondsField.lsb = internal->seconds;
;;;41     		external->nanosecondsField = internal->nanoseconds;
;;;42     		external->secondsField.msb = 0;
;;;43     	}
;;;44     }
000068  4770              BX       lr
                  |L1.106|
00006a  6802              LDR      r2,[r0,#0]            ;40
00006c  600a              STR      r2,[r1,#0]            ;40
00006e  6842              LDR      r2,[r0,#4]            ;41
000070  608a              STR      r2,[r1,#8]            ;41
000072  2200              MOVS     r2,#0                 ;42
000074  808a              STRH     r2,[r1,#4]            ;42
000076  bf00              NOP      
000078  e7f6              B        |L1.104|
;;;45     
                          ENDP

                  toInternalTime PROC
;;;46     void toInternalTime(TimeInternal *internal, const Timestamp *external)
00007a  f06f4300          MVN      r3,#0x80000000
;;;47     {
;;;48     	/* Program will not run after 2038... */
;;;49     	if (external->secondsField.lsb < INT_MAX)
00007e  680a              LDR      r2,[r1,#0]
000080  429a              CMP      r2,r3
000082  d204              BCS      |L1.142|
;;;50     	{
;;;51     		internal->seconds = external->secondsField.lsb;
000084  680a              LDR      r2,[r1,#0]
000086  6002              STR      r2,[r0,#0]
;;;52     		internal->nanoseconds = external->nanosecondsField;
000088  688a              LDR      r2,[r1,#8]
00008a  6042              STR      r2,[r0,#4]
00008c  e000              B        |L1.144|
                  |L1.142|
;;;53     	}
;;;54     	else
;;;55     	{
;;;56     		DBG("Clock servo canno't be executed : seconds field is higher than signed integer (32bits)\n");
;;;57     		return;
;;;58     	}
;;;59     }
00008e  4770              BX       lr
                  |L1.144|
000090  bf00              NOP      
000092  e7fc              B        |L1.142|
;;;60     
                          ENDP

                  normalizeTime PROC
;;;61     void normalizeTime(TimeInternal *r)
000094  4a41              LDR      r2,|L1.412|
;;;62     {
;;;63     	r->seconds += r->nanoseconds / 1000000000;
000096  6841              LDR      r1,[r0,#4]
000098  fb91f1f2          SDIV     r1,r1,r2
00009c  6802              LDR      r2,[r0,#0]
00009e  4411              ADD      r1,r1,r2
0000a0  6001              STR      r1,[r0,#0]
;;;64     	r->nanoseconds -= r->nanoseconds / 1000000000 * 1000000000;
0000a2  4a3e              LDR      r2,|L1.412|
0000a4  6841              LDR      r1,[r0,#4]
0000a6  fb91f1f2          SDIV     r1,r1,r2
0000aa  1252              ASRS     r2,r2,#9
0000ac  4351              MULS     r1,r2,r1
0000ae  6842              LDR      r2,[r0,#4]
0000b0  eba22141          SUB      r1,r2,r1,LSL #9
0000b4  6041              STR      r1,[r0,#4]
;;;65     
;;;66     	if (r->seconds > 0 && r->nanoseconds < 0)
0000b6  6801              LDR      r1,[r0,#0]
0000b8  2900              CMP      r1,#0
0000ba  dd0a              BLE      |L1.210|
0000bc  6841              LDR      r1,[r0,#4]
0000be  2900              CMP      r1,#0
0000c0  da07              BGE      |L1.210|
;;;67     	{
;;;68     		r->seconds -= 1;
0000c2  6801              LDR      r1,[r0,#0]
0000c4  1e49              SUBS     r1,r1,#1
0000c6  6001              STR      r1,[r0,#0]
;;;69     		r->nanoseconds += 1000000000;
0000c8  4a34              LDR      r2,|L1.412|
0000ca  6841              LDR      r1,[r0,#4]
0000cc  4411              ADD      r1,r1,r2
0000ce  6041              STR      r1,[r0,#4]
0000d0  e00c              B        |L1.236|
                  |L1.210|
;;;70     	}
;;;71     	else if (r->seconds < 0 && r->nanoseconds > 0)
0000d2  6801              LDR      r1,[r0,#0]
0000d4  2900              CMP      r1,#0
0000d6  da09              BGE      |L1.236|
0000d8  6841              LDR      r1,[r0,#4]
0000da  2900              CMP      r1,#0
0000dc  dd06              BLE      |L1.236|
;;;72     	{
;;;73     		r->seconds += 1;
0000de  6801              LDR      r1,[r0,#0]
0000e0  1c49              ADDS     r1,r1,#1
0000e2  6001              STR      r1,[r0,#0]
;;;74     		r->nanoseconds -= 1000000000;
0000e4  4a2d              LDR      r2,|L1.412|
0000e6  6841              LDR      r1,[r0,#4]
0000e8  1a89              SUBS     r1,r1,r2
0000ea  6041              STR      r1,[r0,#4]
                  |L1.236|
;;;75     	}
;;;76     }
0000ec  4770              BX       lr
;;;77     
                          ENDP

                  addTime PROC
;;;78     void addTime(TimeInternal *r, const TimeInternal *x, const TimeInternal *y)
0000ee  b530              PUSH     {r4,r5,lr}
;;;79     {
0000f0  4603              MOV      r3,r0
0000f2  460c              MOV      r4,r1
0000f4  4615              MOV      r5,r2
;;;80     	r->seconds = x->seconds + y->seconds;
0000f6  6820              LDR      r0,[r4,#0]
0000f8  6829              LDR      r1,[r5,#0]
0000fa  4408              ADD      r0,r0,r1
0000fc  6018              STR      r0,[r3,#0]
;;;81     	r->nanoseconds = x->nanoseconds + y->nanoseconds;
0000fe  6860              LDR      r0,[r4,#4]
000100  6869              LDR      r1,[r5,#4]
000102  4408              ADD      r0,r0,r1
000104  6058              STR      r0,[r3,#4]
;;;82     
;;;83     	normalizeTime(r);
000106  4618              MOV      r0,r3
000108  f7fffffe          BL       normalizeTime
;;;84     }
00010c  bd30              POP      {r4,r5,pc}
;;;85     
                          ENDP

                  subTime PROC
;;;86     void subTime(TimeInternal *r, const TimeInternal *x, const TimeInternal *y)
00010e  b530              PUSH     {r4,r5,lr}
;;;87     {
000110  4603              MOV      r3,r0
000112  460c              MOV      r4,r1
000114  4615              MOV      r5,r2
;;;88     	r->seconds = x->seconds - y->seconds;
000116  6820              LDR      r0,[r4,#0]
000118  6829              LDR      r1,[r5,#0]
00011a  1a40              SUBS     r0,r0,r1
00011c  6018              STR      r0,[r3,#0]
;;;89     	r->nanoseconds = x->nanoseconds - y->nanoseconds;
00011e  6860              LDR      r0,[r4,#4]
000120  6869              LDR      r1,[r5,#4]
000122  1a40              SUBS     r0,r0,r1
000124  6058              STR      r0,[r3,#4]
;;;90     
;;;91     	normalizeTime(r);
000126  4618              MOV      r0,r3
000128  f7fffffe          BL       normalizeTime
;;;92     }
00012c  bd30              POP      {r4,r5,pc}
;;;93     
                          ENDP

                  div2Time PROC
;;;94     void div2Time(TimeInternal *r)
00012e  b500              PUSH     {lr}
;;;95     {
000130  4603              MOV      r3,r0
;;;96     	r->nanoseconds += r->seconds % 2 * 1000000000;
000132  6818              LDR      r0,[r3,#0]
000134  eb0071d0          ADD      r1,r0,r0,LSR #31
000138  1049              ASRS     r1,r1,#1
00013a  eba00141          SUB      r1,r0,r1,LSL #1
00013e  4a18              LDR      r2,|L1.416|
000140  4351              MULS     r1,r2,r1
000142  685a              LDR      r2,[r3,#4]
000144  eb022141          ADD      r1,r2,r1,LSL #9
000148  6059              STR      r1,[r3,#4]
;;;97     	r->seconds /= 2;
00014a  6818              LDR      r0,[r3,#0]
00014c  eb0071d0          ADD      r1,r0,r0,LSR #31
000150  1049              ASRS     r1,r1,#1
000152  6019              STR      r1,[r3,#0]
;;;98     	r->nanoseconds /= 2;
000154  6858              LDR      r0,[r3,#4]
000156  eb0071d0          ADD      r1,r0,r0,LSR #31
00015a  1049              ASRS     r1,r1,#1
00015c  6059              STR      r1,[r3,#4]
;;;99     
;;;100    	normalizeTime(r);
00015e  4618              MOV      r0,r3
000160  f7fffffe          BL       normalizeTime
;;;101    }
000164  bd00              POP      {pc}
;;;102    
                          ENDP

                  floorLog2 PROC
;;;103    int32_t floorLog2(uint32_t n)
000166  4601              MOV      r1,r0
;;;104    {
;;;105    	int pos = 0;
000168  2200              MOVS     r2,#0
;;;106    
;;;107    	if (n == 0)
00016a  b909              CBNZ     r1,|L1.368|
;;;108    		return -1;
00016c  1e50              SUBS     r0,r2,#1
                  |L1.366|
;;;109    
;;;110    	if (n >= 1<<16) { n >>= 16; pos += 16; }
;;;111    	if (n >= 1<< 8) { n >>=  8; pos +=  8; }
;;;112    	if (n >= 1<< 4) { n >>=  4; pos +=  4; }
;;;113    	if (n >= 1<< 2) { n >>=  2; pos +=  2; }
;;;114    	if (n >= 1<< 1) {           pos +=  1; }
;;;115    	return pos;
;;;116    }
00016e  4770              BX       lr
                  |L1.368|
000170  f5b13f80          CMP      r1,#0x10000           ;110
000174  d301              BCC      |L1.378|
000176  0c09              LSRS     r1,r1,#16             ;110
000178  3210              ADDS     r2,r2,#0x10           ;110
                  |L1.378|
00017a  29ff              CMP      r1,#0xff              ;111
00017c  d901              BLS      |L1.386|
00017e  0a09              LSRS     r1,r1,#8              ;111
000180  3208              ADDS     r2,r2,#8              ;111
                  |L1.386|
000182  2910              CMP      r1,#0x10              ;112
000184  d301              BCC      |L1.394|
000186  0909              LSRS     r1,r1,#4              ;112
000188  1d12              ADDS     r2,r2,#4              ;112
                  |L1.394|
00018a  2904              CMP      r1,#4                 ;113
00018c  d301              BCC      |L1.402|
00018e  0889              LSRS     r1,r1,#2              ;113
000190  1c92              ADDS     r2,r2,#2              ;113
                  |L1.402|
000192  2902              CMP      r1,#2                 ;114
000194  d300              BCC      |L1.408|
000196  1c52              ADDS     r2,r2,#1              ;114
                  |L1.408|
000198  4610              MOV      r0,r2                 ;115
00019a  e7e8              B        |L1.366|
                          ENDP

                  |L1.412|
                          DCD      0x3b9aca00
                  |L1.416|
                          DCD      0x001dcd65

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\arith.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_arith_c_40893358____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_arith_c_40893358____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_arith_c_40893358____REVSH|
#line 128
|__asm___7_arith_c_40893358____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
