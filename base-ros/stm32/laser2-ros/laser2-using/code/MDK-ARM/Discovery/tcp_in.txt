; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\tcp_in.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\tcp_in.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\tcp_in.crf ..\..\libraries\lwip-1.4.1\src\core\tcp_in.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tcp_receive PROC
;;;846    static void
;;;847    tcp_receive(struct tcp_pcb *pcb)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;848    {
000004  4604              MOV      r4,r0
;;;849      struct tcp_seg *next;
;;;850    #if TCP_QUEUE_OOSEQ
;;;851      struct tcp_seg *prev, *cseg;
;;;852    #endif /* TCP_QUEUE_OOSEQ */
;;;853      struct pbuf *p;
;;;854      s32_t off;
;;;855      s16_t m;
;;;856      u32_t right_wnd_edge;
;;;857      u16_t new_tot_len;
;;;858      int found_dupack = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;859    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;860      u32_t ooseq_blen;
;;;861      u16_t ooseq_qlen;
;;;862    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;863    
;;;864      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;865    
;;;866      if (flags & TCP_ACK) {
00000e  48fe              LDR      r0,|L1.1032|
000010  7800              LDRB     r0,[r0,#0]  ; flags
000012  f0000010          AND      r0,r0,#0x10
000016  2800              CMP      r0,#0
000018  d07e              BEQ      |L1.280|
;;;867        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
00001a  f8b40060          LDRH     r0,[r4,#0x60]
00001e  6da1              LDR      r1,[r4,#0x58]
000020  eb000901          ADD      r9,r0,r1
;;;868    
;;;869        /* Update window. */
;;;870        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000024  49f9              LDR      r1,|L1.1036|
000026  6d60              LDR      r0,[r4,#0x54]
000028  6809              LDR      r1,[r1,#0]  ; seqno
00002a  1a40              SUBS     r0,r0,r1
00002c  d415              BMI      |L1.90|
;;;871           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
00002e  49f7              LDR      r1,|L1.1036|
000030  6d60              LDR      r0,[r4,#0x54]
000032  6809              LDR      r1,[r1,#0]  ; seqno
000034  4288              CMP      r0,r1
000036  d104              BNE      |L1.66|
000038  49f5              LDR      r1,|L1.1040|
00003a  6da0              LDR      r0,[r4,#0x58]
00003c  6809              LDR      r1,[r1,#0]  ; ackno
00003e  1a40              SUBS     r0,r0,r1
000040  d40b              BMI      |L1.90|
                  |L1.66|
;;;872           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
000042  49f3              LDR      r1,|L1.1040|
000044  6da0              LDR      r0,[r4,#0x58]
000046  6809              LDR      r1,[r1,#0]  ; ackno
000048  4288              CMP      r0,r1
00004a  d133              BNE      |L1.180|
00004c  48f1              LDR      r0,|L1.1044|
00004e  6800              LDR      r0,[r0,#0]  ; tcphdr
000050  89c0              LDRH     r0,[r0,#0xe]
000052  f8b41060          LDRH     r1,[r4,#0x60]
000056  4288              CMP      r0,r1
000058  dd2c              BLE      |L1.180|
                  |L1.90|
;;;873          pcb->snd_wnd = tcphdr->wnd;
00005a  48ee              LDR      r0,|L1.1044|
00005c  6800              LDR      r0,[r0,#0]  ; tcphdr
00005e  89c0              LDRH     r0,[r0,#0xe]
000060  f8a40060          STRH     r0,[r4,#0x60]
;;;874          /* keep track of the biggest window announced by the remote host to calculate
;;;875             the maximum segment size */
;;;876          if (pcb->snd_wnd_max < tcphdr->wnd) {
000064  f8b40062          LDRH     r0,[r4,#0x62]
000068  49ea              LDR      r1,|L1.1044|
00006a  6809              LDR      r1,[r1,#0]  ; tcphdr
00006c  89c9              LDRH     r1,[r1,#0xe]
00006e  4288              CMP      r0,r1
000070  da04              BGE      |L1.124|
;;;877            pcb->snd_wnd_max = tcphdr->wnd;
000072  48e8              LDR      r0,|L1.1044|
000074  6800              LDR      r0,[r0,#0]  ; tcphdr
000076  89c0              LDRH     r0,[r0,#0xe]
000078  f8a40062          STRH     r0,[r4,#0x62]
                  |L1.124|
;;;878          }
;;;879          pcb->snd_wl1 = seqno;
00007c  48e3              LDR      r0,|L1.1036|
00007e  6800              LDR      r0,[r0,#0]  ; seqno
000080  6560              STR      r0,[r4,#0x54]
;;;880          pcb->snd_wl2 = ackno;
000082  48e3              LDR      r0,|L1.1040|
000084  6800              LDR      r0,[r0,#0]  ; ackno
000086  65a0              STR      r0,[r4,#0x58]
;;;881          if (pcb->snd_wnd == 0) {
000088  f8b40060          LDRH     r0,[r4,#0x60]
00008c  b948              CBNZ     r0,|L1.162|
;;;882            if (pcb->persist_backoff == 0) {
00008e  f8940091          LDRB     r0,[r4,#0x91]
000092  b968              CBNZ     r0,|L1.176|
;;;883              /* start persist timer */
;;;884              pcb->persist_cnt = 0;
000094  2000              MOVS     r0,#0
000096  f8840090          STRB     r0,[r4,#0x90]
;;;885              pcb->persist_backoff = 1;
00009a  2001              MOVS     r0,#1
00009c  f8840091          STRB     r0,[r4,#0x91]
0000a0  e006              B        |L1.176|
                  |L1.162|
;;;886            }
;;;887          } else if (pcb->persist_backoff > 0) {
0000a2  f8940091          LDRB     r0,[r4,#0x91]
0000a6  2800              CMP      r0,#0
0000a8  dd02              BLE      |L1.176|
;;;888            /* stop persist timer */
;;;889              pcb->persist_backoff = 0;
0000aa  2000              MOVS     r0,#0
0000ac  f8840091          STRB     r0,[r4,#0x91]
                  |L1.176|
;;;890          }
;;;891          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
0000b0  bf00              NOP      
0000b2  bf00              NOP      
                  |L1.180|
;;;892    #if TCP_WND_DEBUG
;;;893        } else {
;;;894          if (pcb->snd_wnd != tcphdr->wnd) {
;;;895            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;896                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;897                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;898                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;899          }
;;;900    #endif /* TCP_WND_DEBUG */
;;;901        }
;;;902    
;;;903        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;904         * duplicate ack if:
;;;905         * 1) It doesn't ACK new data 
;;;906         * 2) length of received packet is zero (i.e. no payload) 
;;;907         * 3) the advertised window hasn't changed 
;;;908         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;909         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;910         * 
;;;911         * If it passes all five, should process as a dupack: 
;;;912         * a) dupacks < 3: do nothing 
;;;913         * b) dupacks == 3: fast retransmit 
;;;914         * c) dupacks > 3: increase cwnd 
;;;915         * 
;;;916         * If it only passes 1-3, should reset dupack counter (and add to
;;;917         * stats, which we don't do in lwIP)
;;;918         *
;;;919         * If it only passes 1, should reset dupack counter
;;;920         *
;;;921         */
;;;922    
;;;923        /* Clause 1 */
;;;924        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
0000b4  49d6              LDR      r1,|L1.1040|
0000b6  6ca0              LDR      r0,[r4,#0x48]
0000b8  6809              LDR      r1,[r1,#0]  ; ackno
0000ba  1a08              SUBS     r0,r1,r0
0000bc  2800              CMP      r0,#0
0000be  dc47              BGT      |L1.336|
;;;925          pcb->acked = 0;
0000c0  2000              MOVS     r0,#0
0000c2  f8a40064          STRH     r0,[r4,#0x64]
;;;926          /* Clause 2 */
;;;927          if (tcplen == 0) {
0000c6  48d4              LDR      r0,|L1.1048|
0000c8  8800              LDRH     r0,[r0,#0]  ; tcplen
0000ca  bb30              CBNZ     r0,|L1.282|
;;;928            /* Clause 3 */
;;;929            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
0000cc  f8b41060          LDRH     r1,[r4,#0x60]
0000d0  6da0              LDR      r0,[r4,#0x58]
0000d2  4408              ADD      r0,r0,r1
0000d4  4548              CMP      r0,r9
0000d6  d135              BNE      |L1.324|
;;;930              /* Clause 4 */
;;;931              if (pcb->rtime >= 0) {
0000d8  f9b40034          LDRSH    r0,[r4,#0x34]
0000dc  2800              CMP      r0,#0
0000de  db31              BLT      |L1.324|
;;;932                /* Clause 5 */
;;;933                if (pcb->lastack == ackno) {
0000e0  49cb              LDR      r1,|L1.1040|
0000e2  6ca0              LDR      r0,[r4,#0x48]
0000e4  6809              LDR      r1,[r1,#0]  ; ackno
0000e6  4288              CMP      r0,r1
0000e8  d12c              BNE      |L1.324|
;;;934                  found_dupack = 1;
0000ea  2001              MOVS     r0,#1
0000ec  9000              STR      r0,[sp,#0]
;;;935                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
0000ee  f8940047          LDRB     r0,[r4,#0x47]
0000f2  1c40              ADDS     r0,r0,#1
0000f4  b2c0              UXTB     r0,r0
0000f6  f8941047          LDRB     r1,[r4,#0x47]
0000fa  4288              CMP      r0,r1
0000fc  dd04              BLE      |L1.264|
;;;936                    ++pcb->dupacks;
0000fe  f8940047          LDRB     r0,[r4,#0x47]
000102  1c40              ADDS     r0,r0,#1
000104  f8840047          STRB     r0,[r4,#0x47]
                  |L1.264|
;;;937                  }
;;;938                  if (pcb->dupacks > 3) {
000108  f8940047          LDRB     r0,[r4,#0x47]
00010c  2803              CMP      r0,#3
00010e  dd12              BLE      |L1.310|
;;;939                    /* Inflate the congestion window, but not if it means that
;;;940                       the value overflows. */
;;;941                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
000110  f8b4004c          LDRH     r0,[r4,#0x4c]
000114  8ee1              LDRH     r1,[r4,#0x36]
000116  e001              B        |L1.284|
                  |L1.280|
000118  e163              B        |L1.994|
                  |L1.282|
00011a  e00b              B        |L1.308|
                  |L1.284|
00011c  4408              ADD      r0,r0,r1
00011e  b280              UXTH     r0,r0
000120  f8b4104c          LDRH     r1,[r4,#0x4c]
000124  4288              CMP      r0,r1
000126  dd0d              BLE      |L1.324|
;;;942                      pcb->cwnd += pcb->mss;
000128  f8b4004c          LDRH     r0,[r4,#0x4c]
00012c  8ee1              LDRH     r1,[r4,#0x36]
00012e  4408              ADD      r0,r0,r1
000130  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.308|
000134  e006              B        |L1.324|
                  |L1.310|
;;;943                    }
;;;944                  } else if (pcb->dupacks == 3) {
000136  f8940047          LDRB     r0,[r4,#0x47]
00013a  2803              CMP      r0,#3
00013c  d102              BNE      |L1.324|
;;;945                    /* Do fast retransmit */
;;;946                    tcp_rexmit_fast(pcb);
00013e  4620              MOV      r0,r4
000140  f7fffffe          BL       tcp_rexmit_fast
                  |L1.324|
;;;947                  }
;;;948                }
;;;949              }
;;;950            }
;;;951          }
;;;952          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;953           * count of consecutive duplicate acks */
;;;954          if (!found_dupack) {
000144  9800              LDR      r0,[sp,#0]
000146  2800              CMP      r0,#0
000148  d101              BNE      |L1.334|
;;;955            pcb->dupacks = 0;
00014a  f8840047          STRB     r0,[r4,#0x47]
                  |L1.334|
00014e  e0b9              B        |L1.708|
                  |L1.336|
;;;956          }
;;;957        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
000150  6ca0              LDR      r0,[r4,#0x48]
000152  1c40              ADDS     r0,r0,#1
000154  49ae              LDR      r1,|L1.1040|
000156  6809              LDR      r1,[r1,#0]  ; ackno
000158  1a08              SUBS     r0,r1,r0
00015a  d47c              BMI      |L1.598|
00015c  49ac              LDR      r1,|L1.1040|
00015e  6d20              LDR      r0,[r4,#0x50]
000160  6809              LDR      r1,[r1,#0]  ; ackno
000162  1a08              SUBS     r0,r1,r0
000164  2800              CMP      r0,#0
000166  dc76              BGT      |L1.598|
;;;958          /* We come here when the ACK acknowledges new data. */
;;;959    
;;;960          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;961             in fast retransmit. Also reset the congestion window to the
;;;962             slow start threshold. */
;;;963          if (pcb->flags & TF_INFR) {
000168  7fa0              LDRB     r0,[r4,#0x1e]
00016a  f0000004          AND      r0,r0,#4
00016e  b138              CBZ      r0,|L1.384|
;;;964            pcb->flags &= ~TF_INFR;
000170  7fa0              LDRB     r0,[r4,#0x1e]
000172  f0200004          BIC      r0,r0,#4
000176  77a0              STRB     r0,[r4,#0x1e]
;;;965            pcb->cwnd = pcb->ssthresh;
000178  f8b4004e          LDRH     r0,[r4,#0x4e]
00017c  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.384|
;;;966          }
;;;967    
;;;968          /* Reset the number of retransmissions. */
;;;969          pcb->nrtx = 0;
000180  2000              MOVS     r0,#0
000182  3428              ADDS     r4,r4,#0x28
000184  77a0              STRB     r0,[r4,#0x1e]
;;;970    
;;;971          /* Reset the retransmission time-out. */
;;;972          pcb->rto = (pcb->sa >> 3) + pcb->sv;
000186  8b60              LDRH     r0,[r4,#0x1a]
000188  f9b41018          LDRSH    r1,[r4,#0x18]
00018c  eb0000e1          ADD      r0,r0,r1,ASR #3
000190  b200              SXTH     r0,r0
000192  83a0              STRH     r0,[r4,#0x1c]
;;;973    
;;;974          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;975          pcb->acked = (u16_t)(ackno - pcb->lastack);
000194  8c20              LDRH     r0,[r4,#0x20]
000196  499e              LDR      r1,|L1.1040|
000198  8809              LDRH     r1,[r1,#0]  ; ackno
00019a  1a08              SUBS     r0,r1,r0
00019c  87a0              STRH     r0,[r4,#0x3c]
;;;976    
;;;977          pcb->snd_buf += pcb->acked;
00019e  8fe0              LDRH     r0,[r4,#0x3e]
0001a0  8fa1              LDRH     r1,[r4,#0x3c]
0001a2  4408              ADD      r0,r0,r1
0001a4  87e0              STRH     r0,[r4,#0x3e]
;;;978    
;;;979          /* Reset the fast retransmit variables. */
;;;980          pcb->dupacks = 0;
0001a6  2000              MOVS     r0,#0
0001a8  77e0              STRB     r0,[r4,#0x1f]
;;;981          pcb->lastack = ackno;
0001aa  4899              LDR      r0,|L1.1040|
0001ac  6800              LDR      r0,[r0,#0]  ; ackno
0001ae  6220              STR      r0,[r4,#0x20]
;;;982    
;;;983          /* Update the congestion control variables (cwnd and
;;;984             ssthresh). */
;;;985          if (pcb->state >= ESTABLISHED) {
0001b0  f8140c10          LDRB     r0,[r4,#-0x10]
0001b4  3c28              SUBS     r4,r4,#0x28
0001b6  2804              CMP      r0,#4
0001b8  db27              BLT      |L1.522|
;;;986            if (pcb->cwnd < pcb->ssthresh) {
0001ba  f8b4004c          LDRH     r0,[r4,#0x4c]
0001be  f8b4104e          LDRH     r1,[r4,#0x4e]
0001c2  4288              CMP      r0,r1
0001c4  da10              BGE      |L1.488|
;;;987              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0001c6  f8b4004c          LDRH     r0,[r4,#0x4c]
0001ca  8ee1              LDRH     r1,[r4,#0x36]
0001cc  4408              ADD      r0,r0,r1
0001ce  b280              UXTH     r0,r0
0001d0  f8b4104c          LDRH     r1,[r4,#0x4c]
0001d4  4288              CMP      r0,r1
0001d6  dd05              BLE      |L1.484|
;;;988                pcb->cwnd += pcb->mss;
0001d8  f8b4004c          LDRH     r0,[r4,#0x4c]
0001dc  8ee1              LDRH     r1,[r4,#0x36]
0001de  4408              ADD      r0,r0,r1
0001e0  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.484|
;;;989              }
;;;990              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
0001e4  bf00              NOP      
0001e6  e010              B        |L1.522|
                  |L1.488|
;;;991            } else {
;;;992              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
0001e8  f8341f36          LDRH     r1,[r4,#0x36]!
0001ec  4349              MULS     r1,r1,r1
0001ee  8ae2              LDRH     r2,[r4,#0x16]
0001f0  fb91f1f2          SDIV     r1,r1,r2
0001f4  4411              ADD      r1,r1,r2
0001f6  b288              UXTH     r0,r1
;;;993              if (new_cwnd > pcb->cwnd) {
0001f8  8ae1              LDRH     r1,[r4,#0x16]
0001fa  3c36              SUBS     r4,r4,#0x36
0001fc  4281              CMP      r1,r0
0001fe  da01              BGE      |L1.516|
;;;994                pcb->cwnd = new_cwnd;
000200  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.516|
;;;995              }
;;;996              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
000204  bf00              NOP      
000206  bf00              NOP      
;;;997            }
000208  bf00              NOP      
                  |L1.522|
;;;998          }
;;;999          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
00020a  bf00              NOP      
00020c  bf00              NOP      
;;;1000                                       ackno,
;;;1001                                       pcb->unacked != NULL?
;;;1002                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1003                                       pcb->unacked != NULL?
;;;1004                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1005   
;;;1006         /* Remove segment from the unacknowledged list if the incoming
;;;1007            ACK acknowlegdes them. */
;;;1008         while (pcb->unacked != NULL &&
00020e  e02f              B        |L1.624|
                  |L1.528|
;;;1009                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1010                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1011           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
000210  bf00              NOP      
000212  bf00              NOP      
;;;1012                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1014                                         TCP_TCPLEN(pcb->unacked)));
;;;1015   
;;;1016           next = pcb->unacked;
000214  6f25              LDR      r5,[r4,#0x70]
;;;1017           pcb->unacked = pcb->unacked->next;
000216  6f20              LDR      r0,[r4,#0x70]
000218  6800              LDR      r0,[r0,#0]
00021a  6720              STR      r0,[r4,#0x70]
;;;1018   
;;;1019           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
00021c  bf00              NOP      
00021e  bf00              NOP      
;;;1020           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000220  bf00              NOP      
000222  6868              LDR      r0,[r5,#4]
000224  f7fffffe          BL       pbuf_clen
000228  bf00              NOP      
;;;1021           /* Prevent ACK for FIN to generate a sent event */
;;;1022           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
00022a  f8b40064          LDRH     r0,[r4,#0x64]
00022e  b158              CBZ      r0,|L1.584|
000230  6929              LDR      r1,[r5,#0x10]
000232  8988              LDRH     r0,[r1,#0xc]
000234  f7fffffe          BL       lwip_ntohs
000238  f0000001          AND      r0,r0,#1
00023c  b120              CBZ      r0,|L1.584|
;;;1023             pcb->acked--;
00023e  f8b40064          LDRH     r0,[r4,#0x64]
000242  1e40              SUBS     r0,r0,#1
000244  f8a40064          STRH     r0,[r4,#0x64]
                  |L1.584|
;;;1024           }
;;;1025   
;;;1026           pcb->snd_queuelen -= pbuf_clen(next->p);
000248  6868              LDR      r0,[r5,#4]
00024a  f7fffffe          BL       pbuf_clen
00024e  f8b41068          LDRH     r1,[r4,#0x68]
000252  1a08              SUBS     r0,r1,r0
000254  e000              B        |L1.600|
                  |L1.598|
000256  e032              B        |L1.702|
                  |L1.600|
000258  f8a40068          STRH     r0,[r4,#0x68]
;;;1027           tcp_seg_free(next);
00025c  4628              MOV      r0,r5
00025e  f7fffffe          BL       tcp_seg_free
;;;1028   
;;;1029           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
000262  bf00              NOP      
000264  bf00              NOP      
;;;1030           if (pcb->snd_queuelen != 0) {
000266  f8b40068          LDRH     r0,[r4,#0x68]
00026a  b108              CBZ      r0,|L1.624|
;;;1031             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
00026c  bf00              NOP      
00026e  bf00              NOP      
                  |L1.624|
000270  6f20              LDR      r0,[r4,#0x70]         ;1008
000272  b1c8              CBZ      r0,|L1.680|
000274  6f21              LDR      r1,[r4,#0x70]         ;1009
000276  6909              LDR      r1,[r1,#0x10]         ;1009
000278  6848              LDR      r0,[r1,#4]            ;1009
00027a  f7fffffe          BL       lwip_ntohl
00027e  4683              MOV      r11,r0                ;1009
000280  6f21              LDR      r1,[r4,#0x70]         ;1009
000282  6909              LDR      r1,[r1,#0x10]         ;1009
000284  8988              LDRH     r0,[r1,#0xc]          ;1009
000286  f7fffffe          BL       lwip_ntohs
00028a  f0000003          AND      r0,r0,#3              ;1009
00028e  b108              CBZ      r0,|L1.660|
000290  2001              MOVS     r0,#1                 ;1009
000292  e000              B        |L1.662|
                  |L1.660|
000294  2000              MOVS     r0,#0                 ;1009
                  |L1.662|
000296  6f21              LDR      r1,[r4,#0x70]         ;1009
000298  8909              LDRH     r1,[r1,#8]            ;1009
00029a  4408              ADD      r0,r0,r1              ;1009
00029c  4458              ADD      r0,r0,r11             ;1009
00029e  495c              LDR      r1,|L1.1040|
0002a0  6809              LDR      r1,[r1,#0]            ;1009  ; ackno
0002a2  1a40              SUBS     r0,r0,r1              ;1009
0002a4  2800              CMP      r0,#0                 ;1009
0002a6  ddb3              BLE      |L1.528|
                  |L1.680|
;;;1032                         pcb->unsent != NULL);
;;;1033           }
;;;1034         }
;;;1035   
;;;1036         /* If there's nothing left to acknowledge, stop the retransmit
;;;1037            timer, otherwise reset it to start again */
;;;1038         if(pcb->unacked == NULL)
0002a8  6f20              LDR      r0,[r4,#0x70]
0002aa  b918              CBNZ     r0,|L1.692|
;;;1039           pcb->rtime = -1;
0002ac  f04f30ff          MOV      r0,#0xffffffff
0002b0  86a0              STRH     r0,[r4,#0x34]
0002b2  e001              B        |L1.696|
                  |L1.692|
;;;1040         else
;;;1041           pcb->rtime = 0;
0002b4  2000              MOVS     r0,#0
0002b6  86a0              STRH     r0,[r4,#0x34]
                  |L1.696|
;;;1042   
;;;1043         pcb->polltmr = 0;
0002b8  2000              MOVS     r0,#0
0002ba  77e0              STRB     r0,[r4,#0x1f]
0002bc  e002              B        |L1.708|
                  |L1.702|
;;;1044       } else {
;;;1045         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1046         pcb->acked = 0;
0002be  2000              MOVS     r0,#0
0002c0  f8a40064          STRH     r0,[r4,#0x64]
                  |L1.708|
;;;1047       }
;;;1048   
;;;1049       /* We go through the ->unsent list to see if any of the segments
;;;1050          on the list are acknowledged by the ACK. This may seem
;;;1051          strange since an "unsent" segment shouldn't be acked. The
;;;1052          rationale is that lwIP puts all outstanding segments on the
;;;1053          ->unsent list after a retransmission, so these segments may
;;;1054          in fact have been sent once. */
;;;1055       while (pcb->unsent != NULL &&
0002c4  e032              B        |L1.812|
                  |L1.710|
;;;1056              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1057                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1058         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
0002c6  bf00              NOP      
0002c8  bf00              NOP      
;;;1059                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1060                                       TCP_TCPLEN(pcb->unsent)));
;;;1061   
;;;1062         next = pcb->unsent;
0002ca  6ee5              LDR      r5,[r4,#0x6c]
;;;1063         pcb->unsent = pcb->unsent->next;
0002cc  6ee0              LDR      r0,[r4,#0x6c]
0002ce  6800              LDR      r0,[r0,#0]
0002d0  66e0              STR      r0,[r4,#0x6c]
;;;1064   #if TCP_OVERSIZE
;;;1065         if (pcb->unsent == NULL) {
0002d2  6ee0              LDR      r0,[r4,#0x6c]
0002d4  b910              CBNZ     r0,|L1.732|
;;;1066           pcb->unsent_oversize = 0;
0002d6  2000              MOVS     r0,#0
0002d8  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L1.732|
;;;1067         }
;;;1068   #endif /* TCP_OVERSIZE */ 
;;;1069         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
0002dc  bf00              NOP      
0002de  bf00              NOP      
;;;1070         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
0002e0  bf00              NOP      
0002e2  6868              LDR      r0,[r5,#4]
0002e4  f7fffffe          BL       pbuf_clen
0002e8  bf00              NOP      
;;;1071         /* Prevent ACK for FIN to generate a sent event */
;;;1072         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
0002ea  f8b40064          LDRH     r0,[r4,#0x64]
0002ee  b158              CBZ      r0,|L1.776|
0002f0  6929              LDR      r1,[r5,#0x10]
0002f2  8988              LDRH     r0,[r1,#0xc]
0002f4  f7fffffe          BL       lwip_ntohs
0002f8  f0000001          AND      r0,r0,#1
0002fc  b120              CBZ      r0,|L1.776|
;;;1073           pcb->acked--;
0002fe  f8b40064          LDRH     r0,[r4,#0x64]
000302  1e40              SUBS     r0,r0,#1
000304  f8a40064          STRH     r0,[r4,#0x64]
                  |L1.776|
;;;1074         }
;;;1075         pcb->snd_queuelen -= pbuf_clen(next->p);
000308  6868              LDR      r0,[r5,#4]
00030a  f7fffffe          BL       pbuf_clen
00030e  f8b41068          LDRH     r1,[r4,#0x68]
000312  1a08              SUBS     r0,r1,r0
000314  f8a40068          STRH     r0,[r4,#0x68]
;;;1076         tcp_seg_free(next);
000318  4628              MOV      r0,r5
00031a  f7fffffe          BL       tcp_seg_free
;;;1077         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
00031e  bf00              NOP      
000320  bf00              NOP      
;;;1078         if (pcb->snd_queuelen != 0) {
000322  f8b40068          LDRH     r0,[r4,#0x68]
000326  b108              CBZ      r0,|L1.812|
;;;1079           LWIP_ASSERT("tcp_receive: valid queue length",
000328  bf00              NOP      
00032a  bf00              NOP      
                  |L1.812|
00032c  6ee0              LDR      r0,[r4,#0x6c]         ;1055
00032e  b1f0              CBZ      r0,|L1.878|
000330  6ee1              LDR      r1,[r4,#0x6c]         ;1056
000332  6909              LDR      r1,[r1,#0x10]         ;1056
000334  6848              LDR      r0,[r1,#4]            ;1056
000336  f7fffffe          BL       lwip_ntohl
00033a  4683              MOV      r11,r0                ;1056
00033c  6ee1              LDR      r1,[r4,#0x6c]         ;1056
00033e  6909              LDR      r1,[r1,#0x10]         ;1056
000340  8988              LDRH     r0,[r1,#0xc]          ;1056
000342  f7fffffe          BL       lwip_ntohs
000346  f0000003          AND      r0,r0,#3              ;1056
00034a  b108              CBZ      r0,|L1.848|
00034c  2001              MOVS     r0,#1                 ;1056
00034e  e000              B        |L1.850|
                  |L1.848|
000350  2000              MOVS     r0,#0                 ;1056
                  |L1.850|
000352  6ee1              LDR      r1,[r4,#0x6c]         ;1056
000354  8909              LDRH     r1,[r1,#8]            ;1056
000356  4408              ADD      r0,r0,r1              ;1056
000358  4458              ADD      r0,r0,r11             ;1056
00035a  492d              LDR      r1,|L1.1040|
00035c  6809              LDR      r1,[r1,#0]            ;1056  ; ackno
00035e  1a08              SUBS     r0,r1,r0              ;1056
000360  d405              BMI      |L1.878|
000362  492b              LDR      r1,|L1.1040|
000364  6d20              LDR      r0,[r4,#0x50]         ;1056
000366  6809              LDR      r1,[r1,#0]            ;1056  ; ackno
000368  1a08              SUBS     r0,r1,r0              ;1056
00036a  2800              CMP      r0,#0                 ;1056
00036c  ddab              BLE      |L1.710|
                  |L1.878|
;;;1080             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1081         }
;;;1082       }
;;;1083       /* End of ACK for new data processing. */
;;;1084   
;;;1085       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
00036e  bf00              NOP      
000370  bf00              NOP      
;;;1086                                   pcb->rttest, pcb->rtseq, ackno));
;;;1087   
;;;1088       /* RTT estimation calculations. This is done by checking if the
;;;1089          incoming segment acknowledges the segment we use to take a
;;;1090          round-trip time measurement. */
;;;1091       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
000372  6ba0              LDR      r0,[r4,#0x38]
000374  b3a8              CBZ      r0,|L1.994|
000376  4926              LDR      r1,|L1.1040|
000378  6be0              LDR      r0,[r4,#0x3c]
00037a  6809              LDR      r1,[r1,#0]  ; ackno
00037c  1a40              SUBS     r0,r0,r1
00037e  d530              BPL      |L1.994|
;;;1092         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1093            and a round-trip shouldn't be that long... */
;;;1094         m = (s16_t)(tcp_ticks - pcb->rttest);
000380  8f20              LDRH     r0,[r4,#0x38]
000382  4926              LDR      r1,|L1.1052|
000384  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
000386  1a08              SUBS     r0,r1,r0
000388  fa0ff880          SXTH     r8,r0
;;;1095   
;;;1096         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
00038c  bf00              NOP      
00038e  bf00              NOP      
;;;1097                                     m, m * TCP_SLOW_INTERVAL));
;;;1098   
;;;1099         /* This is taken directly from VJs original code in his paper */
;;;1100         m = m - (pcb->sa >> 3);
000390  f9340f40          LDRSH    r0,[r4,#0x40]!
000394  eba800e0          SUB      r0,r8,r0,ASR #3
000398  fa0ff880          SXTH     r8,r0
;;;1101         pcb->sa += m;
00039c  8820              LDRH     r0,[r4,#0]
00039e  4440              ADD      r0,r0,r8
0003a0  b200              SXTH     r0,r0
0003a2  f8240940          STRH     r0,[r4],#-0x40
;;;1102         if (m < 0) {
0003a6  f1b80f00          CMP      r8,#0
0003aa  da03              BGE      |L1.948|
;;;1103           m = -m;
0003ac  f1c80000          RSB      r0,r8,#0
0003b0  fa0ff880          SXTH     r8,r0
                  |L1.948|
;;;1104         }
;;;1105         m = m - (pcb->sv >> 2);
0003b4  3440              ADDS     r4,r4,#0x40
0003b6  f9b40002          LDRSH    r0,[r4,#2]
0003ba  eba800a0          SUB      r0,r8,r0,ASR #2
0003be  fa0ff880          SXTH     r8,r0
;;;1106         pcb->sv += m;
0003c2  8860              LDRH     r0,[r4,#2]
0003c4  4440              ADD      r0,r0,r8
0003c6  b200              SXTH     r0,r0
0003c8  8060              STRH     r0,[r4,#2]
;;;1107         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0003ca  8860              LDRH     r0,[r4,#2]
0003cc  f9b41000          LDRSH    r1,[r4,#0]
0003d0  eb0000e1          ADD      r0,r0,r1,ASR #3
0003d4  b200              SXTH     r0,r0
0003d6  80a0              STRH     r0,[r4,#4]
0003d8  3c40              SUBS     r4,r4,#0x40
;;;1108   
;;;1109         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
0003da  bf00              NOP      
0003dc  bf00              NOP      
;;;1110                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1111   
;;;1112         pcb->rttest = 0;
0003de  2000              MOVS     r0,#0
0003e0  63a0              STR      r0,[r4,#0x38]
                  |L1.994|
;;;1113       }
;;;1114     }
;;;1115   
;;;1116     /* If the incoming segment contains data, we must process it
;;;1117        further unless the pcb already received a FIN.
;;;1118        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1119        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1120     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
0003e2  480d              LDR      r0,|L1.1048|
0003e4  8800              LDRH     r0,[r0,#0]  ; tcplen
0003e6  2800              CMP      r0,#0
0003e8  dd7e              BLE      |L1.1256|
0003ea  7e20              LDRB     r0,[r4,#0x18]
0003ec  2807              CMP      r0,#7
0003ee  da7b              BGE      |L1.1256|
;;;1121       /* This code basically does three things:
;;;1122   
;;;1123       +) If the incoming segment contains data that is the next
;;;1124       in-sequence data, this data is passed to the application. This
;;;1125       might involve trimming the first edge of the data. The rcv_nxt
;;;1126       variable and the advertised window are adjusted.
;;;1127   
;;;1128       +) If the incoming segment has data that is above the next
;;;1129       sequence number expected (->rcv_nxt), the segment is placed on
;;;1130       the ->ooseq queue. This is done by finding the appropriate
;;;1131       place in the ->ooseq queue (which is ordered by sequence
;;;1132       number) and trim the segment in both ends if needed. An
;;;1133       immediate ACK is sent to indicate that we received an
;;;1134       out-of-sequence segment.
;;;1135   
;;;1136       +) Finally, we check if the first segment on the ->ooseq queue
;;;1137       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1138       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1139       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1140       segments that are now on sequence are chained onto the
;;;1141       incoming segment so that we only need to call the application
;;;1142       once.
;;;1143       */
;;;1144   
;;;1145       /* First, we check if we must trim the first edge. We have to do
;;;1146          this if the sequence number of the incoming segment is less
;;;1147          than rcv_nxt, and the sequence number plus the length of the
;;;1148          segment is larger than rcv_nxt. */
;;;1149       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1150             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1151       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
0003f0  4806              LDR      r0,|L1.1036|
0003f2  6aa1              LDR      r1,[r4,#0x28]
0003f4  6800              LDR      r0,[r0,#0]  ; seqno
0003f6  1c40              ADDS     r0,r0,#1
0003f8  1a08              SUBS     r0,r1,r0
0003fa  d458              BMI      |L1.1198|
0003fc  4803              LDR      r0,|L1.1036|
0003fe  6aa1              LDR      r1,[r4,#0x28]
000400  6800              LDR      r0,[r0,#0]  ; seqno
000402  4a05              LDR      r2,|L1.1048|
000404  8812              LDRH     r2,[r2,#0]  ; tcplen
000406  e00b              B        |L1.1056|
                  |L1.1032|
                          DCD      flags
                  |L1.1036|
                          DCD      seqno
                  |L1.1040|
                          DCD      ackno
                  |L1.1044|
                          DCD      tcphdr
                  |L1.1048|
                          DCD      tcplen
                  |L1.1052|
                          DCD      tcp_ticks
                  |L1.1056|
000420  4410              ADD      r0,r0,r2
000422  1e40              SUBS     r0,r0,#1
000424  1a08              SUBS     r0,r1,r0
000426  2800              CMP      r0,#0
000428  dc41              BGT      |L1.1198|
;;;1152         /* Trimming the first edge is done by pushing the payload
;;;1153            pointer in the pbuf downwards. This is somewhat tricky since
;;;1154            we do not want to discard the full contents of the pbuf up to
;;;1155            the new starting point of the data since we have to keep the
;;;1156            TCP header which is present in the first pbuf in the chain.
;;;1157   
;;;1158            What is done is really quite a nasty hack: the first pbuf in
;;;1159            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1160            able to deallocate the whole pbuf, we cannot change this
;;;1161            inseg.p pointer to point to any of the later pbufs in the
;;;1162            chain. Instead, we point the ->payload pointer in the first
;;;1163            pbuf to data in one of the later pbufs. We also set the
;;;1164            inseg.data pointer to point to the right place. This way, the
;;;1165            ->p pointer will still point to the first pbuf, but the
;;;1166            ->p->payload pointer will point to data in another pbuf.
;;;1167   
;;;1168            After we are done with adjusting the pbuf pointers we must
;;;1169            adjust the ->data pointer in the seg and the segment
;;;1170            length.*/
;;;1171   
;;;1172         off = pcb->rcv_nxt - seqno;
00042a  49fe              LDR      r1,|L1.2084|
00042c  6aa0              LDR      r0,[r4,#0x28]
00042e  6809              LDR      r1,[r1,#0]  ; seqno
000430  1a47              SUBS     r7,r0,r1
;;;1173         p = inseg.p;
000432  48fd              LDR      r0,|L1.2088|
000434  6846              LDR      r6,[r0,#4]  ; inseg
;;;1174         LWIP_ASSERT("inseg.p != NULL", inseg.p);
000436  bf00              NOP      
000438  bf00              NOP      
;;;1175         LWIP_ASSERT("insane offset!", (off < 0x7fff));
00043a  bf00              NOP      
00043c  bf00              NOP      
;;;1176         if (inseg.p->len < off) {
00043e  6840              LDR      r0,[r0,#4]  ; inseg
000440  8940              LDRH     r0,[r0,#0xa]
000442  42b8              CMP      r0,r7
000444  da1a              BGE      |L1.1148|
;;;1177           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
000446  bf00              NOP      
000448  bf00              NOP      
;;;1178           new_tot_len = (u16_t)(inseg.p->tot_len - off);
00044a  48f7              LDR      r0,|L1.2088|
00044c  6840              LDR      r0,[r0,#4]  ; inseg
00044e  8900              LDRH     r0,[r0,#8]
000450  1bc0              SUBS     r0,r0,r7
000452  fa1ffa80          UXTH     r10,r0
;;;1179           while (p->len < off) {
000456  e006              B        |L1.1126|
                  |L1.1112|
;;;1180             off -= p->len;
000458  8970              LDRH     r0,[r6,#0xa]
00045a  1a3f              SUBS     r7,r7,r0
;;;1181             /* KJM following line changed (with addition of new_tot_len var)
;;;1182                to fix bug #9076
;;;1183                inseg.p->tot_len -= p->len; */
;;;1184             p->tot_len = new_tot_len;
00045c  f8a6a008          STRH     r10,[r6,#8]
;;;1185             p->len = 0;
000460  2000              MOVS     r0,#0
000462  8170              STRH     r0,[r6,#0xa]
;;;1186             p = p->next;
000464  6836              LDR      r6,[r6,#0]
                  |L1.1126|
000466  8970              LDRH     r0,[r6,#0xa]          ;1179
000468  42b8              CMP      r0,r7                 ;1179
00046a  dbf5              BLT      |L1.1112|
;;;1187           }
;;;1188           if(pbuf_header(p, (s16_t)-off)) {
00046c  4278              RSBS     r0,r7,#0
00046e  b201              SXTH     r1,r0
000470  4630              MOV      r0,r6
000472  f7fffffe          BL       pbuf_header
000476  b150              CBZ      r0,|L1.1166|
;;;1189             /* Do we need to cope with this failing?  Assert for now */
;;;1190             LWIP_ASSERT("pbuf_header failed", 0);
000478  bf00              NOP      
00047a  e008              B        |L1.1166|
                  |L1.1148|
;;;1191           }
;;;1192         } else {
;;;1193           if(pbuf_header(inseg.p, (s16_t)-off)) {
00047c  49ea              LDR      r1,|L1.2088|
00047e  6848              LDR      r0,[r1,#4]  ; inseg
000480  4279              RSBS     r1,r7,#0
000482  b209              SXTH     r1,r1
000484  f7fffffe          BL       pbuf_header
000488  b108              CBZ      r0,|L1.1166|
;;;1194             /* Do we need to cope with this failing?  Assert for now */
;;;1195             LWIP_ASSERT("pbuf_header failed", 0);
00048a  bf00              NOP      
00048c  bf00              NOP      
                  |L1.1166|
;;;1196           }
;;;1197         }
;;;1198         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
00048e  48e6              LDR      r0,|L1.2088|
000490  8900              LDRH     r0,[r0,#8]  ; inseg
000492  8d21              LDRH     r1,[r4,#0x28]
000494  4ae3              LDR      r2,|L1.2084|
000496  8812              LDRH     r2,[r2,#0]  ; seqno
000498  1a89              SUBS     r1,r1,r2
00049a  1a40              SUBS     r0,r0,r1
00049c  49e2              LDR      r1,|L1.2088|
00049e  8108              STRH     r0,[r1,#8]
;;;1199         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
0004a0  49e0              LDR      r1,|L1.2084|
0004a2  6aa0              LDR      r0,[r4,#0x28]
0004a4  6008              STR      r0,[r1,#0]  ; seqno
0004a6  49e0              LDR      r1,|L1.2088|
0004a8  6909              LDR      r1,[r1,#0x10]  ; inseg
0004aa  6048              STR      r0,[r1,#4]
0004ac  e00c              B        |L1.1224|
                  |L1.1198|
;;;1200       }
;;;1201       else {
;;;1202         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
0004ae  49dd              LDR      r1,|L1.2084|
0004b0  6aa0              LDR      r0,[r4,#0x28]
0004b2  6809              LDR      r1,[r1,#0]  ; seqno
0004b4  1a08              SUBS     r0,r1,r0
0004b6  d507              BPL      |L1.1224|
;;;1203           /* the whole segment is < rcv_nxt */
;;;1204           /* must be a duplicate of a packet that has already been correctly handled */
;;;1205   
;;;1206           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
0004b8  bf00              NOP      
0004ba  bf00              NOP      
;;;1207           tcp_ack_now(pcb);
0004bc  bf00              NOP      
0004be  7fa0              LDRB     r0,[r4,#0x1e]
0004c0  f0400002          ORR      r0,r0,#2
0004c4  77a0              STRB     r0,[r4,#0x1e]
0004c6  bf00              NOP      
                  |L1.1224|
;;;1208         }
;;;1209       }
;;;1210   
;;;1211       /* The sequence number must be within the window (above rcv_nxt
;;;1212          and below rcv_nxt + rcv_wnd) in order to be further
;;;1213          processed. */
;;;1214       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
0004c8  49d6              LDR      r1,|L1.2084|
0004ca  6aa0              LDR      r0,[r4,#0x28]
0004cc  6809              LDR      r1,[r1,#0]  ; seqno
0004ce  1a08              SUBS     r0,r1,r0
0004d0  d47e              BMI      |L1.1488|
0004d2  8da1              LDRH     r1,[r4,#0x2c]
0004d4  6aa0              LDR      r0,[r4,#0x28]
0004d6  4408              ADD      r0,r0,r1
0004d8  1e40              SUBS     r0,r0,#1
0004da  49d2              LDR      r1,|L1.2084|
0004dc  6809              LDR      r1,[r1,#0]  ; seqno
0004de  1a08              SUBS     r0,r1,r0
0004e0  2800              CMP      r0,#0
0004e2  dc75              BGT      |L1.1488|
;;;1215                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1216         if (pcb->rcv_nxt == seqno) {
0004e4  49cf              LDR      r1,|L1.2084|
0004e6  e000              B        |L1.1258|
                  |L1.1256|
0004e8  e0a5              B        |L1.1590|
                  |L1.1258|
0004ea  6aa0              LDR      r0,[r4,#0x28]
0004ec  6809              LDR      r1,[r1,#0]  ; seqno
0004ee  4288              CMP      r0,r1
0004f0  d16f              BNE      |L1.1490|
;;;1217           /* The incoming segment is the next in sequence. We check if
;;;1218              we have to trim the end of the segment and update rcv_nxt
;;;1219              and pass the data to the application. */
;;;1220           tcplen = TCP_TCPLEN(&inseg);
0004f2  49cd              LDR      r1,|L1.2088|
0004f4  6909              LDR      r1,[r1,#0x10]  ; inseg
0004f6  8988              LDRH     r0,[r1,#0xc]
0004f8  f7fffffe          BL       lwip_ntohs
0004fc  f0000003          AND      r0,r0,#3
000500  b108              CBZ      r0,|L1.1286|
000502  2001              MOVS     r0,#1
000504  e000              B        |L1.1288|
                  |L1.1286|
000506  2000              MOVS     r0,#0
                  |L1.1288|
000508  49c7              LDR      r1,|L1.2088|
00050a  8909              LDRH     r1,[r1,#8]  ; inseg
00050c  4408              ADD      r0,r0,r1
00050e  49c7              LDR      r1,|L1.2092|
000510  8008              STRH     r0,[r1,#0]
;;;1221   
;;;1222           if (tcplen > pcb->rcv_wnd) {
000512  8da0              LDRH     r0,[r4,#0x2c]
000514  8809              LDRH     r1,[r1,#0]  ; tcplen
000516  4288              CMP      r0,r1
000518  da43              BGE      |L1.1442|
;;;1223             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
00051a  bf00              NOP      
00051c  bf00              NOP      
;;;1224                         ("tcp_receive: other end overran receive window"
;;;1225                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1226                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1227             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
00051e  49c2              LDR      r1,|L1.2088|
000520  6909              LDR      r1,[r1,#0x10]  ; inseg
000522  8988              LDRH     r0,[r1,#0xc]
000524  f7fffffe          BL       lwip_ntohs
000528  f0000001          AND      r0,r0,#1
00052c  b198              CBZ      r0,|L1.1366|
;;;1228               /* Must remove the FIN from the header as we're trimming 
;;;1229                * that byte of sequence-space from the packet */
;;;1230               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
00052e  49be              LDR      r1,|L1.2088|
000530  6909              LDR      r1,[r1,#0x10]  ; inseg
000532  8988              LDRH     r0,[r1,#0xc]
000534  f7fffffe          BL       lwip_ntohs
000538  f0000b3e          AND      r11,r0,#0x3e
00053c  4658              MOV      r0,r11
00053e  f7fffffe          BL       lwip_htons
000542  49b9              LDR      r1,|L1.2088|
000544  6909              LDR      r1,[r1,#0x10]  ; inseg
000546  8989              LDRH     r1,[r1,#0xc]
000548  f24c02ff          MOV      r2,#0xc0ff
00054c  4011              ANDS     r1,r1,r2
00054e  4308              ORRS     r0,r0,r1
000550  49b5              LDR      r1,|L1.2088|
000552  6909              LDR      r1,[r1,#0x10]  ; inseg
000554  8188              STRH     r0,[r1,#0xc]
                  |L1.1366|
;;;1231             }
;;;1232             /* Adjust length of segment to fit in the window. */
;;;1233             inseg.len = pcb->rcv_wnd;
000556  8da0              LDRH     r0,[r4,#0x2c]
000558  49b3              LDR      r1,|L1.2088|
00055a  8108              STRH     r0,[r1,#8]
;;;1234             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
00055c  6909              LDR      r1,[r1,#0x10]  ; inseg
00055e  8988              LDRH     r0,[r1,#0xc]
000560  f7fffffe          BL       lwip_ntohs
000564  f0000002          AND      r0,r0,#2
000568  b120              CBZ      r0,|L1.1396|
;;;1235               inseg.len -= 1;
00056a  48af              LDR      r0,|L1.2088|
00056c  8900              LDRH     r0,[r0,#8]  ; inseg
00056e  1e40              SUBS     r0,r0,#1
000570  49ad              LDR      r1,|L1.2088|
000572  8108              STRH     r0,[r1,#8]
                  |L1.1396|
;;;1236             }
;;;1237             pbuf_realloc(inseg.p, inseg.len);
000574  4aac              LDR      r2,|L1.2088|
000576  8911              LDRH     r1,[r2,#8]  ; inseg
000578  6850              LDR      r0,[r2,#4]  ; inseg
00057a  f7fffffe          BL       pbuf_realloc
;;;1238             tcplen = TCP_TCPLEN(&inseg);
00057e  49aa              LDR      r1,|L1.2088|
000580  6909              LDR      r1,[r1,#0x10]  ; inseg
000582  8988              LDRH     r0,[r1,#0xc]
000584  f7fffffe          BL       lwip_ntohs
000588  f0000003          AND      r0,r0,#3
00058c  b108              CBZ      r0,|L1.1426|
00058e  2001              MOVS     r0,#1
000590  e000              B        |L1.1428|
                  |L1.1426|
000592  2000              MOVS     r0,#0
                  |L1.1428|
000594  49a4              LDR      r1,|L1.2088|
000596  8909              LDRH     r1,[r1,#8]  ; inseg
000598  4408              ADD      r0,r0,r1
00059a  49a4              LDR      r1,|L1.2092|
00059c  8008              STRH     r0,[r1,#0]
;;;1239             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
00059e  bf00              NOP      
0005a0  bf00              NOP      
                  |L1.1442|
;;;1240                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1241           }
;;;1242   #if TCP_QUEUE_OOSEQ
;;;1243           /* Received in-sequence data, adjust ooseq data if:
;;;1244              - FIN has been received or
;;;1245              - inseq overlaps with ooseq */
;;;1246           if (pcb->ooseq != NULL) {
;;;1247             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
;;;1248               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1249                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1250               /* Received in-order FIN means anything that was received
;;;1251                * out of order must now have been received in-order, so
;;;1252                * bin the ooseq queue */
;;;1253               while (pcb->ooseq != NULL) {
;;;1254                 struct tcp_seg *old_ooseq = pcb->ooseq;
;;;1255                 pcb->ooseq = pcb->ooseq->next;
;;;1256                 tcp_seg_free(old_ooseq);
;;;1257               }
;;;1258             } else {
;;;1259               next = pcb->ooseq;
;;;1260               /* Remove all segments on ooseq that are covered by inseg already.
;;;1261                * FIN is copied from ooseq to inseg if present. */
;;;1262               while (next &&
;;;1263                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1264                                  next->tcphdr->seqno + next->len)) {
;;;1265                 /* inseg cannot have FIN here (already processed above) */
;;;1266                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
;;;1267                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
;;;1268                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
;;;1269                   tcplen = TCP_TCPLEN(&inseg);
;;;1270                 }
;;;1271                 prev = next;
;;;1272                 next = next->next;
;;;1273                 tcp_seg_free(prev);
;;;1274               }
;;;1275               /* Now trim right side of inseg if it overlaps with the first
;;;1276                * segment on ooseq */
;;;1277               if (next &&
;;;1278                   TCP_SEQ_GT(seqno + tcplen,
;;;1279                              next->tcphdr->seqno)) {
;;;1280                 /* inseg cannot have FIN here (already processed above) */
;;;1281                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
;;;1282                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
;;;1283                   inseg.len -= 1;
;;;1284                 }
;;;1285                 pbuf_realloc(inseg.p, inseg.len);
;;;1286                 tcplen = TCP_TCPLEN(&inseg);
;;;1287                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
;;;1288                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1289               }
;;;1290               pcb->ooseq = next;
;;;1291             }
;;;1292           }
;;;1293   #endif /* TCP_QUEUE_OOSEQ */
;;;1294   
;;;1295           pcb->rcv_nxt = seqno + tcplen;
0005a2  48a0              LDR      r0,|L1.2084|
0005a4  6800              LDR      r0,[r0,#0]  ; seqno
0005a6  49a1              LDR      r1,|L1.2092|
0005a8  8809              LDRH     r1,[r1,#0]  ; tcplen
0005aa  4408              ADD      r0,r0,r1
0005ac  62a0              STR      r0,[r4,#0x28]
;;;1296   
;;;1297           /* Update the receiver's (our) window. */
;;;1298           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
0005ae  bf00              NOP      
0005b0  bf00              NOP      
;;;1299           pcb->rcv_wnd -= tcplen;
0005b2  8da0              LDRH     r0,[r4,#0x2c]
0005b4  499d              LDR      r1,|L1.2092|
0005b6  8809              LDRH     r1,[r1,#0]  ; tcplen
0005b8  1a40              SUBS     r0,r0,r1
0005ba  85a0              STRH     r0,[r4,#0x2c]
;;;1300   
;;;1301           tcp_update_rcv_ann_wnd(pcb);
0005bc  4620              MOV      r0,r4
0005be  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1302   
;;;1303           /* If there is data in the segment, we make preparations to
;;;1304              pass this up to the application. The ->recv_data variable
;;;1305              is used for holding the pbuf that goes to the
;;;1306              application. The code for reassembling out-of-sequence data
;;;1307              chains its data on this pbuf as well.
;;;1308   
;;;1309              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1310              be used to indicate to the application that the remote side has
;;;1311              closed its end of the connection. */
;;;1312           if (inseg.p->tot_len > 0) {
0005c2  4899              LDR      r0,|L1.2088|
0005c4  6840              LDR      r0,[r0,#4]  ; inseg
0005c6  8900              LDRH     r0,[r0,#8]
0005c8  2800              CMP      r0,#0
0005ca  dd09              BLE      |L1.1504|
;;;1313             recv_data = inseg.p;
0005cc  4896              LDR      r0,|L1.2088|
0005ce  e001              B        |L1.1492|
                  |L1.1488|
0005d0  e02d              B        |L1.1582|
                  |L1.1490|
0005d2  e028              B        |L1.1574|
                  |L1.1492|
0005d4  6840              LDR      r0,[r0,#4]  ; inseg
0005d6  4996              LDR      r1,|L1.2096|
0005d8  6008              STR      r0,[r1,#0]  ; recv_data
;;;1314             /* Since this pbuf now is the responsibility of the
;;;1315                application, we delete our reference to it so that we won't
;;;1316                (mistakingly) deallocate it. */
;;;1317             inseg.p = NULL;
0005da  2000              MOVS     r0,#0
0005dc  4992              LDR      r1,|L1.2088|
0005de  6048              STR      r0,[r1,#4]  ; inseg
                  |L1.1504|
;;;1318           }
;;;1319           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0005e0  4991              LDR      r1,|L1.2088|
0005e2  6909              LDR      r1,[r1,#0x10]  ; inseg
0005e4  8988              LDRH     r0,[r1,#0xc]
0005e6  f7fffffe          BL       lwip_ntohs
0005ea  f0000001          AND      r0,r0,#1
0005ee  b138              CBZ      r0,|L1.1536|
;;;1320             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
0005f0  bf00              NOP      
0005f2  bf00              NOP      
;;;1321             recv_flags |= TF_GOT_FIN;
0005f4  488f              LDR      r0,|L1.2100|
0005f6  7800              LDRB     r0,[r0,#0]  ; recv_flags
0005f8  f0400020          ORR      r0,r0,#0x20
0005fc  498d              LDR      r1,|L1.2100|
0005fe  7008              STRB     r0,[r1,#0]
                  |L1.1536|
;;;1322           }
;;;1323   
;;;1324   #if TCP_QUEUE_OOSEQ
;;;1325           /* We now check if we have segments on the ->ooseq queue that
;;;1326              are now in sequence. */
;;;1327           while (pcb->ooseq != NULL &&
;;;1328                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1329   
;;;1330             cseg = pcb->ooseq;
;;;1331             seqno = pcb->ooseq->tcphdr->seqno;
;;;1332   
;;;1333             pcb->rcv_nxt += TCP_TCPLEN(cseg);
;;;1334             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
;;;1335                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1336             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
;;;1337   
;;;1338             tcp_update_rcv_ann_wnd(pcb);
;;;1339   
;;;1340             if (cseg->p->tot_len > 0) {
;;;1341               /* Chain this pbuf onto the pbuf that we will pass to
;;;1342                  the application. */
;;;1343               if (recv_data) {
;;;1344                 pbuf_cat(recv_data, cseg->p);
;;;1345               } else {
;;;1346                 recv_data = cseg->p;
;;;1347               }
;;;1348               cseg->p = NULL;
;;;1349             }
;;;1350             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
;;;1351               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1352               recv_flags |= TF_GOT_FIN;
;;;1353               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
;;;1354                 pcb->state = CLOSE_WAIT;
;;;1355               } 
;;;1356             }
;;;1357   
;;;1358             pcb->ooseq = cseg->next;
;;;1359             tcp_seg_free(cseg);
;;;1360           }
;;;1361   #endif /* TCP_QUEUE_OOSEQ */
;;;1362   
;;;1363   
;;;1364           /* Acknowledge the segment(s). */
;;;1365           tcp_ack(pcb);
000600  bf00              NOP      
000602  7fa0              LDRB     r0,[r4,#0x1e]
000604  f0000001          AND      r0,r0,#1
000608  b140              CBZ      r0,|L1.1564|
00060a  7fa0              LDRB     r0,[r4,#0x1e]
00060c  f0200001          BIC      r0,r0,#1
000610  77a0              STRB     r0,[r4,#0x1e]
000612  7fa0              LDRB     r0,[r4,#0x1e]
000614  f0400002          ORR      r0,r0,#2
000618  77a0              STRB     r0,[r4,#0x1e]
00061a  e003              B        |L1.1572|
                  |L1.1564|
00061c  7fa0              LDRB     r0,[r4,#0x1e]
00061e  f0400001          ORR      r0,r0,#1
000622  77a0              STRB     r0,[r4,#0x1e]
                  |L1.1572|
000624  e01b              B        |L1.1630|
                  |L1.1574|
;;;1366   
;;;1367         } else {
;;;1368           /* We get here if the incoming segment is out-of-sequence. */
;;;1369           tcp_send_empty_ack(pcb);
000626  4620              MOV      r0,r4
000628  f7fffffe          BL       tcp_send_empty_ack
00062c  e017              B        |L1.1630|
                  |L1.1582|
;;;1370   #if TCP_QUEUE_OOSEQ
;;;1371           /* We queue the segment on the ->ooseq queue. */
;;;1372           if (pcb->ooseq == NULL) {
;;;1373             pcb->ooseq = tcp_seg_copy(&inseg);
;;;1374           } else {
;;;1375             /* If the queue is not empty, we walk through the queue and
;;;1376                try to find a place where the sequence number of the
;;;1377                incoming segment is between the sequence numbers of the
;;;1378                previous and the next segment on the ->ooseq queue. That is
;;;1379                the place where we put the incoming segment. If needed, we
;;;1380                trim the second edges of the previous and the incoming
;;;1381                segment so that it will fit into the sequence.
;;;1382   
;;;1383                If the incoming segment has the same sequence number as a
;;;1384                segment on the ->ooseq queue, we discard the segment that
;;;1385                contains less data. */
;;;1386   
;;;1387             prev = NULL;
;;;1388             for(next = pcb->ooseq; next != NULL; next = next->next) {
;;;1389               if (seqno == next->tcphdr->seqno) {
;;;1390                 /* The sequence number of the incoming segment is the
;;;1391                    same as the sequence number of the segment on
;;;1392                    ->ooseq. We check the lengths to see which one to
;;;1393                    discard. */
;;;1394                 if (inseg.len > next->len) {
;;;1395                   /* The incoming segment is larger than the old
;;;1396                      segment. We replace some segments with the new
;;;1397                      one. */
;;;1398                   cseg = tcp_seg_copy(&inseg);
;;;1399                   if (cseg != NULL) {
;;;1400                     if (prev != NULL) {
;;;1401                       prev->next = cseg;
;;;1402                     } else {
;;;1403                       pcb->ooseq = cseg;
;;;1404                     }
;;;1405                     tcp_oos_insert_segment(cseg, next);
;;;1406                   }
;;;1407                   break;
;;;1408                 } else {
;;;1409                   /* Either the lenghts are the same or the incoming
;;;1410                      segment was smaller than the old one; in either
;;;1411                      case, we ditch the incoming segment. */
;;;1412                   break;
;;;1413                 }
;;;1414               } else {
;;;1415                 if (prev == NULL) {
;;;1416                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
;;;1417                     /* The sequence number of the incoming segment is lower
;;;1418                        than the sequence number of the first segment on the
;;;1419                        queue. We put the incoming segment first on the
;;;1420                        queue. */
;;;1421                     cseg = tcp_seg_copy(&inseg);
;;;1422                     if (cseg != NULL) {
;;;1423                       pcb->ooseq = cseg;
;;;1424                       tcp_oos_insert_segment(cseg, next);
;;;1425                     }
;;;1426                     break;
;;;1427                   }
;;;1428                 } else {
;;;1429                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1430                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1431                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
;;;1432                     /* The sequence number of the incoming segment is in
;;;1433                        between the sequence numbers of the previous and
;;;1434                        the next segment on ->ooseq. We trim trim the previous
;;;1435                        segment, delete next segments that included in received segment
;;;1436                        and trim received, if needed. */
;;;1437                     cseg = tcp_seg_copy(&inseg);
;;;1438                     if (cseg != NULL) {
;;;1439                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
;;;1440                         /* We need to trim the prev segment. */
;;;1441                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
;;;1442                         pbuf_realloc(prev->p, prev->len);
;;;1443                       }
;;;1444                       prev->next = cseg;
;;;1445                       tcp_oos_insert_segment(cseg, next);
;;;1446                     }
;;;1447                     break;
;;;1448                   }
;;;1449                 }
;;;1450                 /* If the "next" segment is the last segment on the
;;;1451                    ooseq queue, we add the incoming segment to the end
;;;1452                    of the list. */
;;;1453                 if (next->next == NULL &&
;;;1454                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
;;;1455                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
;;;1456                     /* segment "next" already contains all data */
;;;1457                     break;
;;;1458                   }
;;;1459                   next->next = tcp_seg_copy(&inseg);
;;;1460                   if (next->next != NULL) {
;;;1461                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
;;;1462                       /* We need to trim the last segment. */
;;;1463                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
;;;1464                       pbuf_realloc(next->p, next->len);
;;;1465                     }
;;;1466                     /* check if the remote side overruns our receive window */
;;;1467                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
;;;1468                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1469                                   ("tcp_receive: other end overran receive window"
;;;1470                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1471                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1472                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
;;;1473                         /* Must remove the FIN from the header as we're trimming 
;;;1474                          * that byte of sequence-space from the packet */
;;;1475                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
;;;1476                       }
;;;1477                       /* Adjust length of segment to fit in the window. */
;;;1478                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
;;;1479                       pbuf_realloc(next->next->p, next->next->len);
;;;1480                       tcplen = TCP_TCPLEN(next->next);
;;;1481                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
;;;1482                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1483                     }
;;;1484                   }
;;;1485                   break;
;;;1486                 }
;;;1487               }
;;;1488               prev = next;
;;;1489             }
;;;1490           }
;;;1491   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1492           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1493              and throw away everything above that limit. */
;;;1494           ooseq_blen = 0;
;;;1495           ooseq_qlen = 0;
;;;1496           prev = NULL;
;;;1497           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1498             struct pbuf *p = next->p;
;;;1499             ooseq_blen += p->tot_len;
;;;1500             ooseq_qlen += pbuf_clen(p);
;;;1501             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1502                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1503                /* too much ooseq data, dump this and everything after it */
;;;1504                tcp_segs_free(next);
;;;1505                if (prev == NULL) {
;;;1506                  /* first ooseq segment is too much, dump the whole queue */
;;;1507                  pcb->ooseq = NULL;
;;;1508                } else {
;;;1509                  /* just dump 'next' and everything after it */
;;;1510                  prev->next = NULL;
;;;1511                }
;;;1512                break;
;;;1513             }
;;;1514           }
;;;1515   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517         }
;;;1518       } else {
;;;1519         /* The incoming segment is not withing the window. */
;;;1520         tcp_send_empty_ack(pcb);
00062e  4620              MOV      r0,r4
000630  f7fffffe          BL       tcp_send_empty_ack
000634  e013              B        |L1.1630|
                  |L1.1590|
;;;1521       }
;;;1522     } else {
;;;1523       /* Segments with length 0 is taken care of here. Segments that
;;;1524          fall out of the window are ACKed. */
;;;1525       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1526         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1527       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
000636  497b              LDR      r1,|L1.2084|
000638  6aa0              LDR      r0,[r4,#0x28]
00063a  6809              LDR      r1,[r1,#0]  ; seqno
00063c  1a08              SUBS     r0,r1,r0
00063e  d408              BMI      |L1.1618|
000640  8da1              LDRH     r1,[r4,#0x2c]
000642  6aa0              LDR      r0,[r4,#0x28]
000644  4408              ADD      r0,r0,r1
000646  1e40              SUBS     r0,r0,#1
000648  4976              LDR      r1,|L1.2084|
00064a  6809              LDR      r1,[r1,#0]  ; seqno
00064c  1a08              SUBS     r0,r1,r0
00064e  2800              CMP      r0,#0
000650  dd05              BLE      |L1.1630|
                  |L1.1618|
;;;1528         tcp_ack_now(pcb);
000652  bf00              NOP      
000654  7fa0              LDRB     r0,[r4,#0x1e]
000656  f0400002          ORR      r0,r0,#2
00065a  77a0              STRB     r0,[r4,#0x1e]
00065c  bf00              NOP      
                  |L1.1630|
;;;1529       }
;;;1530     }
;;;1531   }
00065e  e8bd8ff8          POP      {r3-r11,pc}
;;;1532   
                          ENDP

                  tcp_parseopt PROC
;;;1541   static void
;;;1542   tcp_parseopt(struct tcp_pcb *pcb)
000662  e92d47f0          PUSH     {r4-r10,lr}
;;;1543   {
000666  4680              MOV      r8,r0
;;;1544     u16_t c, max_c;
;;;1545     u16_t mss;
;;;1546     u8_t *opts, opt;
;;;1547   #if LWIP_TCP_TIMESTAMPS
;;;1548     u32_t tsval;
;;;1549   #endif
;;;1550   
;;;1551     opts = (u8_t *)tcphdr + TCP_HLEN;
000668  4873              LDR      r0,|L1.2104|
00066a  6800              LDR      r0,[r0,#0]  ; tcphdr
00066c  f1000514          ADD      r5,r0,#0x14
;;;1552   
;;;1553     /* Parse the TCP MSS option, if present. */
;;;1554     if(TCPH_HDRLEN(tcphdr) > 0x5) {
000670  4971              LDR      r1,|L1.2104|
000672  6809              LDR      r1,[r1,#0]  ; tcphdr
000674  8988              LDRH     r0,[r1,#0xc]
000676  f7fffffe          BL       lwip_ntohs
00067a  2105              MOVS     r1,#5
00067c  ebb13f20          CMP      r1,r0,ASR #12
000680  da52              BGE      |L1.1832|
;;;1555       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
000682  496d              LDR      r1,|L1.2104|
000684  6809              LDR      r1,[r1,#0]  ; tcphdr
000686  8988              LDRH     r0,[r1,#0xc]
000688  f7fffffe          BL       lwip_ntohs
00068c  2105              MOVS     r1,#5
00068e  ebc13020          RSB      r0,r1,r0,ASR #12
000692  f64f71ff          MOV      r1,#0xffff
000696  ea010680          AND      r6,r1,r0,LSL #2
;;;1556       for (c = 0; c < max_c; ) {
00069a  2400              MOVS     r4,#0
00069c  e042              B        |L1.1828|
                  |L1.1694|
;;;1557         opt = opts[c];
00069e  f8159004          LDRB     r9,[r5,r4]
;;;1558         switch (opt) {
0006a2  f1b90f00          CMP      r9,#0
0006a6  d006              BEQ      |L1.1718|
0006a8  f1b90f01          CMP      r9,#1
0006ac  d007              BEQ      |L1.1726|
0006ae  f1b90f02          CMP      r9,#2
0006b2  d129              BNE      |L1.1800|
0006b4  e008              B        |L1.1736|
                  |L1.1718|
;;;1559         case 0x00:
;;;1560           /* End of options. */
;;;1561           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
0006b6  bf00              NOP      
0006b8  bf00              NOP      
                  |L1.1722|
;;;1562           return;
;;;1563         case 0x01:
;;;1564           /* NOP option. */
;;;1565           ++c;
;;;1566           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1567           break;
;;;1568         case 0x02:
;;;1569           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1570           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1571             /* Bad length */
;;;1572             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1573             return;
;;;1574           }
;;;1575           /* An MSS option with the right option length. */
;;;1576           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1577           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1578           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
;;;1579           /* Advance to next option */
;;;1580           c += 0x04;
;;;1581           break;
;;;1582   #if LWIP_TCP_TIMESTAMPS
;;;1583         case 0x08:
;;;1584           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1585           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1586             /* Bad length */
;;;1587             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1588             return;
;;;1589           }
;;;1590           /* TCP timestamp option with valid length */
;;;1591           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1592             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1593           if (flags & TCP_SYN) {
;;;1594             pcb->ts_recent = ntohl(tsval);
;;;1595             pcb->flags |= TF_TIMESTAMP;
;;;1596           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1597             pcb->ts_recent = ntohl(tsval);
;;;1598           }
;;;1599           /* Advance to next option */
;;;1600           c += 0x0A;
;;;1601           break;
;;;1602   #endif
;;;1603         default:
;;;1604           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1605           if (opts[c + 1] == 0) {
;;;1606             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1607             /* If the length field is zero, the options are malformed
;;;1608                and we don't process them further. */
;;;1609             return;
;;;1610           }
;;;1611           /* All other options have a length field, so that we easily
;;;1612              can skip past them. */
;;;1613           c += opts[c + 1];
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   }
0006ba  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1726|
0006be  1c60              ADDS     r0,r4,#1              ;1565
0006c0  b284              UXTH     r4,r0                 ;1565
0006c2  bf00              NOP                            ;1566
0006c4  bf00              NOP                            ;1566
0006c6  e02c              B        |L1.1826|
                  |L1.1736|
0006c8  bf00              NOP                            ;1569
0006ca  bf00              NOP                            ;1569
0006cc  1c60              ADDS     r0,r4,#1              ;1570
0006ce  5c28              LDRB     r0,[r5,r0]            ;1570
0006d0  2804              CMP      r0,#4                 ;1570
0006d2  d102              BNE      |L1.1754|
0006d4  1d20              ADDS     r0,r4,#4              ;1570
0006d6  42b0              CMP      r0,r6                 ;1570
0006d8  dd02              BLE      |L1.1760|
                  |L1.1754|
0006da  bf00              NOP                            ;1572
0006dc  bf00              NOP                            ;1572
0006de  e7ec              B        |L1.1722|
                  |L1.1760|
0006e0  1ce0              ADDS     r0,r4,#3              ;1576
0006e2  5c29              LDRB     r1,[r5,r0]            ;1576
0006e4  1ca0              ADDS     r0,r4,#2              ;1576
0006e6  5c28              LDRB     r0,[r5,r0]            ;1576
0006e8  ea412700          ORR      r7,r1,r0,LSL #8       ;1576
0006ec  f24050b4          MOV      r0,#0x5b4             ;1578
0006f0  4287              CMP      r7,r0                 ;1578
0006f2  dc00              BGT      |L1.1782|
0006f4  b917              CBNZ     r7,|L1.1788|
                  |L1.1782|
0006f6  f24050b4          MOV      r0,#0x5b4             ;1578
0006fa  e000              B        |L1.1790|
                  |L1.1788|
0006fc  4638              MOV      r0,r7                 ;1578
                  |L1.1790|
0006fe  f8a80036          STRH     r0,[r8,#0x36]         ;1578
000702  1d20              ADDS     r0,r4,#4              ;1580
000704  b284              UXTH     r4,r0                 ;1580
000706  e00c              B        |L1.1826|
                  |L1.1800|
000708  bf00              NOP                            ;1604
00070a  bf00              NOP                            ;1604
00070c  1c60              ADDS     r0,r4,#1              ;1605
00070e  5c28              LDRB     r0,[r5,r0]            ;1605
000710  b910              CBNZ     r0,|L1.1816|
000712  bf00              NOP                            ;1606
000714  bf00              NOP                            ;1606
000716  e7d0              B        |L1.1722|
                  |L1.1816|
000718  1c60              ADDS     r0,r4,#1              ;1613
00071a  5c28              LDRB     r0,[r5,r0]            ;1613
00071c  4420              ADD      r0,r0,r4              ;1613
00071e  b284              UXTH     r4,r0                 ;1613
000720  bf00              NOP                            ;1558
                  |L1.1826|
000722  bf00              NOP                            ;1567
                  |L1.1828|
000724  42b4              CMP      r4,r6                 ;1556
000726  dbba              BLT      |L1.1694|
                  |L1.1832|
000728  bf00              NOP      
00072a  e7c6              B        |L1.1722|
;;;1618   
                          ENDP

                  tcp_process PROC
;;;574    static err_t
;;;575    tcp_process(struct tcp_pcb *pcb)
00072c  e92d41fc          PUSH     {r2-r8,lr}
;;;576    {
000730  4604              MOV      r4,r0
;;;577      struct tcp_seg *rseg;
;;;578      u8_t acceptable = 0;
000732  f04f0800          MOV      r8,#0
;;;579      err_t err;
;;;580    
;;;581      err = ERR_OK;
000736  2600              MOVS     r6,#0
;;;582    
;;;583      /* Process incoming RST segments. */
;;;584      if (flags & TCP_RST) {
000738  4840              LDR      r0,|L1.2108|
00073a  7800              LDRB     r0,[r0,#0]  ; flags
00073c  f0000004          AND      r0,r0,#4
000740  b3a0              CBZ      r0,|L1.1964|
;;;585        /* First, determine if the reset is acceptable. */
;;;586        if (pcb->state == SYN_SENT) {
000742  7e20              LDRB     r0,[r4,#0x18]
000744  2802              CMP      r0,#2
000746  d107              BNE      |L1.1880|
;;;587          if (ackno == pcb->snd_nxt) {
000748  493d              LDR      r1,|L1.2112|
00074a  6d20              LDR      r0,[r4,#0x50]
00074c  6809              LDR      r1,[r1,#0]  ; ackno
00074e  4288              CMP      r0,r1
000750  d111              BNE      |L1.1910|
;;;588            acceptable = 1;
000752  f04f0801          MOV      r8,#1
000756  e00e              B        |L1.1910|
                  |L1.1880|
;;;589          }
;;;590        } else {
;;;591          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000758  4932              LDR      r1,|L1.2084|
00075a  6aa0              LDR      r0,[r4,#0x28]
00075c  6809              LDR      r1,[r1,#0]  ; seqno
00075e  1a08              SUBS     r0,r1,r0
000760  d409              BMI      |L1.1910|
000762  8da1              LDRH     r1,[r4,#0x2c]
000764  6aa0              LDR      r0,[r4,#0x28]
000766  4408              ADD      r0,r0,r1
000768  492e              LDR      r1,|L1.2084|
00076a  6809              LDR      r1,[r1,#0]  ; seqno
00076c  1a08              SUBS     r0,r1,r0
00076e  2800              CMP      r0,#0
000770  dc01              BGT      |L1.1910|
;;;592                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;593            acceptable = 1;
000772  f04f0801          MOV      r8,#1
                  |L1.1910|
;;;594          }
;;;595        }
;;;596    
;;;597        if (acceptable) {
000776  f1b80f00          CMP      r8,#0
00077a  d011              BEQ      |L1.1952|
;;;598          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
00077c  bf00              NOP      
00077e  bf00              NOP      
;;;599          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
000780  bf00              NOP      
000782  bf00              NOP      
;;;600          recv_flags |= TF_RESET;
000784  482b              LDR      r0,|L1.2100|
000786  7800              LDRB     r0,[r0,#0]  ; recv_flags
000788  f0400008          ORR      r0,r0,#8
00078c  4929              LDR      r1,|L1.2100|
00078e  7008              STRB     r0,[r1,#0]
;;;601          pcb->flags &= ~TF_ACK_DELAY;
000790  7fa0              LDRB     r0,[r4,#0x1e]
000792  f0200001          BIC      r0,r0,#1
000796  77a0              STRB     r0,[r4,#0x1e]
;;;602          return ERR_RST;
000798  f06f000a          MVN      r0,#0xa
                  |L1.1948|
;;;603        } else {
;;;604          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;605           seqno, pcb->rcv_nxt));
;;;606          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;607           seqno, pcb->rcv_nxt));
;;;608          return ERR_OK;
;;;609        }
;;;610      }
;;;611    
;;;612      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;613        /* Cope with new connection attempt after remote end crashed */
;;;614        tcp_ack_now(pcb);
;;;615        return ERR_OK;
;;;616      }
;;;617      
;;;618      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;619        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;620        pcb->tmr = tcp_ticks;
;;;621      }
;;;622      pcb->keep_cnt_sent = 0;
;;;623    
;;;624      tcp_parseopt(pcb);
;;;625    
;;;626      /* Do different things depending on the TCP state. */
;;;627      switch (pcb->state) {
;;;628      case SYN_SENT:
;;;629        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;630         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;631        /* received SYN ACK with expected sequence number? */
;;;632        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;633            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;634          pcb->snd_buf++;
;;;635          pcb->rcv_nxt = seqno + 1;
;;;636          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;637          pcb->lastack = ackno;
;;;638          pcb->snd_wnd = tcphdr->wnd;
;;;639          pcb->snd_wnd_max = tcphdr->wnd;
;;;640          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;641          pcb->state = ESTABLISHED;
;;;642    
;;;643    #if TCP_CALCULATE_EFF_SEND_MSS
;;;644          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;645    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;646    
;;;647          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;648           * but for the default value of pcb->mss) */
;;;649          pcb->ssthresh = pcb->mss * 10;
;;;650    
;;;651          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;652          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;653          --pcb->snd_queuelen;
;;;654          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;655          rseg = pcb->unacked;
;;;656          pcb->unacked = rseg->next;
;;;657          tcp_seg_free(rseg);
;;;658    
;;;659          /* If there's nothing left to acknowledge, stop the retransmit
;;;660             timer, otherwise reset it to start again */
;;;661          if(pcb->unacked == NULL)
;;;662            pcb->rtime = -1;
;;;663          else {
;;;664            pcb->rtime = 0;
;;;665            pcb->nrtx = 0;
;;;666          }
;;;667    
;;;668          /* Call the user specified function to call when sucessfully
;;;669           * connected. */
;;;670          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;671          if (err == ERR_ABRT) {
;;;672            return ERR_ABRT;
;;;673          }
;;;674          tcp_ack_now(pcb);
;;;675        }
;;;676        /* received ACK? possibly a half-open connection */
;;;677        else if (flags & TCP_ACK) {
;;;678          /* send a RST to bring the other side in a non-synchronized state. */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;680            tcphdr->dest, tcphdr->src);
;;;681        }
;;;682        break;
;;;683      case SYN_RCVD:
;;;684        if (flags & TCP_ACK) {
;;;685          /* expected ACK number? */
;;;686          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;687            u16_t old_cwnd;
;;;688            pcb->state = ESTABLISHED;
;;;689            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;690    #if LWIP_CALLBACK_API
;;;691            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;692    #endif
;;;693            /* Call the accept function. */
;;;694            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;695            if (err != ERR_OK) {
;;;696              /* If the accept function returns with an error, we abort
;;;697               * the connection. */
;;;698              /* Already aborted? */
;;;699              if (err != ERR_ABRT) {
;;;700                tcp_abort(pcb);
;;;701              }
;;;702              return ERR_ABRT;
;;;703            }
;;;704            old_cwnd = pcb->cwnd;
;;;705            /* If there was any data contained within this ACK,
;;;706             * we'd better pass it on to the application as well. */
;;;707            tcp_receive(pcb);
;;;708    
;;;709            /* Prevent ACK for SYN to generate a sent event */
;;;710            if (pcb->acked != 0) {
;;;711              pcb->acked--;
;;;712            }
;;;713    
;;;714            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;715    
;;;716            if (recv_flags & TF_GOT_FIN) {
;;;717              tcp_ack_now(pcb);
;;;718              pcb->state = CLOSE_WAIT;
;;;719            }
;;;720          } else {
;;;721            /* incorrect ACK number, send RST */
;;;722            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;723                    tcphdr->dest, tcphdr->src);
;;;724          }
;;;725        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;726          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;727          tcp_rexmit(pcb);
;;;728        }
;;;729        break;
;;;730      case CLOSE_WAIT:
;;;731        /* FALLTHROUGH */
;;;732      case ESTABLISHED:
;;;733        tcp_receive(pcb);
;;;734        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;735          tcp_ack_now(pcb);
;;;736          pcb->state = CLOSE_WAIT;
;;;737        }
;;;738        break;
;;;739      case FIN_WAIT_1:
;;;740        tcp_receive(pcb);
;;;741        if (recv_flags & TF_GOT_FIN) {
;;;742          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;743            LWIP_DEBUGF(TCP_DEBUG,
;;;744              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;745            tcp_ack_now(pcb);
;;;746            tcp_pcb_purge(pcb);
;;;747            TCP_RMV_ACTIVE(pcb);
;;;748            pcb->state = TIME_WAIT;
;;;749            TCP_REG(&tcp_tw_pcbs, pcb);
;;;750          } else {
;;;751            tcp_ack_now(pcb);
;;;752            pcb->state = CLOSING;
;;;753          }
;;;754        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;755          pcb->state = FIN_WAIT_2;
;;;756        }
;;;757        break;
;;;758      case FIN_WAIT_2:
;;;759        tcp_receive(pcb);
;;;760        if (recv_flags & TF_GOT_FIN) {
;;;761          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;762          tcp_ack_now(pcb);
;;;763          tcp_pcb_purge(pcb);
;;;764          TCP_RMV_ACTIVE(pcb);
;;;765          pcb->state = TIME_WAIT;
;;;766          TCP_REG(&tcp_tw_pcbs, pcb);
;;;767        }
;;;768        break;
;;;769      case CLOSING:
;;;770        tcp_receive(pcb);
;;;771        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;772          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;773          tcp_pcb_purge(pcb);
;;;774          TCP_RMV_ACTIVE(pcb);
;;;775          pcb->state = TIME_WAIT;
;;;776          TCP_REG(&tcp_tw_pcbs, pcb);
;;;777        }
;;;778        break;
;;;779      case LAST_ACK:
;;;780        tcp_receive(pcb);
;;;781        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;782          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;783          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;784          recv_flags |= TF_CLOSED;
;;;785        }
;;;786        break;
;;;787      default:
;;;788        break;
;;;789      }
;;;790      return ERR_OK;
;;;791    }
00079c  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1952|
0007a0  bf00              NOP                            ;604
0007a2  bf00              NOP                            ;604
0007a4  bf00              NOP                            ;606
0007a6  bf00              NOP                            ;606
0007a8  2000              MOVS     r0,#0                 ;608
0007aa  e7f7              B        |L1.1948|
                  |L1.1964|
0007ac  e7ff              B        |L1.1966|
                  |L1.1966|
0007ae  4823              LDR      r0,|L1.2108|
0007b0  7800              LDRB     r0,[r0,#0]            ;612  ; flags
0007b2  f0000002          AND      r0,r0,#2              ;612
0007b6  b168              CBZ      r0,|L1.2004|
0007b8  7e20              LDRB     r0,[r4,#0x18]         ;612
0007ba  2802              CMP      r0,#2                 ;612
0007bc  d00a              BEQ      |L1.2004|
0007be  7e20              LDRB     r0,[r4,#0x18]         ;612
0007c0  2803              CMP      r0,#3                 ;612
0007c2  d007              BEQ      |L1.2004|
0007c4  bf00              NOP                            ;614
0007c6  7fa0              LDRB     r0,[r4,#0x1e]         ;614
0007c8  f0400002          ORR      r0,r0,#2              ;614
0007cc  77a0              STRB     r0,[r4,#0x1e]         ;614
0007ce  bf00              NOP                            ;614
0007d0  2000              MOVS     r0,#0                 ;615
0007d2  e7e3              B        |L1.1948|
                  |L1.2004|
0007d4  7fa0              LDRB     r0,[r4,#0x1e]         ;618
0007d6  f0000010          AND      r0,r0,#0x10           ;618
0007da  b910              CBNZ     r0,|L1.2018|
0007dc  4819              LDR      r0,|L1.2116|
0007de  6800              LDR      r0,[r0,#0]            ;620  ; tcp_ticks
0007e0  6260              STR      r0,[r4,#0x24]         ;620
                  |L1.2018|
0007e2  2000              MOVS     r0,#0                 ;622
0007e4  f8840092          STRB     r0,[r4,#0x92]         ;622
0007e8  4620              MOV      r0,r4                 ;624
0007ea  f7fffffe          BL       tcp_parseopt
0007ee  7e20              LDRB     r0,[r4,#0x18]         ;627
0007f0  1e80              SUBS     r0,r0,#2              ;627
0007f2  2808              CMP      r0,#8                 ;627
0007f4  d27a              BCS      |L1.2284|
0007f6  e8dff000          TBB      [pc,r0]               ;627
0007fa  04b2              DCB      0x04,0xb2
0007fc  f8f7f6f5          DCB      0xf8,0xf7,0xf6,0xf5
000800  f4f3              DCB      0xf4,0xf3
000802  bf00              NOP                            ;629
000804  bf00              NOP                            ;629
000806  480d              LDR      r0,|L1.2108|
000808  7800              LDRB     r0,[r0,#0]            ;632  ; flags
00080a  f0000010          AND      r0,r0,#0x10           ;632
00080e  2800              CMP      r0,#0                 ;632
000810  d06d              BEQ      |L1.2286|
000812  480a              LDR      r0,|L1.2108|
000814  7800              LDRB     r0,[r0,#0]            ;632  ; flags
000816  f0000002          AND      r0,r0,#2              ;632
00081a  2800              CMP      r0,#0                 ;632
00081c  d067              BEQ      |L1.2286|
00081e  6f21              LDR      r1,[r4,#0x70]         ;633
000820  6909              LDR      r1,[r1,#0x10]         ;633
000822  e011              B        |L1.2120|
                  |L1.2084|
                          DCD      seqno
                  |L1.2088|
                          DCD      inseg
                  |L1.2092|
                          DCD      tcplen
                  |L1.2096|
                          DCD      recv_data
                  |L1.2100|
                          DCD      recv_flags
                  |L1.2104|
                          DCD      tcphdr
                  |L1.2108|
                          DCD      flags
                  |L1.2112|
                          DCD      ackno
                  |L1.2116|
                          DCD      tcp_ticks
                  |L1.2120|
000848  6848              LDR      r0,[r1,#4]            ;633
00084a  f7fffffe          BL       lwip_ntohl
00084e  1c40              ADDS     r0,r0,#1              ;633
000850  49f7              LDR      r1,|L1.3120|
000852  6809              LDR      r1,[r1,#0]            ;633  ; ackno
000854  4288              CMP      r0,r1                 ;633
000856  d169              BNE      |L1.2348|
000858  3428              ADDS     r4,r4,#0x28           ;634
00085a  8fe0              LDRH     r0,[r4,#0x3e]         ;634
00085c  1c40              ADDS     r0,r0,#1              ;634
00085e  87e0              STRH     r0,[r4,#0x3e]         ;634
000860  48f4              LDR      r0,|L1.3124|
000862  6800              LDR      r0,[r0,#0]            ;635  ; seqno
000864  1c40              ADDS     r0,r0,#1              ;635
000866  6020              STR      r0,[r4,#0]            ;635
000868  6820              LDR      r0,[r4,#0]            ;636
00086a  60a0              STR      r0,[r4,#8]            ;636
00086c  48f0              LDR      r0,|L1.3120|
00086e  6800              LDR      r0,[r0,#0]            ;637  ; ackno
000870  6220              STR      r0,[r4,#0x20]         ;637
000872  48f1              LDR      r0,|L1.3128|
000874  6800              LDR      r0,[r0,#0]            ;638  ; tcphdr
000876  89c0              LDRH     r0,[r0,#0xe]          ;638
000878  8720              STRH     r0,[r4,#0x38]         ;638
00087a  48ef              LDR      r0,|L1.3128|
00087c  6800              LDR      r0,[r0,#0]            ;639  ; tcphdr
00087e  89c0              LDRH     r0,[r0,#0xe]          ;639
000880  8760              STRH     r0,[r4,#0x3a]         ;639
000882  48ec              LDR      r0,|L1.3124|
000884  6800              LDR      r0,[r0,#0]            ;640  ; seqno
000886  1e40              SUBS     r0,r0,#1              ;640
000888  62e0              STR      r0,[r4,#0x2c]         ;640
00088a  2004              MOVS     r0,#4                 ;641
00088c  f8040c10          STRB     r0,[r4,#-0x10]        ;641
000890  89e0              LDRH     r0,[r4,#0xe]          ;644
000892  3c28              SUBS     r4,r4,#0x28           ;644
000894  1d21              ADDS     r1,r4,#4              ;644
000896  f7fffffe          BL       tcp_eff_send_mss
00089a  86e0              STRH     r0,[r4,#0x36]         ;644
00089c  8ee0              LDRH     r0,[r4,#0x36]         ;649
00089e  eb000080          ADD      r0,r0,r0,LSL #2       ;649
0008a2  f64f71ff          MOV      r1,#0xffff            ;649
0008a6  ea010040          AND      r0,r1,r0,LSL #1       ;649
0008aa  f8a4004e          STRH     r0,[r4,#0x4e]         ;649
0008ae  f8b4004c          LDRH     r0,[r4,#0x4c]         ;651
0008b2  2801              CMP      r0,#1                 ;651
0008b4  d102              BNE      |L1.2236|
0008b6  8ee0              LDRH     r0,[r4,#0x36]         ;651
0008b8  0040              LSLS     r0,r0,#1              ;651
0008ba  e000              B        |L1.2238|
                  |L1.2236|
0008bc  8ee0              LDRH     r0,[r4,#0x36]         ;651
                  |L1.2238|
0008be  f8a4004c          STRH     r0,[r4,#0x4c]         ;651
0008c2  bf00              NOP                            ;652
0008c4  bf00              NOP                            ;652
0008c6  f8b40068          LDRH     r0,[r4,#0x68]         ;653
0008ca  1e40              SUBS     r0,r0,#1              ;653
0008cc  f8a40068          STRH     r0,[r4,#0x68]         ;653
0008d0  bf00              NOP                            ;654
0008d2  bf00              NOP                            ;654
0008d4  6f25              LDR      r5,[r4,#0x70]         ;655
0008d6  6828              LDR      r0,[r5,#0]            ;656
0008d8  6720              STR      r0,[r4,#0x70]         ;656
0008da  4628              MOV      r0,r5                 ;657
0008dc  f7fffffe          BL       tcp_seg_free
0008e0  6f20              LDR      r0,[r4,#0x70]         ;661
0008e2  b928              CBNZ     r0,|L1.2288|
0008e4  f04f30ff          MOV      r0,#0xffffffff        ;662
0008e8  86a0              STRH     r0,[r4,#0x34]         ;662
0008ea  e005              B        |L1.2296|
                  |L1.2284|
0008ec  e1f6              B        |L1.3292|
                  |L1.2286|
0008ee  e01d              B        |L1.2348|
                  |L1.2288|
0008f0  2000              MOVS     r0,#0                 ;664
0008f2  86a0              STRH     r0,[r4,#0x34]         ;664
0008f4  f8840046          STRB     r0,[r4,#0x46]         ;665
                  |L1.2296|
0008f8  bf00              NOP                            ;670
0008fa  f8d40080          LDR      r0,[r4,#0x80]         ;670
0008fe  b138              CBZ      r0,|L1.2320|
000900  2200              MOVS     r2,#0                 ;670
000902  4621              MOV      r1,r4                 ;670
000904  f8d43080          LDR      r3,[r4,#0x80]         ;670
000908  6920              LDR      r0,[r4,#0x10]         ;670
00090a  4798              BLX      r3                    ;670
00090c  4606              MOV      r6,r0                 ;670
00090e  e000              B        |L1.2322|
                  |L1.2320|
000910  2600              MOVS     r6,#0                 ;670
                  |L1.2322|
000912  bf00              NOP                            ;670
000914  f106000a          ADD      r0,r6,#0xa            ;671
000918  b910              CBNZ     r0,|L1.2336|
00091a  f06f0009          MVN      r0,#9                 ;672
00091e  e73d              B        |L1.1948|
                  |L1.2336|
000920  bf00              NOP                            ;674
000922  7fa0              LDRB     r0,[r4,#0x1e]         ;674
000924  f0400002          ORR      r0,r0,#2              ;674
000928  77a0              STRB     r0,[r4,#0x1e]         ;674
00092a  e017              B        |L1.2396|
                  |L1.2348|
00092c  48c3              LDR      r0,|L1.3132|
00092e  7800              LDRB     r0,[r0,#0]            ;677  ; flags
000930  f0000010          AND      r0,r0,#0x10           ;677
000934  b190              CBZ      r0,|L1.2396|
000936  48c0              LDR      r0,|L1.3128|
000938  6800              LDR      r0,[r0,#0]            ;679  ; tcphdr
00093a  8800              LDRH     r0,[r0,#0]            ;679
00093c  49be              LDR      r1,|L1.3128|
00093e  6809              LDR      r1,[r1,#0]            ;679  ; tcphdr
000940  8849              LDRH     r1,[r1,#2]            ;679
000942  e9cd1000          STRD     r1,r0,[sp,#0]         ;679
000946  48bb              LDR      r0,|L1.3124|
000948  6800              LDR      r0,[r0,#0]            ;679  ; seqno
00094a  4abd              LDR      r2,|L1.3136|
00094c  8812              LDRH     r2,[r2,#0]            ;679  ; tcplen
00094e  1881              ADDS     r1,r0,r2              ;679
000950  4bbc              LDR      r3,|L1.3140|
000952  4abd              LDR      r2,|L1.3144|
000954  48b6              LDR      r0,|L1.3120|
000956  6800              LDR      r0,[r0,#0]            ;679  ; ackno
000958  f7fffffe          BL       tcp_rst
                  |L1.2396|
00095c  e1bf              B        |L1.3294|
00095e  48b7              LDR      r0,|L1.3132|
000960  7800              LDRB     r0,[r0,#0]            ;684  ; flags
000962  f0000010          AND      r0,r0,#0x10           ;684
000966  2800              CMP      r0,#0                 ;684
000968  d065              BEQ      |L1.2614|
00096a  6ca0              LDR      r0,[r4,#0x48]         ;686
00096c  1c40              ADDS     r0,r0,#1              ;686
00096e  49b0              LDR      r1,|L1.3120|
000970  6809              LDR      r1,[r1,#0]            ;686  ; ackno
000972  1a08              SUBS     r0,r1,r0              ;686
000974  d44b              BMI      |L1.2574|
000976  49ae              LDR      r1,|L1.3120|
000978  6d20              LDR      r0,[r4,#0x50]         ;686
00097a  6809              LDR      r1,[r1,#0]            ;686  ; ackno
00097c  1a08              SUBS     r0,r1,r0              ;686
00097e  2800              CMP      r0,#0                 ;686
000980  dc45              BGT      |L1.2574|
000982  2004              MOVS     r0,#4                 ;688
000984  7620              STRB     r0,[r4,#0x18]         ;688
000986  bf00              NOP                            ;689
000988  bf00              NOP                            ;689
00098a  bf00              NOP                            ;691
00098c  bf00              NOP                            ;691
00098e  bf00              NOP                            ;694
000990  6960              LDR      r0,[r4,#0x14]         ;694
000992  b130              CBZ      r0,|L1.2466|
000994  2200              MOVS     r2,#0                 ;694
000996  4621              MOV      r1,r4                 ;694
000998  e9d40304          LDRD     r0,r3,[r4,#0x10]      ;694
00099c  4798              BLX      r3                    ;694
00099e  4606              MOV      r6,r0                 ;694
0009a0  e001              B        |L1.2470|
                  |L1.2466|
0009a2  f06f060d          MVN      r6,#0xd               ;694
                  |L1.2470|
0009a6  bf00              NOP                            ;694
0009a8  b146              CBZ      r6,|L1.2492|
0009aa  f106000a          ADD      r0,r6,#0xa            ;699
0009ae  b110              CBZ      r0,|L1.2486|
0009b0  4620              MOV      r0,r4                 ;700
0009b2  f7fffffe          BL       tcp_abort
                  |L1.2486|
0009b6  f06f0009          MVN      r0,#9                 ;702
0009ba  e6ef              B        |L1.1948|
                  |L1.2492|
0009bc  f8b4704c          LDRH     r7,[r4,#0x4c]         ;704
0009c0  4620              MOV      r0,r4                 ;707
0009c2  f7fffffe          BL       tcp_receive
0009c6  f8b40064          LDRH     r0,[r4,#0x64]         ;710
0009ca  b120              CBZ      r0,|L1.2518|
0009cc  f8b40064          LDRH     r0,[r4,#0x64]         ;711
0009d0  1e40              SUBS     r0,r0,#1              ;711
0009d2  f8a40064          STRH     r0,[r4,#0x64]         ;711
                  |L1.2518|
0009d6  2f01              CMP      r7,#1                 ;714
0009d8  d108              BNE      |L1.2540|
0009da  8ee0              LDRH     r0,[r4,#0x36]         ;714
0009dc  0040              LSLS     r0,r0,#1              ;714
0009de  e006              B        |L1.2542|
0009e0  e166              B        |L1.3248|
0009e2  e102              B        |L1.3050|
0009e4  e036              B        |L1.2644|
0009e6  e0b3              B        |L1.2896|
0009e8  e046              B        |L1.2680|
0009ea  e034              B        |L1.2646|
                  |L1.2540|
0009ec  8ee0              LDRH     r0,[r4,#0x36]         ;714
                  |L1.2542|
0009ee  f8a4004c          STRH     r0,[r4,#0x4c]         ;714
0009f2  4896              LDR      r0,|L1.3148|
0009f4  7800              LDRB     r0,[r0,#0]            ;716  ; recv_flags
0009f6  f0000020          AND      r0,r0,#0x20           ;716
0009fa  b138              CBZ      r0,|L1.2572|
0009fc  bf00              NOP                            ;717
0009fe  7fa0              LDRB     r0,[r4,#0x1e]         ;717
000a00  f0400002          ORR      r0,r0,#2              ;717
000a04  77a0              STRB     r0,[r4,#0x1e]         ;717
000a06  bf00              NOP                            ;717
000a08  2007              MOVS     r0,#7                 ;718
000a0a  7620              STRB     r0,[r4,#0x18]         ;718
                  |L1.2572|
000a0c  e021              B        |L1.2642|
                  |L1.2574|
000a0e  488a              LDR      r0,|L1.3128|
000a10  6800              LDR      r0,[r0,#0]            ;722  ; tcphdr
000a12  8800              LDRH     r0,[r0,#0]            ;722
000a14  4988              LDR      r1,|L1.3128|
000a16  6809              LDR      r1,[r1,#0]            ;722  ; tcphdr
000a18  8849              LDRH     r1,[r1,#2]            ;722
000a1a  e9cd1000          STRD     r1,r0,[sp,#0]         ;722
000a1e  4885              LDR      r0,|L1.3124|
000a20  6800              LDR      r0,[r0,#0]            ;722  ; seqno
000a22  4a87              LDR      r2,|L1.3136|
000a24  8812              LDRH     r2,[r2,#0]            ;722  ; tcplen
000a26  1881              ADDS     r1,r0,r2              ;722
000a28  4b86              LDR      r3,|L1.3140|
000a2a  4a87              LDR      r2,|L1.3144|
000a2c  4880              LDR      r0,|L1.3120|
000a2e  6800              LDR      r0,[r0,#0]            ;722  ; ackno
000a30  f7fffffe          BL       tcp_rst
000a34  e00d              B        |L1.2642|
                  |L1.2614|
000a36  4881              LDR      r0,|L1.3132|
000a38  7800              LDRB     r0,[r0,#0]            ;725  ; flags
000a3a  f0000002          AND      r0,r0,#2              ;725
000a3e  b140              CBZ      r0,|L1.2642|
000a40  6aa0              LDR      r0,[r4,#0x28]         ;725
000a42  1e40              SUBS     r0,r0,#1              ;725
000a44  497b              LDR      r1,|L1.3124|
000a46  6809              LDR      r1,[r1,#0]            ;725  ; seqno
000a48  4288              CMP      r0,r1                 ;725
000a4a  d102              BNE      |L1.2642|
000a4c  4620              MOV      r0,r4                 ;727
000a4e  f7fffffe          BL       tcp_rexmit
                  |L1.2642|
000a52  e144              B        |L1.3294|
                  |L1.2644|
000a54  bf00              NOP                            ;732
                  |L1.2646|
000a56  4620              MOV      r0,r4                 ;733
000a58  f7fffffe          BL       tcp_receive
000a5c  487b              LDR      r0,|L1.3148|
000a5e  7800              LDRB     r0,[r0,#0]            ;734  ; recv_flags
000a60  f0000020          AND      r0,r0,#0x20           ;734
000a64  b138              CBZ      r0,|L1.2678|
000a66  bf00              NOP                            ;735
000a68  7fa0              LDRB     r0,[r4,#0x1e]         ;735
000a6a  f0400002          ORR      r0,r0,#2              ;735
000a6e  77a0              STRB     r0,[r4,#0x1e]         ;735
000a70  bf00              NOP                            ;735
000a72  2007              MOVS     r0,#7                 ;736
000a74  7620              STRB     r0,[r4,#0x18]         ;736
                  |L1.2678|
000a76  e132              B        |L1.3294|
                  |L1.2680|
000a78  4620              MOV      r0,r4                 ;740
000a7a  f7fffffe          BL       tcp_receive
000a7e  4873              LDR      r0,|L1.3148|
000a80  7800              LDRB     r0,[r0,#0]            ;741  ; recv_flags
000a82  f0000020          AND      r0,r0,#0x20           ;741
000a86  b378              CBZ      r0,|L1.2792|
000a88  486c              LDR      r0,|L1.3132|
000a8a  7800              LDRB     r0,[r0,#0]            ;742  ; flags
000a8c  f0000010          AND      r0,r0,#0x10           ;742
000a90  b358              CBZ      r0,|L1.2794|
000a92  4967              LDR      r1,|L1.3120|
000a94  6d20              LDR      r0,[r4,#0x50]         ;742
000a96  6809              LDR      r1,[r1,#0]            ;742  ; ackno
000a98  4288              CMP      r0,r1                 ;742
000a9a  d143              BNE      |L1.2852|
000a9c  bf00              NOP                            ;743
000a9e  bf00              NOP                            ;743
000aa0  bf00              NOP                            ;745
000aa2  7fa0              LDRB     r0,[r4,#0x1e]         ;745
000aa4  f0400002          ORR      r0,r0,#2              ;745
000aa8  77a0              STRB     r0,[r4,#0x1e]         ;745
000aaa  bf00              NOP                            ;745
000aac  4620              MOV      r0,r4                 ;746
000aae  f7fffffe          BL       tcp_pcb_purge
000ab2  bf00              NOP                            ;747
000ab4  bf00              NOP                            ;747
000ab6  4866              LDR      r0,|L1.3152|
000ab8  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
000aba  42a0              CMP      r0,r4                 ;747
000abc  d105              BNE      |L1.2762|
000abe  4864              LDR      r0,|L1.3152|
000ac0  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
000ac2  68c0              LDR      r0,[r0,#0xc]          ;747
000ac4  4962              LDR      r1,|L1.3152|
000ac6  6008              STR      r0,[r1,#0]            ;747  ; tcp_active_pcbs
000ac8  e01a              B        |L1.2816|
                  |L1.2762|
000aca  4861              LDR      r0,|L1.3152|
000acc  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
000ace  4961              LDR      r1,|L1.3156|
000ad0  6008              STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
000ad2  e010              B        |L1.2806|
                  |L1.2772|
000ad4  485f              LDR      r0,|L1.3156|
000ad6  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
000ad8  68c0              LDR      r0,[r0,#0xc]          ;747
000ada  42a0              CMP      r0,r4                 ;747
000adc  d106              BNE      |L1.2796|
000ade  495d              LDR      r1,|L1.3156|
000ae0  68e0              LDR      r0,[r4,#0xc]          ;747
000ae2  6809              LDR      r1,[r1,#0]            ;747  ; tcp_tmp_pcb
000ae4  60c8              STR      r0,[r1,#0xc]          ;747
000ae6  e00a              B        |L1.2814|
                  |L1.2792|
000ae8  e025              B        |L1.2870|
                  |L1.2794|
000aea  e01b              B        |L1.2852|
                  |L1.2796|
000aec  4859              LDR      r0,|L1.3156|
000aee  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
000af0  68c0              LDR      r0,[r0,#0xc]          ;747
000af2  4958              LDR      r1,|L1.3156|
000af4  6008              STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
                  |L1.2806|
000af6  4857              LDR      r0,|L1.3156|
000af8  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
000afa  2800              CMP      r0,#0                 ;747
000afc  d1ea              BNE      |L1.2772|
                  |L1.2814|
000afe  bf00              NOP                            ;747
                  |L1.2816|
000b00  2000              MOVS     r0,#0                 ;747
000b02  60e0              STR      r0,[r4,#0xc]          ;747
000b04  bf00              NOP                            ;747
000b06  2001              MOVS     r0,#1                 ;747
000b08  4953              LDR      r1,|L1.3160|
000b0a  7008              STRB     r0,[r1,#0]            ;747
000b0c  bf00              NOP                            ;747
000b0e  200a              MOVS     r0,#0xa               ;748
000b10  7620              STRB     r0,[r4,#0x18]         ;748
000b12  bf00              NOP                            ;749
000b14  4851              LDR      r0,|L1.3164|
000b16  6800              LDR      r0,[r0,#0]            ;749  ; tcp_tw_pcbs
000b18  60e0              STR      r0,[r4,#0xc]          ;749
000b1a  4850              LDR      r0,|L1.3164|
000b1c  6004              STR      r4,[r0,#0]            ;749  ; tcp_tw_pcbs
000b1e  f7fffffe          BL       tcp_timer_needed
000b22  e014              B        |L1.2894|
                  |L1.2852|
000b24  bf00              NOP                            ;751
000b26  7fa0              LDRB     r0,[r4,#0x1e]         ;751
000b28  f0400002          ORR      r0,r0,#2              ;751
000b2c  77a0              STRB     r0,[r4,#0x1e]         ;751
000b2e  bf00              NOP                            ;751
000b30  2008              MOVS     r0,#8                 ;752
000b32  7620              STRB     r0,[r4,#0x18]         ;752
000b34  e00b              B        |L1.2894|
                  |L1.2870|
000b36  4841              LDR      r0,|L1.3132|
000b38  7800              LDRB     r0,[r0,#0]            ;754  ; flags
000b3a  f0000010          AND      r0,r0,#0x10           ;754
000b3e  b130              CBZ      r0,|L1.2894|
000b40  493b              LDR      r1,|L1.3120|
000b42  6d20              LDR      r0,[r4,#0x50]         ;754
000b44  6809              LDR      r1,[r1,#0]            ;754  ; ackno
000b46  4288              CMP      r0,r1                 ;754
000b48  d101              BNE      |L1.2894|
000b4a  2006              MOVS     r0,#6                 ;755
000b4c  7620              STRB     r0,[r4,#0x18]         ;755
                  |L1.2894|
000b4e  e0c6              B        |L1.3294|
                  |L1.2896|
000b50  4620              MOV      r0,r4                 ;759
000b52  f7fffffe          BL       tcp_receive
000b56  483d              LDR      r0,|L1.3148|
000b58  7800              LDRB     r0,[r0,#0]            ;760  ; recv_flags
000b5a  f0000020          AND      r0,r0,#0x20           ;760
000b5e  b3e8              CBZ      r0,|L1.3036|
000b60  bf00              NOP                            ;761
000b62  bf00              NOP                            ;761
000b64  bf00              NOP                            ;762
000b66  7fa0              LDRB     r0,[r4,#0x1e]         ;762
000b68  f0400002          ORR      r0,r0,#2              ;762
000b6c  77a0              STRB     r0,[r4,#0x1e]         ;762
000b6e  bf00              NOP                            ;762
000b70  4620              MOV      r0,r4                 ;763
000b72  f7fffffe          BL       tcp_pcb_purge
000b76  bf00              NOP                            ;764
000b78  bf00              NOP                            ;764
000b7a  4835              LDR      r0,|L1.3152|
000b7c  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
000b7e  42a0              CMP      r0,r4                 ;764
000b80  d105              BNE      |L1.2958|
000b82  4833              LDR      r0,|L1.3152|
000b84  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
000b86  68c0              LDR      r0,[r0,#0xc]          ;764
000b88  4931              LDR      r1,|L1.3152|
000b8a  6008              STR      r0,[r1,#0]            ;764  ; tcp_active_pcbs
000b8c  e018              B        |L1.3008|
                  |L1.2958|
000b8e  4830              LDR      r0,|L1.3152|
000b90  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
000b92  4930              LDR      r1,|L1.3156|
000b94  6008              STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
000b96  e00e              B        |L1.2998|
                  |L1.2968|
000b98  482e              LDR      r0,|L1.3156|
000b9a  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000b9c  68c0              LDR      r0,[r0,#0xc]          ;764
000b9e  42a0              CMP      r0,r4                 ;764
000ba0  d104              BNE      |L1.2988|
000ba2  492c              LDR      r1,|L1.3156|
000ba4  68e0              LDR      r0,[r4,#0xc]          ;764
000ba6  6809              LDR      r1,[r1,#0]            ;764  ; tcp_tmp_pcb
000ba8  60c8              STR      r0,[r1,#0xc]          ;764
000baa  e008              B        |L1.3006|
                  |L1.2988|
000bac  4829              LDR      r0,|L1.3156|
000bae  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000bb0  68c0              LDR      r0,[r0,#0xc]          ;764
000bb2  4928              LDR      r1,|L1.3156|
000bb4  6008              STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
                  |L1.2998|
000bb6  4827              LDR      r0,|L1.3156|
000bb8  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000bba  2800              CMP      r0,#0                 ;764
000bbc  d1ec              BNE      |L1.2968|
                  |L1.3006|
000bbe  bf00              NOP                            ;764
                  |L1.3008|
000bc0  2000              MOVS     r0,#0                 ;764
000bc2  60e0              STR      r0,[r4,#0xc]          ;764
000bc4  bf00              NOP                            ;764
000bc6  2001              MOVS     r0,#1                 ;764
000bc8  4923              LDR      r1,|L1.3160|
000bca  7008              STRB     r0,[r1,#0]            ;764
000bcc  bf00              NOP                            ;764
000bce  200a              MOVS     r0,#0xa               ;765
000bd0  7620              STRB     r0,[r4,#0x18]         ;765
000bd2  bf00              NOP                            ;766
000bd4  4821              LDR      r0,|L1.3164|
000bd6  6800              LDR      r0,[r0,#0]            ;766  ; tcp_tw_pcbs
000bd8  60e0              STR      r0,[r4,#0xc]          ;766
000bda  e000              B        |L1.3038|
                  |L1.3036|
000bdc  e004              B        |L1.3048|
                  |L1.3038|
000bde  481f              LDR      r0,|L1.3164|
000be0  6004              STR      r4,[r0,#0]            ;766  ; tcp_tw_pcbs
000be2  f7fffffe          BL       tcp_timer_needed
000be6  bf00              NOP                            ;766
                  |L1.3048|
000be8  e079              B        |L1.3294|
                  |L1.3050|
000bea  4620              MOV      r0,r4                 ;770
000bec  f7fffffe          BL       tcp_receive
000bf0  4812              LDR      r0,|L1.3132|
000bf2  7800              LDRB     r0,[r0,#0]            ;771  ; flags
000bf4  f0000010          AND      r0,r0,#0x10           ;771
000bf8  b390              CBZ      r0,|L1.3168|
000bfa  490d              LDR      r1,|L1.3120|
000bfc  6d20              LDR      r0,[r4,#0x50]         ;771
000bfe  6809              LDR      r1,[r1,#0]            ;771  ; ackno
000c00  4288              CMP      r0,r1                 ;771
000c02  d154              BNE      |L1.3246|
000c04  bf00              NOP                            ;772
000c06  bf00              NOP                            ;772
000c08  4620              MOV      r0,r4                 ;773
000c0a  f7fffffe          BL       tcp_pcb_purge
000c0e  bf00              NOP                            ;774
000c10  bf00              NOP                            ;774
000c12  480f              LDR      r0,|L1.3152|
000c14  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
000c16  42a0              CMP      r0,r4                 ;774
000c18  d105              BNE      |L1.3110|
000c1a  480d              LDR      r0,|L1.3152|
000c1c  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
000c1e  68c0              LDR      r0,[r0,#0xc]          ;774
000c20  490b              LDR      r1,|L1.3152|
000c22  6008              STR      r0,[r1,#0]            ;774  ; tcp_active_pcbs
000c24  e031              B        |L1.3210|
                  |L1.3110|
000c26  480a              LDR      r0,|L1.3152|
000c28  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
000c2a  490a              LDR      r1,|L1.3156|
000c2c  6008              STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
000c2e  e027              B        |L1.3200|
                  |L1.3120|
                          DCD      ackno
                  |L1.3124|
                          DCD      seqno
                  |L1.3128|
                          DCD      tcphdr
                  |L1.3132|
                          DCD      flags
                  |L1.3136|
                          DCD      tcplen
                  |L1.3140|
                          DCD      current_iphdr_src
                  |L1.3144|
                          DCD      current_iphdr_dest
                  |L1.3148|
                          DCD      recv_flags
                  |L1.3152|
                          DCD      tcp_active_pcbs
                  |L1.3156|
                          DCD      tcp_tmp_pcb
                  |L1.3160|
                          DCD      tcp_active_pcbs_changed
                  |L1.3164|
                          DCD      tcp_tw_pcbs
                  |L1.3168|
000c60  e025              B        |L1.3246|
                  |L1.3170|
000c62  48fb              LDR      r0,|L1.4176|
000c64  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000c66  68c0              LDR      r0,[r0,#0xc]          ;774
000c68  42a0              CMP      r0,r4                 ;774
000c6a  d104              BNE      |L1.3190|
000c6c  49f8              LDR      r1,|L1.4176|
000c6e  68e0              LDR      r0,[r4,#0xc]          ;774
000c70  6809              LDR      r1,[r1,#0]            ;774  ; tcp_tmp_pcb
000c72  60c8              STR      r0,[r1,#0xc]          ;774
000c74  e008              B        |L1.3208|
                  |L1.3190|
000c76  48f6              LDR      r0,|L1.4176|
000c78  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000c7a  68c0              LDR      r0,[r0,#0xc]          ;774
000c7c  49f4              LDR      r1,|L1.4176|
000c7e  6008              STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
                  |L1.3200|
000c80  48f3              LDR      r0,|L1.4176|
000c82  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000c84  2800              CMP      r0,#0                 ;774
000c86  d1ec              BNE      |L1.3170|
                  |L1.3208|
000c88  bf00              NOP                            ;774
                  |L1.3210|
000c8a  2000              MOVS     r0,#0                 ;774
000c8c  60e0              STR      r0,[r4,#0xc]          ;774
000c8e  bf00              NOP                            ;774
000c90  2001              MOVS     r0,#1                 ;774
000c92  49f0              LDR      r1,|L1.4180|
000c94  7008              STRB     r0,[r1,#0]            ;774
000c96  bf00              NOP                            ;774
000c98  200a              MOVS     r0,#0xa               ;775
000c9a  7620              STRB     r0,[r4,#0x18]         ;775
000c9c  bf00              NOP                            ;776
000c9e  48ee              LDR      r0,|L1.4184|
000ca0  6800              LDR      r0,[r0,#0]            ;776  ; tcp_tw_pcbs
000ca2  60e0              STR      r0,[r4,#0xc]          ;776
000ca4  48ec              LDR      r0,|L1.4184|
000ca6  6004              STR      r4,[r0,#0]            ;776  ; tcp_tw_pcbs
000ca8  f7fffffe          BL       tcp_timer_needed
000cac  bf00              NOP                            ;776
                  |L1.3246|
000cae  e016              B        |L1.3294|
                  |L1.3248|
000cb0  4620              MOV      r0,r4                 ;780
000cb2  f7fffffe          BL       tcp_receive
000cb6  48e9              LDR      r0,|L1.4188|
000cb8  7800              LDRB     r0,[r0,#0]            ;781  ; flags
000cba  f0000010          AND      r0,r0,#0x10           ;781
000cbe  b160              CBZ      r0,|L1.3290|
000cc0  49e7              LDR      r1,|L1.4192|
000cc2  6d20              LDR      r0,[r4,#0x50]         ;781
000cc4  6809              LDR      r1,[r1,#0]            ;781  ; ackno
000cc6  4288              CMP      r0,r1                 ;781
000cc8  d107              BNE      |L1.3290|
000cca  bf00              NOP                            ;782
000ccc  bf00              NOP                            ;782
000cce  48e5              LDR      r0,|L1.4196|
000cd0  7800              LDRB     r0,[r0,#0]            ;784  ; recv_flags
000cd2  f0400010          ORR      r0,r0,#0x10           ;784
000cd6  49e3              LDR      r1,|L1.4196|
000cd8  7008              STRB     r0,[r1,#0]            ;784
                  |L1.3290|
000cda  e000              B        |L1.3294|
                  |L1.3292|
000cdc  bf00              NOP                            ;788
                  |L1.3294|
000cde  bf00              NOP                            ;682
000ce0  2000              MOVS     r0,#0                 ;790
000ce2  e55b              B        |L1.1948|
;;;792    
                          ENDP

                  tcp_listen_input PROC
;;;439    static err_t
;;;440    tcp_listen_input(struct tcp_pcb_listen *pcb)
000ce4  b57c              PUSH     {r2-r6,lr}
;;;441    {
000ce6  4605              MOV      r5,r0
;;;442      struct tcp_pcb *npcb;
;;;443      err_t rc;
;;;444    
;;;445      if (flags & TCP_RST) {
000ce8  48dc              LDR      r0,|L1.4188|
000cea  7800              LDRB     r0,[r0,#0]  ; flags
000cec  f0000004          AND      r0,r0,#4
000cf0  b108              CBZ      r0,|L1.3318|
;;;446        /* An incoming RST should be ignored. Return. */
;;;447        return ERR_OK;
000cf2  2000              MOVS     r0,#0
                  |L1.3316|
;;;448      }
;;;449    
;;;450      /* In the LISTEN state, we check for incoming SYN segments,
;;;451         creates a new PCB, and responds with a SYN|ACK. */
;;;452      if (flags & TCP_ACK) {
;;;453        /* For incoming segments with the ACK flag set, respond with a
;;;454           RST. */
;;;455        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;456        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;457          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;458      } else if (flags & TCP_SYN) {
;;;459        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;460    #if TCP_LISTEN_BACKLOG
;;;461        if (pcb->accepts_pending >= pcb->backlog) {
;;;462          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;463          return ERR_ABRT;
;;;464        }
;;;465    #endif /* TCP_LISTEN_BACKLOG */
;;;466        npcb = tcp_alloc(pcb->prio);
;;;467        /* If a new PCB could not be created (probably due to lack of memory),
;;;468           we don't do anything, but rely on the sender will retransmit the
;;;469           SYN at a time when we have more memory available. */
;;;470        if (npcb == NULL) {
;;;471          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;472          TCP_STATS_INC(tcp.memerr);
;;;473          return ERR_MEM;
;;;474        }
;;;475    #if TCP_LISTEN_BACKLOG
;;;476        pcb->accepts_pending++;
;;;477    #endif /* TCP_LISTEN_BACKLOG */
;;;478        /* Set up the new PCB. */
;;;479        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
;;;480        npcb->local_port = pcb->local_port;
;;;481        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
;;;482        npcb->remote_port = tcphdr->src;
;;;483        npcb->state = SYN_RCVD;
;;;484        npcb->rcv_nxt = seqno + 1;
;;;485        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;486        npcb->snd_wnd = tcphdr->wnd;
;;;487        npcb->snd_wnd_max = tcphdr->wnd;
;;;488        npcb->ssthresh = npcb->snd_wnd;
;;;489        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;490        npcb->callback_arg = pcb->callback_arg;
;;;491    #if LWIP_CALLBACK_API
;;;492        npcb->accept = pcb->accept;
;;;493    #endif /* LWIP_CALLBACK_API */
;;;494        /* inherit socket options */
;;;495        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;496        /* Register the new PCB so that we can begin receiving segments
;;;497           for it. */
;;;498        TCP_REG_ACTIVE(npcb);
;;;499    
;;;500        /* Parse any options in the SYN. */
;;;501        tcp_parseopt(npcb);
;;;502    #if TCP_CALCULATE_EFF_SEND_MSS
;;;503        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
;;;504    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;505    
;;;506        snmp_inc_tcppassiveopens();
;;;507    
;;;508        /* Send a SYN|ACK together with the MSS option. */
;;;509        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;510        if (rc != ERR_OK) {
;;;511          tcp_abandon(npcb, 0);
;;;512          return rc;
;;;513        }
;;;514        return tcp_output(npcb);
;;;515      }
;;;516      return ERR_OK;
;;;517    }
000cf4  bd7c              POP      {r2-r6,pc}
                  |L1.3318|
000cf6  48d9              LDR      r0,|L1.4188|
000cf8  7800              LDRB     r0,[r0,#0]            ;452  ; flags
000cfa  f0000010          AND      r0,r0,#0x10           ;452
000cfe  b1a8              CBZ      r0,|L1.3372|
000d00  bf00              NOP                            ;455
000d02  bf00              NOP                            ;455
000d04  48d8              LDR      r0,|L1.4200|
000d06  6800              LDR      r0,[r0,#0]            ;456  ; tcphdr
000d08  8800              LDRH     r0,[r0,#0]            ;456
000d0a  49d7              LDR      r1,|L1.4200|
000d0c  6809              LDR      r1,[r1,#0]            ;456  ; tcphdr
000d0e  8849              LDRH     r1,[r1,#2]            ;456
000d10  e9cd1000          STRD     r1,r0,[sp,#0]         ;456
000d14  48d5              LDR      r0,|L1.4204|
000d16  6800              LDR      r0,[r0,#0]            ;456  ; seqno
000d18  4ad5              LDR      r2,|L1.4208|
000d1a  8812              LDRH     r2,[r2,#0]            ;456  ; tcplen
000d1c  1881              ADDS     r1,r0,r2              ;456
000d1e  4bd5              LDR      r3,|L1.4212|
000d20  4ad5              LDR      r2,|L1.4216|
000d22  48cf              LDR      r0,|L1.4192|
000d24  6800              LDR      r0,[r0,#0]            ;456  ; ackno
000d26  f7fffffe          BL       tcp_rst
000d2a  e071              B        |L1.3600|
                  |L1.3372|
000d2c  48cb              LDR      r0,|L1.4188|
000d2e  7800              LDRB     r0,[r0,#0]            ;458  ; flags
000d30  f0000002          AND      r0,r0,#2              ;458
000d34  2800              CMP      r0,#0                 ;458
000d36  d06b              BEQ      |L1.3600|
000d38  bf00              NOP                            ;459
000d3a  bf00              NOP                            ;459
000d3c  7f68              LDRB     r0,[r5,#0x1d]         ;461
000d3e  7f29              LDRB     r1,[r5,#0x1c]         ;461
000d40  4288              CMP      r0,r1                 ;461
000d42  db04              BLT      |L1.3406|
000d44  bf00              NOP                            ;462
000d46  bf00              NOP                            ;462
000d48  f06f0009          MVN      r0,#9                 ;463
000d4c  e7d2              B        |L1.3316|
                  |L1.3406|
000d4e  7e68              LDRB     r0,[r5,#0x19]         ;466
000d50  f7fffffe          BL       tcp_alloc
000d54  4604              MOV      r4,r0                 ;466
000d56  b924              CBNZ     r4,|L1.3426|
000d58  bf00              NOP                            ;471
000d5a  bf00              NOP                            ;471
000d5c  f04f30ff          MOV      r0,#0xffffffff        ;473
000d60  e7c8              B        |L1.3316|
                  |L1.3426|
000d62  7f68              LDRB     r0,[r5,#0x1d]         ;476
000d64  1c40              ADDS     r0,r0,#1              ;476
000d66  7768              STRB     r0,[r5,#0x1d]         ;476
000d68  48c3              LDR      r0,|L1.4216|
000d6a  6800              LDR      r0,[r0,#0]            ;479  ; current_iphdr_dest
000d6c  6020              STR      r0,[r4,#0]            ;479
000d6e  8b68              LDRH     r0,[r5,#0x1a]         ;480
000d70  8360              STRH     r0,[r4,#0x1a]         ;480
000d72  48c0              LDR      r0,|L1.4212|
000d74  6800              LDR      r0,[r0,#0]            ;481  ; current_iphdr_src
000d76  6060              STR      r0,[r4,#4]            ;481
000d78  48bb              LDR      r0,|L1.4200|
000d7a  6800              LDR      r0,[r0,#0]            ;482  ; tcphdr
000d7c  8800              LDRH     r0,[r0,#0]            ;482
000d7e  83a0              STRH     r0,[r4,#0x1c]         ;482
000d80  2003              MOVS     r0,#3                 ;483
000d82  7620              STRB     r0,[r4,#0x18]         ;483
000d84  48b9              LDR      r0,|L1.4204|
000d86  6800              LDR      r0,[r0,#0]            ;484  ; seqno
000d88  1c40              ADDS     r0,r0,#1              ;484
000d8a  62a0              STR      r0,[r4,#0x28]         ;484
000d8c  6aa0              LDR      r0,[r4,#0x28]         ;485
000d8e  6320              STR      r0,[r4,#0x30]         ;485
000d90  48b5              LDR      r0,|L1.4200|
000d92  6800              LDR      r0,[r0,#0]            ;486  ; tcphdr
000d94  89c0              LDRH     r0,[r0,#0xe]          ;486
000d96  f8a40060          STRH     r0,[r4,#0x60]         ;486
000d9a  48b3              LDR      r0,|L1.4200|
000d9c  6800              LDR      r0,[r0,#0]            ;487  ; tcphdr
000d9e  89c0              LDRH     r0,[r0,#0xe]          ;487
000da0  f8a40062          STRH     r0,[r4,#0x62]         ;487
000da4  f8b40060          LDRH     r0,[r4,#0x60]         ;488
000da8  f8a4004e          STRH     r0,[r4,#0x4e]         ;488
000dac  48af              LDR      r0,|L1.4204|
000dae  6800              LDR      r0,[r0,#0]            ;489  ; seqno
000db0  1e40              SUBS     r0,r0,#1              ;489
000db2  6560              STR      r0,[r4,#0x54]         ;489
000db4  6928              LDR      r0,[r5,#0x10]         ;490
000db6  6120              STR      r0,[r4,#0x10]         ;490
000db8  6968              LDR      r0,[r5,#0x14]         ;492
000dba  6160              STR      r0,[r4,#0x14]         ;492
000dbc  7a28              LDRB     r0,[r5,#8]            ;495
000dbe  f000008c          AND      r0,r0,#0x8c           ;495
000dc2  7220              STRB     r0,[r4,#8]            ;495
000dc4  bf00              NOP                            ;498
000dc6  bf00              NOP                            ;498
000dc8  48ac              LDR      r0,|L1.4220|
000dca  6800              LDR      r0,[r0,#0]            ;498  ; tcp_active_pcbs
000dcc  60e0              STR      r0,[r4,#0xc]          ;498
000dce  48ab              LDR      r0,|L1.4220|
000dd0  6004              STR      r4,[r0,#0]            ;498  ; tcp_active_pcbs
000dd2  f7fffffe          BL       tcp_timer_needed
000dd6  bf00              NOP                            ;498
000dd8  2001              MOVS     r0,#1                 ;498
000dda  499e              LDR      r1,|L1.4180|
000ddc  7008              STRB     r0,[r1,#0]            ;498
000dde  bf00              NOP                            ;498
000de0  4620              MOV      r0,r4                 ;501
000de2  f7fffffe          BL       tcp_parseopt
000de6  8ee0              LDRH     r0,[r4,#0x36]         ;503
000de8  1d21              ADDS     r1,r4,#4              ;503
000dea  f7fffffe          BL       tcp_eff_send_mss
000dee  86e0              STRH     r0,[r4,#0x36]         ;503
000df0  2112              MOVS     r1,#0x12              ;509
000df2  4620              MOV      r0,r4                 ;509
000df4  f7fffffe          BL       tcp_enqueue_flags
000df8  4606              MOV      r6,r0                 ;509
000dfa  b12e              CBZ      r6,|L1.3592|
000dfc  2100              MOVS     r1,#0                 ;511
000dfe  4620              MOV      r0,r4                 ;511
000e00  f7fffffe          BL       tcp_abandon
000e04  4630              MOV      r0,r6                 ;512
000e06  e775              B        |L1.3316|
                  |L1.3592|
000e08  4620              MOV      r0,r4                 ;514
000e0a  f7fffffe          BL       tcp_output
000e0e  e771              B        |L1.3316|
                  |L1.3600|
000e10  2000              MOVS     r0,#0                 ;516
000e12  e76f              B        |L1.3316|
;;;518    
                          ENDP

                  tcp_timewait_input PROC
;;;528    static err_t
;;;529    tcp_timewait_input(struct tcp_pcb *pcb)
000e14  b51c              PUSH     {r2-r4,lr}
;;;530    {
000e16  4604              MOV      r4,r0
;;;531      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;532      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;533       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;534       *   acceptable since we only send ACKs)
;;;535       * - second check the RST bit (... return) */
;;;536      if (flags & TCP_RST)  {
000e18  4890              LDR      r0,|L1.4188|
000e1a  7800              LDRB     r0,[r0,#0]  ; flags
000e1c  f0000004          AND      r0,r0,#4
000e20  b108              CBZ      r0,|L1.3622|
;;;537        return ERR_OK;
000e22  2000              MOVS     r0,#0
                  |L1.3620|
;;;538      }
;;;539      /* - fourth, check the SYN bit, */
;;;540      if (flags & TCP_SYN) {
;;;541        /* If an incoming segment is not acceptable, an acknowledgment
;;;542           should be sent in reply */
;;;543        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;544          /* If the SYN is in the window it is an error, send a reset */
;;;545          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;546            tcphdr->dest, tcphdr->src);
;;;547          return ERR_OK;
;;;548        }
;;;549      } else if (flags & TCP_FIN) {
;;;550        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;551             Restart the 2 MSL time-wait timeout.*/
;;;552        pcb->tmr = tcp_ticks;
;;;553      }
;;;554    
;;;555      if ((tcplen > 0))  {
;;;556        /* Acknowledge data, FIN or out-of-window SYN */
;;;557        pcb->flags |= TF_ACK_NOW;
;;;558        return tcp_output(pcb);
;;;559      }
;;;560      return ERR_OK;
;;;561    }
000e24  bd1c              POP      {r2-r4,pc}
                  |L1.3622|
000e26  488d              LDR      r0,|L1.4188|
000e28  7800              LDRB     r0,[r0,#0]            ;540  ; flags
000e2a  f0000002          AND      r0,r0,#2              ;540
000e2e  b308              CBZ      r0,|L1.3700|
000e30  498e              LDR      r1,|L1.4204|
000e32  6aa0              LDR      r0,[r4,#0x28]         ;543
000e34  6809              LDR      r1,[r1,#0]            ;543  ; seqno
000e36  1a08              SUBS     r0,r1,r0              ;543
000e38  d424              BMI      |L1.3716|
000e3a  8da1              LDRH     r1,[r4,#0x2c]         ;543
000e3c  6aa0              LDR      r0,[r4,#0x28]         ;543
000e3e  4408              ADD      r0,r0,r1              ;543
000e40  498a              LDR      r1,|L1.4204|
000e42  6809              LDR      r1,[r1,#0]            ;543  ; seqno
000e44  1a08              SUBS     r0,r1,r0              ;543
000e46  2800              CMP      r0,#0                 ;543
000e48  dc1c              BGT      |L1.3716|
000e4a  4887              LDR      r0,|L1.4200|
000e4c  6800              LDR      r0,[r0,#0]            ;545  ; tcphdr
000e4e  8800              LDRH     r0,[r0,#0]            ;545
000e50  4985              LDR      r1,|L1.4200|
000e52  6809              LDR      r1,[r1,#0]            ;545  ; tcphdr
000e54  8849              LDRH     r1,[r1,#2]            ;545
000e56  e9cd1000          STRD     r1,r0,[sp,#0]         ;545
000e5a  4884              LDR      r0,|L1.4204|
000e5c  6800              LDR      r0,[r0,#0]            ;545  ; seqno
000e5e  4a84              LDR      r2,|L1.4208|
000e60  8812              LDRH     r2,[r2,#0]            ;545  ; tcplen
000e62  1881              ADDS     r1,r0,r2              ;545
000e64  4b83              LDR      r3,|L1.4212|
000e66  4a84              LDR      r2,|L1.4216|
000e68  487d              LDR      r0,|L1.4192|
000e6a  6800              LDR      r0,[r0,#0]            ;545  ; ackno
000e6c  f7fffffe          BL       tcp_rst
000e70  2000              MOVS     r0,#0                 ;547
000e72  e7d7              B        |L1.3620|
                  |L1.3700|
000e74  4879              LDR      r0,|L1.4188|
000e76  7800              LDRB     r0,[r0,#0]            ;549  ; flags
000e78  f0000001          AND      r0,r0,#1              ;549
000e7c  b110              CBZ      r0,|L1.3716|
000e7e  4880              LDR      r0,|L1.4224|
000e80  6800              LDR      r0,[r0,#0]            ;552  ; tcp_ticks
000e82  6260              STR      r0,[r4,#0x24]         ;552
                  |L1.3716|
000e84  487a              LDR      r0,|L1.4208|
000e86  8800              LDRH     r0,[r0,#0]            ;555  ; tcplen
000e88  2800              CMP      r0,#0                 ;555
000e8a  dd07              BLE      |L1.3740|
000e8c  7fa0              LDRB     r0,[r4,#0x1e]         ;557
000e8e  f0400002          ORR      r0,r0,#2              ;557
000e92  77a0              STRB     r0,[r4,#0x1e]         ;557
000e94  4620              MOV      r0,r4                 ;558
000e96  f7fffffe          BL       tcp_output
000e9a  e7c3              B        |L1.3620|
                  |L1.3740|
000e9c  2000              MOVS     r0,#0                 ;560
000e9e  e7c1              B        |L1.3620|
;;;562    
                          ENDP

                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
000ea0  e92d47fc          PUSH     {r2-r10,lr}
;;;93     {
000ea4  4606              MOV      r6,r0
000ea6  468a              MOV      r10,r1
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
000ea8  4976              LDR      r1,|L1.4228|
000eaa  6870              LDR      r0,[r6,#4]
000eac  6008              STR      r0,[r1,#0]  ; iphdr
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
000eae  4875              LDR      r0,|L1.4228|
000eb0  6871              LDR      r1,[r6,#4]
000eb2  6800              LDR      r0,[r0,#0]  ; iphdr
000eb4  7800              LDRB     r0,[r0,#0]
000eb6  f000000f          AND      r0,r0,#0xf
000eba  eb010080          ADD      r0,r1,r0,LSL #2
000ebe  496a              LDR      r1,|L1.4200|
000ec0  6008              STR      r0,[r1,#0]  ; tcphdr
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
000ec2  4870              LDR      r0,|L1.4228|
000ec4  6800              LDR      r0,[r0,#0]  ; iphdr
000ec6  7800              LDRB     r0,[r0,#0]
000ec8  0700              LSLS     r0,r0,#28
000eca  0e80              LSRS     r0,r0,#26
000ecc  4241              RSBS     r1,r0,#0
000ece  4630              MOV      r0,r6
000ed0  f7fffffe          BL       pbuf_header
000ed4  b910              CBNZ     r0,|L1.3804|
000ed6  8930              LDRH     r0,[r6,#8]
000ed8  2814              CMP      r0,#0x14
000eda  d202              BCS      |L1.3810|
                  |L1.3804|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
000edc  bf00              NOP      
000ede  bf00              NOP      
;;;119        TCP_STATS_INC(tcp.lenerr);
;;;120        goto dropped;
000ee0  e217              B        |L1.4882|
                  |L1.3810|
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
000ee2  4965              LDR      r1,|L1.4216|
000ee4  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
000ee6  4651              MOV      r1,r10
000ee8  f7fffffe          BL       ip4_addr_isbroadcast
000eec  b928              CBNZ     r0,|L1.3834|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
000eee  4862              LDR      r0,|L1.4216|
000ef0  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
000ef2  f00000f0          AND      r0,r0,#0xf0
000ef6  28e0              CMP      r0,#0xe0
000ef8  d100              BNE      |L1.3836|
                  |L1.3834|
;;;126        TCP_STATS_INC(tcp.proterr);
;;;127        goto dropped;
000efa  e20a              B        |L1.4882|
                  |L1.3836|
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
;;;141        goto dropped;
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
000efc  495a              LDR      r1,|L1.4200|
000efe  6809              LDR      r1,[r1,#0]  ; tcphdr
000f00  8988              LDRH     r0,[r1,#0xc]
000f02  f7fffffe          BL       lwip_ntohs
000f06  ea4f3920          ASR      r9,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
000f0a  ea4f0089          LSL      r0,r9,#2
000f0e  4241              RSBS     r1,r0,#0
000f10  4630              MOV      r0,r6
000f12  f7fffffe          BL       pbuf_header
000f16  b110              CBZ      r0,|L1.3870|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
000f18  bf00              NOP      
000f1a  bf00              NOP      
;;;151        TCP_STATS_INC(tcp.lenerr);
;;;152        goto dropped;
000f1c  e1f9              B        |L1.4882|
                  |L1.3870|
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
000f1e  4952              LDR      r1,|L1.4200|
000f20  6809              LDR      r1,[r1,#0]  ; tcphdr
000f22  8808              LDRH     r0,[r1,#0]
000f24  f7fffffe          BL       lwip_ntohs
000f28  494f              LDR      r1,|L1.4200|
000f2a  6809              LDR      r1,[r1,#0]  ; tcphdr
000f2c  8008              STRH     r0,[r1,#0]
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
000f2e  494e              LDR      r1,|L1.4200|
000f30  6809              LDR      r1,[r1,#0]  ; tcphdr
000f32  8848              LDRH     r0,[r1,#2]
000f34  f7fffffe          BL       lwip_ntohs
000f38  494b              LDR      r1,|L1.4200|
000f3a  6809              LDR      r1,[r1,#0]  ; tcphdr
000f3c  8048              STRH     r0,[r1,#2]
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
000f3e  494a              LDR      r1,|L1.4200|
000f40  6809              LDR      r1,[r1,#0]  ; tcphdr
000f42  6848              LDR      r0,[r1,#4]
000f44  f7fffffe          BL       lwip_ntohl
000f48  4947              LDR      r1,|L1.4200|
000f4a  6809              LDR      r1,[r1,#0]  ; tcphdr
000f4c  6048              STR      r0,[r1,#4]
000f4e  4947              LDR      r1,|L1.4204|
000f50  6008              STR      r0,[r1,#0]  ; seqno
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
000f52  4945              LDR      r1,|L1.4200|
000f54  6809              LDR      r1,[r1,#0]  ; tcphdr
000f56  6888              LDR      r0,[r1,#8]
000f58  f7fffffe          BL       lwip_ntohl
000f5c  4942              LDR      r1,|L1.4200|
000f5e  6809              LDR      r1,[r1,#0]  ; tcphdr
000f60  6088              STR      r0,[r1,#8]
000f62  493f              LDR      r1,|L1.4192|
000f64  6008              STR      r0,[r1,#0]  ; ackno
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
000f66  4940              LDR      r1,|L1.4200|
000f68  6809              LDR      r1,[r1,#0]  ; tcphdr
000f6a  89c8              LDRH     r0,[r1,#0xe]
000f6c  f7fffffe          BL       lwip_ntohs
000f70  493d              LDR      r1,|L1.4200|
000f72  6809              LDR      r1,[r1,#0]  ; tcphdr
000f74  81c8              STRH     r0,[r1,#0xe]
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
000f76  493c              LDR      r1,|L1.4200|
000f78  6809              LDR      r1,[r1,#0]  ; tcphdr
000f7a  8988              LDRH     r0,[r1,#0xc]
000f7c  f7fffffe          BL       lwip_ntohs
000f80  f000003f          AND      r0,r0,#0x3f
000f84  4935              LDR      r1,|L1.4188|
000f86  7008              STRB     r0,[r1,#0]
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
000f88  8930              LDRH     r0,[r6,#8]
000f8a  7809              LDRB     r1,[r1,#0]  ; flags
000f8c  f0010103          AND      r1,r1,#3
000f90  b109              CBZ      r1,|L1.3990|
000f92  2101              MOVS     r1,#1
000f94  e000              B        |L1.3992|
                  |L1.3990|
000f96  2100              MOVS     r1,#0
                  |L1.3992|
000f98  4408              ADD      r0,r0,r1
000f9a  4935              LDR      r1,|L1.4208|
000f9c  8008              STRH     r0,[r1,#0]
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
000f9e  2700              MOVS     r7,#0
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000fa0  4836              LDR      r0,|L1.4220|
000fa2  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000fa4  e02a              B        |L1.4092|
                  |L1.4006|
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
000fa6  bf00              NOP      
000fa8  bf00              NOP      
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
000faa  bf00              NOP      
000fac  bf00              NOP      
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
000fae  bf00              NOP      
000fb0  bf00              NOP      
;;;174        if (pcb->remote_port == tcphdr->src &&
000fb2  8ba0              LDRH     r0,[r4,#0x1c]
000fb4  492c              LDR      r1,|L1.4200|
000fb6  6809              LDR      r1,[r1,#0]  ; tcphdr
000fb8  8809              LDRH     r1,[r1,#0]
000fba  4288              CMP      r0,r1
000fbc  d11c              BNE      |L1.4088|
;;;175           pcb->local_port == tcphdr->dest &&
000fbe  8b60              LDRH     r0,[r4,#0x1a]
000fc0  4929              LDR      r1,|L1.4200|
000fc2  6809              LDR      r1,[r1,#0]  ; tcphdr
000fc4  8849              LDRH     r1,[r1,#2]
000fc6  4288              CMP      r0,r1
000fc8  d116              BNE      |L1.4088|
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
000fca  492a              LDR      r1,|L1.4212|
000fcc  6860              LDR      r0,[r4,#4]
000fce  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
000fd0  4288              CMP      r0,r1
000fd2  d111              BNE      |L1.4088|
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
000fd4  4928              LDR      r1,|L1.4216|
000fd6  6820              LDR      r0,[r4,#0]
000fd8  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
000fda  4288              CMP      r0,r1
000fdc  d10c              BNE      |L1.4088|
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
000fde  bf00              NOP      
000fe0  bf00              NOP      
;;;183          if (prev != NULL) {
000fe2  b137              CBZ      r7,|L1.4082|
;;;184            prev->next = pcb->next;
000fe4  68e0              LDR      r0,[r4,#0xc]
000fe6  60f8              STR      r0,[r7,#0xc]
;;;185            pcb->next = tcp_active_pcbs;
000fe8  4824              LDR      r0,|L1.4220|
000fea  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
000fec  60e0              STR      r0,[r4,#0xc]
;;;186            tcp_active_pcbs = pcb;
000fee  4823              LDR      r0,|L1.4220|
000ff0  6004              STR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.4082|
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
000ff2  bf00              NOP      
000ff4  bf00              NOP      
;;;189          break;
000ff6  e003              B        |L1.4096|
                  |L1.4088|
;;;190        }
;;;191        prev = pcb;
000ff8  4627              MOV      r7,r4
000ffa  68e4              LDR      r4,[r4,#0xc]          ;170
                  |L1.4092|
000ffc  2c00              CMP      r4,#0                 ;170
000ffe  d1d2              BNE      |L1.4006|
                  |L1.4096|
001000  bf00              NOP                            ;189
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
001002  2c00              CMP      r4,#0
001004  d16e              BNE      |L1.4324|
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
001006  4814              LDR      r0,|L1.4184|
001008  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
00100a  e03e              B        |L1.4234|
                  |L1.4108|
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
00100c  bf00              NOP      
00100e  bf00              NOP      
;;;199          if (pcb->remote_port == tcphdr->src &&
001010  8ba0              LDRH     r0,[r4,#0x1c]
001012  4915              LDR      r1,|L1.4200|
001014  6809              LDR      r1,[r1,#0]  ; tcphdr
001016  8809              LDRH     r1,[r1,#0]
001018  4288              CMP      r0,r1
00101a  d135              BNE      |L1.4232|
;;;200             pcb->local_port == tcphdr->dest &&
00101c  8b60              LDRH     r0,[r4,#0x1a]
00101e  4912              LDR      r1,|L1.4200|
001020  6809              LDR      r1,[r1,#0]  ; tcphdr
001022  8849              LDRH     r1,[r1,#2]
001024  4288              CMP      r0,r1
001026  d12f              BNE      |L1.4232|
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
001028  4912              LDR      r1,|L1.4212|
00102a  6860              LDR      r0,[r4,#4]
00102c  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
00102e  4288              CMP      r0,r1
001030  d12a              BNE      |L1.4232|
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
001032  4911              LDR      r1,|L1.4216|
001034  6820              LDR      r0,[r4,#0]
001036  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
001038  4288              CMP      r0,r1
00103a  d125              BNE      |L1.4232|
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
00103c  bf00              NOP      
00103e  bf00              NOP      
;;;207            tcp_timewait_input(pcb);
001040  4620              MOV      r0,r4
001042  f7fffffe          BL       tcp_timewait_input
;;;208            pbuf_free(p);
001046  4630              MOV      r0,r6
001048  f7fffffe          BL       pbuf_free
;;;209            return;
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;217          if (lpcb->local_port == tcphdr->dest) {
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
;;;259          pbuf_free(p);
;;;260          return;
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
;;;281        inseg.len = p->tot_len;
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
;;;284    
;;;285        recv_data = NULL;
;;;286        recv_flags = 0;
;;;287    
;;;288        if (flags & TCP_PSH) {
;;;289          p->flags |= PBUF_FLAG_PUSH;
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
;;;308          if (recv_flags & TF_RESET) {
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315            memp_free(MEMP_TCP_PCB, pcb);
;;;316          } else if (recv_flags & TF_CLOSED) {
;;;317            /* The connection has been closed and we will deallocate the
;;;318               PCB. */
;;;319            if (!(pcb->flags & TF_RXCLOSED)) {
;;;320              /* Connection closed although the application has only shut down the
;;;321                 tx side: call the PCB's err callback and indicate the closure to
;;;322                 ensure the application doesn't continue using the PCB. */
;;;323              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;324            }
;;;325            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;326            memp_free(MEMP_TCP_PCB, pcb);
;;;327          } else {
;;;328            err = ERR_OK;
;;;329            /* If the application has registered a "sent" function to be
;;;330               called when new send buffer space is available, we call it
;;;331               now. */
;;;332            if (pcb->acked > 0) {
;;;333              TCP_EVENT_SENT(pcb, pcb->acked, err);
;;;334              if (err == ERR_ABRT) {
;;;335                goto aborted;
;;;336              }
;;;337            }
;;;338    
;;;339            if (recv_data != NULL) {
;;;340              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
;;;341              if (pcb->flags & TF_RXCLOSED) {
;;;342                /* received data although already closed -> abort (send RST) to
;;;343                   notify the remote host that not all data has been processed */
;;;344                pbuf_free(recv_data);
;;;345                tcp_abort(pcb);
;;;346                goto aborted;
;;;347              }
;;;348    
;;;349              /* Notify application that data has been received. */
;;;350              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
;;;351              if (err == ERR_ABRT) {
;;;352                goto aborted;
;;;353              }
;;;354    
;;;355              /* If the upper layer can't receive this data, store it */
;;;356              if (err != ERR_OK) {
;;;357                pcb->refused_data = recv_data;
;;;358                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;359              }
;;;360            }
;;;361    
;;;362            /* If a FIN segment was received, we call the callback
;;;363               function with a NULL buffer to indicate EOF. */
;;;364            if (recv_flags & TF_GOT_FIN) {
;;;365              if (pcb->refused_data != NULL) {
;;;366                /* Delay this if we have refused data. */
;;;367                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
;;;368              } else {
;;;369                /* correct rcv_wnd as the application won't call tcp_recved()
;;;370                   for the FIN's seqno */
;;;371                if (pcb->rcv_wnd != TCP_WND) {
;;;372                  pcb->rcv_wnd++;
;;;373                }
;;;374                TCP_EVENT_CLOSED(pcb, err);
;;;375                if (err == ERR_ABRT) {
;;;376                  goto aborted;
;;;377                }
;;;378              }
;;;379            }
;;;380    
;;;381            tcp_input_pcb = NULL;
;;;382            /* Try to send something out. */
;;;383            tcp_output(pcb);
;;;384    #if TCP_INPUT_DEBUG
;;;385    #if TCP_DEBUG
;;;386            tcp_debug_print_state(pcb->state);
;;;387    #endif /* TCP_DEBUG */
;;;388    #endif /* TCP_INPUT_DEBUG */
;;;389          }
;;;390        }
;;;391        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;392           Below this line, 'pcb' may not be dereferenced! */
;;;393    aborted:
;;;394        tcp_input_pcb = NULL;
;;;395        recv_data = NULL;
;;;396    
;;;397        /* give up our reference to inseg.p */
;;;398        if (inseg.p != NULL)
;;;399        {
;;;400          pbuf_free(inseg.p);
;;;401          inseg.p = NULL;
;;;402        }
;;;403      } else {
;;;404    
;;;405        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;406           sender. */
;;;407        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;408        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;409          TCP_STATS_INC(tcp.proterr);
;;;410          TCP_STATS_INC(tcp.drop);
;;;411          tcp_rst(ackno, seqno + tcplen,
;;;412            ip_current_dest_addr(), ip_current_src_addr(),
;;;413            tcphdr->dest, tcphdr->src);
;;;414        }
;;;415        pbuf_free(p);
;;;416      }
;;;417    
;;;418      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;419      PERF_STOP("tcp_input");
;;;420      return;
;;;421    dropped:
;;;422      TCP_STATS_INC(tcp.drop);
;;;423      snmp_inc_tcpinerrs();
;;;424      pbuf_free(p);
;;;425    }
00104c  e8bd87fc          POP      {r2-r10,pc}
                  |L1.4176|
                          DCD      tcp_tmp_pcb
                  |L1.4180|
                          DCD      tcp_active_pcbs_changed
                  |L1.4184|
                          DCD      tcp_tw_pcbs
                  |L1.4188|
                          DCD      flags
                  |L1.4192|
                          DCD      ackno
                  |L1.4196|
                          DCD      recv_flags
                  |L1.4200|
                          DCD      tcphdr
                  |L1.4204|
                          DCD      seqno
                  |L1.4208|
                          DCD      tcplen
                  |L1.4212|
                          DCD      current_iphdr_src
                  |L1.4216|
                          DCD      current_iphdr_dest
                  |L1.4220|
                          DCD      tcp_active_pcbs
                  |L1.4224|
                          DCD      tcp_ticks
                  |L1.4228|
                          DCD      iphdr
                  |L1.4232|
001088  68e4              LDR      r4,[r4,#0xc]          ;197
                  |L1.4234|
00108a  2c00              CMP      r4,#0                 ;197
00108c  d1be              BNE      |L1.4108|
00108e  2700              MOVS     r7,#0                 ;215
001090  48a2              LDR      r0,|L1.4892|
001092  6805              LDR      r5,[r0,#0]            ;216  ; tcp_listen_pcbs
001094  e010              B        |L1.4280|
                  |L1.4246|
001096  8b68              LDRH     r0,[r5,#0x1a]         ;217
001098  49a1              LDR      r1,|L1.4896|
00109a  6809              LDR      r1,[r1,#0]            ;217  ; tcphdr
00109c  8849              LDRH     r1,[r1,#2]            ;217
00109e  4288              CMP      r0,r1                 ;217
0010a0  d108              BNE      |L1.4276|
0010a2  49a0              LDR      r1,|L1.4900|
0010a4  6828              LDR      r0,[r5,#0]            ;228
0010a6  6809              LDR      r1,[r1,#0]            ;228  ; current_iphdr_dest
0010a8  4288              CMP      r0,r1                 ;228
0010aa  d002              BEQ      |L1.4274|
0010ac  b10d              CBZ      r5,|L1.4274|
0010ae  6828              LDR      r0,[r5,#0]            ;229
0010b0  b900              CBNZ     r0,|L1.4276|
                  |L1.4274|
0010b2  e003              B        |L1.4284|
                  |L1.4276|
0010b4  462f              MOV      r7,r5                 ;235
0010b6  68ed              LDR      r5,[r5,#0xc]          ;216
                  |L1.4280|
0010b8  2d00              CMP      r5,#0                 ;216
0010ba  d1ec              BNE      |L1.4246|
                  |L1.4284|
0010bc  bf00              NOP                            ;231
0010be  b18d              CBZ      r5,|L1.4324|
0010c0  b137              CBZ      r7,|L1.4304|
0010c2  68e8              LDR      r0,[r5,#0xc]          ;250
0010c4  60f8              STR      r0,[r7,#0xc]          ;250
0010c6  4895              LDR      r0,|L1.4892|
0010c8  6800              LDR      r0,[r0,#0]            ;252  ; tcp_listen_pcbs
0010ca  60e8              STR      r0,[r5,#0xc]          ;252
0010cc  4893              LDR      r0,|L1.4892|
0010ce  6005              STR      r5,[r0,#0]            ;254  ; tcp_listen_pcbs
                  |L1.4304|
0010d0  bf00              NOP                            ;257
0010d2  bf00              NOP                            ;257
0010d4  4628              MOV      r0,r5                 ;258
0010d6  f7fffffe          BL       tcp_listen_input
0010da  4630              MOV      r0,r6                 ;259
0010dc  f7fffffe          BL       pbuf_free
                  |L1.4320|
0010e0  e8bd87fc          POP      {r2-r10,pc}
                  |L1.4324|
0010e4  2c00              CMP      r4,#0                 ;271
0010e6  d076              BEQ      |L1.4566|
0010e8  2000              MOVS     r0,#0                 ;280
0010ea  498f              LDR      r1,|L1.4904|
0010ec  6008              STR      r0,[r1,#0]            ;280  ; inseg
0010ee  8930              LDRH     r0,[r6,#8]            ;281
0010f0  8108              STRH     r0,[r1,#8]            ;281
0010f2  4608              MOV      r0,r1                 ;282
0010f4  6046              STR      r6,[r0,#4]            ;282  ; inseg
0010f6  488a              LDR      r0,|L1.4896|
0010f8  6800              LDR      r0,[r0,#0]            ;283  ; tcphdr
0010fa  6108              STR      r0,[r1,#0x10]         ;283  ; inseg
0010fc  2000              MOVS     r0,#0                 ;285
0010fe  498b              LDR      r1,|L1.4908|
001100  6008              STR      r0,[r1,#0]            ;285  ; recv_data
001102  498b              LDR      r1,|L1.4912|
001104  7008              STRB     r0,[r1,#0]            ;286
001106  488b              LDR      r0,|L1.4916|
001108  7800              LDRB     r0,[r0,#0]            ;288  ; flags
00110a  f0000008          AND      r0,r0,#8              ;288
00110e  b118              CBZ      r0,|L1.4376|
001110  7b70              LDRB     r0,[r6,#0xd]          ;289
001112  f0400001          ORR      r0,r0,#1              ;289
001116  7370              STRB     r0,[r6,#0xd]          ;289
                  |L1.4376|
001118  6f60              LDR      r0,[r4,#0x74]         ;293
00111a  b158              CBZ      r0,|L1.4404|
00111c  4620              MOV      r0,r4                 ;294
00111e  f7fffffe          BL       tcp_process_refused_data
001122  300a              ADDS     r0,r0,#0xa            ;294
001124  b128              CBZ      r0,|L1.4402|
001126  6f60              LDR      r0,[r4,#0x74]         ;295
001128  b120              CBZ      r0,|L1.4404|
00112a  4883              LDR      r0,|L1.4920|
00112c  8800              LDRH     r0,[r0,#0]            ;295  ; tcplen
00112e  2800              CMP      r0,#0                 ;295
001130  dd00              BLE      |L1.4404|
                  |L1.4402|
001132  e0bb              B        |L1.4780|
                  |L1.4404|
001134  4881              LDR      r0,|L1.4924|
001136  6004              STR      r4,[r0,#0]            ;303  ; tcp_input_pcb
001138  4620              MOV      r0,r4                 ;304
00113a  f7fffffe          BL       tcp_process
00113e  4680              MOV      r8,r0                 ;304
001140  f108000a          ADD      r0,r8,#0xa            ;307
001144  2800              CMP      r0,#0                 ;307
001146  d017              BEQ      |L1.4472|
001148  4879              LDR      r0,|L1.4912|
00114a  7800              LDRB     r0,[r0,#0]            ;308  ; recv_flags
00114c  f0000008          AND      r0,r0,#8              ;308
001150  b198              CBZ      r0,|L1.4474|
001152  bf00              NOP                            ;313
001154  f8d40088          LDR      r0,[r4,#0x88]         ;313
001158  b128              CBZ      r0,|L1.4454|
00115a  f06f010a          MVN      r1,#0xa               ;313
00115e  f8d42088          LDR      r2,[r4,#0x88]         ;313
001162  6920              LDR      r0,[r4,#0x10]         ;313
001164  4790              BLX      r2                    ;313
                  |L1.4454|
001166  bf00              NOP                            ;313
001168  4621              MOV      r1,r4                 ;314
00116a  4875              LDR      r0,|L1.4928|
00116c  f7fffffe          BL       tcp_pcb_remove
001170  4621              MOV      r1,r4                 ;315
001172  2002              MOVS     r0,#2                 ;315
001174  f7fffffe          BL       memp_free
                  |L1.4472|
001178  e097              B        |L1.4778|
                  |L1.4474|
00117a  486d              LDR      r0,|L1.4912|
00117c  7800              LDRB     r0,[r0,#0]            ;316  ; recv_flags
00117e  f0000010          AND      r0,r0,#0x10           ;316
001182  b1b8              CBZ      r0,|L1.4532|
001184  7fa0              LDRB     r0,[r4,#0x1e]         ;319
001186  f0000010          AND      r0,r0,#0x10           ;319
00118a  b950              CBNZ     r0,|L1.4514|
00118c  bf00              NOP                            ;323
00118e  f8d40088          LDR      r0,[r4,#0x88]         ;323
001192  b128              CBZ      r0,|L1.4512|
001194  f06f010b          MVN      r1,#0xb               ;323
001198  f8d42088          LDR      r2,[r4,#0x88]         ;323
00119c  6920              LDR      r0,[r4,#0x10]         ;323
00119e  4790              BLX      r2                    ;323
                  |L1.4512|
0011a0  bf00              NOP                            ;323
                  |L1.4514|
0011a2  4621              MOV      r1,r4                 ;325
0011a4  4866              LDR      r0,|L1.4928|
0011a6  f7fffffe          BL       tcp_pcb_remove
0011aa  4621              MOV      r1,r4                 ;326
0011ac  2002              MOVS     r0,#2                 ;326
0011ae  f7fffffe          BL       memp_free
0011b2  e07a              B        |L1.4778|
                  |L1.4532|
0011b4  f04f0800          MOV      r8,#0                 ;328
0011b8  f8b40064          LDRH     r0,[r4,#0x64]         ;332
0011bc  2800              CMP      r0,#0                 ;332
0011be  dd12              BLE      |L1.4582|
0011c0  bf00              NOP                            ;333
0011c2  6fa0              LDR      r0,[r4,#0x78]         ;333
0011c4  b140              CBZ      r0,|L1.4568|
0011c6  f8b42064          LDRH     r2,[r4,#0x64]         ;333
0011ca  4621              MOV      r1,r4                 ;333
0011cc  6fa3              LDR      r3,[r4,#0x78]         ;333
0011ce  6920              LDR      r0,[r4,#0x10]         ;333
0011d0  4798              BLX      r3                    ;333
0011d2  4680              MOV      r8,r0                 ;333
0011d4  e002              B        |L1.4572|
                  |L1.4566|
0011d6  e079              B        |L1.4812|
                  |L1.4568|
0011d8  f04f0800          MOV      r8,#0                 ;333
                  |L1.4572|
0011dc  bf00              NOP                            ;333
0011de  f108000a          ADD      r0,r8,#0xa            ;334
0011e2  b900              CBNZ     r0,|L1.4582|
0011e4  e062              B        |L1.4780|
                  |L1.4582|
0011e6  4851              LDR      r0,|L1.4908|
0011e8  6800              LDR      r0,[r0,#0]            ;339  ; recv_data
0011ea  b378              CBZ      r0,|L1.4684|
0011ec  bf00              NOP                            ;340
0011ee  bf00              NOP                            ;340
0011f0  7fa0              LDRB     r0,[r4,#0x1e]         ;341
0011f2  f0000010          AND      r0,r0,#0x10           ;341
0011f6  b138              CBZ      r0,|L1.4616|
0011f8  484c              LDR      r0,|L1.4908|
0011fa  6800              LDR      r0,[r0,#0]            ;344  ; recv_data
0011fc  f7fffffe          BL       pbuf_free
001200  4620              MOV      r0,r4                 ;345
001202  f7fffffe          BL       tcp_abort
001206  e051              B        |L1.4780|
                  |L1.4616|
001208  bf00              NOP                            ;350
00120a  6fe0              LDR      r0,[r4,#0x7c]         ;350
00120c  b148              CBZ      r0,|L1.4642|
00120e  2300              MOVS     r3,#0                 ;350
001210  4946              LDR      r1,|L1.4908|
001212  f8d4c07c          LDR      r12,[r4,#0x7c]        ;350
001216  6920              LDR      r0,[r4,#0x10]         ;350
001218  680a              LDR      r2,[r1,#0]            ;350  ; recv_data
00121a  4621              MOV      r1,r4                 ;350
00121c  47e0              BLX      r12                   ;350
00121e  4680              MOV      r8,r0                 ;350
001220  e007              B        |L1.4658|
                  |L1.4642|
001222  2300              MOVS     r3,#0                 ;350
001224  4841              LDR      r0,|L1.4908|
001226  4621              MOV      r1,r4                 ;350
001228  6802              LDR      r2,[r0,#0]            ;350  ; recv_data
00122a  4618              MOV      r0,r3                 ;350
00122c  f7fffffe          BL       tcp_recv_null
001230  4680              MOV      r8,r0                 ;350
                  |L1.4658|
001232  bf00              NOP                            ;350
001234  f108000a          ADD      r0,r8,#0xa            ;351
001238  b900              CBNZ     r0,|L1.4668|
00123a  e037              B        |L1.4780|
                  |L1.4668|
00123c  f1b80f00          CMP      r8,#0                 ;356
001240  d004              BEQ      |L1.4684|
001242  483a              LDR      r0,|L1.4908|
001244  6800              LDR      r0,[r0,#0]            ;357  ; recv_data
001246  6760              STR      r0,[r4,#0x74]         ;357
001248  bf00              NOP                            ;358
00124a  bf00              NOP                            ;358
                  |L1.4684|
00124c  4838              LDR      r0,|L1.4912|
00124e  7800              LDRB     r0,[r0,#0]            ;364  ; recv_flags
001250  f0000020          AND      r0,r0,#0x20           ;364
001254  b318              CBZ      r0,|L1.4766|
001256  6f60              LDR      r0,[r4,#0x74]         ;365
001258  b130              CBZ      r0,|L1.4712|
00125a  6f60              LDR      r0,[r4,#0x74]         ;367
00125c  7b40              LDRB     r0,[r0,#0xd]          ;367
00125e  f0400020          ORR      r0,r0,#0x20           ;367
001262  6f61              LDR      r1,[r4,#0x74]         ;367
001264  7348              STRB     r0,[r1,#0xd]          ;367
001266  e01a              B        |L1.4766|
                  |L1.4712|
001268  8da0              LDRH     r0,[r4,#0x2c]         ;371
00126a  f24161d0          MOV      r1,#0x16d0            ;371
00126e  4288              CMP      r0,r1                 ;371
001270  d002              BEQ      |L1.4728|
001272  8da0              LDRH     r0,[r4,#0x2c]         ;372
001274  1c40              ADDS     r0,r0,#1              ;372
001276  85a0              STRH     r0,[r4,#0x2c]         ;372
                  |L1.4728|
001278  bf00              NOP                            ;374
00127a  6fe0              LDR      r0,[r4,#0x7c]         ;374
00127c  b140              CBZ      r0,|L1.4752|
00127e  2300              MOVS     r3,#0                 ;374
001280  461a              MOV      r2,r3                 ;374
001282  4621              MOV      r1,r4                 ;374
001284  f8d4c07c          LDR      r12,[r4,#0x7c]        ;374
001288  6920              LDR      r0,[r4,#0x10]         ;374
00128a  47e0              BLX      r12                   ;374
00128c  4680              MOV      r8,r0                 ;374
00128e  e001              B        |L1.4756|
                  |L1.4752|
001290  f04f0800          MOV      r8,#0                 ;374
                  |L1.4756|
001294  bf00              NOP                            ;374
001296  f108000a          ADD      r0,r8,#0xa            ;375
00129a  b900              CBNZ     r0,|L1.4766|
00129c  e006              B        |L1.4780|
                  |L1.4766|
00129e  2000              MOVS     r0,#0                 ;381
0012a0  4926              LDR      r1,|L1.4924|
0012a2  6008              STR      r0,[r1,#0]            ;381  ; tcp_input_pcb
0012a4  4620              MOV      r0,r4                 ;383
0012a6  f7fffffe          BL       tcp_output
                  |L1.4778|
0012aa  bf00              NOP                            ;393
                  |L1.4780|
0012ac  2000              MOVS     r0,#0                 ;394
0012ae  4923              LDR      r1,|L1.4924|
0012b0  6008              STR      r0,[r1,#0]            ;394  ; tcp_input_pcb
0012b2  491e              LDR      r1,|L1.4908|
0012b4  6008              STR      r0,[r1,#0]            ;395  ; recv_data
0012b6  481c              LDR      r0,|L1.4904|
0012b8  6840              LDR      r0,[r0,#4]            ;398  ; inseg
0012ba  b338              CBZ      r0,|L1.4876|
0012bc  491a              LDR      r1,|L1.4904|
0012be  6848              LDR      r0,[r1,#4]            ;400  ; inseg
0012c0  f7fffffe          BL       pbuf_free
0012c4  2000              MOVS     r0,#0                 ;401
0012c6  4918              LDR      r1,|L1.4904|
0012c8  6048              STR      r0,[r1,#4]            ;401  ; inseg
0012ca  e01f              B        |L1.4876|
                  |L1.4812|
0012cc  bf00              NOP                            ;407
0012ce  bf00              NOP                            ;407
0012d0  4913              LDR      r1,|L1.4896|
0012d2  6809              LDR      r1,[r1,#0]            ;408  ; tcphdr
0012d4  8988              LDRH     r0,[r1,#0xc]          ;408
0012d6  f7fffffe          BL       lwip_ntohs
0012da  f0000004          AND      r0,r0,#4              ;408
0012de  b990              CBNZ     r0,|L1.4870|
0012e0  480f              LDR      r0,|L1.4896|
0012e2  6800              LDR      r0,[r0,#0]            ;411  ; tcphdr
0012e4  8800              LDRH     r0,[r0,#0]            ;411
0012e6  490e              LDR      r1,|L1.4896|
0012e8  6809              LDR      r1,[r1,#0]            ;411  ; tcphdr
0012ea  8849              LDRH     r1,[r1,#2]            ;411
0012ec  e9cd1000          STRD     r1,r0,[sp,#0]         ;411
0012f0  4814              LDR      r0,|L1.4932|
0012f2  6800              LDR      r0,[r0,#0]            ;411  ; seqno
0012f4  4a10              LDR      r2,|L1.4920|
0012f6  8812              LDRH     r2,[r2,#0]            ;411  ; tcplen
0012f8  1881              ADDS     r1,r0,r2              ;411
0012fa  4b13              LDR      r3,|L1.4936|
0012fc  4a09              LDR      r2,|L1.4900|
0012fe  4813              LDR      r0,|L1.4940|
001300  6800              LDR      r0,[r0,#0]            ;411  ; ackno
001302  f7fffffe          BL       tcp_rst
                  |L1.4870|
001306  4630              MOV      r0,r6                 ;415
001308  f7fffffe          BL       pbuf_free
                  |L1.4876|
00130c  bf00              NOP                            ;418
00130e  bf00              NOP                            ;418
001310  e6e6              B        |L1.4320|
                  |L1.4882|
001312  4630              MOV      r0,r6                 ;424
001314  f7fffffe          BL       pbuf_free
001318  bf00              NOP      
00131a  e6e1              B        |L1.4320|
;;;426    
                          ENDP

                  |L1.4892|
                          DCD      tcp_listen_pcbs
                  |L1.4896|
                          DCD      tcphdr
                  |L1.4900|
                          DCD      current_iphdr_dest
                  |L1.4904|
                          DCD      inseg
                  |L1.4908|
                          DCD      recv_data
                  |L1.4912|
                          DCD      recv_flags
                  |L1.4916|
                          DCD      flags
                  |L1.4920|
                          DCD      tcplen
                  |L1.4924|
                          DCD      tcp_input_pcb
                  |L1.4928|
                          DCD      tcp_active_pcbs
                  |L1.4932|
                          DCD      seqno
                  |L1.4936|
                          DCD      current_iphdr_src
                  |L1.4940|
                          DCD      ackno

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  flags
000010  0000              DCB      0x00,0x00
                  tcplen
000012  0000              DCB      0x00,0x00
                  recv_flags
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
