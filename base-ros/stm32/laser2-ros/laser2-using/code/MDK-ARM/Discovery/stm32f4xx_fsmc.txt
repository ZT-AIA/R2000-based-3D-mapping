; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4xx_fsmc.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4xx_fsmc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4xx_fsmc.crf ..\..\libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;120      */
;;;121    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  b930              CBNZ     r0,|L1.16|
;;;122    {
;;;123      /* Check the parameter */
;;;124      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;125      
;;;126      /* FSMC_Bank1_NORSRAM1 */
;;;127      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;128      {
;;;129        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
000002  f24302db          MOV      r2,#0x30db
000006  0081              LSLS     r1,r0,#2
000008  f1a141c0          SUB      r1,r1,#0x60000000
00000c  600a              STR      r2,[r1,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;130      }
;;;131      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;132      else
;;;133      {   
;;;134        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000010  f24302d2          MOV      r2,#0x30d2
000014  0081              LSLS     r1,r0,#2
000016  f1a141c0          SUB      r1,r1,#0x60000000
00001a  600a              STR      r2,[r1,#0]
                  |L1.28|
;;;135      }
;;;136      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4270          MVN      r2,#0xf0000000
000020  1c41              ADDS     r1,r0,#1
000022  0089              LSLS     r1,r1,#2
000024  f1a141c0          SUB      r1,r1,#0x60000000
000028  600a              STR      r2,[r1,#0]
;;;137      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00002a  0081              LSLS     r1,r0,#2
00002c  f1a141c0          SUB      r1,r1,#0x60000000
000030  f8c12104          STR      r2,[r1,#0x104]
;;;138    }
000034  4770              BX       lr
;;;139    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;147      */
;;;148    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000036  e9d01201          LDRD     r1,r2,[r0,#4]
;;;149    { 
;;;150      /* Check the parameters */
;;;151      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;152      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;153      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;154      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;155      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;156      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;157      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;158      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;159      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;160      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;161      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;162      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;163      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;164      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;165      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;166      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;167      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;168      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;169      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;170      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;171      
;;;172      /* Bank1 NOR/SRAM control register configuration */ 
;;;173      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
00003a  4311              ORRS     r1,r1,r2
00003c  68c2              LDR      r2,[r0,#0xc]
00003e  4311              ORRS     r1,r1,r2
000040  6902              LDR      r2,[r0,#0x10]
000042  4311              ORRS     r1,r1,r2
000044  6942              LDR      r2,[r0,#0x14]
000046  4311              ORRS     r1,r1,r2
000048  6982              LDR      r2,[r0,#0x18]
00004a  4311              ORRS     r1,r1,r2
00004c  69c2              LDR      r2,[r0,#0x1c]
00004e  4311              ORRS     r1,r1,r2
000050  6a02              LDR      r2,[r0,#0x20]
000052  4311              ORRS     r1,r1,r2
000054  6a42              LDR      r2,[r0,#0x24]
000056  4311              ORRS     r1,r1,r2
000058  6a82              LDR      r2,[r0,#0x28]
00005a  4311              ORRS     r1,r1,r2
00005c  6ac2              LDR      r2,[r0,#0x2c]
00005e  4311              ORRS     r1,r1,r2
000060  6b02              LDR      r2,[r0,#0x30]
000062  4311              ORRS     r1,r1,r2
000064  6802              LDR      r2,[r0,#0]
000066  0092              LSLS     r2,r2,#2
000068  f1a242c0          SUB      r2,r2,#0x60000000
00006c  6011              STR      r1,[r2,#0]
;;;174                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;175                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;176                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;177                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;178                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;179                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;180                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;181                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;182                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;183                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;184                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;185                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;186      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
00006e  6881              LDR      r1,[r0,#8]
000070  2908              CMP      r1,#8
000072  d10b              BNE      |L1.140|
;;;187      {
;;;188        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000074  6801              LDR      r1,[r0,#0]
000076  0089              LSLS     r1,r1,#2
000078  f1a141c0          SUB      r1,r1,#0x60000000
00007c  6809              LDR      r1,[r1,#0]
00007e  f0410240          ORR      r2,r1,#0x40
000082  6801              LDR      r1,[r0,#0]
000084  0089              LSLS     r1,r1,#2
000086  f1a141c0          SUB      r1,r1,#0x60000000
00008a  600a              STR      r2,[r1,#0]
                  |L1.140|
;;;189      }
;;;190      /* Bank1 NOR/SRAM timing register configuration */
;;;191      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
00008c  6b41              LDR      r1,[r0,#0x34]
00008e  6809              LDR      r1,[r1,#0]
000090  6b42              LDR      r2,[r0,#0x34]
000092  6852              LDR      r2,[r2,#4]
000094  ea411102          ORR      r1,r1,r2,LSL #4
000098  6b42              LDR      r2,[r0,#0x34]
00009a  6892              LDR      r2,[r2,#8]
00009c  ea412102          ORR      r1,r1,r2,LSL #8
0000a0  6b42              LDR      r2,[r0,#0x34]
0000a2  8992              LDRH     r2,[r2,#0xc]
0000a4  ea414102          ORR      r1,r1,r2,LSL #16
0000a8  6b42              LDR      r2,[r0,#0x34]
0000aa  8a12              LDRH     r2,[r2,#0x10]
0000ac  ea415102          ORR      r1,r1,r2,LSL #20
0000b0  6b42              LDR      r2,[r0,#0x34]
0000b2  7d12              LDRB     r2,[r2,#0x14]
0000b4  ea416102          ORR      r1,r1,r2,LSL #24
0000b8  6b42              LDR      r2,[r0,#0x34]
0000ba  6992              LDR      r2,[r2,#0x18]
0000bc  4311              ORRS     r1,r1,r2
0000be  6802              LDR      r2,[r0,#0]
0000c0  1c52              ADDS     r2,r2,#1
0000c2  0092              LSLS     r2,r2,#2
0000c4  f1a242c0          SUB      r2,r2,#0x60000000
0000c8  6011              STR      r1,[r2,#0]
;;;192                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;193                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;194                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;195                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;196                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;197                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;198                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;199                
;;;200        
;;;201      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;202      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000ca  6ac1              LDR      r1,[r0,#0x2c]
0000cc  f5b14f80          CMP      r1,#0x4000
0000d0  d11b              BNE      |L1.266|
;;;203      {
;;;204        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;205        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;206        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;207        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;208        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;209        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;210        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
0000d2  6b81              LDR      r1,[r0,#0x38]
0000d4  6809              LDR      r1,[r1,#0]
0000d6  6b82              LDR      r2,[r0,#0x38]
0000d8  6852              LDR      r2,[r2,#4]
0000da  ea411102          ORR      r1,r1,r2,LSL #4
0000de  6b82              LDR      r2,[r0,#0x38]
0000e0  6892              LDR      r2,[r2,#8]
0000e2  ea412102          ORR      r1,r1,r2,LSL #8
0000e6  6b82              LDR      r2,[r0,#0x38]
0000e8  8a12              LDRH     r2,[r2,#0x10]
0000ea  ea415102          ORR      r1,r1,r2,LSL #20
0000ee  6b82              LDR      r2,[r0,#0x38]
0000f0  7d12              LDRB     r2,[r2,#0x14]
0000f2  ea416102          ORR      r1,r1,r2,LSL #24
0000f6  6b82              LDR      r2,[r0,#0x38]
0000f8  6992              LDR      r2,[r2,#0x18]
0000fa  4311              ORRS     r1,r1,r2
0000fc  6802              LDR      r2,[r0,#0]
0000fe  0092              LSLS     r2,r2,#2
000100  f1a242c0          SUB      r2,r2,#0x60000000
000104  f8c21104          STR      r1,[r2,#0x104]
000108  e007              B        |L1.282|
                  |L1.266|
;;;211                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;212                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;213                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;214                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;215                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;216                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;217      }
;;;218      else
;;;219      {
;;;220        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
00010a  f06f4270          MVN      r2,#0xf0000000
00010e  6801              LDR      r1,[r0,#0]
000110  0089              LSLS     r1,r1,#2
000112  f1a141c0          SUB      r1,r1,#0x60000000
000116  f8c12104          STR      r2,[r1,#0x104]
                  |L1.282|
;;;221      }
;;;222    }
00011a  4770              BX       lr
;;;223    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;229      */
;;;230    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
00011c  2100              MOVS     r1,#0
;;;231    {  
;;;232      /* Reset NOR/SRAM Init structure parameters values */
;;;233      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
00011e  6001              STR      r1,[r0,#0]
;;;234      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000120  2102              MOVS     r1,#2
000122  6041              STR      r1,[r0,#4]
;;;235      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
000124  2100              MOVS     r1,#0
000126  6081              STR      r1,[r0,#8]
;;;236      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000128  60c1              STR      r1,[r0,#0xc]
;;;237      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00012a  6101              STR      r1,[r0,#0x10]
;;;238      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00012c  6141              STR      r1,[r0,#0x14]
;;;239      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00012e  6181              STR      r1,[r0,#0x18]
;;;240      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000130  61c1              STR      r1,[r0,#0x1c]
;;;241      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000132  6201              STR      r1,[r0,#0x20]
;;;242      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000134  f44f5180          MOV      r1,#0x1000
000138  6241              STR      r1,[r0,#0x24]
;;;243      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00013a  0049              LSLS     r1,r1,#1
00013c  6281              STR      r1,[r0,#0x28]
;;;244      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
00013e  2100              MOVS     r1,#0
000140  62c1              STR      r1,[r0,#0x2c]
;;;245      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000142  6301              STR      r1,[r0,#0x30]
;;;246      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000144  210f              MOVS     r1,#0xf
000146  6b42              LDR      r2,[r0,#0x34]
000148  6011              STR      r1,[r2,#0]
;;;247      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
00014a  6b42              LDR      r2,[r0,#0x34]
00014c  6051              STR      r1,[r2,#4]
;;;248      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00014e  21ff              MOVS     r1,#0xff
000150  6b42              LDR      r2,[r0,#0x34]
000152  6091              STR      r1,[r2,#8]
;;;249      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000154  210f              MOVS     r1,#0xf
000156  6b42              LDR      r2,[r0,#0x34]
000158  60d1              STR      r1,[r2,#0xc]
;;;250      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
00015a  6b42              LDR      r2,[r0,#0x34]
00015c  6111              STR      r1,[r2,#0x10]
;;;251      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
00015e  6b42              LDR      r2,[r0,#0x34]
000160  6151              STR      r1,[r2,#0x14]
;;;252      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
000162  2100              MOVS     r1,#0
000164  6b42              LDR      r2,[r0,#0x34]
000166  6191              STR      r1,[r2,#0x18]
;;;253      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000168  210f              MOVS     r1,#0xf
00016a  6b82              LDR      r2,[r0,#0x38]
00016c  6011              STR      r1,[r2,#0]
;;;254      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
00016e  6b82              LDR      r2,[r0,#0x38]
000170  6051              STR      r1,[r2,#4]
;;;255      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000172  21ff              MOVS     r1,#0xff
000174  6b82              LDR      r2,[r0,#0x38]
000176  6091              STR      r1,[r2,#8]
;;;256      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000178  210f              MOVS     r1,#0xf
00017a  6b82              LDR      r2,[r0,#0x38]
00017c  60d1              STR      r1,[r2,#0xc]
;;;257      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
00017e  6b82              LDR      r2,[r0,#0x38]
000180  6111              STR      r1,[r2,#0x10]
;;;258      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000182  6b82              LDR      r2,[r0,#0x38]
000184  6151              STR      r1,[r2,#0x14]
;;;259      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
000186  2100              MOVS     r1,#0
000188  6b82              LDR      r2,[r0,#0x38]
00018a  6191              STR      r1,[r2,#0x18]
;;;260    }
00018c  4770              BX       lr
;;;261    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;272      */
;;;273    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
00018e  b151              CBZ      r1,|L1.422|
;;;274    {
;;;275      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;276      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;277      
;;;278      if (NewState != DISABLE)
;;;279      {
;;;280        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;281        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
000190  0082              LSLS     r2,r0,#2
000192  f1a242c0          SUB      r2,r2,#0x60000000
000196  6812              LDR      r2,[r2,#0]
000198  f0420301          ORR      r3,r2,#1
00019c  0082              LSLS     r2,r0,#2
00019e  f1a242c0          SUB      r2,r2,#0x60000000
0001a2  6013              STR      r3,[r2,#0]
0001a4  e009              B        |L1.442|
                  |L1.422|
;;;282      }
;;;283      else
;;;284      {
;;;285        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;286        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
0001a6  0082              LSLS     r2,r0,#2
0001a8  f1a242c0          SUB      r2,r2,#0x60000000
0001ac  6812              LDR      r2,[r2,#0]
0001ae  4bf9              LDR      r3,|L1.1428|
0001b0  401a              ANDS     r2,r2,r3
0001b2  0083              LSLS     r3,r0,#2
0001b4  f1a343c0          SUB      r3,r3,#0x60000000
0001b8  601a              STR      r2,[r3,#0]
                  |L1.442|
;;;287      }
;;;288    }
0001ba  4770              BX       lr
;;;289    /**
                          ENDP

                  FSMC_NANDDeInit PROC
;;;343      */
;;;344    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
0001bc  2810              CMP      r0,#0x10
;;;345    {
;;;346      /* Check the parameter */
;;;347      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;348      
;;;349      if(FSMC_Bank == FSMC_Bank2_NAND)
0001be  d10a              BNE      |L1.470|
;;;350      {
;;;351        /* Set the FSMC_Bank2 registers to their reset values */
;;;352        FSMC_Bank2->PCR2 = 0x00000018;
0001c0  2118              MOVS     r1,#0x18
0001c2  f04f4220          MOV      r2,#0xa0000000
0001c6  6611              STR      r1,[r2,#0x60]
;;;353        FSMC_Bank2->SR2 = 0x00000040;
0001c8  2140              MOVS     r1,#0x40
0001ca  6651              STR      r1,[r2,#0x64]
;;;354        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
0001cc  f04f31fc          MOV      r1,#0xfcfcfcfc
0001d0  6691              STR      r1,[r2,#0x68]
;;;355        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
0001d2  66d1              STR      r1,[r2,#0x6c]
0001d4  e010              B        |L1.504|
                  |L1.470|
;;;356      }
;;;357      /* FSMC_Bank3_NAND */  
;;;358      else
;;;359      {
;;;360        /* Set the FSMC_Bank3 registers to their reset values */
;;;361        FSMC_Bank3->PCR3 = 0x00000018;
0001d6  2118              MOVS     r1,#0x18
0001d8  4aef              LDR      r2,|L1.1432|
0001da  6011              STR      r1,[r2,#0]
;;;362        FSMC_Bank3->SR3 = 0x00000040;
0001dc  2140              MOVS     r1,#0x40
0001de  f04f4220          MOV      r2,#0xa0000000
0001e2  f8c21084          STR      r1,[r2,#0x84]
;;;363        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
0001e6  f04f31fc          MOV      r1,#0xfcfcfcfc
0001ea  4aeb              LDR      r2,|L1.1432|
0001ec  3208              ADDS     r2,r2,#8
0001ee  6011              STR      r1,[r2,#0]
;;;364        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
0001f0  f04f4220          MOV      r2,#0xa0000000
0001f4  f8c2108c          STR      r1,[r2,#0x8c]
                  |L1.504|
;;;365      }  
;;;366    }
0001f8  4770              BX       lr
;;;367    
                          ENDP

                  FSMC_NANDInit PROC
;;;374      */
;;;375    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
0001fa  b530              PUSH     {r4,r5,lr}
;;;376    {
;;;377      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
0001fc  2100              MOVS     r1,#0
0001fe  2200              MOVS     r2,#0
000200  2300              MOVS     r3,#0
;;;378        
;;;379      /* Check the parameters */
;;;380      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;381      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;382      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;383      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;384      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;385      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;386      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;387      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;388      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;389      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;390      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;391      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;392      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;393      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;394      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;395      
;;;396      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;397      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000202  6844              LDR      r4,[r0,#4]
000204  f0440408          ORR      r4,r4,#8
000208  6885              LDR      r5,[r0,#8]
00020a  432c              ORRS     r4,r4,r5
00020c  68c5              LDR      r5,[r0,#0xc]
00020e  432c              ORRS     r4,r4,r5
000210  6905              LDR      r5,[r0,#0x10]
000212  432c              ORRS     r4,r4,r5
000214  6945              LDR      r5,[r0,#0x14]
000216  ea442445          ORR      r4,r4,r5,LSL #9
00021a  6985              LDR      r5,[r0,#0x18]
00021c  ea443145          ORR      r1,r4,r5,LSL #13
;;;398                PCR_MEMORYTYPE_NAND |
;;;399                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;400                FSMC_NANDInitStruct->FSMC_ECC |
;;;401                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;402                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;403                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;404                
;;;405      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;406      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000220  69c4              LDR      r4,[r0,#0x1c]
000222  6824              LDR      r4,[r4,#0]
000224  69c5              LDR      r5,[r0,#0x1c]
000226  686d              LDR      r5,[r5,#4]
000228  ea442405          ORR      r4,r4,r5,LSL #8
00022c  69c5              LDR      r5,[r0,#0x1c]
00022e  892d              LDRH     r5,[r5,#8]
000230  ea444405          ORR      r4,r4,r5,LSL #16
000234  69c5              LDR      r5,[r0,#0x1c]
000236  7b2d              LDRB     r5,[r5,#0xc]
000238  ea446205          ORR      r2,r4,r5,LSL #24
;;;407                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;408                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;409                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;410                
;;;411      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;412      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
00023c  6a04              LDR      r4,[r0,#0x20]
00023e  6824              LDR      r4,[r4,#0]
000240  6a05              LDR      r5,[r0,#0x20]
000242  686d              LDR      r5,[r5,#4]
000244  ea442405          ORR      r4,r4,r5,LSL #8
000248  6a05              LDR      r5,[r0,#0x20]
00024a  892d              LDRH     r5,[r5,#8]
00024c  ea444405          ORR      r4,r4,r5,LSL #16
000250  6a05              LDR      r5,[r0,#0x20]
000252  7b2d              LDRB     r5,[r5,#0xc]
000254  ea446305          ORR      r3,r4,r5,LSL #24
;;;413                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;414                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;415                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;416      
;;;417      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
000258  6804              LDR      r4,[r0,#0]
00025a  2c10              CMP      r4,#0x10
00025c  d105              BNE      |L1.618|
;;;418      {
;;;419        /* FSMC_Bank2_NAND registers configuration */
;;;420        FSMC_Bank2->PCR2 = tmppcr;
00025e  f04f4420          MOV      r4,#0xa0000000
000262  6621              STR      r1,[r4,#0x60]
;;;421        FSMC_Bank2->PMEM2 = tmppmem;
000264  66a2              STR      r2,[r4,#0x68]
;;;422        FSMC_Bank2->PATT2 = tmppatt;
000266  66e3              STR      r3,[r4,#0x6c]
000268  e008              B        |L1.636|
                  |L1.618|
;;;423      }
;;;424      else
;;;425      {
;;;426        /* FSMC_Bank3_NAND registers configuration */
;;;427        FSMC_Bank3->PCR3 = tmppcr;
00026a  4ccb              LDR      r4,|L1.1432|
00026c  6021              STR      r1,[r4,#0]
;;;428        FSMC_Bank3->PMEM3 = tmppmem;
00026e  f04f4420          MOV      r4,#0xa0000000
000272  f8c42088          STR      r2,[r4,#0x88]
;;;429        FSMC_Bank3->PATT3 = tmppatt;
000276  4cc8              LDR      r4,|L1.1432|
000278  340c              ADDS     r4,r4,#0xc
00027a  6023              STR      r3,[r4,#0]
                  |L1.636|
;;;430      }
;;;431    }
00027c  bd30              POP      {r4,r5,pc}
;;;432    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;439      */
;;;440    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
00027e  2110              MOVS     r1,#0x10
;;;441    { 
;;;442      /* Reset NAND Init structure parameters values */
;;;443      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
000280  6001              STR      r1,[r0,#0]
;;;444      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000282  2100              MOVS     r1,#0
000284  6041              STR      r1,[r0,#4]
;;;445      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000286  6081              STR      r1,[r0,#8]
;;;446      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000288  60c1              STR      r1,[r0,#0xc]
;;;447      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00028a  6101              STR      r1,[r0,#0x10]
;;;448      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00028c  6141              STR      r1,[r0,#0x14]
;;;449      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00028e  6181              STR      r1,[r0,#0x18]
;;;450      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000290  21fc              MOVS     r1,#0xfc
000292  69c2              LDR      r2,[r0,#0x1c]
000294  6011              STR      r1,[r2,#0]
;;;451      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000296  69c2              LDR      r2,[r0,#0x1c]
000298  6051              STR      r1,[r2,#4]
;;;452      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00029a  69c2              LDR      r2,[r0,#0x1c]
00029c  6091              STR      r1,[r2,#8]
;;;453      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00029e  69c2              LDR      r2,[r0,#0x1c]
0002a0  60d1              STR      r1,[r2,#0xc]
;;;454      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002a2  6a02              LDR      r2,[r0,#0x20]
0002a4  6011              STR      r1,[r2,#0]
;;;455      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002a6  6a02              LDR      r2,[r0,#0x20]
0002a8  6051              STR      r1,[r2,#4]
;;;456      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002aa  6a02              LDR      r2,[r0,#0x20]
0002ac  6091              STR      r1,[r2,#8]
;;;457      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
0002ae  6a02              LDR      r2,[r0,#0x20]
0002b0  60d1              STR      r1,[r2,#0xc]
;;;458    }
0002b2  4770              BX       lr
;;;459    
                          ENDP

                  FSMC_NANDCmd PROC
;;;468      */
;;;469    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0002b4  b199              CBZ      r1,|L1.734|
;;;470    {
;;;471      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473      
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;477        if(FSMC_Bank == FSMC_Bank2_NAND)
0002b6  2810              CMP      r0,#0x10
0002b8  d108              BNE      |L1.716|
;;;478        {
;;;479          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
0002ba  f04f4220          MOV      r2,#0xa0000000
0002be  6e12              LDR      r2,[r2,#0x60]
0002c0  f0420204          ORR      r2,r2,#4
0002c4  f04f4320          MOV      r3,#0xa0000000
0002c8  661a              STR      r2,[r3,#0x60]
0002ca  e01d              B        |L1.776|
                  |L1.716|
;;;480        }
;;;481        else
;;;482        {
;;;483          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
0002cc  4ab2              LDR      r2,|L1.1432|
0002ce  6812              LDR      r2,[r2,#0]
0002d0  f0420204          ORR      r2,r2,#4
0002d4  f04f4320          MOV      r3,#0xa0000000
0002d8  f8c32080          STR      r2,[r3,#0x80]
0002dc  e014              B        |L1.776|
                  |L1.734|
;;;484        }
;;;485      }
;;;486      else
;;;487      {
;;;488        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;489        if(FSMC_Bank == FSMC_Bank2_NAND)
0002de  2810              CMP      r0,#0x10
0002e0  d109              BNE      |L1.758|
;;;490        {
;;;491          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
0002e2  f04f4220          MOV      r2,#0xa0000000
0002e6  6e12              LDR      r2,[r2,#0x60]
0002e8  4baa              LDR      r3,|L1.1428|
0002ea  1edb              SUBS     r3,r3,#3
0002ec  401a              ANDS     r2,r2,r3
0002ee  f04f4320          MOV      r3,#0xa0000000
0002f2  661a              STR      r2,[r3,#0x60]
0002f4  e008              B        |L1.776|
                  |L1.758|
;;;492        }
;;;493        else
;;;494        {
;;;495          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
0002f6  4aa8              LDR      r2,|L1.1432|
0002f8  6812              LDR      r2,[r2,#0]
0002fa  4ba6              LDR      r3,|L1.1428|
0002fc  1edb              SUBS     r3,r3,#3
0002fe  401a              ANDS     r2,r2,r3
000300  f04f4320          MOV      r3,#0xa0000000
000304  f8c32080          STR      r2,[r3,#0x80]
                  |L1.776|
;;;496        }
;;;497      }
;;;498    }
000308  4770              BX       lr
;;;499    /**
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;508      */
;;;509    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
00030a  b199              CBZ      r1,|L1.820|
;;;510    {
;;;511      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;512      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;513      
;;;514      if (NewState != DISABLE)
;;;515      {
;;;516        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;517        if(FSMC_Bank == FSMC_Bank2_NAND)
00030c  2810              CMP      r0,#0x10
00030e  d108              BNE      |L1.802|
;;;518        {
;;;519          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
000310  f04f4220          MOV      r2,#0xa0000000
000314  6e12              LDR      r2,[r2,#0x60]
000316  f0420240          ORR      r2,r2,#0x40
00031a  f04f4320          MOV      r3,#0xa0000000
00031e  661a              STR      r2,[r3,#0x60]
000320  e01d              B        |L1.862|
                  |L1.802|
;;;520        }
;;;521        else
;;;522        {
;;;523          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
000322  4a9d              LDR      r2,|L1.1432|
000324  6812              LDR      r2,[r2,#0]
000326  f0420240          ORR      r2,r2,#0x40
00032a  f04f4320          MOV      r3,#0xa0000000
00032e  f8c32080          STR      r2,[r3,#0x80]
000332  e014              B        |L1.862|
                  |L1.820|
;;;524        }
;;;525      }
;;;526      else
;;;527      {
;;;528        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;529        if(FSMC_Bank == FSMC_Bank2_NAND)
000334  2810              CMP      r0,#0x10
000336  d109              BNE      |L1.844|
;;;530        {
;;;531          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
000338  f04f4220          MOV      r2,#0xa0000000
00033c  6e12              LDR      r2,[r2,#0x60]
00033e  4b95              LDR      r3,|L1.1428|
000340  3b3f              SUBS     r3,r3,#0x3f
000342  401a              ANDS     r2,r2,r3
000344  f04f4320          MOV      r3,#0xa0000000
000348  661a              STR      r2,[r3,#0x60]
00034a  e008              B        |L1.862|
                  |L1.844|
;;;532        }
;;;533        else
;;;534        {
;;;535          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
00034c  4a92              LDR      r2,|L1.1432|
00034e  6812              LDR      r2,[r2,#0]
000350  4b90              LDR      r3,|L1.1428|
000352  3b3f              SUBS     r3,r3,#0x3f
000354  401a              ANDS     r2,r2,r3
000356  f04f4320          MOV      r3,#0xa0000000
00035a  f8c32080          STR      r2,[r3,#0x80]
                  |L1.862|
;;;536        }
;;;537      }
;;;538    }
00035e  4770              BX       lr
;;;539    
                          ENDP

                  FSMC_GetECC PROC
;;;547      */
;;;548    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000360  4601              MOV      r1,r0
;;;549    {
;;;550      uint32_t eccval = 0x00000000;
000362  2000              MOVS     r0,#0
;;;551      
;;;552      if(FSMC_Bank == FSMC_Bank2_NAND)
000364  2910              CMP      r1,#0x10
000366  d103              BNE      |L1.880|
;;;553      {
;;;554        /* Get the ECCR2 register value */
;;;555        eccval = FSMC_Bank2->ECCR2;
000368  f04f4220          MOV      r2,#0xa0000000
00036c  6f50              LDR      r0,[r2,#0x74]
00036e  e002              B        |L1.886|
                  |L1.880|
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Get the ECCR3 register value */
;;;560        eccval = FSMC_Bank3->ECCR3;
000370  4a89              LDR      r2,|L1.1432|
000372  3214              ADDS     r2,r2,#0x14
000374  6810              LDR      r0,[r2,#0]
                  |L1.886|
;;;561      }
;;;562      /* Return the error correction code value */
;;;563      return(eccval);
;;;564    }
000376  4770              BX       lr
;;;565    /**
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;611      */
;;;612    void FSMC_PCCARDDeInit(void)
000378  2018              MOVS     r0,#0x18
;;;613    {
;;;614      /* Set the FSMC_Bank4 registers to their reset values */
;;;615      FSMC_Bank4->PCR4 = 0x00000018; 
00037a  4987              LDR      r1,|L1.1432|
00037c  3120              ADDS     r1,r1,#0x20
00037e  6008              STR      r0,[r1,#0]
;;;616      FSMC_Bank4->SR4 = 0x00000000;	
000380  2000              MOVS     r0,#0
000382  0609              LSLS     r1,r1,#24
000384  f8c100a4          STR      r0,[r1,#0xa4]
;;;617      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
000388  f04f30fc          MOV      r0,#0xfcfcfcfc
00038c  4982              LDR      r1,|L1.1432|
00038e  3128              ADDS     r1,r1,#0x28
000390  6008              STR      r0,[r1,#0]
;;;618      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000392  1d09              ADDS     r1,r1,#4
000394  6008              STR      r0,[r1,#0]
;;;619      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000396  1d09              ADDS     r1,r1,#4
000398  6008              STR      r0,[r1,#0]
;;;620    }
00039a  4770              BX       lr
;;;621    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;628      */
;;;629    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
00039c  6801              LDR      r1,[r0,#0]
;;;630    {
;;;631      /* Check the parameters */
;;;632      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;633      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;634      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;635     
;;;636      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;637      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;638      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;639      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;640      
;;;641      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;642      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;643      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;644      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;645      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;646      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;647      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;648      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;649      
;;;650      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;651      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
00039e  f0410110          ORR      r1,r1,#0x10
0003a2  6842              LDR      r2,[r0,#4]
0003a4  ea412142          ORR      r1,r1,r2,LSL #9
0003a8  6882              LDR      r2,[r0,#8]
0003aa  ea413142          ORR      r1,r1,r2,LSL #13
0003ae  4a7a              LDR      r2,|L1.1432|
0003b0  3220              ADDS     r2,r2,#0x20
0003b2  6011              STR      r1,[r2,#0]
;;;652                         FSMC_MemoryDataWidth_16b |  
;;;653                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;654                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;655                
;;;656      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;657      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0003b4  68c1              LDR      r1,[r0,#0xc]
0003b6  6809              LDR      r1,[r1,#0]
0003b8  68c2              LDR      r2,[r0,#0xc]
0003ba  6852              LDR      r2,[r2,#4]
0003bc  ea412102          ORR      r1,r1,r2,LSL #8
0003c0  68c2              LDR      r2,[r0,#0xc]
0003c2  8912              LDRH     r2,[r2,#8]
0003c4  ea414102          ORR      r1,r1,r2,LSL #16
0003c8  68c2              LDR      r2,[r0,#0xc]
0003ca  7b12              LDRB     r2,[r2,#0xc]
0003cc  ea416102          ORR      r1,r1,r2,LSL #24
0003d0  4a71              LDR      r2,|L1.1432|
0003d2  3228              ADDS     r2,r2,#0x28
0003d4  6011              STR      r1,[r2,#0]
;;;658                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;659                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;660                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;661                
;;;662      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;663      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
0003d6  6901              LDR      r1,[r0,#0x10]
0003d8  6809              LDR      r1,[r1,#0]
0003da  6902              LDR      r2,[r0,#0x10]
0003dc  6852              LDR      r2,[r2,#4]
0003de  ea412102          ORR      r1,r1,r2,LSL #8
0003e2  6902              LDR      r2,[r0,#0x10]
0003e4  8912              LDRH     r2,[r2,#8]
0003e6  ea414102          ORR      r1,r1,r2,LSL #16
0003ea  6902              LDR      r2,[r0,#0x10]
0003ec  7b12              LDRB     r2,[r2,#0xc]
0003ee  ea416102          ORR      r1,r1,r2,LSL #24
0003f2  4a69              LDR      r2,|L1.1432|
0003f4  322c              ADDS     r2,r2,#0x2c
0003f6  6011              STR      r1,[r2,#0]
;;;664                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;665                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;666                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;667                
;;;668      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;669      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
0003f8  6941              LDR      r1,[r0,#0x14]
0003fa  6809              LDR      r1,[r1,#0]
0003fc  6942              LDR      r2,[r0,#0x14]
0003fe  6852              LDR      r2,[r2,#4]
000400  ea412102          ORR      r1,r1,r2,LSL #8
000404  6942              LDR      r2,[r0,#0x14]
000406  8912              LDRH     r2,[r2,#8]
000408  ea414102          ORR      r1,r1,r2,LSL #16
00040c  6942              LDR      r2,[r0,#0x14]
00040e  7b12              LDRB     r2,[r2,#0xc]
000410  ea416102          ORR      r1,r1,r2,LSL #24
000414  f04f4220          MOV      r2,#0xa0000000
000418  f8c210b0          STR      r1,[r2,#0xb0]
;;;670                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;671                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;672                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;673    }
00041c  4770              BX       lr
;;;674    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;680      */
;;;681    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
00041e  2100              MOVS     r1,#0
;;;682    {
;;;683      /* Reset PCCARD Init structure parameters values */
;;;684      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000420  6001              STR      r1,[r0,#0]
;;;685      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000422  6041              STR      r1,[r0,#4]
;;;686      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000424  6081              STR      r1,[r0,#8]
;;;687      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000426  21fc              MOVS     r1,#0xfc
000428  68c2              LDR      r2,[r0,#0xc]
00042a  6011              STR      r1,[r2,#0]
;;;688      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00042c  68c2              LDR      r2,[r0,#0xc]
00042e  6051              STR      r1,[r2,#4]
;;;689      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000430  68c2              LDR      r2,[r0,#0xc]
000432  6091              STR      r1,[r2,#8]
;;;690      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000434  68c2              LDR      r2,[r0,#0xc]
000436  60d1              STR      r1,[r2,#0xc]
;;;691      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000438  6902              LDR      r2,[r0,#0x10]
00043a  6011              STR      r1,[r2,#0]
;;;692      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00043c  6902              LDR      r2,[r0,#0x10]
00043e  6051              STR      r1,[r2,#4]
;;;693      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000440  6902              LDR      r2,[r0,#0x10]
000442  6091              STR      r1,[r2,#8]
;;;694      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000444  6902              LDR      r2,[r0,#0x10]
000446  60d1              STR      r1,[r2,#0xc]
;;;695      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000448  6942              LDR      r2,[r0,#0x14]
00044a  6011              STR      r1,[r2,#0]
;;;696      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00044c  6942              LDR      r2,[r0,#0x14]
00044e  6051              STR      r1,[r2,#4]
;;;697      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000450  6942              LDR      r2,[r0,#0x14]
000452  6091              STR      r1,[r2,#8]
;;;698      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000454  6942              LDR      r2,[r0,#0x14]
000456  60d1              STR      r1,[r2,#0xc]
;;;699    }
000458  4770              BX       lr
;;;700    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;706      */
;;;707    void FSMC_PCCARDCmd(FunctionalState NewState)
00045a  b148              CBZ      r0,|L1.1136|
;;;708    {
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;710      
;;;711      if (NewState != DISABLE)
;;;712      {
;;;713        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;714        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
00045c  494e              LDR      r1,|L1.1432|
00045e  3120              ADDS     r1,r1,#0x20
000460  6809              LDR      r1,[r1,#0]
000462  f0410104          ORR      r1,r1,#4
000466  f04f4220          MOV      r2,#0xa0000000
00046a  f8c210a0          STR      r1,[r2,#0xa0]
00046e  e009              B        |L1.1156|
                  |L1.1136|
;;;715      }
;;;716      else
;;;717      {
;;;718        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;719        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000470  4949              LDR      r1,|L1.1432|
000472  3120              ADDS     r1,r1,#0x20
000474  6809              LDR      r1,[r1,#0]
000476  4a47              LDR      r2,|L1.1428|
000478  1ed2              SUBS     r2,r2,#3
00047a  4011              ANDS     r1,r1,r2
00047c  f04f4220          MOV      r2,#0xa0000000
000480  f8c210a0          STR      r1,[r2,#0xa0]
                  |L1.1156|
;;;720      }
;;;721    }
000484  4770              BX       lr
;;;722    /**
                          ENDP

                  FSMC_ITConfig PROC
;;;753      */
;;;754    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000486  b510              PUSH     {r4,lr}
;;;755    {
;;;756      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;757      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;758      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;759      
;;;760      if (NewState != DISABLE)
000488  b1f2              CBZ      r2,|L1.1224|
;;;761      {
;;;762        /* Enable the selected FSMC_Bank2 interrupts */
;;;763        if(FSMC_Bank == FSMC_Bank2_NAND)
00048a  2810              CMP      r0,#0x10
00048c  d107              BNE      |L1.1182|
;;;764        {
;;;765          FSMC_Bank2->SR2 |= FSMC_IT;
00048e  f04f4320          MOV      r3,#0xa0000000
000492  6e5b              LDR      r3,[r3,#0x64]
000494  430b              ORRS     r3,r3,r1
000496  f04f4420          MOV      r4,#0xa0000000
00049a  6663              STR      r3,[r4,#0x64]
00049c  e032              B        |L1.1284|
                  |L1.1182|
;;;766        }
;;;767        /* Enable the selected FSMC_Bank3 interrupts */
;;;768        else if (FSMC_Bank == FSMC_Bank3_NAND)
00049e  f5b07f80          CMP      r0,#0x100
0004a2  d108              BNE      |L1.1206|
;;;769        {
;;;770          FSMC_Bank3->SR3 |= FSMC_IT;
0004a4  4b3c              LDR      r3,|L1.1432|
0004a6  1d1b              ADDS     r3,r3,#4
0004a8  681b              LDR      r3,[r3,#0]
0004aa  430b              ORRS     r3,r3,r1
0004ac  f04f4420          MOV      r4,#0xa0000000
0004b0  f8c43084          STR      r3,[r4,#0x84]
0004b4  e026              B        |L1.1284|
                  |L1.1206|
;;;771        }
;;;772        /* Enable the selected FSMC_Bank4 interrupts */
;;;773        else
;;;774        {
;;;775          FSMC_Bank4->SR4 |= FSMC_IT;    
0004b6  4b38              LDR      r3,|L1.1432|
0004b8  3324              ADDS     r3,r3,#0x24
0004ba  681b              LDR      r3,[r3,#0]
0004bc  430b              ORRS     r3,r3,r1
0004be  f04f4420          MOV      r4,#0xa0000000
0004c2  f8c430a4          STR      r3,[r4,#0xa4]
0004c6  e01d              B        |L1.1284|
                  |L1.1224|
;;;776        }
;;;777      }
;;;778      else
;;;779      {
;;;780        /* Disable the selected FSMC_Bank2 interrupts */
;;;781        if(FSMC_Bank == FSMC_Bank2_NAND)
0004c8  2810              CMP      r0,#0x10
0004ca  d107              BNE      |L1.1244|
;;;782        {
;;;783          
;;;784          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
0004cc  f04f4320          MOV      r3,#0xa0000000
0004d0  6e5b              LDR      r3,[r3,#0x64]
0004d2  438b              BICS     r3,r3,r1
0004d4  f04f4420          MOV      r4,#0xa0000000
0004d8  6663              STR      r3,[r4,#0x64]
0004da  e013              B        |L1.1284|
                  |L1.1244|
;;;785        }
;;;786        /* Disable the selected FSMC_Bank3 interrupts */
;;;787        else if (FSMC_Bank == FSMC_Bank3_NAND)
0004dc  f5b07f80          CMP      r0,#0x100
0004e0  d108              BNE      |L1.1268|
;;;788        {
;;;789          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
0004e2  4b2d              LDR      r3,|L1.1432|
0004e4  1d1b              ADDS     r3,r3,#4
0004e6  681b              LDR      r3,[r3,#0]
0004e8  438b              BICS     r3,r3,r1
0004ea  f04f4420          MOV      r4,#0xa0000000
0004ee  f8c43084          STR      r3,[r4,#0x84]
0004f2  e007              B        |L1.1284|
                  |L1.1268|
;;;790        }
;;;791        /* Disable the selected FSMC_Bank4 interrupts */
;;;792        else
;;;793        {
;;;794          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
0004f4  4b28              LDR      r3,|L1.1432|
0004f6  3324              ADDS     r3,r3,#0x24
0004f8  681b              LDR      r3,[r3,#0]
0004fa  438b              BICS     r3,r3,r1
0004fc  f04f4420          MOV      r4,#0xa0000000
000500  f8c430a4          STR      r3,[r4,#0xa4]
                  |L1.1284|
;;;795        }
;;;796      }
;;;797    }
000504  bd10              POP      {r4,pc}
;;;798    
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;813      */
;;;814    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000506  b510              PUSH     {r4,lr}
;;;815    {
000508  4602              MOV      r2,r0
;;;816      FlagStatus bitstatus = RESET;
00050a  2000              MOVS     r0,#0
;;;817      uint32_t tmpsr = 0x00000000;
00050c  2300              MOVS     r3,#0
;;;818      
;;;819      /* Check the parameters */
;;;820      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;821      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;822      
;;;823      if(FSMC_Bank == FSMC_Bank2_NAND)
00050e  2a10              CMP      r2,#0x10
000510  d103              BNE      |L1.1306|
;;;824      {
;;;825        tmpsr = FSMC_Bank2->SR2;
000512  f04f4420          MOV      r4,#0xa0000000
000516  6e63              LDR      r3,[r4,#0x64]
000518  e009              B        |L1.1326|
                  |L1.1306|
;;;826      }  
;;;827      else if(FSMC_Bank == FSMC_Bank3_NAND)
00051a  f5b27f80          CMP      r2,#0x100
00051e  d103              BNE      |L1.1320|
;;;828      {
;;;829        tmpsr = FSMC_Bank3->SR3;
000520  4c1d              LDR      r4,|L1.1432|
000522  1d24              ADDS     r4,r4,#4
000524  6823              LDR      r3,[r4,#0]
000526  e002              B        |L1.1326|
                  |L1.1320|
;;;830      }
;;;831      /* FSMC_Bank4_PCCARD*/
;;;832      else
;;;833      {
;;;834        tmpsr = FSMC_Bank4->SR4;
000528  4c1b              LDR      r4,|L1.1432|
00052a  3424              ADDS     r4,r4,#0x24
00052c  6823              LDR      r3,[r4,#0]
                  |L1.1326|
;;;835      } 
;;;836      
;;;837      /* Get the flag status */
;;;838      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
00052e  ea030401          AND      r4,r3,r1
000532  b10c              CBZ      r4,|L1.1336|
;;;839      {
;;;840        bitstatus = SET;
000534  2001              MOVS     r0,#1
000536  e000              B        |L1.1338|
                  |L1.1336|
;;;841      }
;;;842      else
;;;843      {
;;;844        bitstatus = RESET;
000538  2000              MOVS     r0,#0
                  |L1.1338|
;;;845      }
;;;846      /* Return the flag status */
;;;847      return bitstatus;
;;;848    }
00053a  bd10              POP      {r4,pc}
;;;849    
                          ENDP

                  FSMC_ClearFlag PROC
;;;863      */
;;;864    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
00053c  2810              CMP      r0,#0x10
;;;865    {
;;;866     /* Check the parameters */
;;;867      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;868      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;869        
;;;870      if(FSMC_Bank == FSMC_Bank2_NAND)
00053e  d107              BNE      |L1.1360|
;;;871      {
;;;872        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
000540  f04f4220          MOV      r2,#0xa0000000
000544  6e52              LDR      r2,[r2,#0x64]
000546  438a              BICS     r2,r2,r1
000548  f04f4320          MOV      r3,#0xa0000000
00054c  665a              STR      r2,[r3,#0x64]
00054e  e013              B        |L1.1400|
                  |L1.1360|
;;;873      }  
;;;874      else if(FSMC_Bank == FSMC_Bank3_NAND)
000550  f5b07f80          CMP      r0,#0x100
000554  d108              BNE      |L1.1384|
;;;875      {
;;;876        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
000556  4a10              LDR      r2,|L1.1432|
000558  1d12              ADDS     r2,r2,#4
00055a  6812              LDR      r2,[r2,#0]
00055c  438a              BICS     r2,r2,r1
00055e  f04f4320          MOV      r3,#0xa0000000
000562  f8c32084          STR      r2,[r3,#0x84]
000566  e007              B        |L1.1400|
                  |L1.1384|
;;;877      }
;;;878      /* FSMC_Bank4_PCCARD*/
;;;879      else
;;;880      {
;;;881        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
000568  4a0b              LDR      r2,|L1.1432|
00056a  3224              ADDS     r2,r2,#0x24
00056c  6812              LDR      r2,[r2,#0]
00056e  438a              BICS     r2,r2,r1
000570  f04f4320          MOV      r3,#0xa0000000
000574  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.1400|
;;;882      }
;;;883    }
000578  4770              BX       lr
;;;884    
                          ENDP

                  FSMC_GetITStatus PROC
;;;898      */
;;;899    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00057a  b570              PUSH     {r4-r6,lr}
;;;900    {
00057c  4602              MOV      r2,r0
;;;901      ITStatus bitstatus = RESET;
00057e  2000              MOVS     r0,#0
;;;902      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
000580  2300              MOVS     r3,#0
000582  2400              MOVS     r4,#0
000584  2500              MOVS     r5,#0
;;;903      
;;;904      /* Check the parameters */
;;;905      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;906      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;907      
;;;908      if(FSMC_Bank == FSMC_Bank2_NAND)
000586  2a10              CMP      r2,#0x10
000588  d108              BNE      |L1.1436|
;;;909      {
;;;910        tmpsr = FSMC_Bank2->SR2;
00058a  f04f4620          MOV      r6,#0xa0000000
00058e  6e73              LDR      r3,[r6,#0x64]
000590  e00d              B        |L1.1454|
000592  0000              DCW      0x0000
                  |L1.1428|
                          DCD      0x000ffffe
                  |L1.1432|
                          DCD      0xa0000080
                  |L1.1436|
;;;911      }  
;;;912      else if(FSMC_Bank == FSMC_Bank3_NAND)
00059c  f5b27f80          CMP      r2,#0x100
0005a0  d102              BNE      |L1.1448|
;;;913      {
;;;914        tmpsr = FSMC_Bank3->SR3;
0005a2  4e18              LDR      r6,|L1.1540|
0005a4  6833              LDR      r3,[r6,#0]
0005a6  e002              B        |L1.1454|
                  |L1.1448|
;;;915      }
;;;916      /* FSMC_Bank4_PCCARD*/
;;;917      else
;;;918      {
;;;919        tmpsr = FSMC_Bank4->SR4;
0005a8  4e16              LDR      r6,|L1.1540|
0005aa  3620              ADDS     r6,r6,#0x20
0005ac  6833              LDR      r3,[r6,#0]
                  |L1.1454|
;;;920      } 
;;;921      
;;;922      itstatus = tmpsr & FSMC_IT;
0005ae  ea030401          AND      r4,r3,r1
;;;923      
;;;924      itenable = tmpsr & (FSMC_IT >> 3);
0005b2  ea0305d1          AND      r5,r3,r1,LSR #3
;;;925      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
0005b6  b114              CBZ      r4,|L1.1470|
0005b8  b10d              CBZ      r5,|L1.1470|
;;;926      {
;;;927        bitstatus = SET;
0005ba  2001              MOVS     r0,#1
0005bc  e000              B        |L1.1472|
                  |L1.1470|
;;;928      }
;;;929      else
;;;930      {
;;;931        bitstatus = RESET;
0005be  2000              MOVS     r0,#0
                  |L1.1472|
;;;932      }
;;;933      return bitstatus; 
;;;934    }
0005c0  bd70              POP      {r4-r6,pc}
;;;935    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;949      */
;;;950    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
0005c2  2810              CMP      r0,#0x10
;;;951    {
;;;952      /* Check the parameters */
;;;953      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;954      assert_param(IS_FSMC_IT(FSMC_IT));
;;;955        
;;;956      if(FSMC_Bank == FSMC_Bank2_NAND)
0005c4  d108              BNE      |L1.1496|
;;;957      {
;;;958        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
0005c6  f04f4220          MOV      r2,#0xa0000000
0005ca  6e52              LDR      r2,[r2,#0x64]
0005cc  ea2202d1          BIC      r2,r2,r1,LSR #3
0005d0  f04f4320          MOV      r3,#0xa0000000
0005d4  665a              STR      r2,[r3,#0x64]
0005d6  e014              B        |L1.1538|
                  |L1.1496|
;;;959      }  
;;;960      else if(FSMC_Bank == FSMC_Bank3_NAND)
0005d8  f5b07f80          CMP      r0,#0x100
0005dc  d108              BNE      |L1.1520|
;;;961      {
;;;962        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
0005de  4a09              LDR      r2,|L1.1540|
0005e0  6812              LDR      r2,[r2,#0]
0005e2  ea2202d1          BIC      r2,r2,r1,LSR #3
0005e6  f04f4320          MOV      r3,#0xa0000000
0005ea  f8c32084          STR      r2,[r3,#0x84]
0005ee  e008              B        |L1.1538|
                  |L1.1520|
;;;963      }
;;;964      /* FSMC_Bank4_PCCARD*/
;;;965      else
;;;966      {
;;;967        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
0005f0  4a04              LDR      r2,|L1.1540|
0005f2  3220              ADDS     r2,r2,#0x20
0005f4  6812              LDR      r2,[r2,#0]
0005f6  ea2202d1          BIC      r2,r2,r1,LSR #3
0005fa  f04f4320          MOV      r3,#0xa0000000
0005fe  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.1538|
;;;968      }
;;;969    }
000602  4770              BX       lr
;;;970    
                          ENDP

                  |L1.1540|
                          DCD      0xa0000084

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_fsmc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_2e710976____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_fsmc_c_2e710976____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_2e710976____REVSH|
#line 128
|__asm___16_stm32f4xx_fsmc_c_2e710976____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
