; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\timers.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\timers.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\timers.crf ..\..\libraries\lwip-1.4.1\src\core\timers.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sys_timeout PROC
;;;265    void
;;;266    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;268    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;269      struct sys_timeo *timeout, *t;
;;;270    
;;;271      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       memp_malloc
000010  4604              MOV      r4,r0
;;;272      if (timeout == NULL) {
000012  b91c              CBNZ     r4,|L1.28|
;;;273        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L1.24|
;;;274        return;
;;;275      }
;;;276      timeout->next = NULL;
;;;277      timeout->h = handler;
;;;278      timeout->arg = arg;
;;;279      timeout->time = msecs;
;;;280    #if LWIP_DEBUG_TIMERNAMES
;;;281      timeout->handler_name = handler_name;
;;;282      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
;;;283        (void *)timeout, msecs, handler_name, (void *)arg));
;;;284    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;285    
;;;286      if (next_timeout == NULL) {
;;;287        next_timeout = timeout;
;;;288        return;
;;;289      }
;;;290    
;;;291      if (next_timeout->time > msecs) {
;;;292        next_timeout->time -= msecs;
;;;293        timeout->next = next_timeout;
;;;294        next_timeout = timeout;
;;;295      } else {
;;;296        for(t = next_timeout; t != NULL; t = t->next) {
;;;297          timeout->time -= t->time;
;;;298          if (t->next == NULL || t->next->time > timeout->time) {
;;;299            if (t->next != NULL) {
;;;300              t->next->time -= timeout->time;
;;;301            }
;;;302            timeout->next = t->next;
;;;303            t->next = timeout;
;;;304            break;
;;;305          }
;;;306        }
;;;307      }
;;;308    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;276
00001e  6020              STR      r0,[r4,#0]            ;276
000020  60a7              STR      r7,[r4,#8]            ;277
000022  f8c4800c          STR      r8,[r4,#0xc]          ;278
000026  6066              STR      r6,[r4,#4]            ;279
000028  488c              LDR      r0,|L1.604|
00002a  6800              LDR      r0,[r0,#0]            ;286  ; next_timeout
00002c  b910              CBNZ     r0,|L1.52|
00002e  488b              LDR      r0,|L1.604|
000030  6004              STR      r4,[r0,#0]            ;287  ; next_timeout
000032  e7f1              B        |L1.24|
                  |L1.52|
000034  4889              LDR      r0,|L1.604|
000036  6800              LDR      r0,[r0,#0]            ;291  ; next_timeout
000038  6840              LDR      r0,[r0,#4]            ;291
00003a  42b0              CMP      r0,r6                 ;291
00003c  d90c              BLS      |L1.88|
00003e  4887              LDR      r0,|L1.604|
000040  6800              LDR      r0,[r0,#0]            ;292  ; next_timeout
000042  6840              LDR      r0,[r0,#4]            ;292
000044  1b80              SUBS     r0,r0,r6              ;292
000046  4985              LDR      r1,|L1.604|
000048  6809              LDR      r1,[r1,#0]            ;292  ; next_timeout
00004a  6048              STR      r0,[r1,#4]            ;292
00004c  4883              LDR      r0,|L1.604|
00004e  6800              LDR      r0,[r0,#0]            ;293  ; next_timeout
000050  6020              STR      r0,[r4,#0]            ;293
000052  4882              LDR      r0,|L1.604|
000054  6004              STR      r4,[r0,#0]            ;294  ; next_timeout
000056  e01d              B        |L1.148|
                  |L1.88|
000058  4880              LDR      r0,|L1.604|
00005a  6805              LDR      r5,[r0,#0]            ;296  ; next_timeout
00005c  e017              B        |L1.142|
                  |L1.94|
00005e  6860              LDR      r0,[r4,#4]            ;297
000060  6869              LDR      r1,[r5,#4]            ;297
000062  1a40              SUBS     r0,r0,r1              ;297
000064  6060              STR      r0,[r4,#4]            ;297
000066  6828              LDR      r0,[r5,#0]            ;298
000068  b120              CBZ      r0,|L1.116|
00006a  6828              LDR      r0,[r5,#0]            ;298
00006c  6840              LDR      r0,[r0,#4]            ;298
00006e  6861              LDR      r1,[r4,#4]            ;298
000070  4288              CMP      r0,r1                 ;298
000072  d90b              BLS      |L1.140|
                  |L1.116|
000074  6828              LDR      r0,[r5,#0]            ;299
000076  b128              CBZ      r0,|L1.132|
000078  6828              LDR      r0,[r5,#0]            ;300
00007a  6840              LDR      r0,[r0,#4]            ;300
00007c  6861              LDR      r1,[r4,#4]            ;300
00007e  1a40              SUBS     r0,r0,r1              ;300
000080  6829              LDR      r1,[r5,#0]            ;300
000082  6048              STR      r0,[r1,#4]            ;300
                  |L1.132|
000084  6828              LDR      r0,[r5,#0]            ;302
000086  6020              STR      r0,[r4,#0]            ;302
000088  602c              STR      r4,[r5,#0]            ;303
00008a  e002              B        |L1.146|
                  |L1.140|
00008c  682d              LDR      r5,[r5,#0]            ;296
                  |L1.142|
00008e  2d00              CMP      r5,#0                 ;296
000090  d1e5              BNE      |L1.94|
                  |L1.146|
000092  bf00              NOP                            ;304
                  |L1.148|
000094  bf00              NOP      
000096  e7bf              B        |L1.24|
;;;309    
                          ENDP

                  tcpip_tcp_timer PROC
;;;78     static void
;;;79     tcpip_tcp_timer(void *arg)
000098  b510              PUSH     {r4,lr}
;;;80     {
00009a  4604              MOV      r4,r0
;;;81       LWIP_UNUSED_ARG(arg);
;;;82     
;;;83       /* call TCP timer handler */
;;;84       tcp_tmr();
00009c  f7fffffe          BL       tcp_tmr
;;;85       /* timer still needed? */
;;;86       if (tcp_active_pcbs || tcp_tw_pcbs) {
0000a0  486f              LDR      r0,|L1.608|
0000a2  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0000a4  b910              CBNZ     r0,|L1.172|
0000a6  486f              LDR      r0,|L1.612|
0000a8  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0000aa  b128              CBZ      r0,|L1.184|
                  |L1.172|
;;;87         /* restart timer */
;;;88         sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
0000ac  2200              MOVS     r2,#0
0000ae  496e              LDR      r1,|L1.616|
0000b0  20fa              MOVS     r0,#0xfa
0000b2  f7fffffe          BL       sys_timeout
0000b6  e002              B        |L1.190|
                  |L1.184|
;;;89       } else {
;;;90         /* disable timer */
;;;91         tcpip_tcp_timer_active = 0;
0000b8  2000              MOVS     r0,#0
0000ba  496c              LDR      r1,|L1.620|
0000bc  6008              STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
                  |L1.190|
;;;92       }
;;;93     }
0000be  bd10              POP      {r4,pc}
;;;94     
                          ENDP

                  tcp_timer_needed PROC
;;;100    void
;;;101    tcp_timer_needed(void)
0000c0  b510              PUSH     {r4,lr}
;;;102    {
;;;103      /* timer is off but needed again? */
;;;104      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
0000c2  486a              LDR      r0,|L1.620|
0000c4  6800              LDR      r0,[r0,#0]  ; tcpip_tcp_timer_active
0000c6  b968              CBNZ     r0,|L1.228|
0000c8  4865              LDR      r0,|L1.608|
0000ca  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0000cc  b910              CBNZ     r0,|L1.212|
0000ce  4865              LDR      r0,|L1.612|
0000d0  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0000d2  b138              CBZ      r0,|L1.228|
                  |L1.212|
;;;105        /* enable and start timer */
;;;106        tcpip_tcp_timer_active = 1;
0000d4  2001              MOVS     r0,#1
0000d6  4965              LDR      r1,|L1.620|
0000d8  6008              STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
;;;107        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
0000da  2200              MOVS     r2,#0
0000dc  4962              LDR      r1,|L1.616|
0000de  20fa              MOVS     r0,#0xfa
0000e0  f7fffffe          BL       sys_timeout
                  |L1.228|
;;;108      }
;;;109    }
0000e4  bd10              POP      {r4,pc}
;;;110    #endif /* LWIP_TCP */
                          ENDP

                  arp_timer PROC
;;;134    static void
;;;135    arp_timer(void *arg)
0000e6  b510              PUSH     {r4,lr}
;;;136    {
0000e8  4604              MOV      r4,r0
;;;137      LWIP_UNUSED_ARG(arg);
;;;138      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
0000ea  bf00              NOP      
0000ec  bf00              NOP      
;;;139      etharp_tmr();
0000ee  f7fffffe          BL       etharp_tmr
;;;140      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
0000f2  2200              MOVS     r2,#0
0000f4  495e              LDR      r1,|L1.624|
0000f6  f2413088          MOV      r0,#0x1388
0000fa  f7fffffe          BL       sys_timeout
;;;141    }
0000fe  bd10              POP      {r4,pc}
;;;142    #endif /* LWIP_ARP */
                          ENDP

                  dhcp_timer_coarse PROC
;;;150    static void
;;;151    dhcp_timer_coarse(void *arg)
000100  b510              PUSH     {r4,lr}
;;;152    {
000102  4604              MOV      r4,r0
;;;153      LWIP_UNUSED_ARG(arg);
;;;154      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
000104  bf00              NOP      
000106  bf00              NOP      
;;;155      dhcp_coarse_tmr();
000108  f7fffffe          BL       dhcp_coarse_tmr
;;;156      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
00010c  2200              MOVS     r2,#0
00010e  4959              LDR      r1,|L1.628|
000110  f64e2060          MOV      r0,#0xea60
000114  f7fffffe          BL       sys_timeout
;;;157    }
000118  bd10              POP      {r4,pc}
;;;158    
                          ENDP

                  dhcp_timer_fine PROC
;;;164    static void
;;;165    dhcp_timer_fine(void *arg)
00011a  b510              PUSH     {r4,lr}
;;;166    {
00011c  4604              MOV      r4,r0
;;;167      LWIP_UNUSED_ARG(arg);
;;;168      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
00011e  bf00              NOP      
000120  bf00              NOP      
;;;169      dhcp_fine_tmr();
000122  f7fffffe          BL       dhcp_fine_tmr
;;;170      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
000126  2200              MOVS     r2,#0
000128  4953              LDR      r1,|L1.632|
00012a  f44f70fa          MOV      r0,#0x1f4
00012e  f7fffffe          BL       sys_timeout
;;;171    }
000132  bd10              POP      {r4,pc}
;;;172    #endif /* LWIP_DHCP */
                          ENDP

                  igmp_timer PROC
;;;196    static void
;;;197    igmp_timer(void *arg)
000134  b510              PUSH     {r4,lr}
;;;198    {
000136  4604              MOV      r4,r0
;;;199      LWIP_UNUSED_ARG(arg);
;;;200      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: igmp_tmr()\n"));
000138  bf00              NOP      
00013a  bf00              NOP      
;;;201      igmp_tmr();
00013c  f7fffffe          BL       igmp_tmr
;;;202      sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
000140  2200              MOVS     r2,#0
000142  494e              LDR      r1,|L1.636|
000144  2064              MOVS     r0,#0x64
000146  f7fffffe          BL       sys_timeout
;;;203    }
00014a  bd10              POP      {r4,pc}
;;;204    #endif /* LWIP_IGMP */
                          ENDP

                  sys_timeouts_init PROC
;;;222    /** Initialize this module */
;;;223    void sys_timeouts_init(void)
00014c  b510              PUSH     {r4,lr}
;;;224    {
;;;225    #if IP_REASSEMBLY
;;;226      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
;;;227    #endif /* IP_REASSEMBLY */
;;;228    #if LWIP_ARP
;;;229      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
00014e  2200              MOVS     r2,#0
000150  4947              LDR      r1,|L1.624|
000152  f2413088          MOV      r0,#0x1388
000156  f7fffffe          BL       sys_timeout
;;;230    #endif /* LWIP_ARP */
;;;231    #if LWIP_DHCP
;;;232      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
00015a  2200              MOVS     r2,#0
00015c  4945              LDR      r1,|L1.628|
00015e  f64e2060          MOV      r0,#0xea60
000162  f7fffffe          BL       sys_timeout
;;;233      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
000166  2200              MOVS     r2,#0
000168  4943              LDR      r1,|L1.632|
00016a  f44f70fa          MOV      r0,#0x1f4
00016e  f7fffffe          BL       sys_timeout
;;;234    #endif /* LWIP_DHCP */
;;;235    #if LWIP_AUTOIP
;;;236      sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
;;;237    #endif /* LWIP_AUTOIP */
;;;238    #if LWIP_IGMP
;;;239      sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
000172  2200              MOVS     r2,#0
000174  4941              LDR      r1,|L1.636|
000176  2064              MOVS     r0,#0x64
000178  f7fffffe          BL       sys_timeout
;;;240    #endif /* LWIP_IGMP */
;;;241    #if LWIP_DNS
;;;242      sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
;;;243    #endif /* LWIP_DNS */
;;;244    
;;;245    #if NO_SYS
;;;246      /* Initialise timestamp for sys_check_timeouts */
;;;247      timeouts_last_time = sys_now();
;;;248    #endif
;;;249    }
00017c  bd10              POP      {r4,pc}
;;;250    
                          ENDP

                  sys_untimeout PROC
;;;320    void
;;;321    sys_untimeout(sys_timeout_handler handler, void *arg)
00017e  e92d41f0          PUSH     {r4-r8,lr}
;;;322    {
000182  4606              MOV      r6,r0
000184  460f              MOV      r7,r1
;;;323      struct sys_timeo *prev_t, *t;
;;;324    
;;;325      if (next_timeout == NULL) {
000186  4835              LDR      r0,|L1.604|
000188  6800              LDR      r0,[r0,#0]  ; next_timeout
00018a  b908              CBNZ     r0,|L1.400|
                  |L1.396|
;;;326        return;
;;;327      }
;;;328    
;;;329      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
;;;330        if ((t->h == handler) && (t->arg == arg)) {
;;;331          /* We have a match */
;;;332          /* Unlink from previous in list */
;;;333          if (prev_t == NULL) {
;;;334            next_timeout = t->next;
;;;335          } else {
;;;336            prev_t->next = t->next;
;;;337          }
;;;338          /* If not the last one, add time of this one back to next */
;;;339          if (t->next != NULL) {
;;;340            t->next->time += t->time;
;;;341          }
;;;342          memp_free(MEMP_SYS_TIMEOUT, t);
;;;343          return;
;;;344        }
;;;345      }
;;;346      return;
;;;347    }
00018c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.400|
000190  4832              LDR      r0,|L1.604|
000192  6804              LDR      r4,[r0,#0]            ;329  ; next_timeout
000194  2500              MOVS     r5,#0                 ;329
000196  e01b              B        |L1.464|
                  |L1.408|
000198  68a0              LDR      r0,[r4,#8]            ;330
00019a  42b0              CMP      r0,r6                 ;330
00019c  d116              BNE      |L1.460|
00019e  68e0              LDR      r0,[r4,#0xc]          ;330
0001a0  42b8              CMP      r0,r7                 ;330
0001a2  d113              BNE      |L1.460|
0001a4  b91d              CBNZ     r5,|L1.430|
0001a6  492d              LDR      r1,|L1.604|
0001a8  6820              LDR      r0,[r4,#0]            ;334
0001aa  6008              STR      r0,[r1,#0]            ;334  ; next_timeout
0001ac  e001              B        |L1.434|
                  |L1.430|
0001ae  6820              LDR      r0,[r4,#0]            ;336
0001b0  6028              STR      r0,[r5,#0]            ;336
                  |L1.434|
0001b2  6820              LDR      r0,[r4,#0]            ;339
0001b4  b128              CBZ      r0,|L1.450|
0001b6  6820              LDR      r0,[r4,#0]            ;340
0001b8  6840              LDR      r0,[r0,#4]            ;340
0001ba  6861              LDR      r1,[r4,#4]            ;340
0001bc  4408              ADD      r0,r0,r1              ;340
0001be  6821              LDR      r1,[r4,#0]            ;340
0001c0  6048              STR      r0,[r1,#4]            ;340
                  |L1.450|
0001c2  4621              MOV      r1,r4                 ;342
0001c4  200a              MOVS     r0,#0xa               ;342
0001c6  f7fffffe          BL       memp_free
0001ca  e7df              B        |L1.396|
                  |L1.460|
0001cc  4625              MOV      r5,r4                 ;329
0001ce  6824              LDR      r4,[r4,#0]            ;329
                  |L1.464|
0001d0  2c00              CMP      r4,#0                 ;329
0001d2  d1e1              BNE      |L1.408|
0001d4  bf00              NOP                            ;346
0001d6  e7d9              B        |L1.396|
;;;348    
                          ENDP

                  sys_timeouts_mbox_fetch PROC
;;;422    void
;;;423    sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
0001d8  e92d47f0          PUSH     {r4-r10,lr}
;;;424    {
0001dc  4680              MOV      r8,r0
0001de  4689              MOV      r9,r1
;;;425      u32_t time_needed;
;;;426      struct sys_timeo *tmptimeout;
;;;427      sys_timeout_handler handler;
;;;428      void *arg;
;;;429    
;;;430     again:
0001e0  bf00              NOP      
                  |L1.482|
;;;431      if (!next_timeout) {
0001e2  481e              LDR      r0,|L1.604|
0001e4  6800              LDR      r0,[r0,#0]  ; next_timeout
0001e6  b930              CBNZ     r0,|L1.502|
;;;432        time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
0001e8  2200              MOVS     r2,#0
0001ea  4649              MOV      r1,r9
0001ec  4640              MOV      r0,r8
0001ee  f7fffffe          BL       sys_arch_mbox_fetch
0001f2  4605              MOV      r5,r0
0001f4  e030              B        |L1.600|
                  |L1.502|
;;;433      } else {
;;;434        if (next_timeout->time > 0) {
0001f6  4819              LDR      r0,|L1.604|
0001f8  6800              LDR      r0,[r0,#0]  ; next_timeout
0001fa  6840              LDR      r0,[r0,#4]
0001fc  b140              CBZ      r0,|L1.528|
;;;435          time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
0001fe  4817              LDR      r0,|L1.604|
000200  6800              LDR      r0,[r0,#0]  ; next_timeout
000202  4649              MOV      r1,r9
000204  6842              LDR      r2,[r0,#4]
000206  4640              MOV      r0,r8
000208  f7fffffe          BL       sys_arch_mbox_fetch
00020c  4605              MOV      r5,r0
00020e  e001              B        |L1.532|
                  |L1.528|
;;;436        } else {
;;;437          time_needed = SYS_ARCH_TIMEOUT;
000210  f04f35ff          MOV      r5,#0xffffffff
                  |L1.532|
;;;438        }
;;;439    
;;;440        if (time_needed == SYS_ARCH_TIMEOUT) {
000214  1c68              ADDS     r0,r5,#1
000216  b970              CBNZ     r0,|L1.566|
;;;441          /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
;;;442             could be fetched. We should now call the timeout handler and
;;;443             deallocate the memory allocated for the timeout. */
;;;444          tmptimeout = next_timeout;
000218  4810              LDR      r0,|L1.604|
00021a  6804              LDR      r4,[r0,#0]  ; next_timeout
;;;445          next_timeout = tmptimeout->next;
00021c  490f              LDR      r1,|L1.604|
00021e  6820              LDR      r0,[r4,#0]
000220  6008              STR      r0,[r1,#0]  ; next_timeout
;;;446          handler = tmptimeout->h;
000222  68a6              LDR      r6,[r4,#8]
;;;447          arg = tmptimeout->arg;
000224  68e7              LDR      r7,[r4,#0xc]
;;;448    #if LWIP_DEBUG_TIMERNAMES
;;;449          if (handler != NULL) {
;;;450            LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
;;;451              tmptimeout->handler_name, arg));
;;;452          }
;;;453    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;454          memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
000226  4621              MOV      r1,r4
000228  200a              MOVS     r0,#0xa
00022a  f7fffffe          BL       memp_free
;;;455          if (handler != NULL) {
00022e  b10e              CBZ      r6,|L1.564|
;;;456            /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
;;;457               timeout handler function. */
;;;458            LOCK_TCPIP_CORE();
;;;459            handler(arg);
000230  4638              MOV      r0,r7
000232  47b0              BLX      r6
                  |L1.564|
;;;460            UNLOCK_TCPIP_CORE();
;;;461          }
;;;462          LWIP_TCPIP_THREAD_ALIVE();
;;;463    
;;;464          /* We try again to fetch a message from the mbox. */
;;;465          goto again;
000234  e7d5              B        |L1.482|
                  |L1.566|
;;;466        } else {
;;;467          /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
;;;468             occured. The time variable is set to the number of
;;;469             milliseconds we waited for the message. */
;;;470          if (time_needed < next_timeout->time) {
000236  4809              LDR      r0,|L1.604|
000238  6800              LDR      r0,[r0,#0]  ; next_timeout
00023a  6840              LDR      r0,[r0,#4]
00023c  42a8              CMP      r0,r5
00023e  d907              BLS      |L1.592|
;;;471            next_timeout->time -= time_needed;
000240  4806              LDR      r0,|L1.604|
000242  6800              LDR      r0,[r0,#0]  ; next_timeout
000244  6840              LDR      r0,[r0,#4]
000246  1b40              SUBS     r0,r0,r5
000248  4904              LDR      r1,|L1.604|
00024a  6809              LDR      r1,[r1,#0]  ; next_timeout
00024c  6048              STR      r0,[r1,#4]
00024e  e003              B        |L1.600|
                  |L1.592|
;;;472          } else {
;;;473            next_timeout->time = 0;
000250  2000              MOVS     r0,#0
000252  4902              LDR      r1,|L1.604|
000254  6809              LDR      r1,[r1,#0]  ; next_timeout
000256  6048              STR      r0,[r1,#4]
                  |L1.600|
;;;474          }
;;;475        }
;;;476      }
;;;477    }
000258  e8bd87f0          POP      {r4-r10,pc}
;;;478    
                          ENDP

                  |L1.604|
                          DCD      next_timeout
                  |L1.608|
                          DCD      tcp_active_pcbs
                  |L1.612|
                          DCD      tcp_tw_pcbs
                  |L1.616|
                          DCD      tcpip_tcp_timer
                  |L1.620|
                          DCD      tcpip_tcp_timer_active
                  |L1.624|
                          DCD      arp_timer
                  |L1.628|
                          DCD      dhcp_timer_coarse
                  |L1.632|
                          DCD      dhcp_timer_fine
                  |L1.636|
                          DCD      igmp_timer

                          AREA ||.data||, DATA, ALIGN=2

                  next_timeout
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000
