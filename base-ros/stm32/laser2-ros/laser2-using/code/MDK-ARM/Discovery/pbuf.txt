; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\pbuf.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\pbuf.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\pbuf.crf ..\..\libraries\lwip-1.4.1\src\core\pbuf.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;619    {
000004  4604              MOV      r4,r0
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
000006  b934              CBNZ     r4,|L1.22|
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
000008  bf00              NOP      
00000a  bf00              NOP      
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
000010  2000              MOVS     r0,#0
                  |L1.18|
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L1.22|
000016  bf00              NOP                            ;631
000018  bf00              NOP                            ;631
00001a  bf00              NOP                            ;635
00001c  bf00              NOP                            ;635
00001e  2600              MOVS     r6,#0                 ;639
000020  e02f              B        |L1.130|
                  |L1.34|
000022  f7fffffe          BL       sys_arch_protect
000026  4681              MOV      r9,r0                 ;648
000028  bf00              NOP                            ;650
00002a  bf00              NOP                            ;650
00002c  89e0              LDRH     r0,[r4,#0xe]          ;652
00002e  1e40              SUBS     r0,r0,#1              ;652
000030  fa1ff880          UXTH     r8,r0                 ;652
000034  f8a4800e          STRH     r8,[r4,#0xe]          ;652
000038  4648              MOV      r0,r9                 ;653
00003a  f7fffffe          BL       sys_arch_unprotect
00003e  f1b80f00          CMP      r8,#0                 ;655
000042  d11a              BNE      |L1.122|
000044  6827              LDR      r7,[r4,#0]            ;657
000046  bf00              NOP                            ;658
000048  bf00              NOP                            ;658
00004a  7b25              LDRB     r5,[r4,#0xc]          ;659
00004c  2d03              CMP      r5,#3                 ;670
00004e  d104              BNE      |L1.90|
000050  4621              MOV      r1,r4                 ;671
000052  200c              MOVS     r0,#0xc               ;671
000054  f7fffffe          BL       memp_free
000058  e00b              B        |L1.114|
                  |L1.90|
00005a  2d01              CMP      r5,#1                 ;673
00005c  d001              BEQ      |L1.98|
00005e  2d02              CMP      r5,#2                 ;673
000060  d104              BNE      |L1.108|
                  |L1.98|
000062  4621              MOV      r1,r4                 ;674
000064  200b              MOVS     r0,#0xb               ;674
000066  f7fffffe          BL       memp_free
00006a  e002              B        |L1.114|
                  |L1.108|
00006c  4620              MOV      r0,r4                 ;677
00006e  f7fffffe          BL       mem_free
                  |L1.114|
000072  1c70              ADDS     r0,r6,#1              ;680
000074  b2c6              UXTB     r6,r0                 ;680
000076  463c              MOV      r4,r7                 ;682
000078  e002              B        |L1.128|
                  |L1.122|
00007a  bf00              NOP                            ;686
00007c  bf00              NOP                            ;686
00007e  2400              MOVS     r4,#0                 ;688
                  |L1.128|
000080  bf00              NOP                            ;690
                  |L1.130|
000082  2c00              CMP      r4,#0                 ;642
000084  d1cd              BNE      |L1.34|
000086  4630              MOV      r0,r6                 ;693
000088  e7c3              B        |L1.18|
;;;695    
                          ENDP

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
00008a  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
00008e  4683              MOV      r11,r0
000090  460f              MOV      r7,r1
000092  4690              MOV      r8,r2
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
000094  bf00              NOP      
000096  bf00              NOP      
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
000098  f1bb0f00          CMP      r11,#0
00009c  d009              BEQ      |L1.178|
00009e  f1bb0f01          CMP      r11,#1
0000a2  d008              BEQ      |L1.182|
0000a4  f1bb0f02          CMP      r11,#2
0000a8  d007              BEQ      |L1.186|
0000aa  f1bb0f03          CMP      r11,#3
0000ae  d108              BNE      |L1.194|
0000b0  e005              B        |L1.190|
                  |L1.178|
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
0000b2  2636              MOVS     r6,#0x36
;;;219        break;
0000b4  e00a              B        |L1.204|
                  |L1.182|
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
0000b6  2622              MOVS     r6,#0x22
;;;223        break;
0000b8  e008              B        |L1.204|
                  |L1.186|
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
0000ba  260e              MOVS     r6,#0xe
;;;227        break;
0000bc  e006              B        |L1.204|
                  |L1.190|
;;;228      case PBUF_RAW:
;;;229        offset = 0;
0000be  2600              MOVS     r6,#0
;;;230        break;
0000c0  e004              B        |L1.204|
                  |L1.194|
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
0000c2  bf00              NOP      
0000c4  bf00              NOP      
;;;233        return NULL;
0000c6  2000              MOVS     r0,#0
                  |L1.200|
;;;234      }
;;;235    
;;;236      switch (type) {
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
0000c8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.204|
0000cc  bf00              NOP                            ;219
0000ce  f1b80f00          CMP      r8,#0                 ;236
0000d2  d06d              BEQ      |L1.432|
0000d4  f1b80f01          CMP      r8,#1                 ;236
0000d8  d079              BEQ      |L1.462|
0000da  f1b80f02          CMP      r8,#2                 ;236
0000de  d077              BEQ      |L1.464|
0000e0  f1b80f03          CMP      r8,#3                 ;236
0000e4  d175              BNE      |L1.466|
0000e6  200c              MOVS     r0,#0xc               ;239
0000e8  f7fffffe          BL       memp_malloc
0000ec  4604              MOV      r4,r0                 ;239
0000ee  bf00              NOP                            ;240
0000f0  bf00              NOP                            ;240
0000f2  b90c              CBNZ     r4,|L1.248|
0000f4  2000              MOVS     r0,#0                 ;243
0000f6  e7e7              B        |L1.200|
                  |L1.248|
0000f8  f884800c          STRB     r8,[r4,#0xc]          ;245
0000fc  2000              MOVS     r0,#0                 ;246
0000fe  6020              STR      r0,[r4,#0]            ;246
000100  f1060018          ADD      r0,r6,#0x18           ;249
000104  4420              ADD      r0,r0,r4              ;249
000106  1cc0              ADDS     r0,r0,#3              ;249
000108  f0200003          BIC      r0,r0,#3              ;249
00010c  6060              STR      r0,[r4,#4]            ;249
00010e  bf00              NOP                            ;250
000110  bf00              NOP                            ;250
000112  8127              STRH     r7,[r4,#8]            ;253
000114  1cf0              ADDS     r0,r6,#3              ;255
000116  f0200003          BIC      r0,r0,#3              ;255
00011a  f24051ec          MOV      r1,#0x5ec             ;255
00011e  1a08              SUBS     r0,r1,r0              ;255
000120  42b8              CMP      r0,r7                 ;255
000122  dd01              BLE      |L1.296|
000124  4638              MOV      r0,r7                 ;255
000126  e005              B        |L1.308|
                  |L1.296|
000128  1cf0              ADDS     r0,r6,#3              ;255
00012a  f0200003          BIC      r0,r0,#3              ;255
00012e  f24051ec          MOV      r1,#0x5ec             ;255
000132  1a08              SUBS     r0,r1,r0              ;255
                  |L1.308|
000134  8160              STRH     r0,[r4,#0xa]          ;255
000136  bf00              NOP                            ;256
000138  bf00              NOP                            ;256
00013a  bf00              NOP                            ;259
00013c  bf00              NOP                            ;259
00013e  2001              MOVS     r0,#1                 ;262
000140  81e0              STRH     r0,[r4,#0xe]          ;262
000142  46a2              MOV      r10,r4                ;267
000144  8960              LDRH     r0,[r4,#0xa]          ;269
000146  eba70900          SUB      r9,r7,r0              ;269
00014a  e02d              B        |L1.424|
                  |L1.332|
00014c  200c              MOVS     r0,#0xc               ;272
00014e  f7fffffe          BL       memp_malloc
000152  4605              MOV      r5,r0                 ;272
000154  b925              CBNZ     r5,|L1.352|
000156  4620              MOV      r0,r4                 ;276
000158  f7fffffe          BL       pbuf_free
00015c  2000              MOVS     r0,#0                 ;278
00015e  e7b3              B        |L1.200|
                  |L1.352|
000160  f885800c          STRB     r8,[r5,#0xc]          ;280
000164  2000              MOVS     r0,#0                 ;281
000166  7368              STRB     r0,[r5,#0xd]          ;281
000168  6028              STR      r0,[r5,#0]            ;282
00016a  f8ca5000          STR      r5,[r10,#0]           ;284
00016e  bf00              NOP                            ;286
000170  bf00              NOP                            ;286
000172  f8a59008          STRH     r9,[r5,#8]            ;287
000176  fa1ff089          UXTH     r0,r9                 ;289
00017a  f24051ec          MOV      r1,#0x5ec             ;289
00017e  4288              CMP      r0,r1                 ;289
000180  da02              BGE      |L1.392|
000182  fa1ff089          UXTH     r0,r9                 ;289
000186  e001              B        |L1.396|
                  |L1.392|
000188  f24050ec          MOV      r0,#0x5ec             ;289
                  |L1.396|
00018c  8168              STRH     r0,[r5,#0xa]          ;289
00018e  f1050018          ADD      r0,r5,#0x18           ;290
000192  6068              STR      r0,[r5,#4]            ;290
000194  bf00              NOP                            ;291
000196  bf00              NOP                            ;291
000198  bf00              NOP                            ;293
00019a  bf00              NOP                            ;293
00019c  2001              MOVS     r0,#1                 ;296
00019e  81e8              STRH     r0,[r5,#0xe]          ;296
0001a0  8968              LDRH     r0,[r5,#0xa]          ;298
0001a2  eba90900          SUB      r9,r9,r0              ;298
0001a6  46aa              MOV      r10,r5                ;300
                  |L1.424|
0001a8  f1b90f00          CMP      r9,#0                 ;271
0001ac  dcce              BGT      |L1.332|
0001ae  e037              B        |L1.544|
                  |L1.432|
0001b0  f106011b          ADD      r1,r6,#0x1b           ;308
0001b4  f0210203          BIC      r2,r1,#3              ;308
0001b8  1cf9              ADDS     r1,r7,#3              ;308
0001ba  f0210103          BIC      r1,r1,#3              ;308
0001be  4411              ADD      r1,r1,r2              ;308
0001c0  b288              UXTH     r0,r1                 ;308
0001c2  f7fffffe          BL       mem_malloc
0001c6  4604              MOV      r4,r0                 ;308
0001c8  b924              CBNZ     r4,|L1.468|
0001ca  2000              MOVS     r0,#0                 ;310
0001cc  e77c              B        |L1.200|
                  |L1.462|
0001ce  e011              B        |L1.500|
                  |L1.464|
0001d0  e011              B        |L1.502|
                  |L1.466|
0001d2  e021              B        |L1.536|
                  |L1.468|
0001d4  f1040018          ADD      r0,r4,#0x18           ;313
0001d8  4430              ADD      r0,r0,r6              ;313
0001da  1cc0              ADDS     r0,r0,#3              ;313
0001dc  f0200003          BIC      r0,r0,#3              ;313
0001e0  6060              STR      r0,[r4,#4]            ;313
0001e2  8127              STRH     r7,[r4,#8]            ;314
0001e4  8167              STRH     r7,[r4,#0xa]          ;314
0001e6  2000              MOVS     r0,#0                 ;315
0001e8  6020              STR      r0,[r4,#0]            ;315
0001ea  f884800c          STRB     r8,[r4,#0xc]          ;316
0001ee  bf00              NOP                            ;318
0001f0  bf00              NOP                            ;318
0001f2  e015              B        |L1.544|
                  |L1.500|
0001f4  bf00              NOP                            ;324
                  |L1.502|
0001f6  200b              MOVS     r0,#0xb               ;326
0001f8  f7fffffe          BL       memp_malloc
0001fc  4604              MOV      r4,r0                 ;326
0001fe  b91c              CBNZ     r4,|L1.520|
000200  bf00              NOP                            ;328
000202  bf00              NOP                            ;328
000204  2000              MOVS     r0,#0                 ;331
000206  e75f              B        |L1.200|
                  |L1.520|
000208  2000              MOVS     r0,#0                 ;334
00020a  6060              STR      r0,[r4,#4]            ;334
00020c  8127              STRH     r7,[r4,#8]            ;335
00020e  8167              STRH     r7,[r4,#0xa]          ;335
000210  6020              STR      r0,[r4,#0]            ;336
000212  f884800c          STRB     r8,[r4,#0xc]          ;337
000216  e003              B        |L1.544|
                  |L1.536|
000218  bf00              NOP                            ;340
00021a  bf00              NOP                            ;340
00021c  2000              MOVS     r0,#0                 ;341
00021e  e753              B        |L1.200|
                  |L1.544|
000220  bf00              NOP                            ;305
000222  2001              MOVS     r0,#1                 ;344
000224  81e0              STRH     r0,[r4,#0xe]          ;344
000226  2000              MOVS     r0,#0                 ;346
000228  7360              STRB     r0,[r4,#0xd]          ;346
00022a  bf00              NOP                            ;347
00022c  bf00              NOP                            ;347
00022e  4620              MOV      r0,r4                 ;348
000230  e74a              B        |L1.200|
;;;350    
                          ENDP

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
000232  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000236  4606              MOV      r6,r0
000238  460f              MOV      r7,r1
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
00023a  bf00              NOP      
00023c  bf00              NOP      
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
00023e  bf00              NOP      
000240  bf00              NOP      
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
000242  8930              LDRH     r0,[r6,#8]
000244  42b8              CMP      r0,r7
000246  dc01              BGT      |L1.588|
                  |L1.584|
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
;;;461        q->tot_len += (u16_t)grow;
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
000248  e8bd81f0          POP      {r4-r8,pc}
                  |L1.588|
00024c  8930              LDRH     r0,[r6,#8]            ;450
00024e  eba70800          SUB      r8,r7,r0              ;450
000252  463d              MOV      r5,r7                 ;453
000254  4634              MOV      r4,r6                 ;454
000256  e00a              B        |L1.622|
                  |L1.600|
000258  8960              LDRH     r0,[r4,#0xa]          ;458
00025a  1a28              SUBS     r0,r5,r0              ;458
00025c  b285              UXTH     r5,r0                 ;458
00025e  bf00              NOP                            ;460
000260  bf00              NOP                            ;460
000262  8920              LDRH     r0,[r4,#8]            ;461
000264  4440              ADD      r0,r0,r8              ;461
000266  8120              STRH     r0,[r4,#8]            ;461
000268  6824              LDR      r4,[r4,#0]            ;463
00026a  bf00              NOP                            ;464
00026c  bf00              NOP                            ;464
                  |L1.622|
00026e  8960              LDRH     r0,[r4,#0xa]          ;456
000270  42a8              CMP      r0,r5                 ;456
000272  dbf1              BLT      |L1.600|
000274  7b20              LDRB     r0,[r4,#0xc]          ;471
000276  b960              CBNZ     r0,|L1.658|
000278  8960              LDRH     r0,[r4,#0xa]          ;471
00027a  42a8              CMP      r0,r5                 ;471
00027c  d009              BEQ      |L1.658|
00027e  88a0              LDRH     r0,[r4,#4]            ;473
000280  1b00              SUBS     r0,r0,r4              ;473
000282  4428              ADD      r0,r0,r5              ;473
000284  b281              UXTH     r1,r0                 ;473
000286  4620              MOV      r0,r4                 ;473
000288  f7fffffe          BL       mem_trim
00028c  4604              MOV      r4,r0                 ;473
00028e  bf00              NOP                            ;474
000290  bf00              NOP                            ;474
                  |L1.658|
000292  8165              STRH     r5,[r4,#0xa]          ;477
000294  8960              LDRH     r0,[r4,#0xa]          ;478
000296  8120              STRH     r0,[r4,#8]            ;478
000298  6820              LDR      r0,[r4,#0]            ;481
00029a  b110              CBZ      r0,|L1.674|
00029c  6820              LDR      r0,[r4,#0]            ;483
00029e  f7fffffe          BL       pbuf_free
                  |L1.674|
0002a2  2000              MOVS     r0,#0                 ;486
0002a4  6020              STR      r0,[r4,#0]            ;486
0002a6  bf00              NOP      
0002a8  e7ce              B        |L1.584|
;;;489    
                          ENDP

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
0002aa  b570              PUSH     {r4-r6,lr}
;;;512    {
0002ac  4602              MOV      r2,r0
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
0002ae  bf00              NOP      
0002b0  bf00              NOP      
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
0002b2  b101              CBZ      r1,|L1.694|
0002b4  b90a              CBNZ     r2,|L1.698|
                  |L1.694|
;;;519        return 0;
0002b6  2000              MOVS     r0,#0
                  |L1.696|
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
0002b8  bd70              POP      {r4-r6,pc}
                  |L1.698|
0002ba  2900              CMP      r1,#0                 ;522
0002bc  da08              BGE      |L1.720|
0002be  4248              RSBS     r0,r1,#0              ;523
0002c0  b284              UXTH     r4,r0                 ;523
0002c2  bf00              NOP                            ;525
0002c4  8950              LDRH     r0,[r2,#0xa]          ;525
0002c6  42a0              CMP      r0,r4                 ;525
0002c8  da01              BGE      |L1.718|
0002ca  2001              MOVS     r0,#1                 ;525
0002cc  e7f4              B        |L1.696|
                  |L1.718|
0002ce  e000              B        |L1.722|
                  |L1.720|
0002d0  b28c              UXTH     r4,r1                 ;527
                  |L1.722|
0002d2  7b13              LDRB     r3,[r2,#0xc]          ;540
0002d4  6855              LDR      r5,[r2,#4]            ;542
0002d6  b10b              CBZ      r3,|L1.732|
0002d8  2b03              CMP      r3,#3                 ;545
0002da  d10c              BNE      |L1.758|
                  |L1.732|
0002dc  6850              LDR      r0,[r2,#4]            ;547
0002de  1a40              SUBS     r0,r0,r1              ;547
0002e0  6050              STR      r0,[r2,#4]            ;547
0002e2  f1020018          ADD      r0,r2,#0x18           ;549
0002e6  6856              LDR      r6,[r2,#4]            ;549
0002e8  4286              CMP      r6,r0                 ;549
0002ea  d217              BCS      |L1.796|
0002ec  bf00              NOP                            ;550
0002ee  bf00              NOP                            ;550
0002f0  6055              STR      r5,[r2,#4]            ;554
0002f2  2001              MOVS     r0,#1                 ;556
0002f4  e7e0              B        |L1.696|
                  |L1.758|
0002f6  2b02              CMP      r3,#2                 ;559
0002f8  d001              BEQ      |L1.766|
0002fa  2b01              CMP      r3,#1                 ;559
0002fc  d10a              BNE      |L1.788|
                  |L1.766|
0002fe  2900              CMP      r1,#0                 ;561
000300  da06              BGE      |L1.784|
000302  8950              LDRH     r0,[r2,#0xa]          ;561
000304  42a0              CMP      r0,r4                 ;561
000306  db03              BLT      |L1.784|
000308  6850              LDR      r0,[r2,#4]            ;563
00030a  1a40              SUBS     r0,r0,r1              ;563
00030c  6050              STR      r0,[r2,#4]            ;563
00030e  e005              B        |L1.796|
                  |L1.784|
000310  2001              MOVS     r0,#1                 ;567
000312  e7d1              B        |L1.696|
                  |L1.788|
000314  bf00              NOP                            ;571
000316  bf00              NOP                            ;571
000318  2001              MOVS     r0,#1                 ;572
00031a  e7cd              B        |L1.696|
                  |L1.796|
00031c  8950              LDRH     r0,[r2,#0xa]          ;575
00031e  4408              ADD      r0,r0,r1              ;575
000320  8150              STRH     r0,[r2,#0xa]          ;575
000322  8910              LDRH     r0,[r2,#8]            ;576
000324  4408              ADD      r0,r0,r1              ;576
000326  8110              STRH     r0,[r2,#8]            ;576
000328  bf00              NOP                            ;578
00032a  bf00              NOP                            ;578
00032c  2000              MOVS     r0,#0                 ;581
00032e  e7c3              B        |L1.696|
;;;583    
                          ENDP

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000330  4601              MOV      r1,r0
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
000332  2000              MOVS     r0,#0
;;;709      while (p != NULL) {
000334  e002              B        |L1.828|
                  |L1.822|
;;;710        ++len;
000336  1c42              ADDS     r2,r0,#1
000338  b2d0              UXTB     r0,r2
;;;711        p = p->next;
00033a  6809              LDR      r1,[r1,#0]
                  |L1.828|
00033c  2900              CMP      r1,#0                 ;709
00033e  d1fa              BNE      |L1.822|
;;;712      }
;;;713      return len;
;;;714    }
000340  4770              BX       lr
;;;715    
                          ENDP

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000342  b570              PUSH     {r4-r6,lr}
;;;724    {
000344  4604              MOV      r4,r0
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
000346  b144              CBZ      r4,|L1.858|
;;;728        SYS_ARCH_PROTECT(old_level);
000348  f7fffffe          BL       sys_arch_protect
00034c  4605              MOV      r5,r0
;;;729        ++(p->ref);
00034e  89e0              LDRH     r0,[r4,#0xe]
000350  1c40              ADDS     r0,r0,#1
000352  81e0              STRH     r0,[r4,#0xe]
;;;730        SYS_ARCH_UNPROTECT(old_level);
000354  4628              MOV      r0,r5
000356  f7fffffe          BL       sys_arch_unprotect
                  |L1.858|
;;;731      }
;;;732    }
00035a  bd70              POP      {r4-r6,pc}
;;;733    
                          ENDP

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
00035c  b510              PUSH     {r4,lr}
;;;746    {
00035e  4602              MOV      r2,r0
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000360  bf00              NOP      
000362  b102              CBZ      r2,|L1.870|
000364  b901              CBNZ     r1,|L1.872|
                  |L1.870|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
000366  bd10              POP      {r4,pc}
                  |L1.872|
000368  bf00              NOP                            ;749
00036a  4610              MOV      r0,r2                 ;753
00036c  e004              B        |L1.888|
                  |L1.878|
00036e  8903              LDRH     r3,[r0,#8]            ;755
000370  890c              LDRH     r4,[r1,#8]            ;755
000372  4423              ADD      r3,r3,r4              ;755
000374  8103              STRH     r3,[r0,#8]            ;755
000376  6800              LDR      r0,[r0,#0]            ;753
                  |L1.888|
000378  6803              LDR      r3,[r0,#0]            ;753
00037a  2b00              CMP      r3,#0                 ;753
00037c  d1f7              BNE      |L1.878|
00037e  bf00              NOP                            ;758
000380  bf00              NOP                            ;758
000382  bf00              NOP                            ;759
000384  bf00              NOP                            ;759
000386  8903              LDRH     r3,[r0,#8]            ;761
000388  890c              LDRH     r4,[r1,#8]            ;761
00038a  4423              ADD      r3,r3,r4              ;761
00038c  8103              STRH     r3,[r0,#8]            ;761
00038e  6001              STR      r1,[r0,#0]            ;763
000390  bf00              NOP      
000392  e7e8              B        |L1.870|
;;;768    
                          ENDP

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000394  b570              PUSH     {r4-r6,lr}
;;;787    {
000396  4605              MOV      r5,r0
000398  460c              MOV      r4,r1
;;;788      pbuf_cat(h, t);
00039a  4621              MOV      r1,r4
00039c  4628              MOV      r0,r5
00039e  f7fffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
0003a2  4620              MOV      r0,r4
0003a4  f7fffffe          BL       pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
0003a8  bf00              NOP      
0003aa  bf00              NOP      
;;;792    }
0003ac  bd70              POP      {r4-r6,pc}
;;;793    
                          ENDP

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
0003ae  b570              PUSH     {r4-r6,lr}
;;;804    {
0003b0  4604              MOV      r4,r0
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
0003b2  2601              MOVS     r6,#1
;;;807      /* tail */
;;;808      q = p->next;
0003b4  6825              LDR      r5,[r4,#0]
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
0003b6  b19d              CBZ      r5,|L1.992|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
0003b8  bf00              NOP      
0003ba  bf00              NOP      
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
0003bc  8920              LDRH     r0,[r4,#8]
0003be  8961              LDRH     r1,[r4,#0xa]
0003c0  1a40              SUBS     r0,r0,r1
0003c2  8128              STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
0003c4  2000              MOVS     r0,#0
0003c6  6020              STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
0003c8  8960              LDRH     r0,[r4,#0xa]
0003ca  8120              STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
0003cc  bf00              NOP      
0003ce  bf00              NOP      
;;;821        tail_gone = pbuf_free(q);
0003d0  4628              MOV      r0,r5
0003d2  f7fffffe          BL       pbuf_free
0003d6  4606              MOV      r6,r0
;;;822        if (tail_gone > 0) {
0003d8  2e00              CMP      r6,#0
0003da  dd01              BLE      |L1.992|
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
0003dc  bf00              NOP      
0003de  bf00              NOP      
                  |L1.992|
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
0003e0  bf00              NOP      
0003e2  bf00              NOP      
;;;830      return ((tail_gone > 0) ? NULL : q);
0003e4  2e00              CMP      r6,#0
0003e6  dd01              BLE      |L1.1004|
0003e8  2000              MOVS     r0,#0
                  |L1.1002|
;;;831    }
0003ea  bd70              POP      {r4-r6,pc}
                  |L1.1004|
0003ec  4628              MOV      r0,r5                 ;830
0003ee  e7fc              B        |L1.1002|
;;;832    
                          ENDP

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
0003f0  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
0003f4  4605              MOV      r5,r0
0003f6  460c              MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
0003f8  2600              MOVS     r6,#0
0003fa  2700              MOVS     r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
0003fc  bf00              NOP      
0003fe  bf00              NOP      
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000400  bf00              NOP      
000402  b125              CBZ      r5,|L1.1038|
000404  b11c              CBZ      r4,|L1.1038|
000406  8928              LDRH     r0,[r5,#8]
000408  8921              LDRH     r1,[r4,#8]
00040a  4288              CMP      r0,r1
00040c  da03              BGE      |L1.1046|
                  |L1.1038|
00040e  f06f000d          MVN      r0,#0xd
                  |L1.1042|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
000412  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1046|
000416  bf00              NOP                            ;860
000418  bf00              NOP                            ;864
                  |L1.1050|
00041a  8968              LDRH     r0,[r5,#0xa]          ;867
00041c  1b80              SUBS     r0,r0,r6              ;867
00041e  8961              LDRH     r1,[r4,#0xa]          ;867
000420  1bc9              SUBS     r1,r1,r7              ;867
000422  4288              CMP      r0,r1                 ;867
000424  db04              BLT      |L1.1072|
000426  8960              LDRH     r0,[r4,#0xa]          ;869
000428  1bc0              SUBS     r0,r0,r7              ;869
00042a  fa1ff880          UXTH     r8,r0                 ;869
00042e  e003              B        |L1.1080|
                  |L1.1072|
000430  8968              LDRH     r0,[r5,#0xa]          ;872
000432  1b80              SUBS     r0,r0,r6              ;872
000434  fa1ff880          UXTH     r8,r0                 ;872
                  |L1.1080|
000438  6862              LDR      r2,[r4,#4]            ;874
00043a  19d1              ADDS     r1,r2,r7              ;874
00043c  686a              LDR      r2,[r5,#4]            ;874
00043e  1990              ADDS     r0,r2,r6              ;874
000440  4642              MOV      r2,r8                 ;874
000442  f7fffffe          BL       __aeabi_memcpy
000446  eb060008          ADD      r0,r6,r8              ;875
00044a  b286              UXTH     r6,r0                 ;875
00044c  eb070008          ADD      r0,r7,r8              ;876
000450  b287              UXTH     r7,r0                 ;876
000452  bf00              NOP                            ;877
000454  bf00              NOP                            ;877
000456  bf00              NOP                            ;878
000458  bf00              NOP                            ;878
00045a  8960              LDRH     r0,[r4,#0xa]          ;879
00045c  42b8              CMP      r0,r7                 ;879
00045e  dc01              BGT      |L1.1124|
000460  2700              MOVS     r7,#0                 ;881
000462  6824              LDR      r4,[r4,#0]            ;882
                  |L1.1124|
000464  8968              LDRH     r0,[r5,#0xa]          ;884
000466  42b0              CMP      r0,r6                 ;884
000468  d108              BNE      |L1.1148|
00046a  2600              MOVS     r6,#0                 ;886
00046c  682d              LDR      r5,[r5,#0]            ;887
00046e  bf00              NOP                            ;888
000470  b91d              CBNZ     r5,|L1.1146|
000472  b114              CBZ      r4,|L1.1146|
000474  f06f000d          MVN      r0,#0xd               ;888
000478  e7cb              B        |L1.1042|
                  |L1.1146|
00047a  bf00              NOP                            ;888
                  |L1.1148|
00047c  b154              CBZ      r4,|L1.1172|
00047e  8960              LDRH     r0,[r4,#0xa]          ;891
000480  8921              LDRH     r1,[r4,#8]            ;891
000482  4288              CMP      r0,r1                 ;891
000484  d106              BNE      |L1.1172|
000486  bf00              NOP                            ;893
000488  6820              LDR      r0,[r4,#0]            ;893
00048a  b110              CBZ      r0,|L1.1170|
00048c  f06f0005          MVN      r0,#5                 ;893
000490  e7bf              B        |L1.1042|
                  |L1.1170|
000492  bf00              NOP                            ;893
                  |L1.1172|
000494  b155              CBZ      r5,|L1.1196|
000496  8968              LDRH     r0,[r5,#0xa]          ;896
000498  8929              LDRH     r1,[r5,#8]            ;896
00049a  4288              CMP      r0,r1                 ;896
00049c  d106              BNE      |L1.1196|
00049e  bf00              NOP                            ;898
0004a0  6828              LDR      r0,[r5,#0]            ;898
0004a2  b110              CBZ      r0,|L1.1194|
0004a4  f06f0005          MVN      r0,#5                 ;898
0004a8  e7b3              B        |L1.1042|
                  |L1.1194|
0004aa  bf00              NOP                            ;898
                  |L1.1196|
0004ac  2c00              CMP      r4,#0                 ;901
0004ae  d1b4              BNE      |L1.1050|
0004b0  bf00              NOP                            ;902
0004b2  bf00              NOP                            ;902
0004b4  2000              MOVS     r0,#0                 ;903
0004b6  e7ac              B        |L1.1042|
;;;905    
                          ENDP

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
0004b8  e92d5ff0          PUSH     {r4-r12,lr}
;;;919    {
0004bc  4680              MOV      r8,r0
0004be  4689              MOV      r9,r1
0004c0  4616              MOV      r6,r2
0004c2  461d              MOV      r5,r3
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
0004c4  f04f0b00          MOV      r11,#0
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
0004c8  bf00              NOP      
0004ca  f1b80f00          CMP      r8,#0
0004ce  d102              BNE      |L1.1238|
0004d0  2000              MOVS     r0,#0
                  |L1.1234|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
;;;927    
;;;928      left = 0;
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
0004d2  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1238|
0004d6  bf00              NOP                            ;925
0004d8  bf00              NOP                            ;926
0004da  f1b90f00          CMP      r9,#0                 ;926
0004de  d101              BNE      |L1.1252|
0004e0  2000              MOVS     r0,#0                 ;926
0004e2  e7f6              B        |L1.1234|
                  |L1.1252|
0004e4  bf00              NOP                            ;926
0004e6  f04f0a00          MOV      r10,#0                ;928
0004ea  f1b80f00          CMP      r8,#0                 ;930
0004ee  d002              BEQ      |L1.1270|
0004f0  f1b90f00          CMP      r9,#0                 ;930
0004f4  d101              BNE      |L1.1274|
                  |L1.1270|
0004f6  2000              MOVS     r0,#0                 ;931
0004f8  e7eb              B        |L1.1234|
                  |L1.1274|
0004fa  4644              MOV      r4,r8                 ;935
0004fc  e020              B        |L1.1344|
                  |L1.1278|
0004fe  b135              CBZ      r5,|L1.1294|
000500  8960              LDRH     r0,[r4,#0xa]          ;936
000502  42a8              CMP      r0,r5                 ;936
000504  dc03              BGT      |L1.1294|
000506  8960              LDRH     r0,[r4,#0xa]          ;938
000508  1a28              SUBS     r0,r5,r0              ;938
00050a  b285              UXTH     r5,r0                 ;938
00050c  e017              B        |L1.1342|
                  |L1.1294|
00050e  8960              LDRH     r0,[r4,#0xa]          ;941
000510  1b40              SUBS     r0,r0,r5              ;941
000512  b287              UXTH     r7,r0                 ;941
000514  42b7              CMP      r7,r6                 ;942
000516  dd00              BLE      |L1.1306|
000518  4637              MOV      r7,r6                 ;943
                  |L1.1306|
00051a  6862              LDR      r2,[r4,#4]            ;945
00051c  1951              ADDS     r1,r2,r5              ;945
00051e  eb09000a          ADD      r0,r9,r10             ;945
000522  463a              MOV      r2,r7                 ;945
000524  f7fffffe          BL       __aeabi_memcpy
000528  eb0b0007          ADD      r0,r11,r7             ;946
00052c  fa1ffb80          UXTH     r11,r0                ;946
000530  eb0a0007          ADD      r0,r10,r7             ;947
000534  fa1ffa80          UXTH     r10,r0                ;947
000538  1bf0              SUBS     r0,r6,r7              ;948
00053a  b286              UXTH     r6,r0                 ;948
00053c  2500              MOVS     r5,#0                 ;949
                  |L1.1342|
00053e  6824              LDR      r4,[r4,#0]            ;935
                  |L1.1344|
000540  b10e              CBZ      r6,|L1.1350|
000542  2c00              CMP      r4,#0                 ;935
000544  d1db              BNE      |L1.1278|
                  |L1.1350|
000546  4658              MOV      r0,r11                ;952
000548  e7c3              B        |L1.1234|
;;;954    
                          ENDP

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
00054a  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
00054e  4604              MOV      r4,r0
000550  460e              MOV      r6,r1
000552  4691              MOV      r9,r2
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
000554  46c8              MOV      r8,r9
;;;971      u16_t copied_total = 0;
000556  f04f0a00          MOV      r10,#0
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
00055a  bf00              NOP      
00055c  b914              CBNZ     r4,|L1.1380|
00055e  2000              MOVS     r0,#0
                  |L1.1376|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
000560  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1380|
000564  bf00              NOP                            ;973
000566  bf00              NOP                            ;974
000568  b90e              CBNZ     r6,|L1.1390|
00056a  2000              MOVS     r0,#0                 ;974
00056c  e7f8              B        |L1.1376|
                  |L1.1390|
00056e  bf00              NOP                            ;974
000570  b11c              CBZ      r4,|L1.1402|
000572  b116              CBZ      r6,|L1.1402|
000574  8920              LDRH     r0,[r4,#8]            ;976
000576  4548              CMP      r0,r9                 ;976
000578  da02              BGE      |L1.1408|
                  |L1.1402|
00057a  f06f000d          MVN      r0,#0xd               ;977
00057e  e7ef              B        |L1.1376|
                  |L1.1408|
000580  4625              MOV      r5,r4                 ;981
000582  e015              B        |L1.1456|
                  |L1.1412|
000584  bf00              NOP                            ;982
000586  bf00              NOP                            ;982
000588  4647              MOV      r7,r8                 ;983
00058a  8968              LDRH     r0,[r5,#0xa]          ;984
00058c  42b8              CMP      r0,r7                 ;984
00058e  da00              BGE      |L1.1426|
000590  896f              LDRH     r7,[r5,#0xa]          ;986
                  |L1.1426|
000592  eb06010a          ADD      r1,r6,r10             ;989
000596  463a              MOV      r2,r7                 ;989
000598  6868              LDR      r0,[r5,#4]            ;989
00059a  f7fffffe          BL       __aeabi_memcpy
00059e  eba80007          SUB      r0,r8,r7              ;990
0005a2  fa1ff880          UXTH     r8,r0                 ;990
0005a6  eb0a0007          ADD      r0,r10,r7             ;991
0005aa  fa1ffa80          UXTH     r10,r0                ;991
0005ae  682d              LDR      r5,[r5,#0]            ;981
                  |L1.1456|
0005b0  f1b80f00          CMP      r8,#0                 ;981
0005b4  d1e6              BNE      |L1.1412|
0005b6  bf00              NOP                            ;993
0005b8  bf00              NOP                            ;993
0005ba  2000              MOVS     r0,#0                 ;994
0005bc  e7d0              B        |L1.1376|
;;;996    
                          ENDP

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
0005be  e92d41f0          PUSH     {r4-r8,lr}
;;;1011   {
0005c2  4604              MOV      r4,r0
0005c4  460e              MOV      r6,r1
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
0005c6  6820              LDR      r0,[r4,#0]
0005c8  b910              CBNZ     r0,|L1.1488|
;;;1015       return p;
0005ca  4620              MOV      r0,r4
                  |L1.1484|
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
;;;1018     if (q == NULL) {
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
;;;1024     pbuf_free(p);
;;;1025     return q;
;;;1026   }
0005cc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1488|
0005d0  8921              LDRH     r1,[r4,#8]            ;1017
0005d2  2200              MOVS     r2,#0                 ;1017
0005d4  4630              MOV      r0,r6                 ;1017
0005d6  f7fffffe          BL       pbuf_alloc
0005da  4605              MOV      r5,r0                 ;1017
0005dc  b90d              CBNZ     r5,|L1.1506|
0005de  4620              MOV      r0,r4                 ;1020
0005e0  e7f4              B        |L1.1484|
                  |L1.1506|
0005e2  4621              MOV      r1,r4                 ;1022
0005e4  4628              MOV      r0,r5                 ;1022
0005e6  f7fffffe          BL       pbuf_copy
0005ea  4607              MOV      r7,r0                 ;1022
0005ec  bf00              NOP                            ;1023
0005ee  bf00              NOP                            ;1023
0005f0  4620              MOV      r0,r4                 ;1024
0005f2  f7fffffe          BL       pbuf_free
0005f6  4628              MOV      r0,r5                 ;1025
0005f8  e7e8              B        |L1.1484|
;;;1027   
                          ENDP

                  pbuf_get_at PROC
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
0005fa  b510              PUSH     {r4,lr}
;;;1078   {
0005fc  4603              MOV      r3,r0
0005fe  460c              MOV      r4,r1
;;;1079     u16_t copy_from = offset;
000600  4622              MOV      r2,r4
;;;1080     struct pbuf* q = p;
000602  4619              MOV      r1,r3
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
000604  e003              B        |L1.1550|
                  |L1.1542|
;;;1084       copy_from -= q->len;
000606  8948              LDRH     r0,[r1,#0xa]
000608  1a10              SUBS     r0,r2,r0
00060a  b282              UXTH     r2,r0
;;;1085       q = q->next;
00060c  6809              LDR      r1,[r1,#0]
                  |L1.1550|
00060e  b111              CBZ      r1,|L1.1558|
000610  8948              LDRH     r0,[r1,#0xa]          ;1083
000612  4290              CMP      r0,r2                 ;1083
000614  ddf7              BLE      |L1.1542|
                  |L1.1558|
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
000616  b129              CBZ      r1,|L1.1572|
000618  8948              LDRH     r0,[r1,#0xa]
00061a  4290              CMP      r0,r2
00061c  dd02              BLE      |L1.1572|
;;;1089       return ((u8_t*)q->payload)[copy_from];
00061e  6848              LDR      r0,[r1,#4]
000620  5c80              LDRB     r0,[r0,r2]
                  |L1.1570|
;;;1090     }
;;;1091     return 0;
;;;1092   }
000622  bd10              POP      {r4,pc}
                  |L1.1572|
000624  2000              MOVS     r0,#0                 ;1091
000626  e7fc              B        |L1.1570|
;;;1093   
                          ENDP

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000628  e92d4ff8          PUSH     {r3-r11,lr}
;;;1105   {
00062c  4607              MOV      r7,r0
00062e  4688              MOV      r8,r1
000630  4691              MOV      r9,r2
000632  469a              MOV      r10,r3
;;;1106     u16_t start = offset;
000634  4646              MOV      r6,r8
;;;1107     struct pbuf* q = p;
000636  463c              MOV      r4,r7
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
000638  e003              B        |L1.1602|
                  |L1.1594|
;;;1111       start -= q->len;
00063a  8960              LDRH     r0,[r4,#0xa]
00063c  1a30              SUBS     r0,r6,r0
00063e  b286              UXTH     r6,r0
;;;1112       q = q->next;
000640  6824              LDR      r4,[r4,#0]
                  |L1.1602|
000642  b114              CBZ      r4,|L1.1610|
000644  8960              LDRH     r0,[r4,#0xa]          ;1110
000646  42b0              CMP      r0,r6                 ;1110
000648  ddf7              BLE      |L1.1594|
                  |L1.1610|
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
00064a  b1d4              CBZ      r4,|L1.1666|
00064c  8960              LDRH     r0,[r4,#0xa]
00064e  42b0              CMP      r0,r6
000650  dd17              BLE      |L1.1666|
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
000652  2500              MOVS     r5,#0
000654  e011              B        |L1.1658|
                  |L1.1622|
;;;1118         u8_t a = pbuf_get_at(q, start + i);
000656  1970              ADDS     r0,r6,r5
000658  b281              UXTH     r1,r0
00065a  4620              MOV      r0,r4
00065c  f7fffffe          BL       pbuf_get_at
000660  4683              MOV      r11,r0
;;;1119         u8_t b = ((u8_t*)s2)[i];
000662  f8190005          LDRB     r0,[r9,r5]
000666  9000              STR      r0,[sp,#0]
;;;1120         if (a != b) {
000668  9800              LDR      r0,[sp,#0]
00066a  4583              CMP      r11,r0
00066c  d003              BEQ      |L1.1654|
;;;1121           return i+1;
00066e  1c68              ADDS     r0,r5,#1
000670  b280              UXTH     r0,r0
                  |L1.1650|
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
;;;1127   }
000672  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.1654|
000676  1c68              ADDS     r0,r5,#1              ;1117
000678  b285              UXTH     r5,r0                 ;1117
                  |L1.1658|
00067a  4555              CMP      r5,r10                ;1117
00067c  dbeb              BLT      |L1.1622|
00067e  2000              MOVS     r0,#0                 ;1124
000680  e7f7              B        |L1.1650|
                  |L1.1666|
000682  f64f70ff          MOV      r0,#0xffff            ;1126
000686  e7f4              B        |L1.1650|
;;;1128   
                          ENDP

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000688  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   {
00068c  4606              MOV      r6,r0
00068e  4688              MOV      r8,r1
000690  4615              MOV      r5,r2
000692  461f              MOV      r7,r3
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
000694  8930              LDRH     r0,[r6,#8]
000696  1b40              SUBS     r0,r0,r5
000698  fa1ffa80          UXTH     r10,r0
;;;1144     if (p->tot_len >= mem_len + start_offset) {
00069c  8930              LDRH     r0,[r6,#8]
00069e  19e9              ADDS     r1,r5,r7
0006a0  4288              CMP      r0,r1
0006a2  db14              BLT      |L1.1742|
;;;1145       for(i = start_offset; i <= max; ) {
0006a4  463c              MOV      r4,r7
0006a6  e010              B        |L1.1738|
                  |L1.1704|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
0006a8  462b              MOV      r3,r5
0006aa  4642              MOV      r2,r8
0006ac  4621              MOV      r1,r4
0006ae  4630              MOV      r0,r6
0006b0  f7fffffe          BL       pbuf_memcmp
0006b4  4681              MOV      r9,r0
;;;1147         if (plus == 0) {
0006b6  f1b90f00          CMP      r9,#0
0006ba  d102              BNE      |L1.1730|
;;;1148           return i;
0006bc  4620              MOV      r0,r4
                  |L1.1726|
;;;1149         } else {
;;;1150           i += plus;
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
0006be  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1730|
0006c2  eb040009          ADD      r0,r4,r9              ;1150
0006c6  b284              UXTH     r4,r0                 ;1150
0006c8  bf00              NOP                            ;1152
                  |L1.1738|
0006ca  4554              CMP      r4,r10                ;1145
0006cc  ddec              BLE      |L1.1704|
                  |L1.1742|
0006ce  f64f70ff          MOV      r0,#0xffff            ;1154
0006d2  e7f4              B        |L1.1726|
;;;1156   
                          ENDP

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
0006d4  b570              PUSH     {r4-r6,lr}
;;;1169   {
0006d6  4606              MOV      r6,r0
0006d8  460c              MOV      r4,r1
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
0006da  b134              CBZ      r4,|L1.1770|
0006dc  7820              LDRB     r0,[r4,#0]
0006de  b120              CBZ      r0,|L1.1770|
0006e0  8930              LDRH     r0,[r6,#8]
0006e2  f64f71ff          MOV      r1,#0xffff
0006e6  4288              CMP      r0,r1
0006e8  d102              BNE      |L1.1776|
                  |L1.1770|
;;;1172       return 0xFFFF;
0006ea  f64f70ff          MOV      r0,#0xffff
                  |L1.1774|
;;;1173     }
;;;1174     substr_len = strlen(substr);
;;;1175     if (substr_len >= 0xFFFF) {
;;;1176       return 0xFFFF;
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
0006ee  bd70              POP      {r4-r6,pc}
                  |L1.1776|
0006f0  4620              MOV      r0,r4                 ;1174
0006f2  f7fffffe          BL       strlen
0006f6  4605              MOV      r5,r0                 ;1174
0006f8  f64f70ff          MOV      r0,#0xffff            ;1175
0006fc  4285              CMP      r5,r0                 ;1175
0006fe  d300              BCC      |L1.1794|
000700  e7f5              B        |L1.1774|
                  |L1.1794|
000702  b2aa              UXTH     r2,r5                 ;1178
000704  2300              MOVS     r3,#0                 ;1178
000706  4621              MOV      r1,r4                 ;1178
000708  4630              MOV      r0,r6                 ;1178
00070a  f7fffffe          BL       pbuf_memfind
00070e  e7ee              B        |L1.1774|
                          ENDP

