; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\hal_cm.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\hal_cm.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\hal_cm.crf ..\..\libraries\rtx-v4.73\SRC\HAL_CM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_init_stack PROC
;;;54     
;;;55     void rt_init_stack (P_TCB p_TCB, FUNCP task_body) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;56       /* Prepare TCB and saved context for a first time start of a task. */
;;;57       U32 *stk,i,size;
;;;58     
;;;59       /* Prepare a complete interrupt frame for first task start */
;;;60       size = p_TCB->priv_stack >> 2;
000006  8cd5              LDRH     r5,[r2,#0x26]
000008  10ac              ASRS     r4,r5,#2
;;;61       if (size == 0) {
00000a  b91c              CBNZ     r4,|L1.20|
;;;62         size = (U16)os_stackinfo >> 2;
00000c  4d1f              LDR      r5,|L1.140|
00000e  882d              LDRH     r5,[r5,#0]  ; os_stackinfo
000010  f3c5048d          UBFX     r4,r5,#2,#14
                  |L1.20|
;;;63       }
;;;64     
;;;65       /* Write to the top of stack. */
;;;66       stk = &p_TCB->stack[size];
000014  6ad5              LDR      r5,[r2,#0x2c]
000016  eb050084          ADD      r0,r5,r4,LSL #2
;;;67     
;;;68       /* Auto correct to 8-byte ARM stack alignment. */
;;;69       if ((U32)stk & 0x04) {
00001a  f0000504          AND      r5,r0,#4
00001e  b105              CBZ      r5,|L1.34|
;;;70         stk--;
000020  1f00              SUBS     r0,r0,#4
                  |L1.34|
;;;71       }
;;;72     
;;;73       stk -= 16;
000022  3840              SUBS     r0,r0,#0x40
;;;74     
;;;75       /* Default xPSR and initial PC */
;;;76       stk[15] = INITIAL_xPSR;
000024  f04f7580          MOV      r5,#0x1000000
000028  63c5              STR      r5,[r0,#0x3c]
;;;77       stk[14] = (U32)task_body;
00002a  6383              STR      r3,[r0,#0x38]
;;;78     
;;;79       /* Clear R4-R11,R0-R3,R12,LR registers. */
;;;80       for (i = 0; i < 14; i++) {
00002c  2100              MOVS     r1,#0
00002e  e003              B        |L1.56|
                  |L1.48|
;;;81         stk[i] = 0;
000030  2500              MOVS     r5,#0
000032  f8405021          STR      r5,[r0,r1,LSL #2]
000036  1c49              ADDS     r1,r1,#1              ;80
                  |L1.56|
000038  290e              CMP      r1,#0xe               ;80
00003a  d3f9              BCC      |L1.48|
;;;82       }
;;;83     
;;;84       /* Assign a void pointer to R0. */
;;;85       stk[8] = (U32)p_TCB->msg;
00003c  69d5              LDR      r5,[r2,#0x1c]
00003e  6205              STR      r5,[r0,#0x20]
;;;86     
;;;87       /* Initial Task stack pointer. */
;;;88       p_TCB->tsk_stack = (U32)stk;
000040  6290              STR      r0,[r2,#0x28]
;;;89     
;;;90       /* Task entry point. */
;;;91       p_TCB->ptask = task_body;
000042  6313              STR      r3,[r2,#0x30]
;;;92     
;;;93       /* Set a magic word for checking of stack overflow. */
;;;94       p_TCB->stack[0] = MAGIC_WORD;
000044  4d12              LDR      r5,|L1.144|
000046  6ad6              LDR      r6,[r2,#0x2c]
000048  6035              STR      r5,[r6,#0]
;;;95     }
00004a  bd70              POP      {r4-r6,pc}
;;;96     
                          ENDP

                  rt_ret_val PROC
;;;115    
;;;116    void rt_ret_val (P_TCB p_TCB, U32 v0) {
00004c  b570              PUSH     {r4-r6,lr}
00004e  4605              MOV      r5,r0
000050  460c              MOV      r4,r1
;;;117      U32 *ret;
;;;118    
;;;119      ret = rt_ret_regs(p_TCB);
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       rt_ret_regs
000058  4606              MOV      r6,r0
;;;120      ret[0] = v0;
00005a  6034              STR      r4,[r6,#0]
;;;121    }
00005c  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP

                  rt_ret_val2 PROC
;;;123    void rt_ret_val2(P_TCB p_TCB, U32 v0, U32 v1) {
00005e  e92d41f0          PUSH     {r4-r8,lr}
000062  4607              MOV      r7,r0
000064  460c              MOV      r4,r1
000066  4615              MOV      r5,r2
;;;124      U32 *ret;
;;;125    
;;;126      ret = rt_ret_regs(p_TCB);
000068  4638              MOV      r0,r7
00006a  f7fffffe          BL       rt_ret_regs
00006e  4606              MOV      r6,r0
;;;127      ret[0] = v0;
000070  6034              STR      r4,[r6,#0]
;;;128      ret[1] = v1;
000072  6075              STR      r5,[r6,#4]
;;;129    }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;130    
                          ENDP

                  rt_ret_regs PROC
;;;99     
;;;100    static __inline U32 *rt_ret_regs (P_TCB p_TCB) {
000078  4601              MOV      r1,r0
;;;101      /* Get pointer to task return value registers (R0..R3) in Stack */
;;;102    #if (__TARGET_FPU_VFP)
;;;103      if (p_TCB->stack_frame) {
00007a  f8910025          LDRB     r0,[r1,#0x25]
00007e  b110              CBZ      r0,|L1.134|
;;;104        /* Extended Stack Frame: R4-R11,S16-S31,R0-R3,R12,LR,PC,xPSR,S0-S15,FPSCR */
;;;105        return (U32 *)(p_TCB->tsk_stack + 8*4 + 16*4);
000080  6a88              LDR      r0,[r1,#0x28]
000082  3060              ADDS     r0,r0,#0x60
                  |L1.132|
;;;106      } else {
;;;107        /* Basic Stack Frame: R4-R11,R0-R3,R12,LR,PC,xPSR */
;;;108        return (U32 *)(p_TCB->tsk_stack + 8*4);
;;;109      }
;;;110    #else
;;;111      /* Stack Frame: R4-R11,R0-R3,R12,LR,PC,xPSR */
;;;112      return (U32 *)(p_TCB->tsk_stack + 8*4);
;;;113    #endif
;;;114    }
000084  4770              BX       lr
                  |L1.134|
000086  6a88              LDR      r0,[r1,#0x28]         ;108
000088  3020              ADDS     r0,r0,#0x20           ;108
00008a  e7fb              B        |L1.132|
;;;115    
                          ENDP

                  |L1.140|
                          DCD      os_stackinfo
                  |L1.144|
                          DCD      0xe25a2ea5
