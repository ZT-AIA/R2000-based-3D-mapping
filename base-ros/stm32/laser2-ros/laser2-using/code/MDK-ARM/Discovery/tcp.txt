; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\tcp.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\tcp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\tcp.crf ..\..\libraries\lwip-1.4.1\src\core\tcp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  4770              BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP

                  tcp_seg_free PROC
;;;1142   void
;;;1143   tcp_seg_free(struct tcp_seg *seg)
000002  b510              PUSH     {r4,lr}
;;;1144   {
000004  4604              MOV      r4,r0
;;;1145     if (seg != NULL) {
000006  b144              CBZ      r4,|L1.26|
;;;1146       if (seg->p != NULL) {
000008  6860              LDR      r0,[r4,#4]
00000a  b110              CBZ      r0,|L1.18|
;;;1147         pbuf_free(seg->p);
00000c  6860              LDR      r0,[r4,#4]
00000e  f7fffffe          BL       pbuf_free
                  |L1.18|
;;;1148   #if TCP_DEBUG
;;;1149         seg->p = NULL;
;;;1150   #endif /* TCP_DEBUG */
;;;1151       }
;;;1152       memp_free(MEMP_TCP_SEG, seg);
000012  4621              MOV      r1,r4
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       memp_free
                  |L1.26|
;;;1153     }
;;;1154   }
00001a  bd10              POP      {r4,pc}
;;;1155   
                          ENDP

                  tcp_segs_free PROC
;;;1127   void
;;;1128   tcp_segs_free(struct tcp_seg *seg)
00001c  b570              PUSH     {r4-r6,lr}
;;;1129   {
00001e  4604              MOV      r4,r0
;;;1130     while (seg != NULL) {
000020  e005              B        |L1.46|
                  |L1.34|
;;;1131       struct tcp_seg *next = seg->next;
000022  6825              LDR      r5,[r4,#0]
;;;1132       tcp_seg_free(seg);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       tcp_seg_free
;;;1133       seg = next;
00002a  462c              MOV      r4,r5
;;;1134     }
00002c  bf00              NOP      
                  |L1.46|
00002e  2c00              CMP      r4,#0                 ;1130
000030  d1f7              BNE      |L1.34|
;;;1135   }
000032  bd70              POP      {r4-r6,pc}
;;;1136   
                          ENDP

                  tcp_pcb_purge PROC
;;;1469   void
;;;1470   tcp_pcb_purge(struct tcp_pcb *pcb)
000034  b510              PUSH     {r4,lr}
;;;1471   {
000036  4604              MOV      r4,r0
;;;1472     if (pcb->state != CLOSED &&
000038  7e20              LDRB     r0,[r4,#0x18]
00003a  2800              CMP      r0,#0
00003c  d044              BEQ      |L1.200|
;;;1473        pcb->state != TIME_WAIT &&
00003e  7e20              LDRB     r0,[r4,#0x18]
000040  280a              CMP      r0,#0xa
000042  d041              BEQ      |L1.200|
;;;1474        pcb->state != LISTEN) {
000044  7e20              LDRB     r0,[r4,#0x18]
000046  2801              CMP      r0,#1
000048  d03e              BEQ      |L1.200|
;;;1475   
;;;1476       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
00004a  bf00              NOP      
00004c  bf00              NOP      
;;;1477   
;;;1478   #if TCP_LISTEN_BACKLOG
;;;1479       if (pcb->state == SYN_RCVD) {
00004e  7e20              LDRB     r0,[r4,#0x18]
000050  2803              CMP      r0,#3
000052  d11a              BNE      |L1.138|
;;;1480         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1481         struct tcp_pcb_listen *lpcb;
;;;1482         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
000054  bf00              NOP      
000056  bf00              NOP      
;;;1483           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1484         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
000058  49f8              LDR      r1,|L1.1084|
00005a  6808              LDR      r0,[r1,#0]  ; tcp_listen_pcbs
00005c  e011              B        |L1.130|
                  |L1.94|
;;;1485           if ((lpcb->local_port == pcb->local_port) &&
00005e  8b41              LDRH     r1,[r0,#0x1a]
000060  8b62              LDRH     r2,[r4,#0x1a]
000062  4291              CMP      r1,r2
000064  d10c              BNE      |L1.128|
;;;1486               (ip_addr_isany(&lpcb->local_ip) ||
000066  b128              CBZ      r0,|L1.116|
000068  6801              LDR      r1,[r0,#0]
00006a  b119              CBZ      r1,|L1.116|
;;;1487                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
00006c  6821              LDR      r1,[r4,#0]
00006e  6802              LDR      r2,[r0,#0]
000070  4291              CMP      r1,r2
000072  d105              BNE      |L1.128|
                  |L1.116|
;;;1488               /* port and address of the listen pcb match the timed-out pcb */
;;;1489               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
000074  bf00              NOP      
000076  bf00              NOP      
;;;1490                 lpcb->accepts_pending > 0);
;;;1491               lpcb->accepts_pending--;
000078  7f41              LDRB     r1,[r0,#0x1d]
00007a  1e49              SUBS     r1,r1,#1
00007c  7741              STRB     r1,[r0,#0x1d]
;;;1492               break;
00007e  e002              B        |L1.134|
                  |L1.128|
000080  68c0              LDR      r0,[r0,#0xc]          ;1484
                  |L1.130|
000082  2800              CMP      r0,#0                 ;1484
000084  d1eb              BNE      |L1.94|
                  |L1.134|
000086  bf00              NOP      
;;;1493             }
;;;1494         }
;;;1495       }
000088  bf00              NOP      
                  |L1.138|
;;;1496   #endif /* TCP_LISTEN_BACKLOG */
;;;1497   
;;;1498   
;;;1499       if (pcb->refused_data != NULL) {
00008a  6f60              LDR      r0,[r4,#0x74]
00008c  b130              CBZ      r0,|L1.156|
;;;1500         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
00008e  bf00              NOP      
000090  bf00              NOP      
;;;1501         pbuf_free(pcb->refused_data);
000092  6f60              LDR      r0,[r4,#0x74]
000094  f7fffffe          BL       pbuf_free
;;;1502         pcb->refused_data = NULL;
000098  2000              MOVS     r0,#0
00009a  6760              STR      r0,[r4,#0x74]
                  |L1.156|
;;;1503       }
;;;1504       if (pcb->unsent != NULL) {
00009c  6ee0              LDR      r0,[r4,#0x6c]
00009e  b108              CBZ      r0,|L1.164|
;;;1505         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
0000a0  bf00              NOP      
0000a2  bf00              NOP      
                  |L1.164|
;;;1506       }
;;;1507       if (pcb->unacked != NULL) {
0000a4  6f20              LDR      r0,[r4,#0x70]
0000a6  b108              CBZ      r0,|L1.172|
;;;1508         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
0000a8  bf00              NOP      
0000aa  bf00              NOP      
                  |L1.172|
;;;1509       }
;;;1510   #if TCP_QUEUE_OOSEQ
;;;1511       if (pcb->ooseq != NULL) {
;;;1512         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1513       }
;;;1514       tcp_segs_free(pcb->ooseq);
;;;1515       pcb->ooseq = NULL;
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517   
;;;1518       /* Stop the retransmission timer as it will expect data on unacked
;;;1519          queue if it fires */
;;;1520       pcb->rtime = -1;
0000ac  f04f30ff          MOV      r0,#0xffffffff
0000b0  86a0              STRH     r0,[r4,#0x34]
;;;1521   
;;;1522       tcp_segs_free(pcb->unsent);
0000b2  6ee0              LDR      r0,[r4,#0x6c]
0000b4  f7fffffe          BL       tcp_segs_free
;;;1523       tcp_segs_free(pcb->unacked);
0000b8  6f20              LDR      r0,[r4,#0x70]
0000ba  f7fffffe          BL       tcp_segs_free
;;;1524       pcb->unacked = pcb->unsent = NULL;
0000be  2000              MOVS     r0,#0
0000c0  66e0              STR      r0,[r4,#0x6c]
0000c2  6720              STR      r0,[r4,#0x70]
;;;1525   #if TCP_OVERSIZE
;;;1526       pcb->unsent_oversize = 0;
0000c4  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L1.200|
;;;1527   #endif /* TCP_OVERSIZE */
;;;1528     }
;;;1529   }
0000c8  bd10              POP      {r4,pc}
;;;1530   
                          ENDP

                  tcp_slowtmr PROC
;;;787    void
;;;788    tcp_slowtmr(void)
0000ca  e92d4ffe          PUSH     {r1-r11,lr}
;;;789    {
;;;790      struct tcp_pcb *pcb, *prev;
;;;791      u16_t eff_wnd;
;;;792      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;793      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;794      err_t err;
;;;795    
;;;796      err = ERR_OK;
0000ce  2000              MOVS     r0,#0
0000d0  9002              STR      r0,[sp,#8]
;;;797    
;;;798      ++tcp_ticks;
0000d2  48db              LDR      r0,|L1.1088|
0000d4  6800              LDR      r0,[r0,#0]  ; tcp_ticks
0000d6  1c40              ADDS     r0,r0,#1
0000d8  49d9              LDR      r1,|L1.1088|
0000da  6008              STR      r0,[r1,#0]  ; tcp_ticks
;;;799      ++tcp_timer_ctr;
0000dc  48d9              LDR      r0,|L1.1092|
0000de  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
0000e0  1c40              ADDS     r0,r0,#1
0000e2  49d8              LDR      r1,|L1.1092|
0000e4  7008              STRB     r0,[r1,#0]
;;;800    
;;;801    tcp_slowtmr_start:
0000e6  bf00              NOP      
                  |L1.232|
;;;802      /* Steps through all of the active PCBs. */
;;;803      prev = NULL;
0000e8  2500              MOVS     r5,#0
;;;804      pcb = tcp_active_pcbs;
0000ea  48d7              LDR      r0,|L1.1096|
0000ec  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;805      if (pcb == NULL) {
0000ee  b90c              CBNZ     r4,|L1.244|
;;;806        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
0000f0  bf00              NOP      
0000f2  bf00              NOP      
                  |L1.244|
;;;807      }
;;;808      while (pcb != NULL) {
0000f4  e15b              B        |L1.942|
                  |L1.246|
;;;809        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
0000f6  bf00              NOP      
0000f8  bf00              NOP      
;;;810        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
0000fa  bf00              NOP      
0000fc  bf00              NOP      
;;;811        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
0000fe  bf00              NOP      
000100  bf00              NOP      
;;;812        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
000102  bf00              NOP      
000104  bf00              NOP      
;;;813        if (pcb->last_timer == tcp_timer_ctr) {
000106  f8940021          LDRB     r0,[r4,#0x21]
00010a  49ce              LDR      r1,|L1.1092|
00010c  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
00010e  4288              CMP      r0,r1
000110  d101              BNE      |L1.278|
;;;814          /* skip this pcb, we have already processed it */
;;;815          pcb = pcb->next;
000112  68e4              LDR      r4,[r4,#0xc]
;;;816          continue;
000114  e14b              B        |L1.942|
                  |L1.278|
;;;817        }
;;;818        pcb->last_timer = tcp_timer_ctr;
000116  48cb              LDR      r0,|L1.1092|
000118  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
00011a  f8840021          STRB     r0,[r4,#0x21]
;;;819    
;;;820        pcb_remove = 0;
00011e  2600              MOVS     r6,#0
;;;821        pcb_reset = 0;
000120  46b1              MOV      r9,r6
;;;822    
;;;823        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
000122  7e20              LDRB     r0,[r4,#0x18]
000124  2802              CMP      r0,#2
000126  d107              BNE      |L1.312|
000128  f8940046          LDRB     r0,[r4,#0x46]
00012c  2806              CMP      r0,#6
00012e  d103              BNE      |L1.312|
;;;824          ++pcb_remove;
000130  1c70              ADDS     r0,r6,#1
000132  b2c6              UXTB     r6,r0
;;;825          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
000134  bf00              NOP      
000136  e072              B        |L1.542|
                  |L1.312|
;;;826        }
;;;827        else if (pcb->nrtx == TCP_MAXRTX) {
000138  f8940046          LDRB     r0,[r4,#0x46]
00013c  280c              CMP      r0,#0xc
00013e  d103              BNE      |L1.328|
;;;828          ++pcb_remove;
000140  1c70              ADDS     r0,r6,#1
000142  b2c6              UXTB     r6,r0
;;;829          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
000144  bf00              NOP      
000146  e06a              B        |L1.542|
                  |L1.328|
;;;830        } else {
;;;831          if (pcb->persist_backoff > 0) {
000148  f8940091          LDRB     r0,[r4,#0x91]
00014c  2800              CMP      r0,#0
00014e  dd1b              BLE      |L1.392|
;;;832            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;833             * instead of using the standard retransmission mechanism. */
;;;834            pcb->persist_cnt++;
000150  f8140f90          LDRB     r0,[r4,#0x90]!
000154  1c40              ADDS     r0,r0,#1
000156  7020              STRB     r0,[r4,#0]
;;;835            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
000158  7821              LDRB     r1,[r4,#0]
00015a  7860              LDRB     r0,[r4,#1]
00015c  3c90              SUBS     r4,r4,#0x90
00015e  1e40              SUBS     r0,r0,#1
000160  4aba              LDR      r2,|L1.1100|
000162  5c10              LDRB     r0,[r2,r0]
000164  4281              CMP      r1,r0
000166  db5a              BLT      |L1.542|
;;;836              pcb->persist_cnt = 0;
000168  2000              MOVS     r0,#0
00016a  f8840090          STRB     r0,[r4,#0x90]
;;;837              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
00016e  f8940091          LDRB     r0,[r4,#0x91]
000172  2807              CMP      r0,#7
000174  d204              BCS      |L1.384|
;;;838                pcb->persist_backoff++;
000176  f8940091          LDRB     r0,[r4,#0x91]
00017a  1c40              ADDS     r0,r0,#1
00017c  f8840091          STRB     r0,[r4,#0x91]
                  |L1.384|
;;;839              }
;;;840              tcp_zero_window_probe(pcb);
000180  4620              MOV      r0,r4
000182  f7fffffe          BL       tcp_zero_window_probe
000186  e04a              B        |L1.542|
                  |L1.392|
;;;841            }
;;;842          } else {
;;;843            /* Increase the retransmission timer if it is running */
;;;844            if(pcb->rtime >= 0) {
000188  f9b40034          LDRSH    r0,[r4,#0x34]
00018c  2800              CMP      r0,#0
00018e  db03              BLT      |L1.408|
;;;845              ++pcb->rtime;
000190  8ea0              LDRH     r0,[r4,#0x34]
000192  1c40              ADDS     r0,r0,#1
000194  b200              SXTH     r0,r0
000196  86a0              STRH     r0,[r4,#0x34]
                  |L1.408|
;;;846            }
;;;847    
;;;848            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
000198  6f20              LDR      r0,[r4,#0x70]
00019a  b3e8              CBZ      r0,|L1.536|
00019c  f9b40034          LDRSH    r0,[r4,#0x34]
0001a0  f9b41044          LDRSH    r1,[r4,#0x44]
0001a4  4288              CMP      r0,r1
0001a6  db3a              BLT      |L1.542|
;;;849              /* Time for a retransmission. */
;;;850              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
0001a8  bf00              NOP      
0001aa  bf00              NOP      
;;;851                                          " pcb->rto %"S16_F"\n",
;;;852                                          pcb->rtime, pcb->rto));
;;;853    
;;;854              /* Double retransmission time-out unless we are trying to
;;;855               * connect to somebody (i.e., we are in SYN_SENT). */
;;;856              if (pcb->state != SYN_SENT) {
0001ac  7e20              LDRB     r0,[r4,#0x18]
0001ae  2802              CMP      r0,#2
0001b0  d00c              BEQ      |L1.460|
;;;857                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
0001b2  3440              ADDS     r4,r4,#0x40
0001b4  8860              LDRH     r0,[r4,#2]
0001b6  f9b41000          LDRSH    r1,[r4,#0]
0001ba  eb0000e1          ADD      r0,r0,r1,ASR #3
0001be  79a1              LDRB     r1,[r4,#6]
0001c0  4aa3              LDR      r2,|L1.1104|
0001c2  5c51              LDRB     r1,[r2,r1]
0001c4  4088              LSLS     r0,r0,r1
0001c6  b200              SXTH     r0,r0
0001c8  80a0              STRH     r0,[r4,#4]
0001ca  3c40              SUBS     r4,r4,#0x40
                  |L1.460|
;;;858              }
;;;859    
;;;860              /* Reset the retransmission timer. */
;;;861              pcb->rtime = 0;
0001cc  2000              MOVS     r0,#0
0001ce  86a0              STRH     r0,[r4,#0x34]
;;;862    
;;;863              /* Reduce congestion window and ssthresh. */
;;;864              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
0001d0  f8b4004c          LDRH     r0,[r4,#0x4c]
0001d4  f8b41060          LDRH     r1,[r4,#0x60]
0001d8  4288              CMP      r0,r1
0001da  da02              BGE      |L1.482|
0001dc  f8b4004c          LDRH     r0,[r4,#0x4c]
0001e0  e001              B        |L1.486|
                  |L1.482|
0001e2  f8b40060          LDRH     r0,[r4,#0x60]
                  |L1.486|
0001e6  4682              MOV      r10,r0
;;;865              pcb->ssthresh = eff_wnd >> 1;
0001e8  ea4f006a          ASR      r0,r10,#1
0001ec  f8a4004e          STRH     r0,[r4,#0x4e]
;;;866              if (pcb->ssthresh < (pcb->mss << 1)) {
0001f0  f8b4004e          LDRH     r0,[r4,#0x4e]
0001f4  8ee1              LDRH     r1,[r4,#0x36]
0001f6  ebb00f41          CMP      r0,r1,LSL #1
0001fa  da06              BGE      |L1.522|
;;;867                pcb->ssthresh = (pcb->mss << 1);
0001fc  8ee0              LDRH     r0,[r4,#0x36]
0001fe  f64f71ff          MOV      r1,#0xffff
000202  ea010040          AND      r0,r1,r0,LSL #1
000206  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L1.522|
;;;868              }
;;;869              pcb->cwnd = pcb->mss;
00020a  8ee0              LDRH     r0,[r4,#0x36]
00020c  f8a4004c          STRH     r0,[r4,#0x4c]
;;;870              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
000210  bf00              NOP      
000212  bf00              NOP      
;;;871                                           " ssthresh %"U16_F"\n",
;;;872                                           pcb->cwnd, pcb->ssthresh));
;;;873     
;;;874              /* The following needs to be called AFTER cwnd is set to one
;;;875                 mss - STJ */
;;;876              tcp_rexmit_rto(pcb);
000214  4620              MOV      r0,r4
000216  e000              B        |L1.538|
                  |L1.536|
000218  e001              B        |L1.542|
                  |L1.538|
00021a  f7fffffe          BL       tcp_rexmit_rto
                  |L1.542|
;;;877            }
;;;878          }
;;;879        }
;;;880        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;881        if (pcb->state == FIN_WAIT_2) {
00021e  7e20              LDRB     r0,[r4,#0x18]
000220  2806              CMP      r0,#6
000222  d10d              BNE      |L1.576|
;;;882          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;883          if (pcb->flags & TF_RXCLOSED) {
000224  7fa0              LDRB     r0,[r4,#0x1e]
000226  f0000010          AND      r0,r0,#0x10
00022a  b148              CBZ      r0,|L1.576|
;;;884            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;885               normal FIN-WAIT timeout handling. */
;;;886            if ((u32_t)(tcp_ticks - pcb->tmr) >
00022c  4984              LDR      r1,|L1.1088|
00022e  6a60              LDR      r0,[r4,#0x24]
000230  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000232  1a08              SUBS     r0,r1,r0
000234  2828              CMP      r0,#0x28
000236  d903              BLS      |L1.576|
;;;887                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;888              ++pcb_remove;
000238  1c70              ADDS     r0,r6,#1
00023a  b2c6              UXTB     r6,r0
;;;889              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
00023c  bf00              NOP      
00023e  bf00              NOP      
                  |L1.576|
;;;890            }
;;;891          }
;;;892        }
;;;893    
;;;894        /* Check if KEEPALIVE should be sent */
;;;895        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
000240  7a20              LDRB     r0,[r4,#8]
000242  f0000008          AND      r0,r0,#8
000246  b3c0              CBZ      r0,|L1.698|
;;;896           ((pcb->state == ESTABLISHED) ||
000248  7e20              LDRB     r0,[r4,#0x18]
00024a  2804              CMP      r0,#4
00024c  d002              BEQ      |L1.596|
;;;897            (pcb->state == CLOSE_WAIT))) {
00024e  7e20              LDRB     r0,[r4,#0x18]
000250  2807              CMP      r0,#7
000252  d132              BNE      |L1.698|
                  |L1.596|
;;;898          if((u32_t)(tcp_ticks - pcb->tmr) >
000254  497f              LDR      r1,|L1.1108|
000256  f8d4008c          LDR      r0,[r4,#0x8c]
00025a  4408              ADD      r0,r0,r1
00025c  f44f71fa          MOV      r1,#0x1f4
000260  fbb0f0f1          UDIV     r0,r0,r1
000264  4a76              LDR      r2,|L1.1088|
000266  6a61              LDR      r1,[r4,#0x24]
000268  6812              LDR      r2,[r2,#0]  ; tcp_ticks
00026a  1a51              SUBS     r1,r2,r1
00026c  4288              CMP      r0,r1
00026e  d208              BCS      |L1.642|
;;;899             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;900          {
;;;901            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
000270  bf00              NOP      
000272  bf00              NOP      
;;;902                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;903                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;904            
;;;905            ++pcb_remove;
000274  1c70              ADDS     r0,r6,#1
000276  b2c6              UXTB     r6,r0
;;;906            ++pcb_reset;
000278  f1090001          ADD      r0,r9,#1
00027c  f00009ff          AND      r9,r0,#0xff
000280  e01b              B        |L1.698|
                  |L1.642|
;;;907          }
;;;908          else if((u32_t)(tcp_ticks - pcb->tmr) > 
000282  f8941092          LDRB     r1,[r4,#0x92]
000286  f242429f          MOV      r2,#0x249f
00028a  fb11f102          SMULBB   r1,r1,r2
00028e  f8d4008c          LDR      r0,[r4,#0x8c]
000292  eb0000c1          ADD      r0,r0,r1,LSL #3
000296  f44f71fa          MOV      r1,#0x1f4
00029a  fbb0f1f1          UDIV     r1,r0,r1
00029e  4a68              LDR      r2,|L1.1088|
0002a0  6a60              LDR      r0,[r4,#0x24]
0002a2  6812              LDR      r2,[r2,#0]  ; tcp_ticks
0002a4  1a10              SUBS     r0,r2,r0
0002a6  4281              CMP      r1,r0
0002a8  d207              BCS      |L1.698|
;;;909                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;910                  / TCP_SLOW_INTERVAL)
;;;911          {
;;;912            tcp_keepalive(pcb);
0002aa  4620              MOV      r0,r4
0002ac  f7fffffe          BL       tcp_keepalive
;;;913            pcb->keep_cnt_sent++;
0002b0  f8940092          LDRB     r0,[r4,#0x92]
0002b4  1c40              ADDS     r0,r0,#1
0002b6  f8840092          STRB     r0,[r4,#0x92]
                  |L1.698|
;;;914          }
;;;915        }
;;;916    
;;;917        /* If this PCB has queued out of sequence data, but has been
;;;918           inactive for too long, will drop the data (it will eventually
;;;919           be retransmitted). */
;;;920    #if TCP_QUEUE_OOSEQ
;;;921        if (pcb->ooseq != NULL &&
;;;922            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
;;;923          tcp_segs_free(pcb->ooseq);
;;;924          pcb->ooseq = NULL;
;;;925          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;926        }
;;;927    #endif /* TCP_QUEUE_OOSEQ */
;;;928    
;;;929        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;930        if (pcb->state == SYN_RCVD) {
0002ba  7e20              LDRB     r0,[r4,#0x18]
0002bc  2803              CMP      r0,#3
0002be  d109              BNE      |L1.724|
;;;931          if ((u32_t)(tcp_ticks - pcb->tmr) >
0002c0  495f              LDR      r1,|L1.1088|
0002c2  6a60              LDR      r0,[r4,#0x24]
0002c4  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0002c6  1a08              SUBS     r0,r1,r0
0002c8  2828              CMP      r0,#0x28
0002ca  d903              BLS      |L1.724|
;;;932              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;933            ++pcb_remove;
0002cc  1c70              ADDS     r0,r6,#1
0002ce  b2c6              UXTB     r6,r0
;;;934            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
0002d0  bf00              NOP      
0002d2  bf00              NOP      
                  |L1.724|
;;;935          }
;;;936        }
;;;937    
;;;938        /* Check if this PCB has stayed too long in LAST-ACK */
;;;939        if (pcb->state == LAST_ACK) {
0002d4  7e20              LDRB     r0,[r4,#0x18]
0002d6  2809              CMP      r0,#9
0002d8  d109              BNE      |L1.750|
;;;940          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0002da  4959              LDR      r1,|L1.1088|
0002dc  6a60              LDR      r0,[r4,#0x24]
0002de  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0002e0  1a08              SUBS     r0,r1,r0
0002e2  28f0              CMP      r0,#0xf0
0002e4  d903              BLS      |L1.750|
;;;941            ++pcb_remove;
0002e6  1c70              ADDS     r0,r6,#1
0002e8  b2c6              UXTB     r6,r0
;;;942            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
0002ea  bf00              NOP      
0002ec  bf00              NOP      
                  |L1.750|
;;;943          }
;;;944        }
;;;945    
;;;946        /* If the PCB should be removed, do it. */
;;;947        if (pcb_remove) {
0002ee  b3a6              CBZ      r6,|L1.858|
;;;948          struct tcp_pcb *pcb2;
;;;949          tcp_err_fn err_fn;
;;;950          void *err_arg;
;;;951          tcp_pcb_purge(pcb);
0002f0  4620              MOV      r0,r4
0002f2  f7fffffe          BL       tcp_pcb_purge
;;;952          /* Remove PCB from tcp_active_pcbs list. */
;;;953          if (prev != NULL) {
0002f6  b125              CBZ      r5,|L1.770|
;;;954            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
0002f8  bf00              NOP      
0002fa  bf00              NOP      
;;;955            prev->next = pcb->next;
0002fc  68e0              LDR      r0,[r4,#0xc]
0002fe  60e8              STR      r0,[r5,#0xc]
000300  e004              B        |L1.780|
                  |L1.770|
;;;956          } else {
;;;957            /* This PCB was the first. */
;;;958            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
000302  bf00              NOP      
000304  bf00              NOP      
;;;959            tcp_active_pcbs = pcb->next;
000306  4950              LDR      r1,|L1.1096|
000308  68e0              LDR      r0,[r4,#0xc]
00030a  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
                  |L1.780|
;;;960          }
;;;961    
;;;962          if (pcb_reset) {
00030c  f1b90f00          CMP      r9,#0
000310  d009              BEQ      |L1.806|
;;;963            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
000312  8ba0              LDRH     r0,[r4,#0x1c]
000314  8b61              LDRH     r1,[r4,#0x1a]
000316  e9cd1000          STRD     r1,r0,[sp,#0]
00031a  1d23              ADDS     r3,r4,#4
00031c  4622              MOV      r2,r4
00031e  6aa1              LDR      r1,[r4,#0x28]
000320  6d20              LDR      r0,[r4,#0x50]
000322  f7fffffe          BL       tcp_rst
                  |L1.806|
;;;964              pcb->local_port, pcb->remote_port);
;;;965          }
;;;966    
;;;967          err_fn = pcb->errf;
000326  f8d48088          LDR      r8,[r4,#0x88]
;;;968          err_arg = pcb->callback_arg;
00032a  f8d4b010          LDR      r11,[r4,#0x10]
;;;969          pcb2 = pcb;
00032e  4627              MOV      r7,r4
;;;970          pcb = pcb->next;
000330  68e4              LDR      r4,[r4,#0xc]
;;;971          memp_free(MEMP_TCP_PCB, pcb2);
000332  4639              MOV      r1,r7
000334  2002              MOVS     r0,#2
000336  f7fffffe          BL       memp_free
;;;972    
;;;973          tcp_active_pcbs_changed = 0;
00033a  2000              MOVS     r0,#0
00033c  4946              LDR      r1,|L1.1112|
00033e  7008              STRB     r0,[r1,#0]
;;;974          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
000340  bf00              NOP      
000342  f1b80f00          CMP      r8,#0
000346  d003              BEQ      |L1.848|
000348  f06f0109          MVN      r1,#9
00034c  4658              MOV      r0,r11
00034e  47c0              BLX      r8
                  |L1.848|
000350  bf00              NOP      
;;;975          if (tcp_active_pcbs_changed) {
000352  4841              LDR      r0,|L1.1112|
000354  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000356  b108              CBZ      r0,|L1.860|
;;;976            goto tcp_slowtmr_start;
000358  e6c6              B        |L1.232|
                  |L1.858|
00035a  e000              B        |L1.862|
                  |L1.860|
;;;977          }
;;;978        } else {
00035c  e026              B        |L1.940|
                  |L1.862|
;;;979          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;980          prev = pcb;
00035e  4625              MOV      r5,r4
;;;981          pcb = pcb->next;
000360  68e4              LDR      r4,[r4,#0xc]
;;;982    
;;;983          /* We check if we should poll the connection. */
;;;984          ++prev->polltmr;
000362  7fe8              LDRB     r0,[r5,#0x1f]
000364  1c40              ADDS     r0,r0,#1
000366  77e8              STRB     r0,[r5,#0x1f]
;;;985          if (prev->polltmr >= prev->pollinterval) {
000368  7fe8              LDRB     r0,[r5,#0x1f]
00036a  f8951020          LDRB     r1,[r5,#0x20]
00036e  4288              CMP      r0,r1
000370  db1c              BLT      |L1.940|
;;;986            prev->polltmr = 0;
000372  2000              MOVS     r0,#0
000374  77e8              STRB     r0,[r5,#0x1f]
;;;987            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
000376  bf00              NOP      
000378  bf00              NOP      
;;;988            tcp_active_pcbs_changed = 0;
00037a  4937              LDR      r1,|L1.1112|
00037c  7008              STRB     r0,[r1,#0]
;;;989            TCP_EVENT_POLL(prev, err);
00037e  bf00              NOP      
000380  f8d50084          LDR      r0,[r5,#0x84]
000384  b130              CBZ      r0,|L1.916|
000386  4629              MOV      r1,r5
000388  f8d52084          LDR      r2,[r5,#0x84]
00038c  6928              LDR      r0,[r5,#0x10]
00038e  4790              BLX      r2
000390  9002              STR      r0,[sp,#8]
000392  e001              B        |L1.920|
                  |L1.916|
000394  2000              MOVS     r0,#0
000396  9002              STR      r0,[sp,#8]
                  |L1.920|
000398  bf00              NOP      
;;;990            if (tcp_active_pcbs_changed) {
00039a  482f              LDR      r0,|L1.1112|
00039c  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
00039e  b100              CBZ      r0,|L1.930|
;;;991              goto tcp_slowtmr_start;
0003a0  e6a2              B        |L1.232|
                  |L1.930|
;;;992            }
;;;993            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;994            if (err == ERR_OK) {
0003a2  9802              LDR      r0,[sp,#8]
0003a4  b910              CBNZ     r0,|L1.940|
;;;995              tcp_output(prev);
0003a6  4628              MOV      r0,r5
0003a8  f7fffffe          BL       tcp_output
                  |L1.940|
0003ac  bf00              NOP                            ;816
                  |L1.942|
0003ae  2c00              CMP      r4,#0                 ;808
0003b0  f47faea1          BNE      |L1.246|
;;;996            }
;;;997          }
;;;998        }
;;;999      }
;;;1000   
;;;1001     
;;;1002     /* Steps through all of the TIME-WAIT PCBs. */
;;;1003     prev = NULL;
0003b4  2500              MOVS     r5,#0
;;;1004     pcb = tcp_tw_pcbs;
0003b6  4829              LDR      r0,|L1.1116|
0003b8  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
;;;1005     while (pcb != NULL) {
0003ba  e022              B        |L1.1026|
                  |L1.956|
;;;1006       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
0003bc  bf00              NOP      
0003be  bf00              NOP      
;;;1007       pcb_remove = 0;
0003c0  2600              MOVS     r6,#0
;;;1008   
;;;1009       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1010       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0003c2  491f              LDR      r1,|L1.1088|
0003c4  6a60              LDR      r0,[r4,#0x24]
0003c6  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0003c8  1a08              SUBS     r0,r1,r0
0003ca  28f0              CMP      r0,#0xf0
0003cc  d901              BLS      |L1.978|
;;;1011         ++pcb_remove;
0003ce  1c70              ADDS     r0,r6,#1
0003d0  b2c6              UXTB     r6,r0
                  |L1.978|
;;;1012       }
;;;1013       
;;;1014   
;;;1015   
;;;1016       /* If the PCB should be removed, do it. */
;;;1017       if (pcb_remove) {
0003d2  b1a6              CBZ      r6,|L1.1022|
;;;1018         struct tcp_pcb *pcb2;
;;;1019         tcp_pcb_purge(pcb);
0003d4  4620              MOV      r0,r4
0003d6  f7fffffe          BL       tcp_pcb_purge
;;;1020         /* Remove PCB from tcp_tw_pcbs list. */
;;;1021         if (prev != NULL) {
0003da  b125              CBZ      r5,|L1.998|
;;;1022           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
0003dc  bf00              NOP      
0003de  bf00              NOP      
;;;1023           prev->next = pcb->next;
0003e0  68e0              LDR      r0,[r4,#0xc]
0003e2  60e8              STR      r0,[r5,#0xc]
0003e4  e004              B        |L1.1008|
                  |L1.998|
;;;1024         } else {
;;;1025           /* This PCB was the first. */
;;;1026           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
0003e6  bf00              NOP      
0003e8  bf00              NOP      
;;;1027           tcp_tw_pcbs = pcb->next;
0003ea  491c              LDR      r1,|L1.1116|
0003ec  68e0              LDR      r0,[r4,#0xc]
0003ee  6008              STR      r0,[r1,#0]  ; tcp_tw_pcbs
                  |L1.1008|
;;;1028         }
;;;1029         pcb2 = pcb;
0003f0  4627              MOV      r7,r4
;;;1030         pcb = pcb->next;
0003f2  68e4              LDR      r4,[r4,#0xc]
;;;1031         memp_free(MEMP_TCP_PCB, pcb2);
0003f4  4639              MOV      r1,r7
0003f6  2002              MOVS     r0,#2
0003f8  f7fffffe          BL       memp_free
;;;1032       } else {
0003fc  e001              B        |L1.1026|
                  |L1.1022|
;;;1033         prev = pcb;
0003fe  4625              MOV      r5,r4
;;;1034         pcb = pcb->next;
000400  68e4              LDR      r4,[r4,#0xc]
                  |L1.1026|
000402  2c00              CMP      r4,#0                 ;1005
000404  d1da              BNE      |L1.956|
;;;1035       }
;;;1036     }
;;;1037   }
000406  e8bd8ffe          POP      {r1-r11,pc}
;;;1038   
                          ENDP

                  tcp_pcb_remove PROC
;;;1537   void
;;;1538   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
00040a  b570              PUSH     {r4-r6,lr}
;;;1539   {
00040c  4605              MOV      r5,r0
00040e  460c              MOV      r4,r1
;;;1540     TCP_RMV(pcblist, pcb);
000410  bf00              NOP      
000412  6828              LDR      r0,[r5,#0]
000414  42a0              CMP      r0,r4
000416  d103              BNE      |L1.1056|
000418  6828              LDR      r0,[r5,#0]
00041a  68c0              LDR      r0,[r0,#0xc]
00041c  6028              STR      r0,[r5,#0]
00041e  e02b              B        |L1.1144|
                  |L1.1056|
000420  490f              LDR      r1,|L1.1120|
000422  6828              LDR      r0,[r5,#0]
000424  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
000426  e022              B        |L1.1134|
                  |L1.1064|
000428  480d              LDR      r0,|L1.1120|
00042a  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00042c  68c0              LDR      r0,[r0,#0xc]
00042e  42a0              CMP      r0,r4
000430  d118              BNE      |L1.1124|
000432  490b              LDR      r1,|L1.1120|
000434  68e0              LDR      r0,[r4,#0xc]
000436  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
000438  60c8              STR      r0,[r1,#0xc]
00043a  e01c              B        |L1.1142|
                  |L1.1084|
                          DCD      tcp_listen_pcbs
                  |L1.1088|
                          DCD      tcp_ticks
                  |L1.1092|
                          DCD      tcp_timer_ctr
                  |L1.1096|
                          DCD      tcp_active_pcbs
                  |L1.1100|
                          DCD      tcp_persist_backoff
                  |L1.1104|
                          DCD      tcp_backoff
                  |L1.1108|
                          DCD      0x000a4cb8
                  |L1.1112|
                          DCD      tcp_active_pcbs_changed
                  |L1.1116|
                          DCD      tcp_tw_pcbs
                  |L1.1120|
                          DCD      tcp_tmp_pcb
                  |L1.1124|
000464  48f9              LDR      r0,|L1.2124|
000466  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000468  68c0              LDR      r0,[r0,#0xc]
00046a  49f8              LDR      r1,|L1.2124|
00046c  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L1.1134|
00046e  48f7              LDR      r0,|L1.2124|
000470  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000472  2800              CMP      r0,#0
000474  d1d8              BNE      |L1.1064|
                  |L1.1142|
000476  bf00              NOP      
                  |L1.1144|
000478  2000              MOVS     r0,#0
00047a  60e0              STR      r0,[r4,#0xc]
00047c  bf00              NOP      
;;;1541   
;;;1542     tcp_pcb_purge(pcb);
00047e  4620              MOV      r0,r4
000480  f7fffffe          BL       tcp_pcb_purge
;;;1543     
;;;1544     /* if there is an outstanding delayed ACKs, send it */
;;;1545     if (pcb->state != TIME_WAIT &&
000484  7e20              LDRB     r0,[r4,#0x18]
000486  280a              CMP      r0,#0xa
000488  d00d              BEQ      |L1.1190|
;;;1546        pcb->state != LISTEN &&
00048a  7e20              LDRB     r0,[r4,#0x18]
00048c  2801              CMP      r0,#1
00048e  d00a              BEQ      |L1.1190|
;;;1547        pcb->flags & TF_ACK_DELAY) {
000490  7fa0              LDRB     r0,[r4,#0x1e]
000492  f0000001          AND      r0,r0,#1
000496  b130              CBZ      r0,|L1.1190|
;;;1548       pcb->flags |= TF_ACK_NOW;
000498  7fa0              LDRB     r0,[r4,#0x1e]
00049a  f0400002          ORR      r0,r0,#2
00049e  77a0              STRB     r0,[r4,#0x1e]
;;;1549       tcp_output(pcb);
0004a0  4620              MOV      r0,r4
0004a2  f7fffffe          BL       tcp_output
                  |L1.1190|
;;;1550     }
;;;1551   
;;;1552     if (pcb->state != LISTEN) {
0004a6  7e20              LDRB     r0,[r4,#0x18]
0004a8  2801              CMP      r0,#1
0004aa  d003              BEQ      |L1.1204|
;;;1553       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
0004ac  bf00              NOP      
0004ae  bf00              NOP      
;;;1554       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
0004b0  bf00              NOP      
0004b2  bf00              NOP      
                  |L1.1204|
;;;1555   #if TCP_QUEUE_OOSEQ
;;;1556       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
;;;1557   #endif /* TCP_QUEUE_OOSEQ */
;;;1558     }
;;;1559   
;;;1560     pcb->state = CLOSED;
0004b4  2000              MOVS     r0,#0
0004b6  7620              STRB     r0,[r4,#0x18]
;;;1561   
;;;1562     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
0004b8  bf00              NOP      
0004ba  bf00              NOP      
;;;1563   }
0004bc  bd70              POP      {r4-r6,pc}
;;;1564   
                          ENDP

                  tcp_close_shutdown PROC
;;;169    static err_t
;;;170    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
0004be  b57c              PUSH     {r2-r6,lr}
;;;171    {
0004c0  4604              MOV      r4,r0
0004c2  460e              MOV      r6,r1
;;;172      err_t err;
;;;173    
;;;174      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
0004c4  2e00              CMP      r6,#0
0004c6  d05b              BEQ      |L1.1408|
0004c8  7e20              LDRB     r0,[r4,#0x18]
0004ca  2804              CMP      r0,#4
0004cc  d002              BEQ      |L1.1236|
0004ce  7e20              LDRB     r0,[r4,#0x18]
0004d0  2807              CMP      r0,#7
0004d2  d155              BNE      |L1.1408|
                  |L1.1236|
;;;175        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
0004d4  6f60              LDR      r0,[r4,#0x74]
0004d6  b920              CBNZ     r0,|L1.1250|
0004d8  8da0              LDRH     r0,[r4,#0x2c]
0004da  f24161d0          MOV      r1,#0x16d0
0004de  4288              CMP      r0,r1
0004e0  d04e              BEQ      |L1.1408|
                  |L1.1250|
;;;176          /* Not all data received by application, send RST to tell the remote
;;;177             side about this. */
;;;178          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
0004e2  bf00              NOP      
0004e4  bf00              NOP      
;;;179    
;;;180          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;181             that might not be expected when calling tcp_close */
;;;182          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0004e6  8ba0              LDRH     r0,[r4,#0x1c]
0004e8  8b61              LDRH     r1,[r4,#0x1a]
0004ea  e9cd1000          STRD     r1,r0,[sp,#0]
0004ee  1d23              ADDS     r3,r4,#4
0004f0  4622              MOV      r2,r4
0004f2  6aa1              LDR      r1,[r4,#0x28]
0004f4  6d20              LDR      r0,[r4,#0x50]
0004f6  f7fffffe          BL       tcp_rst
;;;183            pcb->local_port, pcb->remote_port);
;;;184    
;;;185          tcp_pcb_purge(pcb);
0004fa  4620              MOV      r0,r4
0004fc  f7fffffe          BL       tcp_pcb_purge
;;;186          TCP_RMV_ACTIVE(pcb);
000500  bf00              NOP      
000502  bf00              NOP      
000504  48d2              LDR      r0,|L1.2128|
000506  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
000508  42a0              CMP      r0,r4
00050a  d105              BNE      |L1.1304|
00050c  48d0              LDR      r0,|L1.2128|
00050e  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
000510  68c0              LDR      r0,[r0,#0xc]
000512  49cf              LDR      r1,|L1.2128|
000514  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
000516  e018              B        |L1.1354|
                  |L1.1304|
000518  48cd              LDR      r0,|L1.2128|
00051a  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00051c  49cb              LDR      r1,|L1.2124|
00051e  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
000520  e00e              B        |L1.1344|
                  |L1.1314|
000522  48ca              LDR      r0,|L1.2124|
000524  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000526  68c0              LDR      r0,[r0,#0xc]
000528  42a0              CMP      r0,r4
00052a  d104              BNE      |L1.1334|
00052c  49c7              LDR      r1,|L1.2124|
00052e  68e0              LDR      r0,[r4,#0xc]
000530  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
000532  60c8              STR      r0,[r1,#0xc]
000534  e008              B        |L1.1352|
                  |L1.1334|
000536  48c5              LDR      r0,|L1.2124|
000538  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00053a  68c0              LDR      r0,[r0,#0xc]
00053c  49c3              LDR      r1,|L1.2124|
00053e  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L1.1344|
000540  48c2              LDR      r0,|L1.2124|
000542  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000544  2800              CMP      r0,#0
000546  d1ec              BNE      |L1.1314|
                  |L1.1352|
000548  bf00              NOP      
                  |L1.1354|
00054a  2000              MOVS     r0,#0
00054c  60e0              STR      r0,[r4,#0xc]
00054e  bf00              NOP      
000550  2001              MOVS     r0,#1
000552  49c0              LDR      r1,|L1.2132|
000554  7008              STRB     r0,[r1,#0]
000556  bf00              NOP      
;;;187          if (pcb->state == ESTABLISHED) {
000558  7e20              LDRB     r0,[r4,#0x18]
00055a  2804              CMP      r0,#4
00055c  d10a              BNE      |L1.1396|
;;;188            /* move to TIME_WAIT since we close actively */
;;;189            pcb->state = TIME_WAIT;
00055e  200a              MOVS     r0,#0xa
000560  7620              STRB     r0,[r4,#0x18]
;;;190            TCP_REG(&tcp_tw_pcbs, pcb);
000562  bf00              NOP      
000564  48bc              LDR      r0,|L1.2136|
000566  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
000568  60e0              STR      r0,[r4,#0xc]
00056a  48bb              LDR      r0,|L1.2136|
00056c  6004              STR      r4,[r0,#0]  ; tcp_tw_pcbs
00056e  f7fffffe          BL       tcp_timer_needed
000572  e003              B        |L1.1404|
                  |L1.1396|
;;;191          } else {
;;;192            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;193            memp_free(MEMP_TCP_PCB, pcb);
000574  4621              MOV      r1,r4
000576  2002              MOVS     r0,#2
000578  f7fffffe          BL       memp_free
                  |L1.1404|
;;;194          }
;;;195          return ERR_OK;
00057c  2000              MOVS     r0,#0
                  |L1.1406|
;;;196        }
;;;197      }
;;;198    
;;;199      switch (pcb->state) {
;;;200      case CLOSED:
;;;201        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;202         * however, it is in this state once allocated and as yet unused
;;;203         * and the user needs some way to free it should the need arise.
;;;204         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;205         * or for a pcb that has been used and then entered the CLOSED state 
;;;206         * is erroneous, but this should never happen as the pcb has in those cases
;;;207         * been freed, and so any remaining handles are bogus. */
;;;208        err = ERR_OK;
;;;209        if (pcb->local_port != 0) {
;;;210          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;211        }
;;;212        memp_free(MEMP_TCP_PCB, pcb);
;;;213        pcb = NULL;
;;;214        break;
;;;215      case LISTEN:
;;;216        err = ERR_OK;
;;;217        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;218        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;219        pcb = NULL;
;;;220        break;
;;;221      case SYN_SENT:
;;;222        err = ERR_OK;
;;;223        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;224        memp_free(MEMP_TCP_PCB, pcb);
;;;225        pcb = NULL;
;;;226        snmp_inc_tcpattemptfails();
;;;227        break;
;;;228      case SYN_RCVD:
;;;229        err = tcp_send_fin(pcb);
;;;230        if (err == ERR_OK) {
;;;231          snmp_inc_tcpattemptfails();
;;;232          pcb->state = FIN_WAIT_1;
;;;233        }
;;;234        break;
;;;235      case ESTABLISHED:
;;;236        err = tcp_send_fin(pcb);
;;;237        if (err == ERR_OK) {
;;;238          snmp_inc_tcpestabresets();
;;;239          pcb->state = FIN_WAIT_1;
;;;240        }
;;;241        break;
;;;242      case CLOSE_WAIT:
;;;243        err = tcp_send_fin(pcb);
;;;244        if (err == ERR_OK) {
;;;245          snmp_inc_tcpestabresets();
;;;246          pcb->state = LAST_ACK;
;;;247        }
;;;248        break;
;;;249      default:
;;;250        /* Has already been closed, do nothing. */
;;;251        err = ERR_OK;
;;;252        pcb = NULL;
;;;253        break;
;;;254      }
;;;255    
;;;256      if (pcb != NULL && err == ERR_OK) {
;;;257        /* To ensure all data has been sent when tcp_close returns, we have
;;;258           to make sure tcp_output doesn't fail.
;;;259           Since we don't really have to ensure all data has been sent when tcp_close
;;;260           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;261           for the return value of tcp_output for now. */
;;;262        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;263           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;264           This can only be valid for sequential APIs, not for the raw API. */
;;;265        tcp_output(pcb);
;;;266      }
;;;267      return err;
;;;268    }
00057e  bd7c              POP      {r2-r6,pc}
                  |L1.1408|
000580  7e20              LDRB     r0,[r4,#0x18]         ;199
000582  2808              CMP      r0,#8                 ;199
000584  d268              BCS      |L1.1624|
000586  e8dff000          TBB      [pc,r0]               ;199
00058a  0434              DCB      0x04,0x34
00058c  3f4f5767          DCB      0x3f,0x4f,0x57,0x67
000590  675f              DCB      0x67,0x5f
000592  2500              MOVS     r5,#0                 ;208
000594  8b60              LDRH     r0,[r4,#0x1a]         ;209
000596  b330              CBZ      r0,|L1.1510|
000598  bf00              NOP                            ;210
00059a  48b0              LDR      r0,|L1.2140|
00059c  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
00059e  42a0              CMP      r0,r4                 ;210
0005a0  d105              BNE      |L1.1454|
0005a2  48ae              LDR      r0,|L1.2140|
0005a4  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
0005a6  68c0              LDR      r0,[r0,#0xc]          ;210
0005a8  49ac              LDR      r1,|L1.2140|
0005aa  6008              STR      r0,[r1,#0]            ;210  ; tcp_bound_pcbs
0005ac  e018              B        |L1.1504|
                  |L1.1454|
0005ae  48ab              LDR      r0,|L1.2140|
0005b0  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
0005b2  49a6              LDR      r1,|L1.2124|
0005b4  6008              STR      r0,[r1,#0]            ;210  ; tcp_tmp_pcb
0005b6  e00e              B        |L1.1494|
                  |L1.1464|
0005b8  48a4              LDR      r0,|L1.2124|
0005ba  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
0005bc  68c0              LDR      r0,[r0,#0xc]          ;210
0005be  42a0              CMP      r0,r4                 ;210
0005c0  d104              BNE      |L1.1484|
0005c2  49a2              LDR      r1,|L1.2124|
0005c4  68e0              LDR      r0,[r4,#0xc]          ;210
0005c6  6809              LDR      r1,[r1,#0]            ;210  ; tcp_tmp_pcb
0005c8  60c8              STR      r0,[r1,#0xc]          ;210
0005ca  e008              B        |L1.1502|
                  |L1.1484|
0005cc  489f              LDR      r0,|L1.2124|
0005ce  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
0005d0  68c0              LDR      r0,[r0,#0xc]          ;210
0005d2  499e              LDR      r1,|L1.2124|
0005d4  6008              STR      r0,[r1,#0]            ;210  ; tcp_tmp_pcb
                  |L1.1494|
0005d6  489d              LDR      r0,|L1.2124|
0005d8  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
0005da  2800              CMP      r0,#0                 ;210
0005dc  d1ec              BNE      |L1.1464|
                  |L1.1502|
0005de  bf00              NOP                            ;210
                  |L1.1504|
0005e0  2000              MOVS     r0,#0                 ;210
0005e2  60e0              STR      r0,[r4,#0xc]          ;210
0005e4  bf00              NOP                            ;210
                  |L1.1510|
0005e6  4621              MOV      r1,r4                 ;212
0005e8  2002              MOVS     r0,#2                 ;212
0005ea  f7fffffe          BL       memp_free
0005ee  2400              MOVS     r4,#0                 ;213
0005f0  e035              B        |L1.1630|
0005f2  2500              MOVS     r5,#0                 ;216
0005f4  4621              MOV      r1,r4                 ;217
0005f6  489a              LDR      r0,|L1.2144|
0005f8  f7fffffe          BL       tcp_pcb_remove
0005fc  4621              MOV      r1,r4                 ;218
0005fe  2003              MOVS     r0,#3                 ;218
000600  f7fffffe          BL       memp_free
000604  2400              MOVS     r4,#0                 ;219
000606  e02a              B        |L1.1630|
000608  2500              MOVS     r5,#0                 ;222
00060a  bf00              NOP                            ;223
00060c  4621              MOV      r1,r4                 ;223
00060e  4890              LDR      r0,|L1.2128|
000610  f7fffffe          BL       tcp_pcb_remove
000614  2001              MOVS     r0,#1                 ;223
000616  498f              LDR      r1,|L1.2132|
000618  7008              STRB     r0,[r1,#0]            ;223
00061a  bf00              NOP                            ;223
00061c  4621              MOV      r1,r4                 ;224
00061e  2002              MOVS     r0,#2                 ;224
000620  f7fffffe          BL       memp_free
000624  2400              MOVS     r4,#0                 ;225
000626  e01a              B        |L1.1630|
000628  4620              MOV      r0,r4                 ;229
00062a  f7fffffe          BL       tcp_send_fin
00062e  4605              MOV      r5,r0                 ;229
000630  b90d              CBNZ     r5,|L1.1590|
000632  2005              MOVS     r0,#5                 ;232
000634  7620              STRB     r0,[r4,#0x18]         ;232
                  |L1.1590|
000636  e012              B        |L1.1630|
000638  4620              MOV      r0,r4                 ;236
00063a  f7fffffe          BL       tcp_send_fin
00063e  4605              MOV      r5,r0                 ;236
000640  b90d              CBNZ     r5,|L1.1606|
000642  2005              MOVS     r0,#5                 ;239
000644  7620              STRB     r0,[r4,#0x18]         ;239
                  |L1.1606|
000646  e00a              B        |L1.1630|
000648  4620              MOV      r0,r4                 ;243
00064a  f7fffffe          BL       tcp_send_fin
00064e  4605              MOV      r5,r0                 ;243
000650  b90d              CBNZ     r5,|L1.1622|
000652  2009              MOVS     r0,#9                 ;246
000654  7620              STRB     r0,[r4,#0x18]         ;246
                  |L1.1622|
000656  e002              B        |L1.1630|
                  |L1.1624|
000658  2500              MOVS     r5,#0                 ;251
00065a  2400              MOVS     r4,#0                 ;252
00065c  bf00              NOP                            ;253
                  |L1.1630|
00065e  bf00              NOP                            ;214
000660  b11c              CBZ      r4,|L1.1642|
000662  b915              CBNZ     r5,|L1.1642|
000664  4620              MOV      r0,r4                 ;265
000666  f7fffffe          BL       tcp_output
                  |L1.1642|
00066a  4628              MOV      r0,r5                 ;267
00066c  e787              B        |L1.1406|
;;;269    
                          ENDP

                  tcp_close PROC
;;;284    err_t
;;;285    tcp_close(struct tcp_pcb *pcb)
00066e  b510              PUSH     {r4,lr}
;;;286    {
000670  4604              MOV      r4,r0
;;;287    #if TCP_DEBUG
;;;288      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;289      tcp_debug_print_state(pcb->state);
;;;290    #endif /* TCP_DEBUG */
;;;291    
;;;292      if (pcb->state != LISTEN) {
000672  7e20              LDRB     r0,[r4,#0x18]
000674  2801              CMP      r0,#1
000676  d003              BEQ      |L1.1664|
;;;293        /* Set a flag not to receive any more data... */
;;;294        pcb->flags |= TF_RXCLOSED;
000678  7fa0              LDRB     r0,[r4,#0x1e]
00067a  f0400010          ORR      r0,r0,#0x10
00067e  77a0              STRB     r0,[r4,#0x1e]
                  |L1.1664|
;;;295      }
;;;296      /* ... and close */
;;;297      return tcp_close_shutdown(pcb, 1);
000680  2101              MOVS     r1,#1
000682  4620              MOV      r0,r4
000684  f7fffffe          BL       tcp_close_shutdown
;;;298    }
000688  bd10              POP      {r4,pc}
;;;299    
                          ENDP

                  tcp_update_rcv_ann_wnd PROC
;;;578     */
;;;579    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
00068a  b510              PUSH     {r4,lr}
;;;580    {
00068c  4601              MOV      r1,r0
;;;581      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
00068e  8d8b              LDRH     r3,[r1,#0x2c]
000690  6a88              LDR      r0,[r1,#0x28]
000692  18c2              ADDS     r2,r0,r3
;;;582    
;;;583      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
000694  8ec8              LDRH     r0,[r1,#0x36]
000696  f6403468          MOV      r4,#0xb68
00069a  6b0b              LDR      r3,[r1,#0x30]
00069c  42a0              CMP      r0,r4
00069e  dd01              BLE      |L1.1700|
0006a0  4620              MOV      r0,r4
0006a2  e000              B        |L1.1702|
                  |L1.1700|
0006a4  8ec8              LDRH     r0,[r1,#0x36]
                  |L1.1702|
0006a6  4418              ADD      r0,r0,r3
0006a8  1a10              SUBS     r0,r2,r0
0006aa  d404              BMI      |L1.1718|
;;;584        /* we can advertise more window */
;;;585        pcb->rcv_ann_wnd = pcb->rcv_wnd;
0006ac  8d88              LDRH     r0,[r1,#0x2c]
0006ae  85c8              STRH     r0,[r1,#0x2e]
;;;586        return new_right_edge - pcb->rcv_ann_right_edge;
0006b0  6b08              LDR      r0,[r1,#0x30]
0006b2  1a10              SUBS     r0,r2,r0
                  |L1.1716|
;;;587      } else {
;;;588        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;589          /* Can happen due to other end sending out of advertised window,
;;;590           * but within actual available (but not yet advertised) window */
;;;591          pcb->rcv_ann_wnd = 0;
;;;592        } else {
;;;593          /* keep the right edge of window constant */
;;;594          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;595          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;596          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;597        }
;;;598        return 0;
;;;599      }
;;;600    }
0006b4  bd10              POP      {r4,pc}
                  |L1.1718|
0006b6  6b0b              LDR      r3,[r1,#0x30]         ;588
0006b8  6a88              LDR      r0,[r1,#0x28]         ;588
0006ba  1ac0              SUBS     r0,r0,r3              ;588
0006bc  2800              CMP      r0,#0                 ;588
0006be  dd02              BLE      |L1.1734|
0006c0  2000              MOVS     r0,#0                 ;591
0006c2  85c8              STRH     r0,[r1,#0x2e]         ;591
0006c4  e006              B        |L1.1748|
                  |L1.1734|
0006c6  6a8c              LDR      r4,[r1,#0x28]         ;594
0006c8  6b0b              LDR      r3,[r1,#0x30]         ;594
0006ca  1b18              SUBS     r0,r3,r4              ;594
0006cc  bf00              NOP                            ;595
0006ce  bf00              NOP                            ;595
0006d0  85c8              STRH     r0,[r1,#0x2e]         ;596
0006d2  bf00              NOP                            ;597
                  |L1.1748|
0006d4  2000              MOVS     r0,#0                 ;598
0006d6  e7ed              B        |L1.1716|
;;;601    
                          ENDP

                  tcp_recved PROC
;;;610    void
;;;611    tcp_recved(struct tcp_pcb *pcb, u16_t len)
0006d8  b570              PUSH     {r4-r6,lr}
;;;612    {
0006da  4604              MOV      r4,r0
0006dc  460e              MOV      r6,r1
;;;613      int wnd_inflation;
;;;614    
;;;615      /* pcb->state LISTEN not allowed here */
;;;616      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
0006de  bf00              NOP      
0006e0  bf00              NOP      
;;;617        pcb->state != LISTEN);
;;;618      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
0006e2  bf00              NOP      
0006e4  bf00              NOP      
;;;619                  len <= 0xffff - pcb->rcv_wnd );
;;;620    
;;;621      pcb->rcv_wnd += len;
0006e6  8da0              LDRH     r0,[r4,#0x2c]
0006e8  4430              ADD      r0,r0,r6
0006ea  85a0              STRH     r0,[r4,#0x2c]
;;;622      if (pcb->rcv_wnd > TCP_WND) {
0006ec  8da0              LDRH     r0,[r4,#0x2c]
0006ee  f24161d0          MOV      r1,#0x16d0
0006f2  4288              CMP      r0,r1
0006f4  dd01              BLE      |L1.1786|
;;;623        pcb->rcv_wnd = TCP_WND;
0006f6  4608              MOV      r0,r1
0006f8  85a0              STRH     r0,[r4,#0x2c]
                  |L1.1786|
;;;624      }
;;;625    
;;;626      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
0006fa  4620              MOV      r0,r4
0006fc  f7fffffe          BL       tcp_update_rcv_ann_wnd
000700  4605              MOV      r5,r0
;;;627    
;;;628      /* If the change in the right edge of window is significant (default
;;;629       * watermark is TCP_WND/4), then send an explicit update now.
;;;630       * Otherwise wait for a packet to be sent in the normal course of
;;;631       * events (or more window to be available later) */
;;;632      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
000702  f24050b4          MOV      r0,#0x5b4
000706  4285              CMP      r5,r0
000708  db08              BLT      |L1.1820|
;;;633        tcp_ack_now(pcb);
00070a  bf00              NOP      
00070c  7fa0              LDRB     r0,[r4,#0x1e]
00070e  f0400002          ORR      r0,r0,#2
000712  77a0              STRB     r0,[r4,#0x1e]
000714  bf00              NOP      
;;;634        tcp_output(pcb);
000716  4620              MOV      r0,r4
000718  f7fffffe          BL       tcp_output
                  |L1.1820|
;;;635      }
;;;636    
;;;637      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
00071c  bf00              NOP      
00071e  bf00              NOP      
;;;638             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;639    }
000720  bd70              POP      {r4-r6,pc}
;;;640    
                          ENDP

                  tcp_recv_null PROC
;;;1196   err_t
;;;1197   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000722  e92d41f0          PUSH     {r4-r8,lr}
;;;1198   {
000726  4607              MOV      r7,r0
000728  460d              MOV      r5,r1
00072a  4614              MOV      r4,r2
00072c  461e              MOV      r6,r3
;;;1199     LWIP_UNUSED_ARG(arg);
;;;1200     if (p != NULL) {
00072e  b13c              CBZ      r4,|L1.1856|
;;;1201       tcp_recved(pcb, p->tot_len);
000730  8921              LDRH     r1,[r4,#8]
000732  4628              MOV      r0,r5
000734  f7fffffe          BL       tcp_recved
;;;1202       pbuf_free(p);
000738  4620              MOV      r0,r4
00073a  f7fffffe          BL       pbuf_free
00073e  e005              B        |L1.1868|
                  |L1.1856|
;;;1203     } else if (err == ERR_OK) {
000740  b926              CBNZ     r6,|L1.1868|
;;;1204       return tcp_close(pcb);
000742  4628              MOV      r0,r5
000744  f7fffffe          BL       tcp_close
                  |L1.1864|
;;;1205     }
;;;1206     return ERR_OK;
;;;1207   }
000748  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1868|
00074c  2000              MOVS     r0,#0                 ;1206
00074e  e7fb              B        |L1.1864|
;;;1208   #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_process_refused_data PROC
;;;1084   err_t
;;;1085   tcp_process_refused_data(struct tcp_pcb *pcb)
000750  e92d41f0          PUSH     {r4-r8,lr}
;;;1086   {
000754  4604              MOV      r4,r0
;;;1087     err_t err;
;;;1088     u8_t refused_flags = pcb->refused_data->flags;
000756  6f60              LDR      r0,[r4,#0x74]
000758  7b47              LDRB     r7,[r0,#0xd]
;;;1089     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1090        closes the pcb */
;;;1091     struct pbuf *refused_data = pcb->refused_data;
00075a  6f66              LDR      r6,[r4,#0x74]
;;;1092     pcb->refused_data = NULL;
00075c  2000              MOVS     r0,#0
00075e  6760              STR      r0,[r4,#0x74]
;;;1093     /* Notify again application with data previously received. */
;;;1094     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
000760  bf00              NOP      
000762  bf00              NOP      
;;;1095     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
000764  bf00              NOP      
000766  6fe0              LDR      r0,[r4,#0x7c]
000768  b140              CBZ      r0,|L1.1916|
00076a  2300              MOVS     r3,#0
00076c  4632              MOV      r2,r6
00076e  4621              MOV      r1,r4
000770  f8d4c07c          LDR      r12,[r4,#0x7c]
000774  6920              LDR      r0,[r4,#0x10]
000776  47e0              BLX      r12
000778  4605              MOV      r5,r0
00077a  e006              B        |L1.1930|
                  |L1.1916|
00077c  2300              MOVS     r3,#0
00077e  4632              MOV      r2,r6
000780  4621              MOV      r1,r4
000782  4618              MOV      r0,r3
000784  f7fffffe          BL       tcp_recv_null
000788  4605              MOV      r5,r0
                  |L1.1930|
00078a  bf00              NOP      
;;;1096     if (err == ERR_OK) {
00078c  b9fd              CBNZ     r5,|L1.1998|
;;;1097       /* did refused_data include a FIN? */
;;;1098       if (refused_flags & PBUF_FLAG_TCP_FIN) {
00078e  f0070020          AND      r0,r7,#0x20
000792  b328              CBZ      r0,|L1.2016|
;;;1099         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1100            for the FIN's seqno */
;;;1101         if (pcb->rcv_wnd != TCP_WND) {
000794  8da0              LDRH     r0,[r4,#0x2c]
000796  f24161d0          MOV      r1,#0x16d0
00079a  4288              CMP      r0,r1
00079c  d002              BEQ      |L1.1956|
;;;1102           pcb->rcv_wnd++;
00079e  8da0              LDRH     r0,[r4,#0x2c]
0007a0  1c40              ADDS     r0,r0,#1
0007a2  85a0              STRH     r0,[r4,#0x2c]
                  |L1.1956|
;;;1103         }
;;;1104         TCP_EVENT_CLOSED(pcb, err);
0007a4  bf00              NOP      
0007a6  6fe0              LDR      r0,[r4,#0x7c]
0007a8  b140              CBZ      r0,|L1.1980|
0007aa  2300              MOVS     r3,#0
0007ac  461a              MOV      r2,r3
0007ae  4621              MOV      r1,r4
0007b0  f8d4c07c          LDR      r12,[r4,#0x7c]
0007b4  6920              LDR      r0,[r4,#0x10]
0007b6  47e0              BLX      r12
0007b8  4605              MOV      r5,r0
0007ba  e000              B        |L1.1982|
                  |L1.1980|
0007bc  2500              MOVS     r5,#0
                  |L1.1982|
0007be  bf00              NOP      
;;;1105         if (err == ERR_ABRT) {
0007c0  f105000a          ADD      r0,r5,#0xa
0007c4  b960              CBNZ     r0,|L1.2016|
;;;1106           return ERR_ABRT;
0007c6  f06f0009          MVN      r0,#9
                  |L1.1994|
;;;1107         }
;;;1108       }
;;;1109     } else if (err == ERR_ABRT) {
;;;1110       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1111       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1112          segment contains data). */
;;;1113       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1114       return ERR_ABRT;
;;;1115     } else {
;;;1116       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1117       pcb->refused_data = refused_data;
;;;1118     }
;;;1119     return ERR_OK;
;;;1120   }
0007ca  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1998|
0007ce  f105000a          ADD      r0,r5,#0xa            ;1109
0007d2  b920              CBNZ     r0,|L1.2014|
0007d4  bf00              NOP                            ;1113
0007d6  bf00              NOP                            ;1113
0007d8  f06f0009          MVN      r0,#9                 ;1114
0007dc  e7f5              B        |L1.1994|
                  |L1.2014|
0007de  6766              STR      r6,[r4,#0x74]         ;1117
                  |L1.2016|
0007e0  2000              MOVS     r0,#0                 ;1119
0007e2  e7f2              B        |L1.1994|
;;;1121   
                          ENDP

                  tcp_fasttmr PROC
;;;1045   void
;;;1046   tcp_fasttmr(void)
0007e4  b570              PUSH     {r4-r6,lr}
;;;1047   {
;;;1048     struct tcp_pcb *pcb;
;;;1049   
;;;1050     ++tcp_timer_ctr;
0007e6  481f              LDR      r0,|L1.2148|
0007e8  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
0007ea  1c40              ADDS     r0,r0,#1
0007ec  491d              LDR      r1,|L1.2148|
0007ee  7008              STRB     r0,[r1,#0]
;;;1051   
;;;1052   tcp_fasttmr_start:
0007f0  bf00              NOP      
                  |L1.2034|
;;;1053     pcb = tcp_active_pcbs;
0007f2  4817              LDR      r0,|L1.2128|
0007f4  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;1054   
;;;1055     while(pcb != NULL) {
0007f6  e039              B        |L1.2156|
                  |L1.2040|
;;;1056       if (pcb->last_timer != tcp_timer_ctr) {
0007f8  f8940021          LDRB     r0,[r4,#0x21]
0007fc  4919              LDR      r1,|L1.2148|
0007fe  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
000800  4288              CMP      r0,r1
000802  d033              BEQ      |L1.2156|
;;;1057         struct tcp_pcb *next;
;;;1058         pcb->last_timer = tcp_timer_ctr;
000804  4817              LDR      r0,|L1.2148|
000806  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000808  f8840021          STRB     r0,[r4,#0x21]
;;;1059         /* send delayed ACKs */
;;;1060         if (pcb->flags & TF_ACK_DELAY) {
00080c  7fa0              LDRB     r0,[r4,#0x1e]
00080e  f0000001          AND      r0,r0,#1
000812  b170              CBZ      r0,|L1.2098|
;;;1061           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
000814  bf00              NOP      
000816  bf00              NOP      
;;;1062           tcp_ack_now(pcb);
000818  bf00              NOP      
00081a  7fa0              LDRB     r0,[r4,#0x1e]
00081c  f0400002          ORR      r0,r0,#2
000820  77a0              STRB     r0,[r4,#0x1e]
000822  bf00              NOP      
;;;1063           tcp_output(pcb);
000824  4620              MOV      r0,r4
000826  f7fffffe          BL       tcp_output
;;;1064           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
00082a  7fa0              LDRB     r0,[r4,#0x1e]
00082c  f0200003          BIC      r0,r0,#3
000830  77a0              STRB     r0,[r4,#0x1e]
                  |L1.2098|
;;;1065         }
;;;1066   
;;;1067         next = pcb->next;
000832  68e5              LDR      r5,[r4,#0xc]
;;;1068   
;;;1069         /* If there is data which was previously "refused" by upper layer */
;;;1070         if (pcb->refused_data != NULL) {
000834  6f60              LDR      r0,[r4,#0x74]
000836  b1b8              CBZ      r0,|L1.2152|
;;;1071           tcp_active_pcbs_changed = 0;
000838  2000              MOVS     r0,#0
00083a  4906              LDR      r1,|L1.2132|
00083c  7008              STRB     r0,[r1,#0]
;;;1072           tcp_process_refused_data(pcb);
00083e  4620              MOV      r0,r4
000840  f7fffffe          BL       tcp_process_refused_data
;;;1073           if (tcp_active_pcbs_changed) {
000844  4803              LDR      r0,|L1.2132|
000846  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000848  b170              CBZ      r0,|L1.2152|
;;;1074             /* application callback has changed the pcb list: restart the loop */
;;;1075             goto tcp_fasttmr_start;
00084a  e7d2              B        |L1.2034|
                  |L1.2124|
                          DCD      tcp_tmp_pcb
                  |L1.2128|
                          DCD      tcp_active_pcbs
                  |L1.2132|
                          DCD      tcp_active_pcbs_changed
                  |L1.2136|
                          DCD      tcp_tw_pcbs
                  |L1.2140|
                          DCD      tcp_bound_pcbs
                  |L1.2144|
                          DCD      tcp_listen_pcbs
                  |L1.2148|
                          DCD      tcp_timer_ctr
                  |L1.2152|
;;;1076           }
;;;1077         }
;;;1078         pcb = next;
000868  462c              MOV      r4,r5
;;;1079       }
00086a  bf00              NOP      
                  |L1.2156|
00086c  2c00              CMP      r4,#0                 ;1055
00086e  d1c3              BNE      |L1.2040|
;;;1080     }
;;;1081   }
000870  bd70              POP      {r4-r6,pc}
;;;1082   
                          ENDP

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000872  b510              PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000874  f7fffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1) {
000878  48fe              LDR      r0,|L1.3188|
00087a  7800              LDRB     r0,[r0,#0]  ; tcp_timer
00087c  1c40              ADDS     r0,r0,#1
00087e  b2c0              UXTB     r0,r0
000880  49fc              LDR      r1,|L1.3188|
000882  7008              STRB     r0,[r1,#0]
000884  f0000001          AND      r0,r0,#1
000888  b108              CBZ      r0,|L1.2190|
;;;147        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;148           tcp_tmr() is called. */
;;;149        tcp_slowtmr();
00088a  f7fffffe          BL       tcp_slowtmr
                  |L1.2190|
;;;150      }
;;;151    }
00088e  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  tcp_shutdown PROC
;;;312    err_t
;;;313    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000890  b570              PUSH     {r4-r6,lr}
;;;314    {
000892  4604              MOV      r4,r0
000894  460d              MOV      r5,r1
000896  4616              MOV      r6,r2
;;;315      if (pcb->state == LISTEN) {
000898  7e20              LDRB     r0,[r4,#0x18]
00089a  2801              CMP      r0,#1
00089c  d102              BNE      |L1.2212|
;;;316        return ERR_CONN;
00089e  f06f000c          MVN      r0,#0xc
                  |L1.2210|
;;;317      }
;;;318      if (shut_rx) {
;;;319        /* shut down the receive side: set a flag not to receive any more data... */
;;;320        pcb->flags |= TF_RXCLOSED;
;;;321        if (shut_tx) {
;;;322          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;323          return tcp_close_shutdown(pcb, 1);
;;;324        }
;;;325        /* ... and free buffered data */
;;;326        if (pcb->refused_data != NULL) {
;;;327          pbuf_free(pcb->refused_data);
;;;328          pcb->refused_data = NULL;
;;;329        }
;;;330      }
;;;331      if (shut_tx) {
;;;332        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;333           Only close in these states as the others directly deallocate the PCB */
;;;334        switch (pcb->state) {
;;;335        case SYN_RCVD:
;;;336        case ESTABLISHED:
;;;337        case CLOSE_WAIT:
;;;338          return tcp_close_shutdown(pcb, shut_rx);
;;;339        default:
;;;340          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;341            into CLOSED state, where the PCB is deallocated. */
;;;342          return ERR_CONN;
;;;343        }
;;;344      }
;;;345      return ERR_OK;
;;;346    }
0008a2  bd70              POP      {r4-r6,pc}
                  |L1.2212|
0008a4  b185              CBZ      r5,|L1.2248|
0008a6  7fa0              LDRB     r0,[r4,#0x1e]         ;320
0008a8  f0400010          ORR      r0,r0,#0x10           ;320
0008ac  77a0              STRB     r0,[r4,#0x1e]         ;320
0008ae  b126              CBZ      r6,|L1.2234|
0008b0  2101              MOVS     r1,#1                 ;323
0008b2  4620              MOV      r0,r4                 ;323
0008b4  f7fffffe          BL       tcp_close_shutdown
0008b8  e7f3              B        |L1.2210|
                  |L1.2234|
0008ba  6f60              LDR      r0,[r4,#0x74]         ;326
0008bc  b120              CBZ      r0,|L1.2248|
0008be  6f60              LDR      r0,[r4,#0x74]         ;327
0008c0  f7fffffe          BL       pbuf_free
0008c4  2000              MOVS     r0,#0                 ;328
0008c6  6760              STR      r0,[r4,#0x74]         ;328
                  |L1.2248|
0008c8  b18e              CBZ      r6,|L1.2286|
0008ca  7e20              LDRB     r0,[r4,#0x18]         ;334
0008cc  2803              CMP      r0,#3                 ;334
0008ce  d004              BEQ      |L1.2266|
0008d0  2804              CMP      r0,#4                 ;334
0008d2  d003              BEQ      |L1.2268|
0008d4  2807              CMP      r0,#7                 ;334
0008d6  d107              BNE      |L1.2280|
0008d8  e001              B        |L1.2270|
                  |L1.2266|
0008da  bf00              NOP                            ;336
                  |L1.2268|
0008dc  bf00              NOP                            ;337
                  |L1.2270|
0008de  b2e9              UXTB     r1,r5                 ;338
0008e0  4620              MOV      r0,r4                 ;338
0008e2  f7fffffe          BL       tcp_close_shutdown
0008e6  e7dc              B        |L1.2210|
                  |L1.2280|
0008e8  f06f000c          MVN      r0,#0xc               ;342
0008ec  e7d9              B        |L1.2210|
                  |L1.2286|
0008ee  2000              MOVS     r0,#0                 ;345
0008f0  e7d7              B        |L1.2210|
;;;347    
                          ENDP

                  tcp_abandon PROC
;;;356    void
;;;357    tcp_abandon(struct tcp_pcb *pcb, int reset)
0008f2  e92d47fc          PUSH     {r2-r10,lr}
;;;358    {
0008f6  4604              MOV      r4,r0
0008f8  460e              MOV      r6,r1
;;;359      u32_t seqno, ackno;
;;;360    #if LWIP_CALLBACK_API  
;;;361      tcp_err_fn errf;
;;;362    #endif /* LWIP_CALLBACK_API */
;;;363      void *errf_arg;
;;;364    
;;;365      /* pcb->state LISTEN not allowed here */
;;;366      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
0008fa  bf00              NOP      
0008fc  bf00              NOP      
;;;367        pcb->state != LISTEN);
;;;368      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;369         are in an active state, call the receive function associated with
;;;370         the PCB with a NULL argument, and send an RST to the remote end. */
;;;371      if (pcb->state == TIME_WAIT) {
0008fe  7e20              LDRB     r0,[r4,#0x18]
000900  280a              CMP      r0,#0xa
000902  d108              BNE      |L1.2326|
;;;372        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
000904  4621              MOV      r1,r4
000906  48dc              LDR      r0,|L1.3192|
000908  f7fffffe          BL       tcp_pcb_remove
;;;373        memp_free(MEMP_TCP_PCB, pcb);
00090c  4621              MOV      r1,r4
00090e  2002              MOVS     r0,#2
000910  f7fffffe          BL       memp_free
000914  e031              B        |L1.2426|
                  |L1.2326|
;;;374      } else {
;;;375        seqno = pcb->snd_nxt;
000916  6d27              LDR      r7,[r4,#0x50]
;;;376        ackno = pcb->rcv_nxt;
000918  f8d48028          LDR      r8,[r4,#0x28]
;;;377    #if LWIP_CALLBACK_API
;;;378        errf = pcb->errf;
00091c  f8d45088          LDR      r5,[r4,#0x88]
;;;379    #endif /* LWIP_CALLBACK_API */
;;;380        errf_arg = pcb->callback_arg;
000920  f8d49010          LDR      r9,[r4,#0x10]
;;;381        TCP_PCB_REMOVE_ACTIVE(pcb);
000924  bf00              NOP      
000926  4621              MOV      r1,r4
000928  48d4              LDR      r0,|L1.3196|
00092a  f7fffffe          BL       tcp_pcb_remove
00092e  2001              MOVS     r0,#1
000930  49d3              LDR      r1,|L1.3200|
000932  7008              STRB     r0,[r1,#0]
000934  bf00              NOP      
;;;382        if (pcb->unacked != NULL) {
000936  6f20              LDR      r0,[r4,#0x70]
000938  b110              CBZ      r0,|L1.2368|
;;;383          tcp_segs_free(pcb->unacked);
00093a  6f20              LDR      r0,[r4,#0x70]
00093c  f7fffffe          BL       tcp_segs_free
                  |L1.2368|
;;;384        }
;;;385        if (pcb->unsent != NULL) {
000940  6ee0              LDR      r0,[r4,#0x6c]
000942  b110              CBZ      r0,|L1.2378|
;;;386          tcp_segs_free(pcb->unsent);
000944  6ee0              LDR      r0,[r4,#0x6c]
000946  f7fffffe          BL       tcp_segs_free
                  |L1.2378|
;;;387        }
;;;388    #if TCP_QUEUE_OOSEQ    
;;;389        if (pcb->ooseq != NULL) {
;;;390          tcp_segs_free(pcb->ooseq);
;;;391        }
;;;392    #endif /* TCP_QUEUE_OOSEQ */
;;;393        if (reset) {
00094a  b15e              CBZ      r6,|L1.2404|
;;;394          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
00094c  bf00              NOP      
00094e  bf00              NOP      
;;;395          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
000950  8ba0              LDRH     r0,[r4,#0x1c]
000952  8b61              LDRH     r1,[r4,#0x1a]
000954  1d23              ADDS     r3,r4,#4
000956  4622              MOV      r2,r4
000958  e9cd1000          STRD     r1,r0,[sp,#0]
00095c  4641              MOV      r1,r8
00095e  4638              MOV      r0,r7
000960  f7fffffe          BL       tcp_rst
                  |L1.2404|
;;;396        }
;;;397        memp_free(MEMP_TCP_PCB, pcb);
000964  4621              MOV      r1,r4
000966  2002              MOVS     r0,#2
000968  f7fffffe          BL       memp_free
;;;398        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
00096c  bf00              NOP      
00096e  b11d              CBZ      r5,|L1.2424|
000970  f06f0109          MVN      r1,#9
000974  4648              MOV      r0,r9
000976  47a8              BLX      r5
                  |L1.2424|
000978  bf00              NOP      
                  |L1.2426|
;;;399      }
;;;400    }
00097a  e8bd87fc          POP      {r2-r10,pc}
;;;401    
                          ENDP

                  tcp_abort PROC
;;;412    void
;;;413    tcp_abort(struct tcp_pcb *pcb)
00097e  b510              PUSH     {r4,lr}
;;;414    {
000980  4604              MOV      r4,r0
;;;415      tcp_abandon(pcb, 1);
000982  2101              MOVS     r1,#1
000984  4620              MOV      r0,r4
000986  f7fffffe          BL       tcp_abandon
;;;416    }
00098a  bd10              POP      {r4,pc}
;;;417    
                          ENDP

                  tcp_new_port PROC
;;;646    static u16_t
;;;647    tcp_new_port(void)
00098c  b530              PUSH     {r4,r5,lr}
;;;648    {
;;;649      u8_t i;
;;;650      u16_t n = 0;
00098e  2300              MOVS     r3,#0
;;;651      struct tcp_pcb *pcb;
;;;652      
;;;653    again:
000990  bf00              NOP      
                  |L1.2450|
;;;654      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
000992  48bc              LDR      r0,|L1.3204|
000994  8804              LDRH     r4,[r0,#0]  ; tcp_port
000996  8800              LDRH     r0,[r0,#0]  ; tcp_port
000998  1c40              ADDS     r0,r0,#1
00099a  4dba              LDR      r5,|L1.3204|
00099c  8028              STRH     r0,[r5,#0]
00099e  f64f70ff          MOV      r0,#0xffff
0009a2  4284              CMP      r4,r0
0009a4  d103              BNE      |L1.2478|
;;;655        tcp_port = TCP_LOCAL_PORT_RANGE_START;
0009a6  f44f4040          MOV      r0,#0xc000
0009aa  462c              MOV      r4,r5
0009ac  8020              STRH     r0,[r4,#0]
                  |L1.2478|
;;;656      }
;;;657      /* Check all PCB lists. */
;;;658      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
0009ae  2100              MOVS     r1,#0
0009b0  e017              B        |L1.2530|
                  |L1.2482|
;;;659        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
0009b2  48b5              LDR      r0,|L1.3208|
0009b4  f8500021          LDR      r0,[r0,r1,LSL #2]
0009b8  6802              LDR      r2,[r0,#0]
0009ba  e00e              B        |L1.2522|
                  |L1.2492|
;;;660          if (pcb->local_port == tcp_port) {
0009bc  8b50              LDRH     r0,[r2,#0x1a]
0009be  4cb1              LDR      r4,|L1.3204|
0009c0  8824              LDRH     r4,[r4,#0]  ; tcp_port
0009c2  42a0              CMP      r0,r4
0009c4  d108              BNE      |L1.2520|
;;;661            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
0009c6  1c58              ADDS     r0,r3,#1
0009c8  b280              UXTH     r0,r0
0009ca  4603              MOV      r3,r0
0009cc  f5b04f80          CMP      r0,#0x4000
0009d0  db01              BLT      |L1.2518|
;;;662              return 0;
0009d2  2000              MOVS     r0,#0
                  |L1.2516|
;;;663            }
;;;664            goto again;
;;;665          }
;;;666        }
;;;667      }
;;;668      return tcp_port;
;;;669    }
0009d4  bd30              POP      {r4,r5,pc}
                  |L1.2518|
0009d6  e7dc              B        |L1.2450|
                  |L1.2520|
0009d8  68d2              LDR      r2,[r2,#0xc]          ;659
                  |L1.2522|
0009da  2a00              CMP      r2,#0                 ;659
0009dc  d1ee              BNE      |L1.2492|
0009de  1c48              ADDS     r0,r1,#1              ;658
0009e0  b2c1              UXTB     r1,r0                 ;658
                  |L1.2530|
0009e2  2904              CMP      r1,#4                 ;658
0009e4  dbe5              BLT      |L1.2482|
0009e6  48a7              LDR      r0,|L1.3204|
0009e8  8800              LDRH     r0,[r0,#0]            ;668  ; tcp_port
0009ea  e7f3              B        |L1.2516|
;;;670    
                          ENDP

                  tcp_bind PROC
;;;432    err_t
;;;433    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
0009ec  e92d47f0          PUSH     {r4-r10,lr}
;;;434    {
0009f0  4605              MOV      r5,r0
0009f2  460c              MOV      r4,r1
0009f4  4617              MOV      r7,r2
;;;435      int i;
;;;436      int max_pcb_list = NUM_TCP_PCB_LISTS;
0009f6  f04f0904          MOV      r9,#4
;;;437      struct tcp_pcb *cpcb;
;;;438    
;;;439      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
0009fa  bf00              NOP      
0009fc  7e28              LDRB     r0,[r5,#0x18]
0009fe  b118              CBZ      r0,|L1.2568|
000a00  f06f0005          MVN      r0,#5
                  |L1.2564|
;;;440    
;;;441    #if SO_REUSE
;;;442      /* Unless the REUSEADDR flag is set,
;;;443         we have to check the pcbs in TIME-WAIT state, also.
;;;444         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;445         packets using both local and remote IP addresses and ports to distinguish.
;;;446       */
;;;447      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;448        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;449      }
;;;450    #endif /* SO_REUSE */
;;;451    
;;;452      if (port == 0) {
;;;453        port = tcp_new_port();
;;;454        if (port == 0) {
;;;455          return ERR_BUF;
;;;456        }
;;;457      }
;;;458    
;;;459      /* Check if the address already is in use (on all lists) */
;;;460      for (i = 0; i < max_pcb_list; i++) {
;;;461        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;462          if (cpcb->local_port == port) {
;;;463    #if SO_REUSE
;;;464            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;465               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;466               tcp_connect. */
;;;467            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;468                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;469    #endif /* SO_REUSE */
;;;470            {
;;;471              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;472                  ip_addr_isany(ipaddr) ||
;;;473                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;474                return ERR_USE;
;;;475              }
;;;476            }
;;;477          }
;;;478        }
;;;479      }
;;;480    
;;;481      if (!ip_addr_isany(ipaddr)) {
;;;482        pcb->local_ip = *ipaddr;
;;;483      }
;;;484      pcb->local_port = port;
;;;485      TCP_REG(&tcp_bound_pcbs, pcb);
;;;486      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;487      return ERR_OK;
;;;488    }
000a04  e8bd87f0          POP      {r4-r10,pc}
                  |L1.2568|
000a08  bf00              NOP                            ;439
000a0a  b937              CBNZ     r7,|L1.2586|
000a0c  f7fffffe          BL       tcp_new_port
000a10  4607              MOV      r7,r0                 ;453
000a12  b917              CBNZ     r7,|L1.2586|
000a14  f06f0001          MVN      r0,#1                 ;455
000a18  e7f4              B        |L1.2564|
                  |L1.2586|
000a1a  f04f0800          MOV      r8,#0                 ;460
000a1e  e019              B        |L1.2644|
                  |L1.2592|
000a20  4899              LDR      r0,|L1.3208|
000a22  f8500028          LDR      r0,[r0,r8,LSL #2]     ;461
000a26  6806              LDR      r6,[r0,#0]            ;461
000a28  e010              B        |L1.2636|
                  |L1.2602|
000a2a  8b70              LDRH     r0,[r6,#0x1a]         ;462
000a2c  42b8              CMP      r0,r7                 ;462
000a2e  d10c              BNE      |L1.2634|
000a30  b146              CBZ      r6,|L1.2628|
000a32  6830              LDR      r0,[r6,#0]            ;471
000a34  b130              CBZ      r0,|L1.2628|
000a36  b12c              CBZ      r4,|L1.2628|
000a38  6820              LDR      r0,[r4,#0]            ;472
000a3a  b118              CBZ      r0,|L1.2628|
000a3c  6830              LDR      r0,[r6,#0]            ;473
000a3e  6821              LDR      r1,[r4,#0]            ;473
000a40  4288              CMP      r0,r1                 ;473
000a42  d102              BNE      |L1.2634|
                  |L1.2628|
000a44  f06f0007          MVN      r0,#7                 ;474
000a48  e7dc              B        |L1.2564|
                  |L1.2634|
000a4a  68f6              LDR      r6,[r6,#0xc]          ;461
                  |L1.2636|
000a4c  2e00              CMP      r6,#0                 ;461
000a4e  d1ec              BNE      |L1.2602|
000a50  f1080801          ADD      r8,r8,#1              ;460
                  |L1.2644|
000a54  45c8              CMP      r8,r9                 ;460
000a56  dbe3              BLT      |L1.2592|
000a58  b11c              CBZ      r4,|L1.2658|
000a5a  6820              LDR      r0,[r4,#0]            ;481
000a5c  b108              CBZ      r0,|L1.2658|
000a5e  6820              LDR      r0,[r4,#0]            ;482
000a60  6028              STR      r0,[r5,#0]            ;482
                  |L1.2658|
000a62  836f              STRH     r7,[r5,#0x1a]         ;484
000a64  bf00              NOP                            ;485
000a66  4889              LDR      r0,|L1.3212|
000a68  6800              LDR      r0,[r0,#0]            ;485  ; tcp_bound_pcbs
000a6a  60e8              STR      r0,[r5,#0xc]          ;485
000a6c  4887              LDR      r0,|L1.3212|
000a6e  6005              STR      r5,[r0,#0]            ;485  ; tcp_bound_pcbs
000a70  f7fffffe          BL       tcp_timer_needed
000a74  bf00              NOP                            ;485
000a76  bf00              NOP                            ;486
000a78  bf00              NOP                            ;486
000a7a  2000              MOVS     r0,#0                 ;487
000a7c  e7c2              B        |L1.2564|
;;;489    #if LWIP_CALLBACK_API
                          ENDP

                  tcp_accept_null PROC
;;;493    static err_t
;;;494    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000a7e  4603              MOV      r3,r0
;;;495    {
;;;496      LWIP_UNUSED_ARG(arg);
;;;497      LWIP_UNUSED_ARG(pcb);
;;;498      LWIP_UNUSED_ARG(err);
;;;499    
;;;500      return ERR_ABRT;
000a80  f06f0009          MVN      r0,#9
;;;501    }
000a84  4770              BX       lr
;;;502    #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_listen_with_backlog PROC
;;;518    struct tcp_pcb *
;;;519    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000a86  b570              PUSH     {r4-r6,lr}
;;;520    {
000a88  4605              MOV      r5,r0
000a8a  460e              MOV      r6,r1
;;;521      struct tcp_pcb_listen *lpcb;
;;;522    
;;;523      LWIP_UNUSED_ARG(backlog);
;;;524      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
000a8c  bf00              NOP      
000a8e  7e28              LDRB     r0,[r5,#0x18]
000a90  b108              CBZ      r0,|L1.2710|
000a92  2000              MOVS     r0,#0
                  |L1.2708|
;;;525    
;;;526      /* already listening? */
;;;527      if (pcb->state == LISTEN) {
;;;528        return pcb;
;;;529      }
;;;530    #if SO_REUSE
;;;531      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;532        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;533           is declared (listen-/connection-pcb), we have to make sure now that
;;;534           this port is only used once for every local IP. */
;;;535        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;536          if (lpcb->local_port == pcb->local_port) {
;;;537            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;538              /* this address/port is already used */
;;;539              return NULL;
;;;540            }
;;;541          }
;;;542        }
;;;543      }
;;;544    #endif /* SO_REUSE */
;;;545      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;546      if (lpcb == NULL) {
;;;547        return NULL;
;;;548      }
;;;549      lpcb->callback_arg = pcb->callback_arg;
;;;550      lpcb->local_port = pcb->local_port;
;;;551      lpcb->state = LISTEN;
;;;552      lpcb->prio = pcb->prio;
;;;553      lpcb->so_options = pcb->so_options;
;;;554      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;555      lpcb->ttl = pcb->ttl;
;;;556      lpcb->tos = pcb->tos;
;;;557      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;558      if (pcb->local_port != 0) {
;;;559        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;560      }
;;;561      memp_free(MEMP_TCP_PCB, pcb);
;;;562    #if LWIP_CALLBACK_API
;;;563      lpcb->accept = tcp_accept_null;
;;;564    #endif /* LWIP_CALLBACK_API */
;;;565    #if TCP_LISTEN_BACKLOG
;;;566      lpcb->accepts_pending = 0;
;;;567      lpcb->backlog = (backlog ? backlog : 1);
;;;568    #endif /* TCP_LISTEN_BACKLOG */
;;;569      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;570      return (struct tcp_pcb *)lpcb;
;;;571    }
000a94  bd70              POP      {r4-r6,pc}
                  |L1.2710|
000a96  bf00              NOP                            ;524
000a98  7e28              LDRB     r0,[r5,#0x18]         ;527
000a9a  2801              CMP      r0,#1                 ;527
000a9c  d101              BNE      |L1.2722|
000a9e  4628              MOV      r0,r5                 ;528
000aa0  e7f8              B        |L1.2708|
                  |L1.2722|
000aa2  2003              MOVS     r0,#3                 ;545
000aa4  f7fffffe          BL       memp_malloc
000aa8  4604              MOV      r4,r0                 ;545
000aaa  b90c              CBNZ     r4,|L1.2736|
000aac  2000              MOVS     r0,#0                 ;547
000aae  e7f1              B        |L1.2708|
                  |L1.2736|
000ab0  6928              LDR      r0,[r5,#0x10]         ;549
000ab2  6120              STR      r0,[r4,#0x10]         ;549
000ab4  8b68              LDRH     r0,[r5,#0x1a]         ;550
000ab6  8360              STRH     r0,[r4,#0x1a]         ;550
000ab8  2001              MOVS     r0,#1                 ;551
000aba  7620              STRB     r0,[r4,#0x18]         ;551
000abc  7e68              LDRB     r0,[r5,#0x19]         ;552
000abe  7660              STRB     r0,[r4,#0x19]         ;552
000ac0  7a28              LDRB     r0,[r5,#8]            ;553
000ac2  7220              STRB     r0,[r4,#8]            ;553
000ac4  7a20              LDRB     r0,[r4,#8]            ;554
000ac6  f0400002          ORR      r0,r0,#2              ;554
000aca  7220              STRB     r0,[r4,#8]            ;554
000acc  7aa8              LDRB     r0,[r5,#0xa]          ;555
000ace  72a0              STRB     r0,[r4,#0xa]          ;555
000ad0  7a68              LDRB     r0,[r5,#9]            ;556
000ad2  7260              STRB     r0,[r4,#9]            ;556
000ad4  6828              LDR      r0,[r5,#0]            ;557
000ad6  6020              STR      r0,[r4,#0]            ;557
000ad8  8b68              LDRH     r0,[r5,#0x1a]         ;558
000ada  b330              CBZ      r0,|L1.2858|
000adc  bf00              NOP                            ;559
000ade  486b              LDR      r0,|L1.3212|
000ae0  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000ae2  42a8              CMP      r0,r5                 ;559
000ae4  d105              BNE      |L1.2802|
000ae6  4869              LDR      r0,|L1.3212|
000ae8  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000aea  68c0              LDR      r0,[r0,#0xc]          ;559
000aec  4967              LDR      r1,|L1.3212|
000aee  6008              STR      r0,[r1,#0]            ;559  ; tcp_bound_pcbs
000af0  e018              B        |L1.2852|
                  |L1.2802|
000af2  4866              LDR      r0,|L1.3212|
000af4  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000af6  4966              LDR      r1,|L1.3216|
000af8  6008              STR      r0,[r1,#0]            ;559  ; tcp_tmp_pcb
000afa  e00e              B        |L1.2842|
                  |L1.2812|
000afc  4864              LDR      r0,|L1.3216|
000afe  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
000b00  68c0              LDR      r0,[r0,#0xc]          ;559
000b02  42a8              CMP      r0,r5                 ;559
000b04  d104              BNE      |L1.2832|
000b06  4962              LDR      r1,|L1.3216|
000b08  68e8              LDR      r0,[r5,#0xc]          ;559
000b0a  6809              LDR      r1,[r1,#0]            ;559  ; tcp_tmp_pcb
000b0c  60c8              STR      r0,[r1,#0xc]          ;559
000b0e  e008              B        |L1.2850|
                  |L1.2832|
000b10  485f              LDR      r0,|L1.3216|
000b12  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
000b14  68c0              LDR      r0,[r0,#0xc]          ;559
000b16  495e              LDR      r1,|L1.3216|
000b18  6008              STR      r0,[r1,#0]            ;559  ; tcp_tmp_pcb
                  |L1.2842|
000b1a  485d              LDR      r0,|L1.3216|
000b1c  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
000b1e  2800              CMP      r0,#0                 ;559
000b20  d1ec              BNE      |L1.2812|
                  |L1.2850|
000b22  bf00              NOP                            ;559
                  |L1.2852|
000b24  2000              MOVS     r0,#0                 ;559
000b26  60e8              STR      r0,[r5,#0xc]          ;559
000b28  bf00              NOP                            ;559
                  |L1.2858|
000b2a  4629              MOV      r1,r5                 ;561
000b2c  2002              MOVS     r0,#2                 ;561
000b2e  f7fffffe          BL       memp_free
000b32  4858              LDR      r0,|L1.3220|
000b34  6160              STR      r0,[r4,#0x14]         ;563
000b36  2000              MOVS     r0,#0                 ;566
000b38  7760              STRB     r0,[r4,#0x1d]         ;566
000b3a  b10e              CBZ      r6,|L1.2880|
000b3c  4630              MOV      r0,r6                 ;567
000b3e  e000              B        |L1.2882|
                  |L1.2880|
000b40  2001              MOVS     r0,#1                 ;567
                  |L1.2882|
000b42  7720              STRB     r0,[r4,#0x1c]         ;567
000b44  bf00              NOP                            ;569
000b46  4854              LDR      r0,|L1.3224|
000b48  6800              LDR      r0,[r0,#0]            ;569  ; tcp_listen_pcbs
000b4a  60e0              STR      r0,[r4,#0xc]          ;569
000b4c  4852              LDR      r0,|L1.3224|
000b4e  6004              STR      r4,[r0,#0]            ;569  ; tcp_listen_pcbs
000b50  f7fffffe          BL       tcp_timer_needed
000b54  bf00              NOP                            ;569
000b56  4620              MOV      r0,r4                 ;570
000b58  e79c              B        |L1.2708|
;;;572    
                          ENDP

                  tcp_eff_send_mss PROC
;;;1585   u16_t
;;;1586   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
000b5a  e92d41f0          PUSH     {r4-r8,lr}
;;;1587   {
000b5e  4605              MOV      r5,r0
000b60  460e              MOV      r6,r1
;;;1588     u16_t mss_s;
;;;1589     struct netif *outif;
;;;1590   
;;;1591     outif = ip_route(addr);
000b62  4630              MOV      r0,r6
000b64  f7fffffe          BL       ip_route
000b68  4604              MOV      r4,r0
;;;1592     if ((outif != NULL) && (outif->mtu != 0)) {
000b6a  b154              CBZ      r4,|L1.2946|
000b6c  8ca0              LDRH     r0,[r4,#0x24]
000b6e  b140              CBZ      r0,|L1.2946|
;;;1593       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
000b70  8ca0              LDRH     r0,[r4,#0x24]
000b72  3828              SUBS     r0,r0,#0x28
000b74  b287              UXTH     r7,r0
;;;1594       /* RFC 1122, chap 4.2.2.6:
;;;1595        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1596        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1597        */
;;;1598       sendmss = LWIP_MIN(sendmss, mss_s);
000b76  42bd              CMP      r5,r7
000b78  da01              BGE      |L1.2942|
000b7a  4628              MOV      r0,r5
000b7c  e000              B        |L1.2944|
                  |L1.2942|
000b7e  4638              MOV      r0,r7
                  |L1.2944|
000b80  4605              MOV      r5,r0
                  |L1.2946|
;;;1599     }
;;;1600     return sendmss;
000b82  4628              MOV      r0,r5
;;;1601   }
000b84  e8bd81f0          POP      {r4-r8,pc}
;;;1602   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP

                  tcp_next_iss PROC
;;;1570   u32_t
;;;1571   tcp_next_iss(void)
000b88  4844              LDR      r0,|L1.3228|
;;;1572   {
;;;1573     static u32_t iss = 6510;
;;;1574     
;;;1575     iss += tcp_ticks;       /* XXX */
000b8a  6800              LDR      r0,[r0,#0]  ; iss
000b8c  4944              LDR      r1,|L1.3232|
000b8e  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000b90  4408              ADD      r0,r0,r1
000b92  4942              LDR      r1,|L1.3228|
000b94  6008              STR      r0,[r1,#0]  ; iss
;;;1576     return iss;
000b96  4608              MOV      r0,r1
000b98  6800              LDR      r0,[r0,#0]  ; iss
;;;1577   }
000b9a  4770              BX       lr
;;;1578   
                          ENDP

                  tcp_connect PROC
;;;683    err_t
;;;684    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
000b9c  e92d5ff0          PUSH     {r4-r12,lr}
;;;685          tcp_connected_fn connected)
;;;686    {
000ba0  4604              MOV      r4,r0
000ba2  460e              MOV      r6,r1
000ba4  4690              MOV      r8,r2
000ba6  4699              MOV      r9,r3
;;;687      err_t ret;
;;;688      u32_t iss;
;;;689      u16_t old_local_port;
;;;690    
;;;691      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
000ba8  bf00              NOP      
000baa  7e20              LDRB     r0,[r4,#0x18]
000bac  b118              CBZ      r0,|L1.2998|
000bae  f06f0008          MVN      r0,#8
                  |L1.2994|
;;;692    
;;;693      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;694      if (ipaddr != NULL) {
;;;695        pcb->remote_ip = *ipaddr;
;;;696      } else {
;;;697        return ERR_VAL;
;;;698      }
;;;699      pcb->remote_port = port;
;;;700    
;;;701      /* check if we have a route to the remote host */
;;;702      if (ip_addr_isany(&(pcb->local_ip))) {
;;;703        /* no local IP address set, yet. */
;;;704        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;705        if (netif == NULL) {
;;;706          /* Don't even try to send a SYN packet if we have no route
;;;707             since that will fail. */
;;;708          return ERR_RTE;
;;;709        }
;;;710        /* Use the netif's IP address as local address. */
;;;711        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;712      }
;;;713    
;;;714      old_local_port = pcb->local_port;
;;;715      if (pcb->local_port == 0) {
;;;716        pcb->local_port = tcp_new_port();
;;;717        if (pcb->local_port == 0) {
;;;718          return ERR_BUF;
;;;719        }
;;;720      }
;;;721    #if SO_REUSE
;;;722      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;723        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;724           now that the 5-tuple is unique. */
;;;725        struct tcp_pcb *cpcb;
;;;726        int i;
;;;727        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;728        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;729          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;730            if ((cpcb->local_port == pcb->local_port) &&
;;;731                (cpcb->remote_port == port) &&
;;;732                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;733                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;734              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;735              return ERR_USE;
;;;736            }
;;;737          }
;;;738        }
;;;739      }
;;;740    #endif /* SO_REUSE */
;;;741      iss = tcp_next_iss();
;;;742      pcb->rcv_nxt = 0;
;;;743      pcb->snd_nxt = iss;
;;;744      pcb->lastack = iss - 1;
;;;745      pcb->snd_lbb = iss - 1;
;;;746      pcb->rcv_wnd = TCP_WND;
;;;747      pcb->rcv_ann_wnd = TCP_WND;
;;;748      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;749      pcb->snd_wnd = TCP_WND;
;;;750      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;751         The send MSS is updated when an MSS option is received. */
;;;752      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;753    #if TCP_CALCULATE_EFF_SEND_MSS
;;;754      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;755    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;756      pcb->cwnd = 1;
;;;757      pcb->ssthresh = pcb->mss * 10;
;;;758    #if LWIP_CALLBACK_API
;;;759      pcb->connected = connected;
;;;760    #else /* LWIP_CALLBACK_API */  
;;;761      LWIP_UNUSED_ARG(connected);
;;;762    #endif /* LWIP_CALLBACK_API */
;;;763    
;;;764      /* Send a SYN together with the MSS option. */
;;;765      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;766      if (ret == ERR_OK) {
;;;767        /* SYN segment was enqueued, changed the pcbs state now */
;;;768        pcb->state = SYN_SENT;
;;;769        if (old_local_port != 0) {
;;;770          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;771        }
;;;772        TCP_REG_ACTIVE(pcb);
;;;773        snmp_inc_tcpactiveopens();
;;;774    
;;;775        tcp_output(pcb);
;;;776      }
;;;777      return ret;
;;;778    }
000bb2  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2998|
000bb6  bf00              NOP                            ;691
000bb8  bf00              NOP                            ;693
000bba  bf00              NOP                            ;693
000bbc  b116              CBZ      r6,|L1.3012|
000bbe  6830              LDR      r0,[r6,#0]            ;695
000bc0  6060              STR      r0,[r4,#4]            ;695
000bc2  e002              B        |L1.3018|
                  |L1.3012|
000bc4  f06f0005          MVN      r0,#5                 ;697
000bc8  e7f3              B        |L1.2994|
                  |L1.3018|
000bca  f8a4801c          STRH     r8,[r4,#0x1c]         ;699
000bce  b10c              CBZ      r4,|L1.3028|
000bd0  6820              LDR      r0,[r4,#0]            ;702
000bd2  b968              CBNZ     r0,|L1.3056|
                  |L1.3028|
000bd4  1d20              ADDS     r0,r4,#4              ;704
000bd6  f7fffffe          BL       ip_route
000bda  4683              MOV      r11,r0                ;704
000bdc  f1bb0f00          CMP      r11,#0                ;705
000be0  d102              BNE      |L1.3048|
000be2  f06f0003          MVN      r0,#3                 ;708
000be6  e7e4              B        |L1.2994|
                  |L1.3048|
000be8  f8db0004          LDR      r0,[r11,#4]           ;711
000bec  6020              STR      r0,[r4,#0]            ;711
000bee  bf00              NOP                            ;712
                  |L1.3056|
000bf0  f8b4a01a          LDRH     r10,[r4,#0x1a]        ;714
000bf4  8b60              LDRH     r0,[r4,#0x1a]         ;715
000bf6  b938              CBNZ     r0,|L1.3080|
000bf8  f7fffffe          BL       tcp_new_port
000bfc  8360              STRH     r0,[r4,#0x1a]         ;716
000bfe  8b60              LDRH     r0,[r4,#0x1a]         ;717
000c00  b910              CBNZ     r0,|L1.3080|
000c02  f06f0001          MVN      r0,#1                 ;718
000c06  e7d4              B        |L1.2994|
                  |L1.3080|
000c08  f7fffffe          BL       tcp_next_iss
000c0c  4605              MOV      r5,r0                 ;741
000c0e  2000              MOVS     r0,#0                 ;742
000c10  f8440f28          STR      r0,[r4,#0x28]!        ;742
000c14  62a5              STR      r5,[r4,#0x28]         ;743
000c16  1e68              SUBS     r0,r5,#1              ;744
000c18  6220              STR      r0,[r4,#0x20]         ;744
000c1a  6360              STR      r0,[r4,#0x34]         ;745
000c1c  f24160d0          MOV      r0,#0x16d0            ;746
000c20  80a0              STRH     r0,[r4,#4]            ;746
000c22  80e0              STRH     r0,[r4,#6]            ;747
000c24  6820              LDR      r0,[r4,#0]            ;748
000c26  60a0              STR      r0,[r4,#8]            ;748
000c28  f24160d0          MOV      r0,#0x16d0            ;749
000c2c  8720              STRH     r0,[r4,#0x38]         ;749
000c2e  f44f7006          MOV      r0,#0x218             ;752
000c32  81e0              STRH     r0,[r4,#0xe]          ;752
000c34  89e0              LDRH     r0,[r4,#0xe]          ;754
000c36  4631              MOV      r1,r6                 ;754
000c38  f7fffffe          BL       tcp_eff_send_mss
000c3c  81e0              STRH     r0,[r4,#0xe]          ;754
000c3e  2001              MOVS     r0,#1                 ;756
000c40  84a0              STRH     r0,[r4,#0x24]         ;756
000c42  89e0              LDRH     r0,[r4,#0xe]          ;757
000c44  eb000080          ADD      r0,r0,r0,LSL #2       ;757
000c48  f64f71ff          MOV      r1,#0xffff            ;757
000c4c  ea010040          AND      r0,r1,r0,LSL #1       ;757
000c50  84e0              STRH     r0,[r4,#0x26]         ;757
000c52  f8c49058          STR      r9,[r4,#0x58]         ;759
000c56  3c28              SUBS     r4,r4,#0x28           ;759
000c58  2102              MOVS     r1,#2                 ;765
000c5a  4620              MOV      r0,r4                 ;765
000c5c  f7fffffe          BL       tcp_enqueue_flags
000c60  4607              MOV      r7,r0                 ;765
000c62  2f00              CMP      r7,#0                 ;766
000c64  d155              BNE      |L1.3346|
000c66  2002              MOVS     r0,#2                 ;768
000c68  7620              STRB     r0,[r4,#0x18]         ;768
000c6a  f1ba0f00          CMP      r10,#0                ;769
000c6e  d03f              BEQ      |L1.3312|
000c70  bf00              NOP                            ;770
000c72  e017              B        |L1.3236|
                  |L1.3188|
                          DCD      tcp_timer
                  |L1.3192|
                          DCD      tcp_tw_pcbs
                  |L1.3196|
                          DCD      tcp_active_pcbs
                  |L1.3200|
                          DCD      tcp_active_pcbs_changed
                  |L1.3204|
                          DCD      tcp_port
                  |L1.3208|
                          DCD      tcp_pcb_lists
                  |L1.3212|
                          DCD      tcp_bound_pcbs
                  |L1.3216|
                          DCD      tcp_tmp_pcb
                  |L1.3220|
                          DCD      tcp_accept_null
                  |L1.3224|
                          DCD      tcp_listen_pcbs
                  |L1.3228|
                          DCD      iss
                  |L1.3232|
                          DCD      tcp_ticks
                  |L1.3236|
000ca4  487d              LDR      r0,|L1.3740|
000ca6  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
000ca8  42a0              CMP      r0,r4                 ;770
000caa  d105              BNE      |L1.3256|
000cac  487b              LDR      r0,|L1.3740|
000cae  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
000cb0  68c0              LDR      r0,[r0,#0xc]          ;770
000cb2  497a              LDR      r1,|L1.3740|
000cb4  6008              STR      r0,[r1,#0]            ;770  ; tcp_bound_pcbs
000cb6  e018              B        |L1.3306|
                  |L1.3256|
000cb8  4878              LDR      r0,|L1.3740|
000cba  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
000cbc  4978              LDR      r1,|L1.3744|
000cbe  6008              STR      r0,[r1,#0]            ;770  ; tcp_tmp_pcb
000cc0  e00e              B        |L1.3296|
                  |L1.3266|
000cc2  4877              LDR      r0,|L1.3744|
000cc4  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
000cc6  68c0              LDR      r0,[r0,#0xc]          ;770
000cc8  42a0              CMP      r0,r4                 ;770
000cca  d104              BNE      |L1.3286|
000ccc  4974              LDR      r1,|L1.3744|
000cce  68e0              LDR      r0,[r4,#0xc]          ;770
000cd0  6809              LDR      r1,[r1,#0]            ;770  ; tcp_tmp_pcb
000cd2  60c8              STR      r0,[r1,#0xc]          ;770
000cd4  e008              B        |L1.3304|
                  |L1.3286|
000cd6  4872              LDR      r0,|L1.3744|
000cd8  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
000cda  68c0              LDR      r0,[r0,#0xc]          ;770
000cdc  4970              LDR      r1,|L1.3744|
000cde  6008              STR      r0,[r1,#0]            ;770  ; tcp_tmp_pcb
                  |L1.3296|
000ce0  486f              LDR      r0,|L1.3744|
000ce2  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
000ce4  2800              CMP      r0,#0                 ;770
000ce6  d1ec              BNE      |L1.3266|
                  |L1.3304|
000ce8  bf00              NOP                            ;770
                  |L1.3306|
000cea  2000              MOVS     r0,#0                 ;770
000cec  60e0              STR      r0,[r4,#0xc]          ;770
000cee  bf00              NOP                            ;770
                  |L1.3312|
000cf0  bf00              NOP                            ;772
000cf2  bf00              NOP                            ;772
000cf4  486b              LDR      r0,|L1.3748|
000cf6  6800              LDR      r0,[r0,#0]            ;772  ; tcp_active_pcbs
000cf8  60e0              STR      r0,[r4,#0xc]          ;772
000cfa  486a              LDR      r0,|L1.3748|
000cfc  6004              STR      r4,[r0,#0]            ;772  ; tcp_active_pcbs
000cfe  f7fffffe          BL       tcp_timer_needed
000d02  bf00              NOP                            ;772
000d04  2001              MOVS     r0,#1                 ;772
000d06  4968              LDR      r1,|L1.3752|
000d08  7008              STRB     r0,[r1,#0]            ;772
000d0a  bf00              NOP                            ;772
000d0c  4620              MOV      r0,r4                 ;775
000d0e  f7fffffe          BL       tcp_output
                  |L1.3346|
000d12  4638              MOV      r0,r7                 ;777
000d14  e74d              B        |L1.2994|
;;;779    
                          ENDP

                  tcp_setprio PROC
;;;1162   void
;;;1163   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000d16  7641              STRB     r1,[r0,#0x19]
;;;1164   {
;;;1165     pcb->prio = prio;
;;;1166   }
000d18  4770              BX       lr
;;;1167   
                          ENDP

                  tcp_kill_prio PROC
;;;1216   static void
;;;1217   tcp_kill_prio(u8_t prio)
000d1a  e92d41f0          PUSH     {r4-r8,lr}
;;;1218   {
000d1e  4606              MOV      r6,r0
;;;1219     struct tcp_pcb *pcb, *inactive;
;;;1220     u32_t inactivity;
;;;1221     u8_t mprio;
;;;1222   
;;;1223   
;;;1224     mprio = TCP_PRIO_MAX;
000d20  f04f087f          MOV      r8,#0x7f
;;;1225     
;;;1226     /* We kill the oldest active connection that has lower priority than prio. */
;;;1227     inactivity = 0;
000d24  2700              MOVS     r7,#0
;;;1228     inactive = NULL;
000d26  2500              MOVS     r5,#0
;;;1229     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000d28  485e              LDR      r0,|L1.3748|
000d2a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000d2c  e013              B        |L1.3414|
                  |L1.3374|
;;;1230       if (pcb->prio <= prio &&
000d2e  7e60              LDRB     r0,[r4,#0x19]
000d30  42b0              CMP      r0,r6
000d32  dc0f              BGT      |L1.3412|
;;;1231          pcb->prio <= mprio &&
000d34  7e60              LDRB     r0,[r4,#0x19]
000d36  4540              CMP      r0,r8
000d38  dc0c              BGT      |L1.3412|
;;;1232          (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000d3a  495c              LDR      r1,|L1.3756|
000d3c  6a60              LDR      r0,[r4,#0x24]
000d3e  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000d40  1a08              SUBS     r0,r1,r0
000d42  42b8              CMP      r0,r7
000d44  d306              BCC      |L1.3412|
;;;1233         inactivity = tcp_ticks - pcb->tmr;
000d46  4959              LDR      r1,|L1.3756|
000d48  6a60              LDR      r0,[r4,#0x24]
000d4a  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000d4c  1a0f              SUBS     r7,r1,r0
;;;1234         inactive = pcb;
000d4e  4625              MOV      r5,r4
;;;1235         mprio = pcb->prio;
000d50  f8948019          LDRB     r8,[r4,#0x19]
                  |L1.3412|
000d54  68e4              LDR      r4,[r4,#0xc]          ;1229
                  |L1.3414|
000d56  2c00              CMP      r4,#0                 ;1229
000d58  d1e9              BNE      |L1.3374|
;;;1236       }
;;;1237     }
;;;1238     if (inactive != NULL) {
000d5a  b125              CBZ      r5,|L1.3430|
;;;1239       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
000d5c  bf00              NOP      
000d5e  bf00              NOP      
;;;1240              (void *)inactive, inactivity));
;;;1241       tcp_abort(inactive);
000d60  4628              MOV      r0,r5
000d62  f7fffffe          BL       tcp_abort
                  |L1.3430|
;;;1242     }
;;;1243   }
000d66  e8bd81f0          POP      {r4-r8,pc}
;;;1244   
                          ENDP

                  tcp_kill_timewait PROC
;;;1249   static void
;;;1250   tcp_kill_timewait(void)
000d6a  b570              PUSH     {r4-r6,lr}
;;;1251   {
;;;1252     struct tcp_pcb *pcb, *inactive;
;;;1253     u32_t inactivity;
;;;1254   
;;;1255     inactivity = 0;
000d6c  2600              MOVS     r6,#0
;;;1256     inactive = NULL;
000d6e  2500              MOVS     r5,#0
;;;1257     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1258     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000d70  484f              LDR      r0,|L1.3760|
000d72  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000d74  e00b              B        |L1.3470|
                  |L1.3446|
;;;1259       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000d76  494d              LDR      r1,|L1.3756|
000d78  6a60              LDR      r0,[r4,#0x24]
000d7a  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000d7c  1a08              SUBS     r0,r1,r0
000d7e  42b0              CMP      r0,r6
000d80  d304              BCC      |L1.3468|
;;;1260         inactivity = tcp_ticks - pcb->tmr;
000d82  494a              LDR      r1,|L1.3756|
000d84  6a60              LDR      r0,[r4,#0x24]
000d86  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000d88  1a0e              SUBS     r6,r1,r0
;;;1261         inactive = pcb;
000d8a  4625              MOV      r5,r4
                  |L1.3468|
000d8c  68e4              LDR      r4,[r4,#0xc]          ;1258
                  |L1.3470|
000d8e  2c00              CMP      r4,#0                 ;1258
000d90  d1f1              BNE      |L1.3446|
;;;1262       }
;;;1263     }
;;;1264     if (inactive != NULL) {
000d92  b125              CBZ      r5,|L1.3486|
;;;1265       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
000d94  bf00              NOP      
000d96  bf00              NOP      
;;;1266              (void *)inactive, inactivity));
;;;1267       tcp_abort(inactive);
000d98  4628              MOV      r0,r5
000d9a  f7fffffe          BL       tcp_abort
                  |L1.3486|
;;;1268     }
;;;1269   }
000d9e  bd70              POP      {r4-r6,pc}
;;;1270   
                          ENDP

                  tcp_alloc PROC
;;;1277   struct tcp_pcb *
;;;1278   tcp_alloc(u8_t prio)
000da0  b570              PUSH     {r4-r6,lr}
;;;1279   {
000da2  4606              MOV      r6,r0
;;;1280     struct tcp_pcb *pcb;
;;;1281     u32_t iss;
;;;1282     
;;;1283     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000da4  2002              MOVS     r0,#2
000da6  f7fffffe          BL       memp_malloc
000daa  4604              MOV      r4,r0
;;;1284     if (pcb == NULL) {
000dac  b99c              CBNZ     r4,|L1.3542|
;;;1285       /* Try killing oldest connection in TIME-WAIT. */
;;;1286       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
000dae  bf00              NOP      
000db0  bf00              NOP      
;;;1287       tcp_kill_timewait();
000db2  f7fffffe          BL       tcp_kill_timewait
;;;1288       /* Try to allocate a tcp_pcb again. */
;;;1289       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000db6  2002              MOVS     r0,#2
000db8  f7fffffe          BL       memp_malloc
000dbc  4604              MOV      r4,r0
;;;1290       if (pcb == NULL) {
000dbe  b94c              CBNZ     r4,|L1.3540|
;;;1291         /* Try killing active connections with lower priority than the new one. */
;;;1292         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
000dc0  bf00              NOP      
000dc2  bf00              NOP      
;;;1293         tcp_kill_prio(prio);
000dc4  4630              MOV      r0,r6
000dc6  f7fffffe          BL       tcp_kill_prio
;;;1294         /* Try to allocate a tcp_pcb again. */
;;;1295         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000dca  2002              MOVS     r0,#2
000dcc  f7fffffe          BL       memp_malloc
000dd0  4604              MOV      r4,r0
;;;1296         if (pcb != NULL) {
000dd2  bf00              NOP      
                  |L1.3540|
;;;1297           /* adjust err stats: memp_malloc failed twice before */
;;;1298           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1299         }
;;;1300       }
;;;1301       if (pcb != NULL) {
000dd4  bf00              NOP      
                  |L1.3542|
;;;1302         /* adjust err stats: timewait PCB was freed above */
;;;1303         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1304       }
;;;1305     }
;;;1306     if (pcb != NULL) {
000dd6  2c00              CMP      r4,#0
000dd8  d03b              BEQ      |L1.3666|
;;;1307       memset(pcb, 0, sizeof(struct tcp_pcb));
000dda  2194              MOVS     r1,#0x94
000ddc  4620              MOV      r0,r4
000dde  f7fffffe          BL       __aeabi_memclr4
;;;1308       pcb->prio = prio;
000de2  3410              ADDS     r4,r4,#0x10
000de4  7266              STRB     r6,[r4,#9]
;;;1309       pcb->snd_buf = TCP_SND_BUF;
000de6  f24160d0          MOV      r0,#0x16d0
000dea  f8a40056          STRH     r0,[r4,#0x56]
;;;1310       pcb->snd_queuelen = 0;
000dee  2000              MOVS     r0,#0
000df0  f8a40058          STRH     r0,[r4,#0x58]
;;;1311       pcb->rcv_wnd = TCP_WND;
000df4  f24160d0          MOV      r0,#0x16d0
000df8  83a0              STRH     r0,[r4,#0x1c]
;;;1312       pcb->rcv_ann_wnd = TCP_WND;
000dfa  83e0              STRH     r0,[r4,#0x1e]
;;;1313       pcb->tos = 0;
000dfc  2000              MOVS     r0,#0
000dfe  f8040c07          STRB     r0,[r4,#-7]
;;;1314       pcb->ttl = TCP_TTL;
000e02  20ff              MOVS     r0,#0xff
000e04  f8040c06          STRB     r0,[r4,#-6]
;;;1315       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1316          The send MSS is updated when an MSS option is received. */
;;;1317       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
000e08  f44f7006          MOV      r0,#0x218
000e0c  84e0              STRH     r0,[r4,#0x26]
;;;1318       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
000e0e  2006              MOVS     r0,#6
000e10  86a0              STRH     r0,[r4,#0x34]
;;;1319       pcb->sa = 0;
000e12  2000              MOVS     r0,#0
000e14  8620              STRH     r0,[r4,#0x30]
;;;1320       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
000e16  2006              MOVS     r0,#6
000e18  8660              STRH     r0,[r4,#0x32]
;;;1321       pcb->rtime = -1;
000e1a  1fc0              SUBS     r0,r0,#7
000e1c  84a0              STRH     r0,[r4,#0x24]
;;;1322       pcb->cwnd = 1;
000e1e  2001              MOVS     r0,#1
000e20  87a0              STRH     r0,[r4,#0x3c]
;;;1323       iss = tcp_next_iss();
000e22  f7fffffe          BL       tcp_next_iss
000e26  4605              MOV      r5,r0
;;;1324       pcb->snd_wl2 = iss;
000e28  64a5              STR      r5,[r4,#0x48]
;;;1325       pcb->snd_nxt = iss;
000e2a  6425              STR      r5,[r4,#0x40]
;;;1326       pcb->lastack = iss;
000e2c  63a5              STR      r5,[r4,#0x38]
;;;1327       pcb->snd_lbb = iss;   
000e2e  64e5              STR      r5,[r4,#0x4c]
;;;1328       pcb->tmr = tcp_ticks;
000e30  481e              LDR      r0,|L1.3756|
000e32  6800              LDR      r0,[r0,#0]  ; tcp_ticks
000e34  6160              STR      r0,[r4,#0x14]
;;;1329       pcb->last_timer = tcp_timer_ctr;
000e36  481f              LDR      r0,|L1.3764|
000e38  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000e3a  7460              STRB     r0,[r4,#0x11]
;;;1330   
;;;1331       pcb->polltmr = 0;
000e3c  2000              MOVS     r0,#0
000e3e  73e0              STRB     r0,[r4,#0xf]
;;;1332   
;;;1333   #if LWIP_CALLBACK_API
;;;1334       pcb->recv = tcp_recv_null;
000e40  f2af7021          ADR      r0,tcp_recv_null + 1
000e44  66e0              STR      r0,[r4,#0x6c]
;;;1335   #endif /* LWIP_CALLBACK_API */  
;;;1336       
;;;1337       /* Init KEEPALIVE timer */
;;;1338       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
000e46  481c              LDR      r0,|L1.3768|
000e48  67e0              STR      r0,[r4,#0x7c]
;;;1339       
;;;1340   #if LWIP_TCP_KEEPALIVE
;;;1341       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1342       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1343   #endif /* LWIP_TCP_KEEPALIVE */
;;;1344   
;;;1345       pcb->keep_cnt_sent = 0;
000e4a  2000              MOVS     r0,#0
000e4c  f8840082          STRB     r0,[r4,#0x82]
000e50  3c10              SUBS     r4,r4,#0x10
                  |L1.3666|
;;;1346     }
;;;1347     return pcb;
000e52  4620              MOV      r0,r4
;;;1348   }
000e54  bd70              POP      {r4-r6,pc}
;;;1349   
                          ENDP

                  tcp_new PROC
;;;1362   struct tcp_pcb *
;;;1363   tcp_new(void)
000e56  b510              PUSH     {r4,lr}
;;;1364   {
;;;1365     return tcp_alloc(TCP_PRIO_NORMAL);
000e58  2040              MOVS     r0,#0x40
000e5a  f7fffffe          BL       tcp_alloc
;;;1366   }
000e5e  bd10              POP      {r4,pc}
;;;1367   
                          ENDP

                  tcp_arg PROC
;;;1375   void
;;;1376   tcp_arg(struct tcp_pcb *pcb, void *arg)
000e60  6101              STR      r1,[r0,#0x10]
;;;1377   {
;;;1378     /* This function is allowed to be called for both listen pcbs and
;;;1379        connection pcbs. */
;;;1380     pcb->callback_arg = arg;
;;;1381   }
000e62  4770              BX       lr
;;;1382   #if LWIP_CALLBACK_API
                          ENDP

                  tcp_recv PROC
;;;1391   void
;;;1392   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000e64  bf00              NOP      
;;;1393   {
;;;1394     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
000e66  bf00              NOP      
;;;1395     pcb->recv = recv;
000e68  67c1              STR      r1,[r0,#0x7c]
;;;1396   }
000e6a  4770              BX       lr
;;;1397   
                          ENDP

                  tcp_sent PROC
;;;1405   void
;;;1406   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000e6c  bf00              NOP      
;;;1407   {
;;;1408     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
000e6e  bf00              NOP      
;;;1409     pcb->sent = sent;
000e70  6781              STR      r1,[r0,#0x78]
;;;1410   }
000e72  4770              BX       lr
;;;1411   
                          ENDP

                  tcp_err PROC
;;;1420   void
;;;1421   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000e74  bf00              NOP      
;;;1422   {
;;;1423     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
000e76  bf00              NOP      
;;;1424     pcb->errf = err;
000e78  f8c01088          STR      r1,[r0,#0x88]
;;;1425   }
000e7c  4770              BX       lr
;;;1426   
                          ENDP

                  tcp_accept PROC
;;;1435   void
;;;1436   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000e7e  6141              STR      r1,[r0,#0x14]
;;;1437   {
;;;1438     /* This function is allowed to be called for both listen pcbs and
;;;1439        connection pcbs. */
;;;1440     pcb->accept = accept;
;;;1441   }
000e80  4770              BX       lr
;;;1442   #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_poll PROC
;;;1451   void
;;;1452   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000e82  bf00              NOP      
;;;1453   {
;;;1454     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000e84  bf00              NOP      
;;;1455   #if LWIP_CALLBACK_API
;;;1456     pcb->poll = poll;
000e86  f8c01084          STR      r1,[r0,#0x84]
;;;1457   #else /* LWIP_CALLBACK_API */  
;;;1458     LWIP_UNUSED_ARG(poll);
;;;1459   #endif /* LWIP_CALLBACK_API */  
;;;1460     pcb->pollinterval = interval;
000e8a  f8802020          STRB     r2,[r0,#0x20]
;;;1461   }
000e8e  4770              BX       lr
;;;1462   
                          ENDP

                  tcp_debug_state_str PROC
;;;1604   const char*
;;;1605   tcp_debug_state_str(enum tcp_state s)
000e90  4601              MOV      r1,r0
;;;1606   {
;;;1607     return tcp_state_str[s];
000e92  480a              LDR      r0,|L1.3772|
000e94  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;1608   }
000e98  4770              BX       lr
;;;1609   
                          ENDP

000e9a  0000              DCW      0x0000
                  |L1.3740|
                          DCD      tcp_bound_pcbs
                  |L1.3744|
                          DCD      tcp_tmp_pcb
                  |L1.3748|
                          DCD      tcp_active_pcbs
                  |L1.3752|
                          DCD      tcp_active_pcbs_changed
                  |L1.3756|
                          DCD      tcp_ticks
                  |L1.3760|
                          DCD      tcp_tw_pcbs
                  |L1.3764|
                          DCD      tcp_timer_ctr
                  |L1.3768|
                          DCD      0x006ddd00
                  |L1.3772|
                          DCD      tcp_state_str

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
00002c  01020304          DCB      0x01,0x02,0x03,0x04
000030  05060707          DCB      0x05,0x06,0x07,0x07
000034  07070707          DCB      0x07,0x07,0x07,0x07
000038  07                DCB      0x07
                  tcp_persist_backoff
000039  03060c            DCB      0x03,0x06,0x0c
00003c  18306078          DCB      0x18,0x30,0x60,0x78
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_port
000000  c000              DCW      0xc000
000002  0000              DCB      0x00,0x00
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
                  tcp_active_pcbs_changed
00001c  00                DCB      0x00
                  tcp_timer
00001d  00                DCB      0x00
                  tcp_timer_ctr
00001e  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
