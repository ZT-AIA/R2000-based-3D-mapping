; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\etharp.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\etharp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\etharp.crf ..\..\libraries\lwip-1.4.1\src\netif\etharp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  b510              PUSH     {r4,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000004  eb040084          ADD      r0,r4,r4,LSL #2
000008  49f9              LDR      r1,|L1.1008|
00000a  f8510020          LDR      r0,[r1,r0,LSL #2]
00000e  b170              CBZ      r0,|L1.46|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
000010  bf00              NOP      
000012  bf00              NOP      
;;;185        free_etharp_q(arp_table[i].q);
000014  eb040184          ADD      r1,r4,r4,LSL #2
000018  4af5              LDR      r2,|L1.1008|
00001a  f8520021          LDR      r0,[r2,r1,LSL #2]
00001e  f7fffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
000022  2000              MOVS     r0,#0
000024  eb040184          ADD      r1,r4,r4,LSL #2
000028  4af1              LDR      r2,|L1.1008|
00002a  f8420021          STR      r0,[r2,r1,LSL #2]
                  |L1.46|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
00002e  2000              MOVS     r0,#0
000030  eb040184          ADD      r1,r4,r4,LSL #2
000034  4aee              LDR      r2,|L1.1008|
000036  eb020181          ADD      r1,r2,r1,LSL #2
00003a  7488              STRB     r0,[r1,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
00003c  eb040184          ADD      r1,r4,r4,LSL #2
000040  eb020181          ADD      r1,r2,r1,LSL #2
000044  74c8              STRB     r0,[r1,#0x13]
;;;193      arp_table[i].netif = NULL;
000046  eb040184          ADD      r1,r4,r4,LSL #2
00004a  eb020181          ADD      r1,r2,r1,LSL #2
00004e  6088              STR      r0,[r1,#8]
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
000050  eb040184          ADD      r1,r4,r4,LSL #2
000054  eb020181          ADD      r1,r2,r1,LSL #2
000058  6048              STR      r0,[r1,#4]
;;;195      arp_table[i].ethaddr = ethzero;
00005a  eb040084          ADD      r0,r4,r4,LSL #2
00005e  4611              MOV      r1,r2
000060  eb010080          ADD      r0,r1,r0,LSL #2
000064  49e3              LDR      r1,|L1.1012|
000066  680a              LDR      r2,[r1,#0]  ; ethzero
000068  60c2              STR      r2,[r0,#0xc]
00006a  8889              LDRH     r1,[r1,#4]  ; ethzero
00006c  8201              STRH     r1,[r0,#0x10]
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
00006e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
000070  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
000072  bf00              NOP      
000074  bf00              NOP      
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000076  2400              MOVS     r4,#0
000078  e03f              B        |L1.250|
                  |L1.122|
;;;213        u8_t state = arp_table[i].state;
00007a  eb040084          ADD      r0,r4,r4,LSL #2
00007e  49dc              LDR      r1,|L1.1008|
000080  eb010080          ADD      r0,r1,r0,LSL #2
000084  7c85              LDRB     r5,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
000086  b335              CBZ      r5,|L1.214|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
000088  eb040084          ADD      r0,r4,r4,LSL #2
00008c  eb010080          ADD      r0,r1,r0,LSL #2
000090  7cc0              LDRB     r0,[r0,#0x13]
000092  1c40              ADDS     r0,r0,#1
000094  eb040184          ADD      r1,r4,r4,LSL #2
000098  4ad5              LDR      r2,|L1.1008|
00009a  eb020181          ADD      r1,r2,r1,LSL #2
00009e  74c8              STRB     r0,[r1,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
0000a0  eb040084          ADD      r0,r4,r4,LSL #2
0000a4  4611              MOV      r1,r2
0000a6  eb010080          ADD      r0,r1,r0,LSL #2
0000aa  7cc0              LDRB     r0,[r0,#0x13]
0000ac  28f0              CMP      r0,#0xf0
0000ae  da0d              BGE      |L1.204|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
0000b0  eb040084          ADD      r0,r4,r4,LSL #2
0000b4  eb010080          ADD      r0,r1,r0,LSL #2
0000b8  7c80              LDRB     r0,[r0,#0x12]
0000ba  2801              CMP      r0,#1
0000bc  d10c              BNE      |L1.216|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
0000be  eb040084          ADD      r0,r4,r4,LSL #2
0000c2  eb010080          ADD      r0,r1,r0,LSL #2
0000c6  7cc0              LDRB     r0,[r0,#0x13]
0000c8  2802              CMP      r0,#2
0000ca  db05              BLT      |L1.216|
                  |L1.204|
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
0000cc  bf00              NOP      
0000ce  bf00              NOP      
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       etharp_free_entry
                  |L1.214|
0000d6  e00e              B        |L1.246|
                  |L1.216|
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
0000d8  eb040084          ADD      r0,r4,r4,LSL #2
0000dc  49c4              LDR      r1,|L1.1008|
0000de  eb010080          ADD      r0,r1,r0,LSL #2
0000e2  7c80              LDRB     r0,[r0,#0x12]
0000e4  2803              CMP      r0,#3
0000e6  d106              BNE      |L1.246|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
0000e8  2002              MOVS     r0,#2
0000ea  eb040184          ADD      r1,r4,r4,LSL #2
0000ee  4ac0              LDR      r2,|L1.1008|
0000f0  eb020181          ADD      r1,r2,r1,LSL #2
0000f4  7488              STRB     r0,[r1,#0x12]
                  |L1.246|
0000f6  1c60              ADDS     r0,r4,#1              ;212
0000f8  b2c4              UXTB     r4,r0                 ;212
                  |L1.250|
0000fa  2c0a              CMP      r4,#0xa               ;212
0000fc  dbbd              BLT      |L1.122|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
0000fe  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
000100  e92d5ffc          PUSH     {r2-r12,lr}
;;;267    {
000104  4605              MOV      r5,r0
000106  460f              MOV      r7,r1
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
000108  f04f080a          MOV      r8,#0xa
00010c  46c1              MOV      r9,r8
;;;269      s8_t empty = ARP_TABLE_SIZE;
00010e  260a              MOVS     r6,#0xa
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
000110  2400              MOVS     r4,#0
000112  46a3              MOV      r11,r4
000114  2000              MOVS     r0,#0
000116  9001              STR      r0,[sp,#4]
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
000118  46b2              MOV      r10,r6
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
00011a  9000              STR      r0,[sp,#0]
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
00011c  bf00              NOP      
00011e  e060              B        |L1.482|
                  |L1.288|
;;;292        u8_t state = arp_table[i].state;
000120  eb040084          ADD      r0,r4,r4,LSL #2
000124  4ab2              LDR      r2,|L1.1008|
000126  eb020080          ADD      r0,r2,r0,LSL #2
00012a  7c81              LDRB     r1,[r0,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
00012c  2e0a              CMP      r6,#0xa
00012e  d104              BNE      |L1.314|
000130  b919              CBNZ     r1,|L1.314|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
000132  bf00              NOP      
000134  bf00              NOP      
;;;296          /* remember first empty entry */
;;;297          empty = i;
000136  b266              SXTB     r6,r4
000138  e051              B        |L1.478|
                  |L1.314|
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
00013a  2900              CMP      r1,#0
00013c  d04f              BEQ      |L1.478|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
00013e  bf00              NOP      
000140  bf00              NOP      
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
000142  b16d              CBZ      r5,|L1.352|
000144  eb040284          ADD      r2,r4,r4,LSL #2
000148  4ba9              LDR      r3,|L1.1008|
00014a  eb030282          ADD      r2,r3,r2,LSL #2
00014e  6828              LDR      r0,[r5,#0]
000150  6852              LDR      r2,[r2,#4]
000152  4290              CMP      r0,r2
000154  d104              BNE      |L1.352|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
000156  bf00              NOP      
000158  bf00              NOP      
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
00015a  b260              SXTB     r0,r4
                  |L1.348|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
00015c  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.352|
000160  2901              CMP      r1,#1                 ;308
000162  d128              BNE      |L1.438|
000164  eb040084          ADD      r0,r4,r4,LSL #2       ;310
000168  4aa1              LDR      r2,|L1.1008|
00016a  f8520020          LDR      r0,[r2,r0,LSL #2]     ;310
00016e  b188              CBZ      r0,|L1.404|
000170  eb040084          ADD      r0,r4,r4,LSL #2       ;311
000174  eb020080          ADD      r0,r2,r0,LSL #2       ;311
000178  7cc2              LDRB     r2,[r0,#0x13]         ;311
00017a  9800              LDR      r0,[sp,#0]            ;311
00017c  4282              CMP      r2,r0                 ;311
00017e  db2e              BLT      |L1.478|
000180  fa4ffa84          SXTB     r10,r4                ;312
000184  eb040084          ADD      r0,r4,r4,LSL #2       ;313
000188  4a99              LDR      r2,|L1.1008|
00018a  eb020080          ADD      r0,r2,r0,LSL #2       ;313
00018e  7cc0              LDRB     r0,[r0,#0x13]         ;313
000190  9000              STR      r0,[sp,#0]            ;313
000192  e024              B        |L1.478|
                  |L1.404|
000194  eb040084          ADD      r0,r4,r4,LSL #2       ;318
000198  4a95              LDR      r2,|L1.1008|
00019a  eb020080          ADD      r0,r2,r0,LSL #2       ;318
00019e  7cc0              LDRB     r0,[r0,#0x13]         ;318
0001a0  4558              CMP      r0,r11                ;318
0001a2  db1c              BLT      |L1.478|
0001a4  fa4ff884          SXTB     r8,r4                 ;319
0001a8  eb040084          ADD      r0,r4,r4,LSL #2       ;320
0001ac  eb020080          ADD      r0,r2,r0,LSL #2       ;320
0001b0  f890b013          LDRB     r11,[r0,#0x13]        ;320
0001b4  e013              B        |L1.478|
                  |L1.438|
0001b6  2902              CMP      r1,#2                 ;324
0001b8  db11              BLT      |L1.478|
0001ba  eb040084          ADD      r0,r4,r4,LSL #2       ;331
0001be  4a8c              LDR      r2,|L1.1008|
0001c0  eb020080          ADD      r0,r2,r0,LSL #2       ;331
0001c4  7cc2              LDRB     r2,[r0,#0x13]         ;331
0001c6  9801              LDR      r0,[sp,#4]            ;331
0001c8  4282              CMP      r2,r0                 ;331
0001ca  db08              BLT      |L1.478|
0001cc  fa4ff984          SXTB     r9,r4                 ;332
0001d0  eb040084          ADD      r0,r4,r4,LSL #2       ;333
0001d4  4a86              LDR      r2,|L1.1008|
0001d6  eb020080          ADD      r0,r2,r0,LSL #2       ;333
0001da  7cc0              LDRB     r0,[r0,#0x13]         ;333
0001dc  9001              STR      r0,[sp,#4]            ;333
                  |L1.478|
0001de  1c60              ADDS     r0,r4,#1              ;291
0001e0  b2c4              UXTB     r4,r0                 ;291
                  |L1.482|
0001e2  2c0a              CMP      r4,#0xa               ;291
0001e4  db9c              BLT      |L1.288|
0001e6  f0070002          AND      r0,r7,#2              ;342
0001ea  b920              CBNZ     r0,|L1.502|
0001ec  2e0a              CMP      r6,#0xa               ;344
0001ee  d107              BNE      |L1.512|
0001f0  f0070001          AND      r0,r7,#1              ;344
0001f4  b920              CBNZ     r0,|L1.512|
                  |L1.502|
0001f6  bf00              NOP                            ;345
0001f8  bf00              NOP                            ;345
0001fa  f04f30ff          MOV      r0,#0xffffffff        ;346
0001fe  e7ad              B        |L1.348|
                  |L1.512|
000200  2e0a              CMP      r6,#0xa               ;359
000202  da02              BGE      |L1.522|
000204  b2f4              UXTB     r4,r6                 ;360
000206  bf00              NOP                            ;361
000208  e020              B        |L1.588|
                  |L1.522|
00020a  f1b90f0a          CMP      r9,#0xa               ;364
00020e  da05              BGE      |L1.540|
000210  f00904ff          AND      r4,r9,#0xff           ;366
000214  bf00              NOP                            ;367
000216  bf00              NOP                            ;367
000218  bf00              NOP                            ;369
00021a  e012              B        |L1.578|
                  |L1.540|
00021c  f1b80f0a          CMP      r8,#0xa               ;371
000220  da03              BGE      |L1.554|
000222  f00804ff          AND      r4,r8,#0xff           ;373
000226  bf00              NOP                            ;374
000228  e00b              B        |L1.578|
                  |L1.554|
00022a  f1ba0f0a          CMP      r10,#0xa              ;376
00022e  da03              BGE      |L1.568|
000230  f00a04ff          AND      r4,r10,#0xff          ;378
000234  bf00              NOP                            ;379
000236  e004              B        |L1.578|
                  |L1.568|
000238  bf00              NOP                            ;382
00023a  bf00              NOP                            ;382
00023c  f04f30ff          MOV      r0,#0xffffffff        ;383
000240  e78c              B        |L1.348|
                  |L1.578|
000242  bf00              NOP                            ;387
000244  bf00              NOP                            ;387
000246  4620              MOV      r0,r4                 ;388
000248  f7fffffe          BL       etharp_free_entry
                  |L1.588|
00024c  bf00              NOP                            ;391
00024e  bf00              NOP                            ;391
000250  bf00              NOP                            ;392
000252  bf00              NOP                            ;392
000254  b135              CBZ      r5,|L1.612|
000256  eb040184          ADD      r1,r4,r4,LSL #2       ;398
00025a  4a65              LDR      r2,|L1.1008|
00025c  eb020181          ADD      r1,r2,r1,LSL #2       ;398
000260  6828              LDR      r0,[r5,#0]            ;398
000262  6048              STR      r0,[r1,#4]            ;398
                  |L1.612|
000264  2000              MOVS     r0,#0                 ;400
000266  eb040184          ADD      r1,r4,r4,LSL #2       ;400
00026a  4a61              LDR      r2,|L1.1008|
00026c  eb020181          ADD      r1,r2,r1,LSL #2       ;400
000270  74c8              STRB     r0,[r1,#0x13]         ;400
000272  b260              SXTB     r0,r4                 ;401
000274  e772              B        |L1.348|
;;;403    
                          ENDP

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000276  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
00027a  4605              MOV      r5,r0
00027c  460e              MOV      r6,r1
00027e  4617              MOV      r7,r2
000280  4698              MOV      r8,r3
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
000282  6874              LDR      r4,[r6,#4]
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
000284  bf00              NOP      
000286  bf00              NOP      
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
000288  f8d80000          LDR      r0,[r8,#0]
00028c  6020              STR      r0,[r4,#0]
00028e  f8b80004          LDRH     r0,[r8,#4]
000292  80a0              STRH     r0,[r4,#4]
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
000294  6838              LDR      r0,[r7,#0]
000296  f8c40006          STR      r0,[r4,#6]
00029a  88b8              LDRH     r0,[r7,#4]
00029c  8160              STRH     r0,[r4,#0xa]
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
00029e  2008              MOVS     r0,#8
0002a0  81a0              STRH     r0,[r4,#0xc]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
0002a2  bf00              NOP      
0002a4  bf00              NOP      
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
0002a6  4631              MOV      r1,r6
0002a8  4628              MOV      r0,r5
0002aa  69aa              LDR      r2,[r5,#0x18]
0002ac  4790              BLX      r2
;;;427    }
0002ae  e8bd81f0          POP      {r4-r8,pc}
;;;428    
                          ENDP

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
0002b2  e92d47f0          PUSH     {r4-r10,lr}
;;;449    {
0002b6  4606              MOV      r6,r0
0002b8  460d              MOV      r5,r1
0002ba  4617              MOV      r7,r2
0002bc  4698              MOV      r8,r3
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
0002be  bf00              NOP      
0002c0  bf00              NOP      
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
0002c2  bf00              NOP      
0002c4  bf00              NOP      
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
0002c6  b15d              CBZ      r5,|L1.736|
0002c8  6828              LDR      r0,[r5,#0]
0002ca  b148              CBZ      r0,|L1.736|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
0002cc  4631              MOV      r1,r6
0002ce  6828              LDR      r0,[r5,#0]
0002d0  f7fffffe          BL       ip4_addr_isbroadcast
0002d4  b920              CBNZ     r0,|L1.736|
;;;459          ip_addr_ismulticast(ipaddr)) {
0002d6  7828              LDRB     r0,[r5,#0]
0002d8  f00000f0          AND      r0,r0,#0xf0
0002dc  28e0              CMP      r0,#0xe0
0002de  d105              BNE      |L1.748|
                  |L1.736|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
0002e0  bf00              NOP      
0002e2  bf00              NOP      
;;;461        return ERR_ARG;
0002e4  f06f000d          MVN      r0,#0xd
                  |L1.744|
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
;;;512      }
;;;513      return ERR_OK;
;;;514    }
0002e8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.748|
0002ec  4641              MOV      r1,r8                 ;464
0002ee  4628              MOV      r0,r5                 ;464
0002f0  f7fffffe          BL       etharp_find_entry
0002f4  4604              MOV      r4,r0                 ;464
0002f6  2c00              CMP      r4,#0                 ;466
0002f8  da01              BGE      |L1.766|
0002fa  4620              MOV      r0,r4                 ;467
0002fc  e7f4              B        |L1.744|
                  |L1.766|
0002fe  2002              MOVS     r0,#2                 ;478
000300  eb040184          ADD      r1,r4,r4,LSL #2       ;478
000304  4a3a              LDR      r2,|L1.1008|
000306  eb020181          ADD      r1,r2,r1,LSL #2       ;478
00030a  7488              STRB     r0,[r1,#0x12]         ;478
00030c  eb040084          ADD      r0,r4,r4,LSL #2       ;482
000310  4611              MOV      r1,r2                 ;482
000312  eb010080          ADD      r0,r1,r0,LSL #2       ;482
000316  6086              STR      r6,[r0,#8]            ;482
000318  bf00              NOP                            ;486
00031a  bf00              NOP                            ;486
00031c  eb040084          ADD      r0,r4,r4,LSL #2       ;488
000320  eb010080          ADD      r0,r1,r0,LSL #2       ;488
000324  6839              LDR      r1,[r7,#0]            ;488
000326  60c1              STR      r1,[r0,#0xc]          ;488
000328  88b9              LDRH     r1,[r7,#4]            ;488
00032a  8201              STRH     r1,[r0,#0x10]         ;488
00032c  2000              MOVS     r0,#0                 ;490
00032e  eb040184          ADD      r1,r4,r4,LSL #2       ;490
000332  eb020181          ADD      r1,r2,r1,LSL #2       ;490
000336  74c8              STRB     r0,[r1,#0x13]         ;490
000338  eb040084          ADD      r0,r4,r4,LSL #2       ;504
00033c  4611              MOV      r1,r2                 ;504
00033e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;504
000342  b198              CBZ      r0,|L1.876|
000344  eb040084          ADD      r0,r4,r4,LSL #2       ;505
000348  f8519020          LDR      r9,[r1,r0,LSL #2]     ;505
00034c  2000              MOVS     r0,#0                 ;506
00034e  eb040184          ADD      r1,r4,r4,LSL #2       ;506
000352  f8420021          STR      r0,[r2,r1,LSL #2]     ;506
000356  463b              MOV      r3,r7                 ;509
000358  f1060227          ADD      r2,r6,#0x27           ;509
00035c  4649              MOV      r1,r9                 ;509
00035e  4630              MOV      r0,r6                 ;509
000360  f7fffffe          BL       etharp_send_ip
000364  4648              MOV      r0,r9                 ;511
000366  f7fffffe          BL       pbuf_free
00036a  bf00              NOP                            ;512
                  |L1.876|
00036c  2000              MOVS     r0,#0                 ;513
00036e  e7bb              B        |L1.744|
;;;515    
                          ENDP

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
000370  b570              PUSH     {r4-r6,lr}
;;;580    {
000372  4605              MOV      r5,r0
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000374  2400              MOVS     r4,#0
000376  e012              B        |L1.926|
                  |L1.888|
;;;584        u8_t state = arp_table[i].state;
000378  eb040084          ADD      r0,r4,r4,LSL #2
00037c  491c              LDR      r1,|L1.1008|
00037e  eb010080          ADD      r0,r1,r0,LSL #2
000382  7c86              LDRB     r6,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000384  b14e              CBZ      r6,|L1.922|
000386  eb040084          ADD      r0,r4,r4,LSL #2
00038a  eb010080          ADD      r0,r1,r0,LSL #2
00038e  6880              LDR      r0,[r0,#8]
000390  42a8              CMP      r0,r5
000392  d102              BNE      |L1.922|
;;;586          etharp_free_entry(i);
000394  4620              MOV      r0,r4
000396  f7fffffe          BL       etharp_free_entry
                  |L1.922|
00039a  1c60              ADDS     r0,r4,#1              ;583
00039c  b2c4              UXTB     r4,r0                 ;583
                  |L1.926|
00039e  2c0a              CMP      r4,#0xa               ;583
0003a0  dbea              BLT      |L1.888|
;;;587        }
;;;588      }
;;;589    }
0003a2  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
0003a4  e92d41f0          PUSH     {r4-r8,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
0003a8  4680              MOV      r8,r0
0003aa  460d              MOV      r5,r1
0003ac  4616              MOV      r6,r2
0003ae  461f              MOV      r7,r3
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
0003b0  bf00              NOP      
0003b2  bf00              NOP      
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
0003b4  2102              MOVS     r1,#2
0003b6  4628              MOV      r0,r5
0003b8  f7fffffe          BL       etharp_find_entry
0003bc  4604              MOV      r4,r0
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
0003be  2c00              CMP      r4,#0
0003c0  db1a              BLT      |L1.1016|
0003c2  eb040084          ADD      r0,r4,r4,LSL #2
0003c6  490a              LDR      r1,|L1.1008|
0003c8  eb010080          ADD      r0,r1,r0,LSL #2
0003cc  7c80              LDRB     r0,[r0,#0x12]
0003ce  2802              CMP      r0,#2
0003d0  db12              BLT      |L1.1016|
;;;615          *eth_ret = &arp_table[i].ethaddr;
0003d2  eb040084          ADD      r0,r4,r4,LSL #2
0003d6  eb010080          ADD      r0,r1,r0,LSL #2
0003da  300c              ADDS     r0,r0,#0xc
0003dc  6030              STR      r0,[r6,#0]
;;;616          *ip_ret = &arp_table[i].ipaddr;
0003de  eb040084          ADD      r0,r4,r4,LSL #2
0003e2  eb010080          ADD      r0,r1,r0,LSL #2
0003e6  1d00              ADDS     r0,r0,#4
0003e8  6038              STR      r0,[r7,#0]
;;;617          return i;
0003ea  4620              MOV      r0,r4
                  |L1.1004|
;;;618      }
;;;619      return -1;
;;;620    }
0003ec  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1008|
                          DCD      arp_table
                  |L1.1012|
                          DCD      ethzero
                  |L1.1016|
0003f8  f04f30ff          MOV      r0,#0xffffffff        ;619
0003fc  e7f6              B        |L1.1004|
;;;621    
                          ENDP

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
0003fe  e92d47fc          PUSH     {r2-r10,lr}
;;;689    {
000402  4605              MOV      r5,r0
000404  4688              MOV      r8,r1
000406  4616              MOV      r6,r2
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
000408  bf00              NOP      
00040a  b90d              CBNZ     r5,|L1.1040|
                  |L1.1036|
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
00040c  e8bd87fc          POP      {r2-r10,pc}
                  |L1.1040|
000410  bf00              NOP                            ;699
000412  8970              LDRH     r0,[r6,#0xa]          ;703
000414  282a              CMP      r0,#0x2a              ;703
000416  da05              BGE      |L1.1060|
000418  bf00              NOP                            ;704
00041a  bf00              NOP                            ;704
00041c  4630              MOV      r0,r6                 ;709
00041e  f7fffffe          BL       pbuf_free
000422  e7f3              B        |L1.1036|
                  |L1.1060|
000424  6877              LDR      r7,[r6,#4]            ;713
000426  f107040e          ADD      r4,r7,#0xe            ;714
00042a  8820              LDRH     r0,[r4,#0]            ;722
00042c  f5b07f80          CMP      r0,#0x100             ;722
000430  d108              BNE      |L1.1092|
000432  7920              LDRB     r0,[r4,#4]            ;723
000434  2806              CMP      r0,#6                 ;723
000436  d105              BNE      |L1.1092|
000438  7960              LDRB     r0,[r4,#5]            ;724
00043a  2804              CMP      r0,#4                 ;724
00043c  d102              BNE      |L1.1092|
00043e  8860              LDRH     r0,[r4,#2]            ;725
000440  2808              CMP      r0,#8                 ;725
000442  d005              BEQ      |L1.1104|
                  |L1.1092|
000444  bf00              NOP                            ;726
000446  bf00              NOP                            ;726
000448  4630              MOV      r0,r6                 ;731
00044a  f7fffffe          BL       pbuf_free
00044e  e7dd              B        |L1.1036|
                  |L1.1104|
000450  f8d4000e          LDR      r0,[r4,#0xe]          ;745
000454  9001              STR      r0,[sp,#4]            ;745
000456  69a0              LDR      r0,[r4,#0x18]         ;746
000458  9000              STR      r0,[sp,#0]            ;746
00045a  1d28              ADDS     r0,r5,#4              ;749
00045c  b108              CBZ      r0,|L1.1122|
00045e  6868              LDR      r0,[r5,#4]            ;749
000460  b910              CBNZ     r0,|L1.1128|
                  |L1.1122|
000462  f04f0900          MOV      r9,#0                 ;750
000466  e007              B        |L1.1144|
                  |L1.1128|
000468  9800              LDR      r0,[sp,#0]            ;753
00046a  6869              LDR      r1,[r5,#4]            ;753
00046c  4288              CMP      r0,r1                 ;753
00046e  d101              BNE      |L1.1140|
000470  2001              MOVS     r0,#1                 ;753
000472  e000              B        |L1.1142|
                  |L1.1140|
000474  2000              MOVS     r0,#0                 ;753
                  |L1.1142|
000476  4681              MOV      r9,r0                 ;753
                  |L1.1144|
000478  f1b90f00          CMP      r9,#0                 ;761
00047c  d001              BEQ      |L1.1154|
00047e  2001              MOVS     r0,#1                 ;762
000480  e000              B        |L1.1156|
                  |L1.1154|
000482  2002              MOVS     r0,#2                 ;762
                  |L1.1156|
000484  4603              MOV      r3,r0                 ;762
000486  f1040208          ADD      r2,r4,#8              ;762
00048a  a901              ADD      r1,sp,#4              ;762
00048c  4628              MOV      r0,r5                 ;762
00048e  f7fffffe          BL       etharp_update_arp_entry
000492  88e0              LDRH     r0,[r4,#6]            ;765
000494  f5b07f80          CMP      r0,#0x100             ;765
000498  d003              BEQ      |L1.1186|
00049a  f5b07f00          CMP      r0,#0x200             ;765
00049e  d13e              BNE      |L1.1310|
0004a0  e036              B        |L1.1296|
                  |L1.1186|
0004a2  bf00              NOP                            ;772
0004a4  bf00              NOP                            ;772
0004a6  f1b90f00          CMP      r9,#0                 ;774
0004aa  d028              BEQ      |L1.1278|
0004ac  bf00              NOP                            ;776
0004ae  bf00              NOP                            ;776
0004b0  2002              MOVS     r0,#2                 ;780
0004b2  f7fffffe          BL       lwip_htons
0004b6  80e0              STRH     r0,[r4,#6]            ;780
0004b8  f8d4000e          LDR      r0,[r4,#0xe]          ;782
0004bc  61a0              STR      r0,[r4,#0x18]         ;782
0004be  6868              LDR      r0,[r5,#4]            ;783
0004c0  f8c4000e          STR      r0,[r4,#0xe]          ;783
0004c4  bf00              NOP                            ;785
0004c6  bf00              NOP                            ;785
0004c8  68a0              LDR      r0,[r4,#8]            ;794
0004ca  f8c40012          STR      r0,[r4,#0x12]         ;794
0004ce  89a0              LDRH     r0,[r4,#0xc]          ;794
0004d0  82e0              STRH     r0,[r4,#0x16]         ;794
0004d2  68a0              LDR      r0,[r4,#8]            ;798
0004d4  6038              STR      r0,[r7,#0]            ;798
0004d6  89a0              LDRH     r0,[r4,#0xc]          ;798
0004d8  80b8              STRH     r0,[r7,#4]            ;798
0004da  f8d80000          LDR      r0,[r8,#0]            ;800
0004de  60a0              STR      r0,[r4,#8]            ;800
0004e0  f8b80004          LDRH     r0,[r8,#4]            ;800
0004e4  81a0              STRH     r0,[r4,#0xc]          ;800
0004e6  f8d80000          LDR      r0,[r8,#0]            ;801
0004ea  f8c70006          STR      r0,[r7,#6]            ;801
0004ee  f8b80004          LDRH     r0,[r8,#4]            ;801
0004f2  8178              STRH     r0,[r7,#0xa]          ;801
0004f4  4631              MOV      r1,r6                 ;807
0004f6  4628              MOV      r0,r5                 ;807
0004f8  69aa              LDR      r2,[r5,#0x18]         ;807
0004fa  4790              BLX      r2                    ;807
0004fc  e007              B        |L1.1294|
                  |L1.1278|
0004fe  1d28              ADDS     r0,r5,#4              ;809
000500  b108              CBZ      r0,|L1.1286|
000502  6868              LDR      r0,[r5,#4]            ;809
000504  b908              CBNZ     r0,|L1.1290|
                  |L1.1286|
000506  bf00              NOP                            ;811
000508  e001              B        |L1.1294|
                  |L1.1290|
00050a  bf00              NOP                            ;815
00050c  bf00              NOP                            ;815
                  |L1.1294|
00050e  e009              B        |L1.1316|
                  |L1.1296|
000510  bf00              NOP                            ;820
000512  bf00              NOP                            ;820
000514  a901              ADD      r1,sp,#4              ;826
000516  4628              MOV      r0,r5                 ;826
000518  f7fffffe          BL       dhcp_arp_reply
00051c  e002              B        |L1.1316|
                  |L1.1310|
00051e  bf00              NOP                            ;830
000520  bf00              NOP                            ;830
000522  bf00              NOP                            ;832
                  |L1.1316|
000524  bf00              NOP                            ;817
000526  4630              MOV      r0,r6                 ;835
000528  f7fffffe          BL       pbuf_free
00052c  bf00              NOP      
00052e  e76d              B        |L1.1036|
;;;837    
                          ENDP

                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000530  e92d4ff8          PUSH     {r3-r11,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000534  4607              MOV      r7,r0
000536  4688              MOV      r8,r1
000538  4691              MOV      r9,r2
00053a  469a              MOV      r10,r3
00053c  f8ddb028          LDR      r11,[sp,#0x28]
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
000540  2000              MOVS     r0,#0
000542  9000              STR      r0,[sp,#0]
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
000544  bf00              NOP      
000546  bf00              NOP      
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
000548  2200              MOVS     r2,#0
00054a  212a              MOVS     r1,#0x2a
00054c  2003              MOVS     r0,#3
00054e  f7fffffe          BL       pbuf_alloc
000552  4605              MOV      r5,r0
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
000554  b92d              CBNZ     r5,|L1.1378|
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
000556  bf00              NOP      
000558  bf00              NOP      
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
;;;1198       return ERR_MEM;
00055a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1374|
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1235     hdr->protolen = sizeof(ip_addr_t);
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
;;;1247   }
00055e  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.1378|
000562  bf00              NOP                            ;1200
000564  bf00              NOP                            ;1200
000566  686e              LDR      r6,[r5,#4]            ;1203
000568  f106040e          ADD      r4,r6,#0xe            ;1204
00056c  bf00              NOP                            ;1205
00056e  bf00              NOP                            ;1205
000570  980d              LDR      r0,[sp,#0x34]         ;1206
000572  f7fffffe          BL       lwip_htons
000576  80e0              STRH     r0,[r4,#6]            ;1206
000578  bf00              NOP                            ;1208
00057a  bf00              NOP                            ;1208
00057c  f8da0000          LDR      r0,[r10,#0]           ;1217
000580  60a0              STR      r0,[r4,#8]            ;1217
000582  f8ba0004          LDRH     r0,[r10,#4]           ;1217
000586  81a0              STRH     r0,[r4,#0xc]          ;1217
000588  980b              LDR      r0,[sp,#0x2c]         ;1218
00058a  6801              LDR      r1,[r0,#0]            ;1218
00058c  f8c41012          STR      r1,[r4,#0x12]         ;1218
000590  8880              LDRH     r0,[r0,#4]            ;1218
000592  82e0              STRH     r0,[r4,#0x16]         ;1218
000594  f8d90000          LDR      r0,[r9,#0]            ;1223
000598  6030              STR      r0,[r6,#0]            ;1223
00059a  f8b90004          LDRH     r0,[r9,#4]            ;1223
00059e  80b0              STRH     r0,[r6,#4]            ;1223
0005a0  f8d80000          LDR      r0,[r8,#0]            ;1225
0005a4  f8c60006          STR      r0,[r6,#6]            ;1225
0005a8  f8b80004          LDRH     r0,[r8,#4]            ;1225
0005ac  8170              STRH     r0,[r6,#0xa]          ;1225
0005ae  f8db0000          LDR      r0,[r11,#0]           ;1228
0005b2  f8c4000e          STR      r0,[r4,#0xe]          ;1228
0005b6  980c              LDR      r0,[sp,#0x30]         ;1229
0005b8  6800              LDR      r0,[r0,#0]            ;1229
0005ba  61a0              STR      r0,[r4,#0x18]         ;1229
0005bc  f44f7080          MOV      r0,#0x100             ;1231
0005c0  8020              STRH     r0,[r4,#0]            ;1231
0005c2  2008              MOVS     r0,#8                 ;1232
0005c4  8060              STRH     r0,[r4,#2]            ;1232
0005c6  2006              MOVS     r0,#6                 ;1234
0005c8  7120              STRB     r0,[r4,#4]            ;1234
0005ca  2004              MOVS     r0,#4                 ;1235
0005cc  7160              STRB     r0,[r4,#5]            ;1235
0005ce  f44f60c1          MOV      r0,#0x608             ;1237
0005d2  81b0              STRH     r0,[r6,#0xc]          ;1237
0005d4  4629              MOV      r1,r5                 ;1239
0005d6  4638              MOV      r0,r7                 ;1239
0005d8  69ba              LDR      r2,[r7,#0x18]         ;1239
0005da  4790              BLX      r2                    ;1239
0005dc  9000              STR      r0,[sp,#0]            ;1239
0005de  4628              MOV      r0,r5                 ;1242
0005e0  f7fffffe          BL       pbuf_free
0005e4  2500              MOVS     r5,#0                 ;1243
0005e6  9800              LDR      r0,[sp,#0]            ;1246
0005e8  e7b9              B        |L1.1374|
;;;1248   
                          ENDP

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
0005ea  b57f              PUSH     {r0-r6,lr}
;;;1260   {
0005ec  4604              MOV      r4,r0
0005ee  460d              MOV      r5,r1
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
0005f0  bf00              NOP      
0005f2  bf00              NOP      
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
0005f4  2101              MOVS     r1,#1
0005f6  4af8              LDR      r2,|L1.2520|
0005f8  1d20              ADDS     r0,r4,#4
0005fa  f1040327          ADD      r3,r4,#0x27
0005fe  e88d0025          STM      sp,{r0,r2,r5}
000602  9103              STR      r1,[sp,#0xc]
000604  4af5              LDR      r2,|L1.2524|
000606  4619              MOV      r1,r3
000608  4620              MOV      r0,r4
00060a  f7fffffe          BL       etharp_raw
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
00060e  b004              ADD      sp,sp,#0x10
000610  bd70              POP      {r4-r6,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
000612  b570              PUSH     {r4-r6,lr}
;;;843    {
000614  4605              MOV      r5,r0
000616  460e              MOV      r6,r1
000618  4614              MOV      r4,r2
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
00061a  bf00              NOP      
00061c  bf00              NOP      
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
00061e  eb040084          ADD      r0,r4,r4,LSL #2
000622  49ef              LDR      r1,|L1.2528|
000624  eb010080          ADD      r0,r1,r0,LSL #2
000628  7c80              LDRB     r0,[r0,#0x12]
00062a  2802              CMP      r0,#2
00062c  d117              BNE      |L1.1630|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
00062e  eb040084          ADD      r0,r4,r4,LSL #2
000632  eb010080          ADD      r0,r1,r0,LSL #2
000636  7cc0              LDRB     r0,[r0,#0x13]
000638  28e4              CMP      r0,#0xe4
00063a  db10              BLT      |L1.1630|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
00063c  eb040084          ADD      r0,r4,r4,LSL #2
000640  460a              MOV      r2,r1
000642  eb020080          ADD      r0,r2,r0,LSL #2
000646  1d01              ADDS     r1,r0,#4
000648  4628              MOV      r0,r5
00064a  f7fffffe          BL       etharp_request
00064e  b930              CBNZ     r0,|L1.1630|
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000650  2003              MOVS     r0,#3
000652  eb040184          ADD      r1,r4,r4,LSL #2
000656  4ae2              LDR      r2,|L1.2528|
000658  eb020181          ADD      r1,r2,r1,LSL #2
00065c  7488              STRB     r0,[r1,#0x12]
                  |L1.1630|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
00065e  eb040084          ADD      r0,r4,r4,LSL #2
000662  49df              LDR      r1,|L1.2528|
000664  eb010080          ADD      r0,r1,r0,LSL #2
000668  f100030c          ADD      r3,r0,#0xc
00066c  f1050227          ADD      r2,r5,#0x27
000670  4631              MOV      r1,r6
000672  4628              MOV      r0,r5
000674  f7fffffe          BL       etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
000678  bd70              POP      {r4-r6,pc}
;;;859    
                          ENDP

                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
00067a  e92d5ff0          PUSH     {r4-r12,lr}
;;;1017   {
00067e  4680              MOV      r8,r0
000680  460f              MOV      r7,r1
000682  4616              MOV      r6,r2
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
000684  f1080927          ADD      r9,r8,#0x27
;;;1019     err_t result = ERR_MEM;
000688  f04f3aff          MOV      r10,#0xffffffff
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
00068c  4641              MOV      r1,r8
00068e  6838              LDR      r0,[r7,#0]
000690  f7fffffe          BL       ip4_addr_isbroadcast
000694  b938              CBNZ     r0,|L1.1702|
;;;1024         ip_addr_ismulticast(ipaddr) ||
000696  7838              LDRB     r0,[r7,#0]
000698  f00000f0          AND      r0,r0,#0xf0
00069c  28e0              CMP      r0,#0xe0
00069e  d002              BEQ      |L1.1702|
;;;1025         ip_addr_isany(ipaddr)) {
0006a0  b10f              CBZ      r7,|L1.1702|
0006a2  6838              LDR      r0,[r7,#0]
0006a4  b928              CBNZ     r0,|L1.1714|
                  |L1.1702|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
0006a6  bf00              NOP      
0006a8  bf00              NOP      
;;;1027       return ERR_ARG;
0006aa  f06f000d          MVN      r0,#0xd
                  |L1.1710|
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
;;;1039       }
;;;1040       return (err_t)i;
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
0006ae  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1714|
0006b2  2101              MOVS     r1,#1                 ;1031
0006b4  4638              MOV      r0,r7                 ;1031
0006b6  f7fffffe          BL       etharp_find_entry
0006ba  4604              MOV      r4,r0                 ;1031
0006bc  2c00              CMP      r4,#0                 ;1034
0006be  da06              BGE      |L1.1742|
0006c0  bf00              NOP                            ;1035
0006c2  bf00              NOP                            ;1035
0006c4  b10e              CBZ      r6,|L1.1738|
0006c6  bf00              NOP                            ;1037
0006c8  bf00              NOP                            ;1037
                  |L1.1738|
0006ca  4620              MOV      r0,r4                 ;1040
0006cc  e7ef              B        |L1.1710|
                  |L1.1742|
0006ce  eb040084          ADD      r0,r4,r4,LSL #2       ;1044
0006d2  49c3              LDR      r1,|L1.2528|
0006d4  eb010080          ADD      r0,r1,r0,LSL #2       ;1044
0006d8  7c80              LDRB     r0,[r0,#0x12]         ;1044
0006da  b930              CBNZ     r0,|L1.1770|
0006dc  2001              MOVS     r0,#1                 ;1045
0006de  eb040184          ADD      r1,r4,r4,LSL #2       ;1045
0006e2  4abf              LDR      r2,|L1.2528|
0006e4  eb020181          ADD      r1,r2,r1,LSL #2       ;1045
0006e8  7488              STRB     r0,[r1,#0x12]         ;1045
                  |L1.1770|
0006ea  bf00              NOP                            ;1049
0006ec  bf00              NOP                            ;1049
0006ee  eb040084          ADD      r0,r4,r4,LSL #2       ;1054
0006f2  49bb              LDR      r1,|L1.2528|
0006f4  eb010080          ADD      r0,r1,r0,LSL #2       ;1054
0006f8  7c80              LDRB     r0,[r0,#0x12]         ;1054
0006fa  2801              CMP      r0,#1                 ;1054
0006fc  d000              BEQ      |L1.1792|
0006fe  b93e              CBNZ     r6,|L1.1808|
                  |L1.1792|
000700  4639              MOV      r1,r7                 ;1056
000702  4640              MOV      r0,r8                 ;1056
000704  f7fffffe          BL       etharp_request
000708  4682              MOV      r10,r0                ;1056
00070a  b90e              CBNZ     r6,|L1.1808|
00070c  4650              MOV      r0,r10                ;1064
00070e  e7ce              B        |L1.1710|
                  |L1.1808|
000710  bf00              NOP                            ;1069
000712  bf00              NOP                            ;1069
000714  eb040084          ADD      r0,r4,r4,LSL #2       ;1071
000718  49b1              LDR      r1,|L1.2528|
00071a  eb010080          ADD      r0,r1,r0,LSL #2       ;1071
00071e  7c80              LDRB     r0,[r0,#0x12]         ;1071
000720  2802              CMP      r0,#2                 ;1071
000722  db0f              BLT      |L1.1860|
000724  49af              LDR      r1,|L1.2532|
000726  700c              STRB     r4,[r1,#0]            ;1073
000728  eb040084          ADD      r0,r4,r4,LSL #2       ;1075
00072c  49ac              LDR      r1,|L1.2528|
00072e  eb010080          ADD      r0,r1,r0,LSL #2       ;1075
000732  f100030c          ADD      r3,r0,#0xc            ;1075
000736  464a              MOV      r2,r9                 ;1075
000738  4631              MOV      r1,r6                 ;1075
00073a  4640              MOV      r0,r8                 ;1075
00073c  f7fffffe          BL       etharp_send_ip
000740  4682              MOV      r10,r0                ;1075
000742  e04d              B        |L1.2016|
                  |L1.1860|
000744  eb040084          ADD      r0,r4,r4,LSL #2       ;1077
000748  49a5              LDR      r1,|L1.2528|
00074a  eb010080          ADD      r0,r1,r0,LSL #2       ;1077
00074e  7c80              LDRB     r0,[r0,#0x12]         ;1077
000750  2801              CMP      r0,#1                 ;1077
000752  d145              BNE      |L1.2016|
000754  f04f0b00          MOV      r11,#0                ;1080
000758  4635              MOV      r5,r6                 ;1084
00075a  e008              B        |L1.1902|
                  |L1.1884|
00075c  bf00              NOP                            ;1086
00075e  bf00              NOP                            ;1086
000760  7b28              LDRB     r0,[r5,#0xc]          ;1087
000762  2801              CMP      r0,#1                 ;1087
000764  d002              BEQ      |L1.1900|
000766  f04f0b01          MOV      r11,#1                ;1088
00076a  e002              B        |L1.1906|
                  |L1.1900|
00076c  682d              LDR      r5,[r5,#0]            ;1091
                  |L1.1902|
00076e  2d00              CMP      r5,#0                 ;1085
000770  d1f4              BNE      |L1.1884|
                  |L1.1906|
000772  bf00              NOP                            ;1089
000774  f1bb0f00          CMP      r11,#0                ;1093
000778  d010              BEQ      |L1.1948|
00077a  8929              LDRH     r1,[r5,#8]            ;1095
00077c  2200              MOVS     r2,#0                 ;1095
00077e  2003              MOVS     r0,#3                 ;1095
000780  f7fffffe          BL       pbuf_alloc
000784  4605              MOV      r5,r0                 ;1095
000786  b16d              CBZ      r5,|L1.1956|
000788  4631              MOV      r1,r6                 ;1097
00078a  4628              MOV      r0,r5                 ;1097
00078c  f7fffffe          BL       pbuf_copy
000790  b140              CBZ      r0,|L1.1956|
000792  4628              MOV      r0,r5                 ;1098
000794  f7fffffe          BL       pbuf_free
000798  2500              MOVS     r5,#0                 ;1099
00079a  e003              B        |L1.1956|
                  |L1.1948|
00079c  4635              MOV      r5,r6                 ;1104
00079e  4628              MOV      r0,r5                 ;1105
0007a0  f7fffffe          BL       pbuf_ref
                  |L1.1956|
0007a4  b1bd              CBZ      r5,|L1.2006|
0007a6  eb040084          ADD      r0,r4,r4,LSL #2       ;1139
0007aa  498d              LDR      r1,|L1.2528|
0007ac  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1139
0007b0  b140              CBZ      r0,|L1.1988|
0007b2  bf00              NOP                            ;1140
0007b4  bf00              NOP                            ;1140
0007b6  eb040184          ADD      r1,r4,r4,LSL #2       ;1141
0007ba  4a89              LDR      r2,|L1.2528|
0007bc  f8520021          LDR      r0,[r2,r1,LSL #2]     ;1141
0007c0  f7fffffe          BL       pbuf_free
                  |L1.1988|
0007c4  eb040084          ADD      r0,r4,r4,LSL #2       ;1143
0007c8  4985              LDR      r1,|L1.2528|
0007ca  f8415020          STR      r5,[r1,r0,LSL #2]     ;1143
0007ce  f04f0a00          MOV      r10,#0                ;1144
0007d2  bf00              NOP                            ;1145
0007d4  e003              B        |L1.2014|
                  |L1.2006|
0007d6  bf00              NOP                            ;1149
0007d8  bf00              NOP                            ;1149
0007da  f04f3aff          MOV      r10,#0xffffffff       ;1150
                  |L1.2014|
0007de  bf00              NOP                            ;1152
                  |L1.2016|
0007e0  4650              MOV      r0,r10                ;1153
0007e2  e764              B        |L1.1710|
;;;1155   
                          ENDP

                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
0007e4  e92d47fc          PUSH     {r2-r10,lr}
;;;880    {
0007e8  4604              MOV      r4,r0
0007ea  460f              MOV      r7,r1
0007ec  4615              MOV      r5,r2
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
0007ee  46a9              MOV      r9,r5
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
0007f0  bf00              NOP      
0007f2  bf00              NOP      
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
0007f4  bf00              NOP      
0007f6  bf00              NOP      
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
0007f8  bf00              NOP      
0007fa  bf00              NOP      
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
0007fc  210e              MOVS     r1,#0xe
0007fe  4638              MOV      r0,r7
000800  f7fffffe          BL       pbuf_header
000804  b128              CBZ      r0,|L1.2066|
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
000806  bf00              NOP      
000808  bf00              NOP      
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
;;;895        return ERR_BUF;
00080a  f06f0001          MVN      r0,#1
                  |L1.2062|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;922            !ip_addr_islinklocal(ipaddr)) {
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;980    }
00080e  e8bd87fc          POP      {r2-r10,pc}
                  |L1.2066|
000812  4621              MOV      r1,r4                 ;902
000814  6828              LDR      r0,[r5,#0]            ;902
000816  f7fffffe          BL       ip4_addr_isbroadcast
00081a  b110              CBZ      r0,|L1.2082|
00081c  f8df81bc          LDR      r8,|L1.2524|
000820  e077              B        |L1.2322|
                  |L1.2082|
000822  7828              LDRB     r0,[r5,#0]            ;906
000824  f00000f0          AND      r0,r0,#0xf0           ;906
000828  28e0              CMP      r0,#0xe0              ;906
00082a  d115              BNE      |L1.2136|
00082c  2001              MOVS     r0,#1                 ;908
00082e  f88d0000          STRB     r0,[sp,#0]            ;908
000832  2000              MOVS     r0,#0                 ;909
000834  f88d0001          STRB     r0,[sp,#1]            ;909
000838  205e              MOVS     r0,#0x5e              ;910
00083a  f88d0002          STRB     r0,[sp,#2]            ;910
00083e  7868              LDRB     r0,[r5,#1]            ;911
000840  f000007f          AND      r0,r0,#0x7f           ;911
000844  f88d0003          STRB     r0,[sp,#3]            ;911
000848  78a8              LDRB     r0,[r5,#2]            ;912
00084a  f88d0004          STRB     r0,[sp,#4]            ;912
00084e  78e8              LDRB     r0,[r5,#3]            ;913
000850  f88d0005          STRB     r0,[sp,#5]            ;913
000854  46e8              MOV      r8,sp                 ;915
000856  e05b              B        |L1.2320|
                  |L1.2136|
000858  6828              LDR      r0,[r5,#0]            ;921
00085a  68a1              LDR      r1,[r4,#8]            ;921
00085c  4008              ANDS     r0,r0,r1              ;921
00085e  e9d41201          LDRD     r1,r2,[r4,#4]         ;921
000862  4011              ANDS     r1,r1,r2              ;921
000864  4288              CMP      r0,r1                 ;921
000866  d010              BEQ      |L1.2186|
000868  8828              LDRH     r0,[r5,#0]            ;922
00086a  b280              UXTH     r0,r0                 ;922
00086c  f64f61a9          MOV      r1,#0xfea9            ;922
000870  4288              CMP      r0,r1                 ;922
000872  d00a              BEQ      |L1.2186|
000874  f104000c          ADD      r0,r4,#0xc            ;934
000878  b120              CBZ      r0,|L1.2180|
00087a  68e0              LDR      r0,[r4,#0xc]          ;934
00087c  b110              CBZ      r0,|L1.2180|
00087e  f104090c          ADD      r9,r4,#0xc            ;936
000882  e002              B        |L1.2186|
                  |L1.2180|
000884  f06f0003          MVN      r0,#3                 ;940
000888  e7c1              B        |L1.2062|
                  |L1.2186|
00088a  4856              LDR      r0,|L1.2532|
00088c  7800              LDRB     r0,[r0,#0]            ;950  ; etharp_cached_entry
00088e  eb000080          ADD      r0,r0,r0,LSL #2       ;950
000892  4953              LDR      r1,|L1.2528|
000894  eb010080          ADD      r0,r1,r0,LSL #2       ;950
000898  7c80              LDRB     r0,[r0,#0x12]         ;950
00089a  2802              CMP      r0,#2                 ;950
00089c  db12              BLT      |L1.2244|
00089e  4951              LDR      r1,|L1.2532|
0008a0  7809              LDRB     r1,[r1,#0]            ;951  ; etharp_cached_entry
0008a2  eb010181          ADD      r1,r1,r1,LSL #2       ;951
0008a6  4a4e              LDR      r2,|L1.2528|
0008a8  eb020181          ADD      r1,r2,r1,LSL #2       ;951
0008ac  f8d90000          LDR      r0,[r9,#0]            ;951
0008b0  6849              LDR      r1,[r1,#4]            ;951
0008b2  4288              CMP      r0,r1                 ;951
0008b4  d106              BNE      |L1.2244|
0008b6  484b              LDR      r0,|L1.2532|
0008b8  7802              LDRB     r2,[r0,#0]            ;954  ; etharp_cached_entry
0008ba  4639              MOV      r1,r7                 ;954
0008bc  4620              MOV      r0,r4                 ;954
0008be  f7fffffe          BL       etharp_output_to_arp_index
0008c2  e7a4              B        |L1.2062|
                  |L1.2244|
0008c4  2600              MOVS     r6,#0                 ;963
0008c6  e01b              B        |L1.2304|
                  |L1.2248|
0008c8  eb060086          ADD      r0,r6,r6,LSL #2       ;964
0008cc  4944              LDR      r1,|L1.2528|
0008ce  eb010080          ADD      r0,r1,r0,LSL #2       ;964
0008d2  7c80              LDRB     r0,[r0,#0x12]         ;964
0008d4  2802              CMP      r0,#2                 ;964
0008d6  db11              BLT      |L1.2300|
0008d8  eb060186          ADD      r1,r6,r6,LSL #2       ;965
0008dc  4a40              LDR      r2,|L1.2528|
0008de  eb020181          ADD      r1,r2,r1,LSL #2       ;965
0008e2  f8d90000          LDR      r0,[r9,#0]            ;965
0008e6  6849              LDR      r1,[r1,#4]            ;965
0008e8  4288              CMP      r0,r1                 ;965
0008ea  d107              BNE      |L1.2300|
0008ec  493d              LDR      r1,|L1.2532|
0008ee  700e              STRB     r6,[r1,#0]            ;967
0008f0  b2f2              UXTB     r2,r6                 ;968
0008f2  4639              MOV      r1,r7                 ;968
0008f4  4620              MOV      r0,r4                 ;968
0008f6  f7fffffe          BL       etharp_output_to_arp_index
0008fa  e788              B        |L1.2062|
                  |L1.2300|
0008fc  1c70              ADDS     r0,r6,#1              ;963
0008fe  b246              SXTB     r6,r0                 ;963
                  |L1.2304|
000900  2e0a              CMP      r6,#0xa               ;963
000902  dbe1              BLT      |L1.2248|
000904  463a              MOV      r2,r7                 ;973
000906  4649              MOV      r1,r9                 ;973
000908  4620              MOV      r0,r4                 ;973
00090a  f7fffffe          BL       etharp_query
00090e  e77e              B        |L1.2062|
                  |L1.2320|
000910  bf00              NOP                            ;974
                  |L1.2322|
000912  4643              MOV      r3,r8                 ;979
000914  f1040227          ADD      r2,r4,#0x27           ;979
000918  4639              MOV      r1,r7                 ;979
00091a  4620              MOV      r0,r4                 ;979
00091c  f7fffffe          BL       etharp_send_ip
000920  e775              B        |L1.2062|
;;;981    
                          ENDP

                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000922  e92d41f0          PUSH     {r4-r8,lr}
;;;1278   {
000926  4604              MOV      r4,r0
000928  460e              MOV      r6,r1
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
00092a  f04f080e          MOV      r8,#0xe
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
00092e  8960              LDRH     r0,[r4,#0xa]
000930  280e              CMP      r0,#0xe
000932  dc00              BGT      |L1.2358|
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
;;;1288       ETHARP_STATS_INC(etharp.drop);
;;;1289       goto free_and_return;
000934  e04b              B        |L1.2510|
                  |L1.2358|
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
000936  6865              LDR      r5,[r4,#4]
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
000938  bf00              NOP      
00093a  bf00              NOP      
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
00093c  89af              LDRH     r7,[r5,#0xc]
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
00093e  7828              LDRB     r0,[r5,#0]
000940  f0000001          AND      r0,r0,#1
000944  b1b0              CBZ      r0,|L1.2420|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
000946  7828              LDRB     r0,[r5,#0]
000948  2801              CMP      r0,#1
00094a  d109              BNE      |L1.2400|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
00094c  7868              LDRB     r0,[r5,#1]
00094e  b988              CBNZ     r0,|L1.2420|
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
000950  78a8              LDRB     r0,[r5,#2]
000952  285e              CMP      r0,#0x5e
000954  d10e              BNE      |L1.2420|
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
000956  7b60              LDRB     r0,[r4,#0xd]
000958  f0400010          ORR      r0,r0,#0x10
00095c  7360              STRB     r0,[r4,#0xd]
00095e  e009              B        |L1.2420|
                  |L1.2400|
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
000960  2206              MOVS     r2,#6
000962  491e              LDR      r1,|L1.2524|
000964  4628              MOV      r0,r5
000966  f7fffffe          BL       memcmp
00096a  b918              CBNZ     r0,|L1.2420|
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
00096c  7b60              LDRB     r0,[r4,#0xd]
00096e  f0400008          ORR      r0,r0,#8
000972  7360              STRB     r0,[r4,#0xd]
                  |L1.2420|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000974  2f08              CMP      r7,#8
000976  d003              BEQ      |L1.2432|
000978  f5b76fc1          CMP      r7,#0x608
00097c  d122              BNE      |L1.2500|
00097e  e014              B        |L1.2474|
                  |L1.2432|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000980  f896002d          LDRB     r0,[r6,#0x2d]
000984  f0000020          AND      r0,r0,#0x20
000988  b900              CBNZ     r0,|L1.2444|
;;;1351           goto free_and_return;
00098a  e020              B        |L1.2510|
                  |L1.2444|
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
00098c  f1c80000          RSB      r0,r8,#0
000990  b201              SXTH     r1,r0
000992  4620              MOV      r0,r4
000994  f7fffffe          BL       pbuf_header
000998  b110              CBZ      r0,|L1.2464|
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
00099a  bf00              NOP      
00099c  bf00              NOP      
;;;1360           goto free_and_return;
00099e  e016              B        |L1.2510|
                  |L1.2464|
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
0009a0  4631              MOV      r1,r6
0009a2  4620              MOV      r0,r4
0009a4  f7fffffe          BL       ip_input
;;;1364         }
;;;1365         break;
0009a8  e00d              B        |L1.2502|
                  |L1.2474|
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
0009aa  f896002d          LDRB     r0,[r6,#0x2d]
0009ae  f0000020          AND      r0,r0,#0x20
0009b2  b900              CBNZ     r0,|L1.2486|
;;;1369           goto free_and_return;
0009b4  e00b              B        |L1.2510|
                  |L1.2486|
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
0009b6  4622              MOV      r2,r4
0009b8  f1060127          ADD      r1,r6,#0x27
0009bc  4630              MOV      r0,r6
0009be  f7fffffe          BL       etharp_arp_input
;;;1373         break;
0009c2  e000              B        |L1.2502|
                  |L1.2500|
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
;;;1386         ETHARP_STATS_INC(etharp.proterr);
;;;1387         ETHARP_STATS_INC(etharp.drop);
;;;1388         goto free_and_return;
0009c4  e003              B        |L1.2510|
                  |L1.2502|
0009c6  bf00              NOP                            ;1365
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
0009c8  2000              MOVS     r0,#0
                  |L1.2506|
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
0009ca  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2510|
0009ce  4620              MOV      r0,r4                 ;1396
0009d0  f7fffffe          BL       pbuf_free
0009d4  2000              MOVS     r0,#0                 ;1397
0009d6  e7f8              B        |L1.2506|
                  |L1.2520|
                          DCD      ethzero
                  |L1.2524|
                          DCD      ethbroadcast
                  |L1.2528|
                          DCD      arp_table
                  |L1.2532|
                          DCD      etharp_cached_entry
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
