; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\bmc.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\bmc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\bmc.crf ..\..\libraries\ptpd-2.0.0\src\bmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  EUI48toEUI64 PROC
;;;5      /* Convert EUI48 format to EUI64 */
;;;6      void EUI48toEUI64(const octet_t * eui48, octet_t * eui64)
000000  7802              LDRB     r2,[r0,#0]
;;;7      {
;;;8      	eui64[0] = eui48[0];
000002  700a              STRB     r2,[r1,#0]
;;;9      	eui64[1] = eui48[1];
000004  7842              LDRB     r2,[r0,#1]
000006  704a              STRB     r2,[r1,#1]
;;;10     	eui64[2] = eui48[2];
000008  7882              LDRB     r2,[r0,#2]
00000a  708a              STRB     r2,[r1,#2]
;;;11     	eui64[3] = 0xff;
00000c  22ff              MOVS     r2,#0xff
00000e  70ca              STRB     r2,[r1,#3]
;;;12     	eui64[4] = 0xfe;
000010  22fe              MOVS     r2,#0xfe
000012  710a              STRB     r2,[r1,#4]
;;;13     	eui64[5] = eui48[3];
000014  78c2              LDRB     r2,[r0,#3]
000016  714a              STRB     r2,[r1,#5]
;;;14     	eui64[6] = eui48[4];
000018  7902              LDRB     r2,[r0,#4]
00001a  718a              STRB     r2,[r1,#6]
;;;15     	eui64[7] = eui48[5];
00001c  7942              LDRB     r2,[r0,#5]
00001e  71ca              STRB     r2,[r1,#7]
;;;16     }
000020  4770              BX       lr
;;;17     
                          ENDP

                  initData PROC
;;;18     /* Init ptpClock with run time values (initialization constants are in constants.h) */
;;;19     void initData(PtpClock *ptpClock)
000022  b510              PUSH     {r4,lr}
;;;20     {
000024  4603              MOV      r3,r0
;;;21     	RunTimeOpts * rtOpts;
;;;22     
;;;23     	DBG("initData\n");
;;;24     	rtOpts = ptpClock->rtOpts;
000026  f8d34464          LDR      r4,[r3,#0x464]
;;;25     
;;;26     	/* Default data set */
;;;27     	ptpClock->defaultDS.twoStepFlag = DEFAULT_TWO_STEP_FLAG;
00002a  2001              MOVS     r0,#1
00002c  7018              STRB     r0,[r3,#0]
;;;28     
;;;29     	/* Init clockIdentity with MAC address and 0xFF and 0xFE. see spec 7.5.2.2.2 */
;;;30     	if ((CLOCK_IDENTITY_LENGTH == 8) && (PTP_UUID_LENGTH == 6))
;;;31     	{
;;;32     			DBGVV("initData: EUI48toEUI64\n");
;;;33     			EUI48toEUI64(ptpClock->portUuidField, ptpClock->defaultDS.clockIdentity);
00002e  1c59              ADDS     r1,r3,#1
000030  f2034039          ADD      r0,r3,#0x439
000034  f7fffffe          BL       EUI48toEUI64
;;;34     	}
;;;35     	else if (CLOCK_IDENTITY_LENGTH == PTP_UUID_LENGTH)
;;;36     	{
;;;37     			memcpy(ptpClock->defaultDS.clockIdentity, ptpClock->portUuidField, CLOCK_IDENTITY_LENGTH);
;;;38     	}
;;;39     	else
;;;40     	{
;;;41     			ERROR("initData: UUID length is not valid");
;;;42     	}
;;;43     
;;;44     	ptpClock->defaultDS.numberPorts = NUMBER_PORTS;
000038  2001              MOVS     r0,#1
00003a  8158              STRH     r0,[r3,#0xa]
;;;45     
;;;46     	ptpClock->defaultDS.clockQuality.clockAccuracy = rtOpts->clockQuality.clockAccuracy;
00003c  78e1              LDRB     r1,[r4,#3]
00003e  7359              STRB     r1,[r3,#0xd]
;;;47     	ptpClock->defaultDS.clockQuality.clockClass = rtOpts->clockQuality.clockClass;
000040  78a0              LDRB     r0,[r4,#2]
000042  7318              STRB     r0,[r3,#0xc]
;;;48     	ptpClock->defaultDS.clockQuality.offsetScaledLogVariance = rtOpts->clockQuality.offsetScaledLogVariance;
000044  88a1              LDRH     r1,[r4,#4]
000046  81d9              STRH     r1,[r3,#0xe]
;;;49     
;;;50     	ptpClock->defaultDS.priority1 = rtOpts->priority1;
000048  79a0              LDRB     r0,[r4,#6]
00004a  7418              STRB     r0,[r3,#0x10]
;;;51     	ptpClock->defaultDS.priority2 = rtOpts->priority2;
00004c  79e0              LDRB     r0,[r4,#7]
00004e  7458              STRB     r0,[r3,#0x11]
;;;52     
;;;53     	ptpClock->defaultDS.domainNumber = rtOpts->domainNumber;
000050  7a20              LDRB     r0,[r4,#8]
000052  7498              STRB     r0,[r3,#0x12]
;;;54     	ptpClock->defaultDS.slaveOnly = rtOpts->slaveOnly;
000054  7a60              LDRB     r0,[r4,#9]
000056  74d8              STRB     r0,[r3,#0x13]
;;;55     
;;;56     	/* Port configuration data set */
;;;57     
;;;58     	/* PortIdentity Init (portNumber = 1 for an ordinary clock spec 7.5.2.3)*/
;;;59     	memcpy(ptpClock->portDS.portIdentity.clockIdentity, ptpClock->defaultDS.clockIdentity, CLOCK_IDENTITY_LENGTH);
000058  f8d30001          LDR      r0,[r3,#1]
00005c  6598              STR      r0,[r3,#0x58]
00005e  f8d30005          LDR      r0,[r3,#5]
000062  65d8              STR      r0,[r3,#0x5c]
;;;60     	ptpClock->portDS.portIdentity.portNumber = NUMBER_PORTS;
000064  2101              MOVS     r1,#1
000066  2060              MOVS     r0,#0x60
000068  52c1              STRH     r1,[r0,r3]
;;;61     	ptpClock->portDS.logMinDelayReqInterval = DEFAULT_DELAYREQ_INTERVAL;
00006a  2103              MOVS     r1,#3
00006c  2063              MOVS     r0,#0x63
00006e  54c1              STRB     r1,[r0,r3]
;;;62     	ptpClock->portDS.peerMeanPathDelay.seconds = ptpClock->portDS.peerMeanPathDelay.nanoseconds = 0;
000070  2100              MOVS     r1,#0
000072  6699              STR      r1,[r3,#0x68]
000074  6659              STR      r1,[r3,#0x64]
;;;63     	ptpClock->portDS.logAnnounceInterval = rtOpts->announceInterval;
000076  7821              LDRB     r1,[r4,#0]
000078  206c              MOVS     r0,#0x6c
00007a  54c1              STRB     r1,[r0,r3]
;;;64     	ptpClock->portDS.announceReceiptTimeout = DEFAULT_ANNOUNCE_RECEIPT_TIMEOUT;
00007c  2106              MOVS     r1,#6
00007e  206d              MOVS     r0,#0x6d
000080  54c1              STRB     r1,[r0,r3]
;;;65     	ptpClock->portDS.logSyncInterval = rtOpts->syncInterval;
000082  7861              LDRB     r1,[r4,#1]
000084  206e              MOVS     r0,#0x6e
000086  54c1              STRB     r1,[r0,r3]
;;;66     	ptpClock->portDS.delayMechanism = rtOpts->delayMechanism;
000088  f8941032          LDRB     r1,[r4,#0x32]
00008c  206f              MOVS     r0,#0x6f
00008e  54c1              STRB     r1,[r0,r3]
;;;67     	ptpClock->portDS.logMinPdelayReqInterval = DEFAULT_PDELAYREQ_INTERVAL;
000090  2101              MOVS     r1,#1
000092  2070              MOVS     r0,#0x70
000094  54c1              STRB     r1,[r0,r3]
;;;68     	ptpClock->portDS.versionNumber = VERSION_PTP;
000096  2102              MOVS     r1,#2
000098  2071              MOVS     r0,#0x71
00009a  54c1              STRB     r1,[r0,r3]
;;;69     
;;;70     	/* Init other stuff */
;;;71     	ptpClock->foreignMasterDS.count = 0;
00009c  2100              MOVS     r1,#0
00009e  2078              MOVS     r0,#0x78
0000a0  52c1              STRH     r1,[r0,r3]
;;;72     	ptpClock->foreignMasterDS.capacity = rtOpts->maxForeignRecords;
0000a2  8e21              LDRH     r1,[r4,#0x30]
0000a4  207a              MOVS     r0,#0x7a
0000a6  52c1              STRH     r1,[r0,r3]
;;;73     
;;;74     	ptpClock->inboundLatency = rtOpts->inboundLatency;
0000a8  f5036080          ADD      r0,r3,#0x400
0000ac  e9d41208          LDRD     r1,r2,[r4,#0x20]
0000b0  e9c01210          STRD     r1,r2,[r0,#0x40]
;;;75     	ptpClock->outboundLatency = rtOpts->outboundLatency;
0000b4  e9d4120a          LDRD     r1,r2,[r4,#0x28]
0000b8  e9c01212          STRD     r1,r2,[r0,#0x48]
;;;76     
;;;77     	ptpClock->servo.sDelay = rtOpts->servo.sDelay;
0000bc  8f61              LDRH     r1,[r4,#0x3a]
0000be  f2404056          MOV      r0,#0x456
0000c2  52c1              STRH     r1,[r0,r3]
;;;78     	ptpClock->servo.sOffset = rtOpts->servo.sOffset;
0000c4  8fa1              LDRH     r1,[r4,#0x3c]
0000c6  1c80              ADDS     r0,r0,#2
0000c8  52c1              STRH     r1,[r0,r3]
;;;79     	ptpClock->servo.ai = rtOpts->servo.ai;
0000ca  8f21              LDRH     r1,[r4,#0x38]
0000cc  1f00              SUBS     r0,r0,#4
0000ce  52c1              STRH     r1,[r0,r3]
;;;80     	ptpClock->servo.ap = rtOpts->servo.ap;
0000d0  8ee1              LDRH     r1,[r4,#0x36]
0000d2  1e80              SUBS     r0,r0,#2
0000d4  52c1              STRH     r1,[r0,r3]
;;;81     	ptpClock->servo.noAdjust = rtOpts->servo.noAdjust;
0000d6  2035              MOVS     r0,#0x35
0000d8  5d01              LDRB     r1,[r0,r4]
0000da  f2404051          MOV      r0,#0x451
0000de  54c1              STRB     r1,[r0,r3]
;;;82     	ptpClock->servo.noResetClock = rtOpts->servo.noResetClock;
0000e0  f8940034          LDRB     r0,[r4,#0x34]
0000e4  f8830450          STRB     r0,[r3,#0x450]
;;;83     
;;;84     	ptpClock->stats = rtOpts->stats;
0000e8  7ba0              LDRB     r0,[r4,#0xe]
0000ea  f8830460          STRB     r0,[r3,#0x460]
;;;85     }
0000ee  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  isSamePortIdentity PROC
;;;87     bool isSamePortIdentity(const PortIdentity * A, const PortIdentity * B)
0000f0  b570              PUSH     {r4-r6,lr}
;;;88     {
0000f2  4604              MOV      r4,r0
0000f4  460d              MOV      r5,r1
;;;89     	return (bool)(0 == memcmp(A->clockIdentity, B->clockIdentity, CLOCK_IDENTITY_LENGTH) && (A->portNumber == B->portNumber));
0000f6  2208              MOVS     r2,#8
0000f8  4629              MOV      r1,r5
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       memcmp
000100  b938              CBNZ     r0,|L1.274|
000102  f9b40008          LDRSH    r0,[r4,#8]
000106  f9b51008          LDRSH    r1,[r5,#8]
00010a  4288              CMP      r0,r1
00010c  d101              BNE      |L1.274|
00010e  2001              MOVS     r0,#1
                  |L1.272|
;;;90     }
000110  bd70              POP      {r4-r6,pc}
                  |L1.274|
000112  2000              MOVS     r0,#0                 ;89
000114  e7fc              B        |L1.272|
;;;91     
                          ENDP

                  addForeign PROC
;;;92     void addForeign(PtpClock *ptpClock, const MsgHeader *header, const MsgAnnounce * announce)
000116  e92d47f0          PUSH     {r4-r10,lr}
;;;93     {
00011a  4604              MOV      r4,r0
00011c  460e              MOV      r6,r1
00011e  4617              MOV      r7,r2
;;;94     	int i, j;
;;;95     	bool found = FALSE;
000120  f04f0900          MOV      r9,#0
;;;96     
;;;97     	j = ptpClock->foreignMasterDS.best;
000124  f9b4507e          LDRSH    r5,[r4,#0x7e]
;;;98     
;;;99     	/* Check if Foreign master is already known */
;;;100    	for (i = 0; i < ptpClock->foreignMasterDS.count; i++)
000128  46c8              MOV      r8,r9
00012a  e044              B        |L1.438|
                  |L1.300|
;;;101    	{
;;;102    		if (isSamePortIdentity(&header->sourcePortIdentity, &ptpClock->foreignMasterDS.records[j].foreignMasterPortIdentity))
00012c  eb050245          ADD      r2,r5,r5,LSL #1
000130  eb0202c5          ADD      r2,r2,r5,LSL #3
000134  6f60              LDR      r0,[r4,#0x74]
000136  eb0001c2          ADD      r1,r0,r2,LSL #3
00013a  f1060018          ADD      r0,r6,#0x18
00013e  f7fffffe          BL       isSamePortIdentity
000142  b370              CBZ      r0,|L1.418|
;;;103    		{
;;;104    			/* Foreign Master is already in Foreignmaster data set */
;;;105    			ptpClock->foreignMasterDS.records[j].foreignMasterAnnounceMessages++;
000144  eb050145          ADD      r1,r5,r5,LSL #1
000148  eb0101c5          ADD      r1,r1,r5,LSL #3
00014c  6f60              LDR      r0,[r4,#0x74]
00014e  eb0000c1          ADD      r0,r0,r1,LSL #3
000152  8940              LDRH     r0,[r0,#0xa]
000154  1c40              ADDS     r0,r0,#1
000156  b200              SXTH     r0,r0
000158  eb050245          ADD      r2,r5,r5,LSL #1
00015c  eb0202c5          ADD      r2,r2,r5,LSL #3
000160  6f61              LDR      r1,[r4,#0x74]
000162  eb0101c2          ADD      r1,r1,r2,LSL #3
000166  8148              STRH     r0,[r1,#0xa]
;;;106    			found = TRUE;
000168  f04f0901          MOV      r9,#1
;;;107    			DBGV("addForeign: AnnounceMessage incremented \n");
;;;108    			ptpClock->foreignMasterDS.records[j].header = *header;
00016c  eb050245          ADD      r2,r5,r5,LSL #1
000170  eb0202c5          ADD      r2,r2,r5,LSL #3
000174  6f61              LDR      r1,[r4,#0x74]
000176  eb0101c2          ADD      r1,r1,r2,LSL #3
00017a  f1010030          ADD      r0,r1,#0x30
00017e  2228              MOVS     r2,#0x28
000180  4631              MOV      r1,r6
000182  f7fffffe          BL       __aeabi_memcpy4
;;;109    			ptpClock->foreignMasterDS.records[j].announce = *announce;
000186  eb050245          ADD      r2,r5,r5,LSL #1
00018a  eb0202c5          ADD      r2,r2,r5,LSL #3
00018e  6f61              LDR      r1,[r4,#0x74]
000190  eb0101c2          ADD      r1,r1,r2,LSL #3
000194  f101000c          ADD      r0,r1,#0xc
000198  2224              MOVS     r2,#0x24
00019a  4639              MOV      r1,r7
00019c  f7fffffe          BL       __aeabi_memcpy4
;;;110    			break;
0001a0  e00d              B        |L1.446|
                  |L1.418|
0001a2  e7ff              B        |L1.420|
                  |L1.420|
;;;111    		}
;;;112    
;;;113    		j = (j + 1) % ptpClock->foreignMasterDS.count;
0001a4  f9b41078          LDRSH    r1,[r4,#0x78]
0001a8  1c68              ADDS     r0,r5,#1
0001aa  fb90f2f1          SDIV     r2,r0,r1
0001ae  fb010512          MLS      r5,r1,r2,r0
0001b2  f1080801          ADD      r8,r8,#1              ;100
                  |L1.438|
0001b6  f9b40078          LDRSH    r0,[r4,#0x78]         ;100
0001ba  4540              CMP      r0,r8                 ;100
0001bc  dcb6              BGT      |L1.300|
                  |L1.446|
0001be  bf00              NOP                            ;110
;;;114    	}
;;;115    
;;;116    	/* New Foreign Master */
;;;117    	if (!found)
0001c0  f1b90f00          CMP      r9,#0
0001c4  d150              BNE      |L1.616|
;;;118    	{
;;;119    		if (ptpClock->foreignMasterDS.count < ptpClock->foreignMasterDS.capacity)
0001c6  f9b41078          LDRSH    r1,[r4,#0x78]
0001ca  f9b4007a          LDRSH    r0,[r4,#0x7a]
0001ce  4281              CMP      r1,r0
0001d0  da05              BGE      |L1.478|
;;;120    		{
;;;121    			ptpClock->foreignMasterDS.count++;
0001d2  2078              MOVS     r0,#0x78
0001d4  5b00              LDRH     r0,[r0,r4]
0001d6  1c40              ADDS     r0,r0,#1
0001d8  b201              SXTH     r1,r0
0001da  2078              MOVS     r0,#0x78
0001dc  5301              STRH     r1,[r0,r4]
                  |L1.478|
;;;122    		}
;;;123    
;;;124    		j = ptpClock->foreignMasterDS.i;
0001de  f9b4507c          LDRSH    r5,[r4,#0x7c]
;;;125    
;;;126    		/* Copy new foreign master data set from Announce message */
;;;127    		memcpy(ptpClock->foreignMasterDS.records[j].foreignMasterPortIdentity.clockIdentity, header->sourcePortIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
0001e2  eb050145          ADD      r1,r5,r5,LSL #1
0001e6  eb0101c5          ADD      r1,r1,r5,LSL #3
0001ea  6f60              LDR      r0,[r4,#0x74]
0001ec  eb0000c1          ADD      r0,r0,r1,LSL #3
0001f0  69b1              LDR      r1,[r6,#0x18]
0001f2  6001              STR      r1,[r0,#0]
0001f4  69f1              LDR      r1,[r6,#0x1c]
0001f6  6041              STR      r1,[r0,#4]
;;;128    		ptpClock->foreignMasterDS.records[j].foreignMasterPortIdentity.portNumber = header->sourcePortIdentity.portNumber;
0001f8  8c30              LDRH     r0,[r6,#0x20]
0001fa  eb050245          ADD      r2,r5,r5,LSL #1
0001fe  eb0202c5          ADD      r2,r2,r5,LSL #3
000202  6f61              LDR      r1,[r4,#0x74]
000204  eb0101c2          ADD      r1,r1,r2,LSL #3
000208  8108              STRH     r0,[r1,#8]
;;;129    		ptpClock->foreignMasterDS.records[j].foreignMasterAnnounceMessages = 0;
00020a  2000              MOVS     r0,#0
00020c  eb050245          ADD      r2,r5,r5,LSL #1
000210  eb0202c5          ADD      r2,r2,r5,LSL #3
000214  6f61              LDR      r1,[r4,#0x74]
000216  eb0101c2          ADD      r1,r1,r2,LSL #3
00021a  8148              STRH     r0,[r1,#0xa]
;;;130    
;;;131    		/* Header and announce field of each Foreign Master are usefull to run Best Master Clock Algorithm */
;;;132    		ptpClock->foreignMasterDS.records[j].header = *header;
00021c  eb050245          ADD      r2,r5,r5,LSL #1
000220  eb0202c5          ADD      r2,r2,r5,LSL #3
000224  6f61              LDR      r1,[r4,#0x74]
000226  eb0101c2          ADD      r1,r1,r2,LSL #3
00022a  f1010030          ADD      r0,r1,#0x30
00022e  2228              MOVS     r2,#0x28
000230  4631              MOV      r1,r6
000232  f7fffffe          BL       __aeabi_memcpy4
;;;133    		ptpClock->foreignMasterDS.records[j].announce = *announce;
000236  eb050245          ADD      r2,r5,r5,LSL #1
00023a  eb0202c5          ADD      r2,r2,r5,LSL #3
00023e  6f61              LDR      r1,[r4,#0x74]
000240  eb0101c2          ADD      r1,r1,r2,LSL #3
000244  f101000c          ADD      r0,r1,#0xc
000248  2224              MOVS     r2,#0x24
00024a  4639              MOV      r1,r7
00024c  f7fffffe          BL       __aeabi_memcpy4
;;;134    		DBGV("addForeign: New foreign Master added \n");
;;;135    
;;;136    		ptpClock->foreignMasterDS.i = (ptpClock->foreignMasterDS.i + 1) % ptpClock->foreignMasterDS.capacity;
000250  f9b4007c          LDRSH    r0,[r4,#0x7c]
000254  1c40              ADDS     r0,r0,#1
000256  f9b4107a          LDRSH    r1,[r4,#0x7a]
00025a  fb90f2f1          SDIV     r2,r0,r1
00025e  fb010012          MLS      r0,r1,r2,r0
000262  b201              SXTH     r1,r0
000264  207c              MOVS     r0,#0x7c
000266  5301              STRH     r1,[r0,r4]
                  |L1.616|
;;;137    	}
;;;138    }
000268  e8bd87f0          POP      {r4-r10,pc}
;;;139    
                          ENDP

                  ||m1|| PROC
;;;142    /* Local clock is becoming Master. Table 13 (9.3.5) of the spec.*/
;;;143    void m1(PtpClock *ptpClock)
00026c  2100              MOVS     r1,#0
;;;144    {
;;;145    	DBGV("bmc: m1\n");
;;;146    
;;;147    	/* Current data set update */
;;;148    	ptpClock->currentDS.stepsRemoved = 0;
00026e  8281              STRH     r1,[r0,#0x14]
;;;149    	ptpClock->currentDS.offsetFromMaster.seconds = ptpClock->currentDS.offsetFromMaster.nanoseconds = 0;
000270  2200              MOVS     r2,#0
000272  61c2              STR      r2,[r0,#0x1c]
000274  6182              STR      r2,[r0,#0x18]
;;;150    	ptpClock->currentDS.meanPathDelay.seconds = ptpClock->currentDS.meanPathDelay.nanoseconds = 0;
000276  6242              STR      r2,[r0,#0x24]
000278  6202              STR      r2,[r0,#0x20]
;;;151    
;;;152    	/* Parent data set */
;;;153    	memcpy(ptpClock->parentDS.parentPortIdentity.clockIdentity, ptpClock->defaultDS.clockIdentity, CLOCK_IDENTITY_LENGTH);
00027a  f8d01001          LDR      r1,[r0,#1]
00027e  6281              STR      r1,[r0,#0x28]
000280  f8d01005          LDR      r1,[r0,#5]
000284  62c1              STR      r1,[r0,#0x2c]
;;;154    	ptpClock->parentDS.parentPortIdentity.portNumber = 0;
000286  8602              STRH     r2,[r0,#0x30]
;;;155    	memcpy(ptpClock->parentDS.grandmasterIdentity, ptpClock->defaultDS.clockIdentity, CLOCK_IDENTITY_LENGTH);
000288  f8d02001          LDR      r2,[r0,#1]
00028c  63c2              STR      r2,[r0,#0x3c]
00028e  f8d02005          LDR      r2,[r0,#5]
000292  6402              STR      r2,[r0,#0x40]
;;;156    	ptpClock->parentDS.grandmasterClockQuality.clockAccuracy = ptpClock->defaultDS.clockQuality.clockAccuracy;
000294  7b42              LDRB     r2,[r0,#0xd]
000296  2145              MOVS     r1,#0x45
000298  540a              STRB     r2,[r1,r0]
;;;157    	ptpClock->parentDS.grandmasterClockQuality.clockClass = ptpClock->defaultDS.clockQuality.clockClass;
00029a  7b02              LDRB     r2,[r0,#0xc]
00029c  2144              MOVS     r1,#0x44
00029e  540a              STRB     r2,[r1,r0]
;;;158    	ptpClock->parentDS.grandmasterClockQuality.offsetScaledLogVariance = ptpClock->defaultDS.clockQuality.offsetScaledLogVariance;
0002a0  89c2              LDRH     r2,[r0,#0xe]
0002a2  2146              MOVS     r1,#0x46
0002a4  520a              STRH     r2,[r1,r0]
;;;159    	ptpClock->parentDS.grandmasterPriority1 = ptpClock->defaultDS.priority1;
0002a6  7c02              LDRB     r2,[r0,#0x10]
0002a8  f8802048          STRB     r2,[r0,#0x48]
;;;160    	ptpClock->parentDS.grandmasterPriority2 = ptpClock->defaultDS.priority2;
0002ac  7c42              LDRB     r2,[r0,#0x11]
0002ae  f8802049          STRB     r2,[r0,#0x49]
;;;161    
;;;162    	/* Time Properties data set */
;;;163    	ptpClock->timePropertiesDS.currentUtcOffset = ptpClock->rtOpts->currentUtcOffset;
0002b2  f8d01464          LDR      r1,[r0,#0x464]
0002b6  8949              LDRH     r1,[r1,#0xa]
0002b8  f8a0104c          STRH     r1,[r0,#0x4c]
;;;164    	ptpClock->timePropertiesDS.currentUtcOffsetValid = DEFAULT_UTC_VALID;
0002bc  2200              MOVS     r2,#0
0002be  214e              MOVS     r1,#0x4e
0002c0  540a              STRB     r2,[r1,r0]
;;;165    	ptpClock->timePropertiesDS.leap59 = FALSE;
0002c2  214f              MOVS     r1,#0x4f
0002c4  540a              STRB     r2,[r1,r0]
;;;166    	ptpClock->timePropertiesDS.leap61 = FALSE;
0002c6  2150              MOVS     r1,#0x50
0002c8  540a              STRB     r2,[r1,r0]
;;;167    	ptpClock->timePropertiesDS.timeTraceable = DEFAULT_TIME_TRACEABLE;
0002ca  2151              MOVS     r1,#0x51
0002cc  540a              STRB     r2,[r1,r0]
;;;168    	ptpClock->timePropertiesDS.frequencyTraceable = DEFAULT_FREQUENCY_TRACEABLE;
0002ce  2152              MOVS     r1,#0x52
0002d0  540a              STRB     r2,[r1,r0]
;;;169    	ptpClock->timePropertiesDS.ptpTimescale = (bool)(DEFAULT_TIMESCALE == PTP_TIMESCALE);
0002d2  2153              MOVS     r1,#0x53
0002d4  540a              STRB     r2,[r1,r0]
;;;170    	ptpClock->timePropertiesDS.timeSource = DEFAULT_TIME_SOURCE;
0002d6  22a0              MOVS     r2,#0xa0
0002d8  2154              MOVS     r1,#0x54
0002da  540a              STRB     r2,[r1,r0]
;;;171    }
0002dc  4770              BX       lr
;;;172    
                          ENDP

                  ||p1|| PROC
;;;173    void p1(PtpClock *ptpClock)
0002de  4770              BX       lr
;;;174    {
;;;175    	DBGV("bmc: p1\n");
;;;176    }
;;;177    
                          ENDP

                  ||s1|| PROC
;;;178    /* Local clock is synchronized to Ebest Table 16 (9.3.5) of the spec */
;;;179    void s1(PtpClock *ptpClock, const MsgHeader *header, const MsgAnnounce *announce)
0002e0  e92d41f0          PUSH     {r4-r8,lr}
;;;180    {
0002e4  4604              MOV      r4,r0
0002e6  460d              MOV      r5,r1
0002e8  4616              MOV      r6,r2
;;;181    	bool isFromCurrentParent;
;;;182    
;;;183    	DBGV("bmc: s1\n");
;;;184    
;;;185    	/* Current DS */
;;;186    	ptpClock->currentDS.stepsRemoved = announce->stepsRemoved + 1;
0002ea  8bf0              LDRH     r0,[r6,#0x1e]
0002ec  1c40              ADDS     r0,r0,#1
0002ee  b200              SXTH     r0,r0
0002f0  82a0              STRH     r0,[r4,#0x14]
;;;187    
;;;188    	isFromCurrentParent = isSamePortIdentity(&ptpClock->parentDS.parentPortIdentity, &header->sourcePortIdentity);
0002f2  f1050118          ADD      r1,r5,#0x18
0002f6  f1040028          ADD      r0,r4,#0x28
0002fa  f7fffffe          BL       isSamePortIdentity
0002fe  4607              MOV      r7,r0
;;;189    
;;;190    	if (!isFromCurrentParent)
000300  b92f              CBNZ     r7,|L1.782|
;;;191    	{
;;;192    			setFlag(ptpClock->events, MASTER_CLOCK_CHANGED);
000302  f8d4045c          LDR      r0,[r4,#0x45c]
000306  f4406000          ORR      r0,r0,#0x800
00030a  f8c4045c          STR      r0,[r4,#0x45c]
                  |L1.782|
;;;193    	}
;;;194    
;;;195    	/* Parent DS */
;;;196    	memcpy(ptpClock->parentDS.parentPortIdentity.clockIdentity, header->sourcePortIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
00030e  69a8              LDR      r0,[r5,#0x18]
000310  62a0              STR      r0,[r4,#0x28]
000312  69e8              LDR      r0,[r5,#0x1c]
000314  62e0              STR      r0,[r4,#0x2c]
;;;197    	ptpClock->parentDS.parentPortIdentity.portNumber = header->sourcePortIdentity.portNumber;
000316  8c29              LDRH     r1,[r5,#0x20]
000318  8621              STRH     r1,[r4,#0x30]
;;;198    	memcpy(ptpClock->parentDS.grandmasterIdentity, announce->grandmasterIdentity, CLOCK_IDENTITY_LENGTH);
00031a  f8d61015          LDR      r1,[r6,#0x15]
00031e  63e1              STR      r1,[r4,#0x3c]
000320  f8d61019          LDR      r1,[r6,#0x19]
000324  6421              STR      r1,[r4,#0x40]
;;;199    	ptpClock->parentDS.grandmasterClockQuality.clockAccuracy = announce->grandmasterClockQuality.clockAccuracy;
000326  7c71              LDRB     r1,[r6,#0x11]
000328  f8841045          STRB     r1,[r4,#0x45]
;;;200    	ptpClock->parentDS.grandmasterClockQuality.clockClass = announce->grandmasterClockQuality.clockClass;
00032c  7c31              LDRB     r1,[r6,#0x10]
00032e  2044              MOVS     r0,#0x44
000330  5501              STRB     r1,[r0,r4]
;;;201    	ptpClock->parentDS.grandmasterClockQuality.offsetScaledLogVariance = announce->grandmasterClockQuality.offsetScaledLogVariance;
000332  8a71              LDRH     r1,[r6,#0x12]
000334  f8a41046          STRH     r1,[r4,#0x46]
;;;202    	ptpClock->parentDS.grandmasterPriority1 = announce->grandmasterPriority1;
000338  7bb1              LDRB     r1,[r6,#0xe]
00033a  f8841048          STRB     r1,[r4,#0x48]
;;;203    	ptpClock->parentDS.grandmasterPriority2 = announce->grandmasterPriority2;
00033e  7d31              LDRB     r1,[r6,#0x14]
000340  f8841049          STRB     r1,[r4,#0x49]
;;;204    
;;;205    	/* Timeproperties DS */
;;;206    	ptpClock->timePropertiesDS.currentUtcOffset = announce->currentUtcOffset;
000344  89b0              LDRH     r0,[r6,#0xc]
000346  f8a4004c          STRH     r0,[r4,#0x4c]
;;;207    	ptpClock->timePropertiesDS.currentUtcOffsetValid = getFlag(header->flagField[1], FLAG1_UTC_OFFSET_VALID);
00034a  7a28              LDRB     r0,[r5,#8]
00034c  f3c00180          UBFX     r1,r0,#2,#1
000350  204e              MOVS     r0,#0x4e
000352  5501              STRB     r1,[r0,r4]
;;;208    	ptpClock->timePropertiesDS.leap59 = getFlag(header->flagField[1], FLAG1_LEAP59);
000354  7a28              LDRB     r0,[r5,#8]
000356  f3c00140          UBFX     r1,r0,#1,#1
00035a  204f              MOVS     r0,#0x4f
00035c  5501              STRB     r1,[r0,r4]
;;;209    	ptpClock->timePropertiesDS.leap61 = getFlag(header->flagField[1], FLAG1_LEAP61);
00035e  7a28              LDRB     r0,[r5,#8]
000360  f0000001          AND      r0,r0,#1
000364  f0800001          EOR      r0,r0,#1
000368  f0800101          EOR      r1,r0,#1
00036c  2050              MOVS     r0,#0x50
00036e  5501              STRB     r1,[r0,r4]
;;;210    	ptpClock->timePropertiesDS.timeTraceable = getFlag(header->flagField[1], FLAG1_TIME_TRACEABLE);
000370  7a28              LDRB     r0,[r5,#8]
000372  f3c01100          UBFX     r1,r0,#4,#1
000376  2051              MOVS     r0,#0x51
000378  5501              STRB     r1,[r0,r4]
;;;211    	ptpClock->timePropertiesDS.frequencyTraceable = getFlag(header->flagField[1], FLAG1_FREQUENCY_TRACEABLE);
00037a  7a28              LDRB     r0,[r5,#8]
00037c  f3c01140          UBFX     r1,r0,#5,#1
000380  2052              MOVS     r0,#0x52
000382  5501              STRB     r1,[r0,r4]
;;;212    	ptpClock->timePropertiesDS.ptpTimescale = getFlag(header->flagField[1], FLAG1_PTP_TIMESCALE);
000384  7a28              LDRB     r0,[r5,#8]
000386  f3c001c0          UBFX     r1,r0,#3,#1
00038a  2053              MOVS     r0,#0x53
00038c  5501              STRB     r1,[r0,r4]
;;;213    	ptpClock->timePropertiesDS.timeSource = announce->timeSource;
00038e  f8961020          LDRB     r1,[r6,#0x20]
000392  2054              MOVS     r0,#0x54
000394  5501              STRB     r1,[r0,r4]
;;;214    }
000396  e8bd81f0          POP      {r4-r8,pc}
;;;215    
                          ENDP

                  copyD0 PROC
;;;218     */
;;;219    void copyD0(MsgHeader *header, MsgAnnounce *announce, PtpClock *ptpClock)
00039a  b510              PUSH     {r4,lr}
;;;220    {
;;;221    	announce->grandmasterPriority1 = ptpClock->defaultDS.priority1;
00039c  7c13              LDRB     r3,[r2,#0x10]
00039e  738b              STRB     r3,[r1,#0xe]
;;;222    	memcpy(announce->grandmasterIdentity, ptpClock->defaultDS.clockIdentity, CLOCK_IDENTITY_LENGTH);
0003a0  f8d23001          LDR      r3,[r2,#1]
0003a4  f8c13015          STR      r3,[r1,#0x15]
0003a8  f8d23005          LDR      r3,[r2,#5]
0003ac  f8c13019          STR      r3,[r1,#0x19]
;;;223    	announce->grandmasterClockQuality.clockClass = ptpClock->defaultDS.clockQuality.clockClass;
0003b0  7b13              LDRB     r3,[r2,#0xc]
0003b2  740b              STRB     r3,[r1,#0x10]
;;;224    	announce->grandmasterClockQuality.clockAccuracy = ptpClock->defaultDS.clockQuality.clockAccuracy;
0003b4  7b54              LDRB     r4,[r2,#0xd]
0003b6  744c              STRB     r4,[r1,#0x11]
;;;225    	announce->grandmasterClockQuality.offsetScaledLogVariance = ptpClock->defaultDS.clockQuality.offsetScaledLogVariance;
0003b8  89d4              LDRH     r4,[r2,#0xe]
0003ba  824c              STRH     r4,[r1,#0x12]
;;;226    	announce->grandmasterPriority2 = ptpClock->defaultDS.priority2;
0003bc  7c53              LDRB     r3,[r2,#0x11]
0003be  750b              STRB     r3,[r1,#0x14]
;;;227    	announce->stepsRemoved = 0;
0003c0  2300              MOVS     r3,#0
0003c2  83cb              STRH     r3,[r1,#0x1e]
;;;228    	memcpy(header->sourcePortIdentity.clockIdentity, ptpClock->defaultDS.clockIdentity, CLOCK_IDENTITY_LENGTH);
0003c4  f8d23001          LDR      r3,[r2,#1]
0003c8  6183              STR      r3,[r0,#0x18]
0003ca  f8d23005          LDR      r3,[r2,#5]
0003ce  61c3              STR      r3,[r0,#0x1c]
;;;229    }
0003d0  bd10              POP      {r4,pc}
;;;230    
                          ENDP

                  bmcDataSetComparison PROC
;;;250    /* Data set comparison bewteen two foreign masters (9.3.4 fig 27) return similar to memcmp() */
;;;251    int8_t bmcDataSetComparison(MsgHeader *headerA, MsgAnnounce *announceA,
0003d2  e92d47f0          PUSH     {r4-r10,lr}
;;;252    															MsgHeader *headerB, MsgAnnounce *announceB, PtpClock *ptpClock)
;;;253    {
0003d6  4607              MOV      r7,r0
0003d8  460c              MOV      r4,r1
0003da  4690              MOV      r8,r2
0003dc  461d              MOV      r5,r3
0003de  f8dda020          LDR      r10,[sp,#0x20]
;;;254    	int grandmasterIdentityComp;
;;;255    	short comp = 0;
0003e2  2600              MOVS     r6,#0
;;;256    
;;;257    	DBGV("bmcDataSetComparison\n");
;;;258    	/* Identity comparison */
;;;259    
;;;260    	/* GM identity of A == GM identity of B */
;;;261    	/* TODO: zkontrolovat memcmp, co vraci za vysledky !*/
;;;262    	grandmasterIdentityComp = memcmp(announceA->grandmasterIdentity, announceB->grandmasterIdentity, CLOCK_IDENTITY_LENGTH);
0003e4  2208              MOVS     r2,#8
0003e6  f1050115          ADD      r1,r5,#0x15
0003ea  f1040015          ADD      r0,r4,#0x15
0003ee  f7fffffe          BL       memcmp
0003f2  4681              MOV      r9,r0
;;;263    
;;;264    	if (0 != grandmasterIdentityComp)
0003f4  f1b90f00          CMP      r9,#0
0003f8  d04f              BEQ      |L1.1178|
;;;265    	{
;;;266    		/* Algoritgm part 1 - Figure 27 */
;;;267    		COMPARE_AB_RETURN_BETTER(grandmasterPriority1,"grandmaster.Priority1");
0003fa  7ba0              LDRB     r0,[r4,#0xe]
0003fc  7ba9              LDRB     r1,[r5,#0xe]
0003fe  4288              CMP      r0,r1
000400  dd02              BLE      |L1.1032|
000402  1e70              SUBS     r0,r6,#1
                  |L1.1028|
;;;268    		COMPARE_AB_RETURN_BETTER(grandmasterClockQuality.clockClass,"grandmaster.clockClass");
;;;269    		COMPARE_AB_RETURN_BETTER(grandmasterClockQuality.clockAccuracy,"grandmaster.clockAccuracy");
;;;270    		COMPARE_AB_RETURN_BETTER(grandmasterClockQuality.offsetScaledLogVariance,"grandmaster.Variance");
;;;271    		COMPARE_AB_RETURN_BETTER(grandmasterPriority2,"grandmaster.Priority2");
;;;272    
;;;273    		if (grandmasterIdentityComp > 0)
;;;274    		{
;;;275    			DBGVV("bmcDataSetComparison: grandmaster.Identity: B better then A\n");
;;;276    			return B_better_then_A;
;;;277    		}
;;;278    		else if (grandmasterIdentityComp < 0)
;;;279    		{
;;;280    			DBGVV("bmcDataSetComparison: grandmaster.Identity: A better then B\n");
;;;281    			return A_better_then_B;
;;;282    		}
;;;283    	}
;;;284    
;;;285    	/* Algoritgm part 2 - Figure 28 */
;;;286    	if ((announceA->stepsRemoved) > (announceB->stepsRemoved + 1))
;;;287    	{
;;;288    		DBGVV("bmcDataSetComparison: stepsRemoved: B better then A\n");
;;;289    		return B_better_then_A;
;;;290    	}
;;;291    
;;;292    	if ((announceB->stepsRemoved) > (announceA->stepsRemoved + 1))
;;;293    	{
;;;294    		DBGVV("bmcDataSetComparison: stepsRemoved: A better then B\n");
;;;295    		return A_better_then_B;
;;;296    	}
;;;297    
;;;298    	if ((announceA->stepsRemoved) > (announceB->stepsRemoved))
;;;299    	{
;;;300    		comp = memcmp(headerA->sourcePortIdentity.clockIdentity, ptpClock->portDS.portIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
;;;301    
;;;302    		if (comp > 0)
;;;303    		{
;;;304    			/* reciever < sender */
;;;305    			DBGVV("bmcDataSetComparison: PortIdentity: B better then A\n");
;;;306    			return B_better_then_A;
;;;307    		}
;;;308    		else if (comp < 0)
;;;309    		{
;;;310    			/* reciever > sender */
;;;311    			DBGVV("bmcDataSetComparison: PortIdentity: B better by topology then A\n");
;;;312    			return B_better_by_topology_then_A;
;;;313    		}
;;;314    		else
;;;315    		{
;;;316    			DBGVV("bmcDataSetComparison: ERROR 1\n");
;;;317    			return ERROR_1;
;;;318    		}
;;;319    	}
;;;320    	else if ((announceA->stepsRemoved) < (announceB->stepsRemoved))
;;;321    	{
;;;322    		comp = memcmp(headerB->sourcePortIdentity.clockIdentity, ptpClock->portDS.portIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
;;;323    		if (comp > 0)
;;;324    		{
;;;325    			/* reciever < sender */
;;;326    			DBGVV("bmcDataSetComparison: PortIdentity: A better then B\n");
;;;327    			return A_better_then_B;
;;;328    		}
;;;329    		else if (comp < 0)
;;;330    		{
;;;331    			/* reciever > sender */
;;;332    			DBGVV("bmcDataSetComparison: PortIdentity: A better by topology then B\n");
;;;333    			return A_better_by_topology_then_B;
;;;334    		}
;;;335    		else
;;;336    		{
;;;337    			DBGV("bmcDataSetComparison: ERROR 1\n");
;;;338    			return ERROR_1;
;;;339    		}
;;;340    	}
;;;341    
;;;342    	comp = memcmp(headerA->sourcePortIdentity.clockIdentity, headerB->sourcePortIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
;;;343    	if (comp > 0)
;;;344    	{
;;;345    		/* A > B */
;;;346    		DBGVV("bmcDataSetComparison: sourcePortIdentity: B better by topology then A\n");
;;;347    		return B_better_by_topology_then_A;
;;;348    	}
;;;349    	else if (comp < 0)
;;;350    	{
;;;351    		/* B > A */
;;;352    		DBGVV("bmcDataSetComparison: sourcePortIdentity: A better by topology then B\n");
;;;353    		return A_better_by_topology_then_B;
;;;354    	}
;;;355    
;;;356    	/* compare port numbers of recievers of A and B - same as we have only one port */
;;;357    	DBGV("bmcDataSetComparison: ERROR 2\n");
;;;358    	return ERROR_2;
;;;359    }
000404  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1032|
000408  7ba8              LDRB     r0,[r5,#0xe]          ;267
00040a  7ba1              LDRB     r1,[r4,#0xe]          ;267
00040c  4288              CMP      r0,r1                 ;267
00040e  dd01              BLE      |L1.1044|
000410  2001              MOVS     r0,#1                 ;267
000412  e7f7              B        |L1.1028|
                  |L1.1044|
000414  7c20              LDRB     r0,[r4,#0x10]         ;268
000416  7c29              LDRB     r1,[r5,#0x10]         ;268
000418  4288              CMP      r0,r1                 ;268
00041a  dd02              BLE      |L1.1058|
00041c  f04f30ff          MOV      r0,#0xffffffff        ;268
000420  e7f0              B        |L1.1028|
                  |L1.1058|
000422  7c28              LDRB     r0,[r5,#0x10]         ;268
000424  7c21              LDRB     r1,[r4,#0x10]         ;268
000426  4288              CMP      r0,r1                 ;268
000428  dd01              BLE      |L1.1070|
00042a  2001              MOVS     r0,#1                 ;268
00042c  e7ea              B        |L1.1028|
                  |L1.1070|
00042e  7c61              LDRB     r1,[r4,#0x11]         ;269
000430  7c68              LDRB     r0,[r5,#0x11]         ;269
000432  4281              CMP      r1,r0                 ;269
000434  dd02              BLE      |L1.1084|
000436  f04f30ff          MOV      r0,#0xffffffff        ;269
00043a  e7e3              B        |L1.1028|
                  |L1.1084|
00043c  7c69              LDRB     r1,[r5,#0x11]         ;269
00043e  7c60              LDRB     r0,[r4,#0x11]         ;269
000440  4281              CMP      r1,r0                 ;269
000442  dd01              BLE      |L1.1096|
000444  2001              MOVS     r0,#1                 ;269
000446  e7dd              B        |L1.1028|
                  |L1.1096|
000448  f9b41012          LDRSH    r1,[r4,#0x12]         ;270
00044c  f9b50012          LDRSH    r0,[r5,#0x12]         ;270
000450  4281              CMP      r1,r0                 ;270
000452  dd02              BLE      |L1.1114|
000454  f04f30ff          MOV      r0,#0xffffffff        ;270
000458  e7d4              B        |L1.1028|
                  |L1.1114|
00045a  f9b51012          LDRSH    r1,[r5,#0x12]         ;270
00045e  f9b40012          LDRSH    r0,[r4,#0x12]         ;270
000462  4281              CMP      r1,r0                 ;270
000464  dd01              BLE      |L1.1130|
000466  2001              MOVS     r0,#1                 ;270
000468  e7cc              B        |L1.1028|
                  |L1.1130|
00046a  7d20              LDRB     r0,[r4,#0x14]         ;271
00046c  7d29              LDRB     r1,[r5,#0x14]         ;271
00046e  4288              CMP      r0,r1                 ;271
000470  dd02              BLE      |L1.1144|
000472  f04f30ff          MOV      r0,#0xffffffff        ;271
000476  e7c5              B        |L1.1028|
                  |L1.1144|
000478  7d28              LDRB     r0,[r5,#0x14]         ;271
00047a  7d21              LDRB     r1,[r4,#0x14]         ;271
00047c  4288              CMP      r0,r1                 ;271
00047e  dd01              BLE      |L1.1156|
000480  2001              MOVS     r0,#1                 ;271
000482  e7bf              B        |L1.1028|
                  |L1.1156|
000484  f1b90f00          CMP      r9,#0                 ;273
000488  dd02              BLE      |L1.1168|
00048a  f04f30ff          MOV      r0,#0xffffffff        ;276
00048e  e7b9              B        |L1.1028|
                  |L1.1168|
000490  f1b90f00          CMP      r9,#0                 ;278
000494  da01              BGE      |L1.1178|
000496  2001              MOVS     r0,#1                 ;281
000498  e7b4              B        |L1.1028|
                  |L1.1178|
00049a  f9b4101e          LDRSH    r1,[r4,#0x1e]         ;286
00049e  f9b5001e          LDRSH    r0,[r5,#0x1e]         ;286
0004a2  1c40              ADDS     r0,r0,#1              ;286
0004a4  4281              CMP      r1,r0                 ;286
0004a6  dd02              BLE      |L1.1198|
0004a8  f04f30ff          MOV      r0,#0xffffffff        ;289
0004ac  e7aa              B        |L1.1028|
                  |L1.1198|
0004ae  f9b5101e          LDRSH    r1,[r5,#0x1e]         ;292
0004b2  f9b4001e          LDRSH    r0,[r4,#0x1e]         ;292
0004b6  1c40              ADDS     r0,r0,#1              ;292
0004b8  4281              CMP      r1,r0                 ;292
0004ba  dd01              BLE      |L1.1216|
0004bc  2001              MOVS     r0,#1                 ;295
0004be  e7a1              B        |L1.1028|
                  |L1.1216|
0004c0  f9b4001e          LDRSH    r0,[r4,#0x1e]         ;298
0004c4  f9b5101e          LDRSH    r1,[r5,#0x1e]         ;298
0004c8  4288              CMP      r0,r1                 ;298
0004ca  dd13              BLE      |L1.1268|
0004cc  2208              MOVS     r2,#8                 ;300
0004ce  f10a0158          ADD      r1,r10,#0x58          ;300
0004d2  f1070018          ADD      r0,r7,#0x18           ;300
0004d6  f7fffffe          BL       memcmp
0004da  b206              SXTH     r6,r0                 ;300
0004dc  2e00              CMP      r6,#0                 ;302
0004de  dd02              BLE      |L1.1254|
0004e0  f04f30ff          MOV      r0,#0xffffffff        ;306
0004e4  e78e              B        |L1.1028|
                  |L1.1254|
0004e6  2e00              CMP      r6,#0                 ;308
0004e8  da02              BGE      |L1.1264|
0004ea  f04f30ff          MOV      r0,#0xffffffff        ;312
0004ee  e789              B        |L1.1028|
                  |L1.1264|
0004f0  2000              MOVS     r0,#0                 ;317
0004f2  e787              B        |L1.1028|
                  |L1.1268|
0004f4  f9b4001e          LDRSH    r0,[r4,#0x1e]         ;320
0004f8  f9b5101e          LDRSH    r1,[r5,#0x1e]         ;320
0004fc  4288              CMP      r0,r1                 ;320
0004fe  da11              BGE      |L1.1316|
000500  2208              MOVS     r2,#8                 ;322
000502  f10a0158          ADD      r1,r10,#0x58          ;322
000506  f1080018          ADD      r0,r8,#0x18           ;322
00050a  f7fffffe          BL       memcmp
00050e  b206              SXTH     r6,r0                 ;322
000510  2e00              CMP      r6,#0                 ;323
000512  dd01              BLE      |L1.1304|
000514  2001              MOVS     r0,#1                 ;327
000516  e775              B        |L1.1028|
                  |L1.1304|
000518  2e00              CMP      r6,#0                 ;329
00051a  da01              BGE      |L1.1312|
00051c  2001              MOVS     r0,#1                 ;333
00051e  e771              B        |L1.1028|
                  |L1.1312|
000520  2000              MOVS     r0,#0                 ;338
000522  e76f              B        |L1.1028|
                  |L1.1316|
000524  2208              MOVS     r2,#8                 ;342
000526  f1080118          ADD      r1,r8,#0x18           ;342
00052a  f1070018          ADD      r0,r7,#0x18           ;342
00052e  f7fffffe          BL       memcmp
000532  b206              SXTH     r6,r0                 ;342
000534  2e00              CMP      r6,#0                 ;343
000536  dd02              BLE      |L1.1342|
000538  f04f30ff          MOV      r0,#0xffffffff        ;347
00053c  e762              B        |L1.1028|
                  |L1.1342|
00053e  2e00              CMP      r6,#0                 ;349
000540  da01              BGE      |L1.1350|
000542  2001              MOVS     r0,#1                 ;353
000544  e75e              B        |L1.1028|
                  |L1.1350|
000546  2000              MOVS     r0,#0                 ;358
000548  e75c              B        |L1.1028|
;;;360    
                          ENDP

                  bmcStateDecision PROC
;;;361    /* State decision algorithm 9.3.3 Fig 26 */
;;;362    uint8_t bmcStateDecision(MsgHeader *header, MsgAnnounce *announce, PtpClock *ptpClock)
00054a  b5f8              PUSH     {r3-r7,lr}
;;;363    {
00054c  4606              MOV      r6,r0
00054e  460f              MOV      r7,r1
000550  4614              MOV      r4,r2
;;;364    	int comp;
;;;365    
;;;366    	if ((!ptpClock->foreignMasterDS.count) && (ptpClock->portDS.portState == PTP_LISTENING))
000552  2078              MOVS     r0,#0x78
000554  5b00              LDRH     r0,[r0,r4]
000556  b920              CBNZ     r0,|L1.1378|
000558  2062              MOVS     r0,#0x62
00055a  5d00              LDRB     r0,[r0,r4]
00055c  2803              CMP      r0,#3
00055e  d100              BNE      |L1.1378|
                  |L1.1376|
;;;367    	{
;;;368    		return PTP_LISTENING;
;;;369    	}
;;;370    
;;;371    	copyD0(&ptpClock->msgTmpHeader, &ptpClock->msgTmp.announce, ptpClock);
;;;372    
;;;373    	comp = bmcDataSetComparison(&ptpClock->msgTmpHeader, &ptpClock->msgTmp.announce, header, announce, ptpClock);
;;;374    
;;;375    	DBGV("bmcStateDecision: %d\n", comp);
;;;376    
;;;377    	if (ptpClock->defaultDS.clockQuality.clockClass < 128)
;;;378    	{
;;;379    		if (A_better_then_B == comp)
;;;380    		{
;;;381    			m1(ptpClock);  /* M1 */
;;;382    			return PTP_MASTER;
;;;383    		}
;;;384    		else
;;;385    		{
;;;386    			p1(ptpClock);
;;;387    			return PTP_PASSIVE;
;;;388    		}
;;;389    	}
;;;390    	else
;;;391    	{
;;;392    		if (A_better_then_B == comp)
;;;393    		{
;;;394    			m2(ptpClock); /* M2 */
;;;395    			return PTP_MASTER;
;;;396    		}
;;;397    		else
;;;398    		{
;;;399    			s1(ptpClock, header, announce);
;;;400    			return PTP_SLAVE;
;;;401    		}
;;;402    	}
;;;403    }
000560  bdf8              POP      {r3-r7,pc}
                  |L1.1378|
000562  4622              MOV      r2,r4                 ;371
000564  f10401a8          ADD      r1,r4,#0xa8           ;371
000568  f1040080          ADD      r0,r4,#0x80           ;371
00056c  f7fffffe          BL       copyD0
000570  463b              MOV      r3,r7                 ;373
000572  4632              MOV      r2,r6                 ;373
000574  f10401a8          ADD      r1,r4,#0xa8           ;373
000578  f1040080          ADD      r0,r4,#0x80           ;373
00057c  9400              STR      r4,[sp,#0]            ;373
00057e  f7fffffe          BL       bmcDataSetComparison
000582  4605              MOV      r5,r0                 ;373
000584  7b20              LDRB     r0,[r4,#0xc]          ;377
000586  2880              CMP      r0,#0x80              ;377
000588  da0b              BGE      |L1.1442|
00058a  2d01              CMP      r5,#1                 ;379
00058c  d104              BNE      |L1.1432|
00058e  4620              MOV      r0,r4                 ;381
000590  f7fffffe          BL       ||m1||
000594  2005              MOVS     r0,#5                 ;382
000596  e7e3              B        |L1.1376|
                  |L1.1432|
000598  4620              MOV      r0,r4                 ;386
00059a  f7fffffe          BL       ||p1||
00059e  2006              MOVS     r0,#6                 ;387
0005a0  e7de              B        |L1.1376|
                  |L1.1442|
0005a2  2d01              CMP      r5,#1                 ;392
0005a4  d104              BNE      |L1.1456|
0005a6  4620              MOV      r0,r4                 ;394
0005a8  f7fffffe          BL       ||m1||
0005ac  2005              MOVS     r0,#5                 ;395
0005ae  e7d7              B        |L1.1376|
                  |L1.1456|
0005b0  463a              MOV      r2,r7                 ;399
0005b2  4631              MOV      r1,r6                 ;399
0005b4  4620              MOV      r0,r4                 ;399
0005b6  f7fffffe          BL       ||s1||
0005ba  2008              MOVS     r0,#8                 ;400
0005bc  e7d0              B        |L1.1376|
;;;404    
                          ENDP

                  bmc PROC
;;;406    
;;;407    uint8_t bmc(PtpClock *ptpClock)
0005be  b5f8              PUSH     {r3-r7,lr}
;;;408    {
0005c0  4604              MOV      r4,r0
;;;409    	int16_t i, best;
;;;410    
;;;411    	/* Starting from i = 1, not necessery to test record[i = 0] against record[best = 0] -> they are the same */
;;;412    	for (i = 1, best = 0; i < ptpClock->foreignMasterDS.count; i++)
0005c2  2501              MOVS     r5,#1
0005c4  2600              MOVS     r6,#0
0005c6  e02b              B        |L1.1568|
                  |L1.1480|
;;;413    	{
;;;414    		if ((bmcDataSetComparison(&ptpClock->foreignMasterDS.records[i].header, &ptpClock->foreignMasterDS.records[i].announce,
0005c8  9400              STR      r4,[sp,#0]
0005ca  eb060c46          ADD      r12,r6,r6,LSL #1
0005ce  eb0c0cc6          ADD      r12,r12,r6,LSL #3
0005d2  6f67              LDR      r7,[r4,#0x74]
0005d4  eb0707cc          ADD      r7,r7,r12,LSL #3
0005d8  f107030c          ADD      r3,r7,#0xc
0005dc  eb060c46          ADD      r12,r6,r6,LSL #1
0005e0  eb0c0cc6          ADD      r12,r12,r6,LSL #3
0005e4  6f67              LDR      r7,[r4,#0x74]
0005e6  eb0707cc          ADD      r7,r7,r12,LSL #3
0005ea  f1070230          ADD      r2,r7,#0x30
0005ee  eb050c45          ADD      r12,r5,r5,LSL #1
0005f2  eb0c0cc5          ADD      r12,r12,r5,LSL #3
0005f6  6f67              LDR      r7,[r4,#0x74]
0005f8  eb0707cc          ADD      r7,r7,r12,LSL #3
0005fc  f107010c          ADD      r1,r7,#0xc
000600  eb050c45          ADD      r12,r5,r5,LSL #1
000604  eb0c0cc5          ADD      r12,r12,r5,LSL #3
000608  6f67              LDR      r7,[r4,#0x74]
00060a  eb0707cc          ADD      r7,r7,r12,LSL #3
00060e  f1070030          ADD      r0,r7,#0x30
000612  f7fffffe          BL       bmcDataSetComparison
000616  2800              CMP      r0,#0
000618  da00              BGE      |L1.1564|
;;;415    															&ptpClock->foreignMasterDS.records[best].header, &ptpClock->foreignMasterDS.records[best].announce, ptpClock)) < 0)
;;;416    		{
;;;417    			best = i;
00061a  462e              MOV      r6,r5
                  |L1.1564|
00061c  1c68              ADDS     r0,r5,#1              ;412
00061e  b205              SXTH     r5,r0                 ;412
                  |L1.1568|
000620  f9b40078          LDRSH    r0,[r4,#0x78]         ;412
000624  42a8              CMP      r0,r5                 ;412
000626  dccf              BGT      |L1.1480|
;;;418    		}
;;;419    	}
;;;420    
;;;421    	DBGV("bmc: best record %d\n", best);
;;;422    	ptpClock->foreignMasterDS.best = best;
000628  207e              MOVS     r0,#0x7e
00062a  5306              STRH     r6,[r0,r4]
;;;423    
;;;424    	return bmcStateDecision(&ptpClock->foreignMasterDS.records[best].header, &ptpClock->foreignMasterDS.records[best].announce, ptpClock);
00062c  eb060346          ADD      r3,r6,r6,LSL #1
000630  eb0303c6          ADD      r3,r3,r6,LSL #3
000634  6f62              LDR      r2,[r4,#0x74]
000636  eb0202c3          ADD      r2,r2,r3,LSL #3
00063a  f102010c          ADD      r1,r2,#0xc
00063e  eb060346          ADD      r3,r6,r6,LSL #1
000642  eb0303c6          ADD      r3,r3,r6,LSL #3
000646  6f62              LDR      r2,[r4,#0x74]
000648  eb0202c3          ADD      r2,r2,r3,LSL #3
00064c  f1020030          ADD      r0,r2,#0x30
000650  4622              MOV      r2,r4
000652  f7fffffe          BL       bmcStateDecision
;;;425    }
000656  bdf8              POP      {r3-r7,pc}
;;;426    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\bmc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_bmc_c_c7003004____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_bmc_c_c7003004____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_bmc_c_c7003004____REVSH|
#line 128
|__asm___5_bmc_c_c7003004____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
