; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4xx_dma.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4xx_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4xx_dma.crf ..\..\libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  DMA_DeInit PROC
;;;193      */
;;;194    void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
000000  6801              LDR      r1,[r0,#0]
;;;195    {
;;;196      /* Check the parameters */
;;;197      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;198    
;;;199      /* Disable the selected DMAy Streamx */
;;;200      DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;201    
;;;202      /* Reset DMAy Streamx control register */
;;;203      DMAy_Streamx->CR  = 0;
000008  2100              MOVS     r1,#0
00000a  6001              STR      r1,[r0,#0]
;;;204      
;;;205      /* Reset DMAy Streamx Number of Data to Transfer register */
;;;206      DMAy_Streamx->NDTR = 0;
00000c  6041              STR      r1,[r0,#4]
;;;207      
;;;208      /* Reset DMAy Streamx peripheral address register */
;;;209      DMAy_Streamx->PAR  = 0;
00000e  6081              STR      r1,[r0,#8]
;;;210      
;;;211      /* Reset DMAy Streamx memory 0 address register */
;;;212      DMAy_Streamx->M0AR = 0;
000010  60c1              STR      r1,[r0,#0xc]
;;;213    
;;;214      /* Reset DMAy Streamx memory 1 address register */
;;;215      DMAy_Streamx->M1AR = 0;
000012  6101              STR      r1,[r0,#0x10]
;;;216    
;;;217      /* Reset DMAy Streamx FIFO control register */
;;;218      DMAy_Streamx->FCR = (uint32_t)0x00000021; 
000014  2121              MOVS     r1,#0x21
000016  6141              STR      r1,[r0,#0x14]
;;;219    
;;;220      /* Reset interrupt pending bits for the selected stream */
;;;221      if (DMAy_Streamx == DMA1_Stream0)
000018  49db              LDR      r1,|L1.904|
00001a  4288              CMP      r0,r1
00001c  d104              BNE      |L1.40|
;;;222      {
;;;223        /* Reset interrupt pending bits for DMA1 Stream0 */
;;;224        DMA1->LIFCR = DMA_Stream0_IT_MASK;
00001e  213d              MOVS     r1,#0x3d
000020  4ad9              LDR      r2,|L1.904|
000022  3a10              SUBS     r2,r2,#0x10
000024  6091              STR      r1,[r2,#8]
000026  e08c              B        |L1.322|
                  |L1.40|
;;;225      }
;;;226      else if (DMAy_Streamx == DMA1_Stream1)
000028  49d7              LDR      r1,|L1.904|
00002a  3118              ADDS     r1,r1,#0x18
00002c  4288              CMP      r0,r1
00002e  d105              BNE      |L1.60|
;;;227      {
;;;228        /* Reset interrupt pending bits for DMA1 Stream1 */
;;;229        DMA1->LIFCR = DMA_Stream1_IT_MASK;
000030  f44f6174          MOV      r1,#0xf40
000034  4ad4              LDR      r2,|L1.904|
000036  3a10              SUBS     r2,r2,#0x10
000038  6091              STR      r1,[r2,#8]
00003a  e082              B        |L1.322|
                  |L1.60|
;;;230      }
;;;231      else if (DMAy_Streamx == DMA1_Stream2)
00003c  49d2              LDR      r1,|L1.904|
00003e  3130              ADDS     r1,r1,#0x30
000040  4288              CMP      r0,r1
000042  d105              BNE      |L1.80|
;;;232      {
;;;233        /* Reset interrupt pending bits for DMA1 Stream2 */
;;;234        DMA1->LIFCR = DMA_Stream2_IT_MASK;
000044  f44f1174          MOV      r1,#0x3d0000
000048  4acf              LDR      r2,|L1.904|
00004a  3a10              SUBS     r2,r2,#0x10
00004c  6091              STR      r1,[r2,#8]
00004e  e078              B        |L1.322|
                  |L1.80|
;;;235      }
;;;236      else if (DMAy_Streamx == DMA1_Stream3)
000050  49cd              LDR      r1,|L1.904|
000052  3148              ADDS     r1,r1,#0x48
000054  4288              CMP      r0,r1
000056  d105              BNE      |L1.100|
;;;237      {
;;;238        /* Reset interrupt pending bits for DMA1 Stream3 */
;;;239        DMA1->LIFCR = DMA_Stream3_IT_MASK;
000058  f04f6174          MOV      r1,#0xf400000
00005c  4aca              LDR      r2,|L1.904|
00005e  3a10              SUBS     r2,r2,#0x10
000060  6091              STR      r1,[r2,#8]
000062  e06e              B        |L1.322|
                  |L1.100|
;;;240      }
;;;241      else if (DMAy_Streamx == DMA1_Stream4)
000064  49c8              LDR      r1,|L1.904|
000066  3160              ADDS     r1,r1,#0x60
000068  4288              CMP      r0,r1
00006a  d104              BNE      |L1.118|
;;;242      {
;;;243        /* Reset interrupt pending bits for DMA1 Stream4 */
;;;244        DMA1->HIFCR = DMA_Stream4_IT_MASK;
00006c  49c7              LDR      r1,|L1.908|
00006e  4ac6              LDR      r2,|L1.904|
000070  3a10              SUBS     r2,r2,#0x10
000072  60d1              STR      r1,[r2,#0xc]
000074  e065              B        |L1.322|
                  |L1.118|
;;;245      }
;;;246      else if (DMAy_Streamx == DMA1_Stream5)
000076  49c4              LDR      r1,|L1.904|
000078  3178              ADDS     r1,r1,#0x78
00007a  4288              CMP      r0,r1
00007c  d104              BNE      |L1.136|
;;;247      {
;;;248        /* Reset interrupt pending bits for DMA1 Stream5 */
;;;249        DMA1->HIFCR = DMA_Stream5_IT_MASK;
00007e  49c4              LDR      r1,|L1.912|
000080  4ac1              LDR      r2,|L1.904|
000082  3a10              SUBS     r2,r2,#0x10
000084  60d1              STR      r1,[r2,#0xc]
000086  e05c              B        |L1.322|
                  |L1.136|
;;;250      }
;;;251      else if (DMAy_Streamx == DMA1_Stream6)
000088  49bf              LDR      r1,|L1.904|
00008a  3190              ADDS     r1,r1,#0x90
00008c  4288              CMP      r0,r1
00008e  d104              BNE      |L1.154|
;;;252      {
;;;253        /* Reset interrupt pending bits for DMA1 Stream6 */
;;;254        DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
000090  49c0              LDR      r1,|L1.916|
000092  4abd              LDR      r2,|L1.904|
000094  3a10              SUBS     r2,r2,#0x10
000096  60d1              STR      r1,[r2,#0xc]
000098  e053              B        |L1.322|
                  |L1.154|
;;;255      }
;;;256      else if (DMAy_Streamx == DMA1_Stream7)
00009a  49bb              LDR      r1,|L1.904|
00009c  31a8              ADDS     r1,r1,#0xa8
00009e  4288              CMP      r0,r1
0000a0  d105              BNE      |L1.174|
;;;257      {
;;;258        /* Reset interrupt pending bits for DMA1 Stream7 */
;;;259        DMA1->HIFCR = DMA_Stream7_IT_MASK;
0000a2  f04f513d          MOV      r1,#0x2f400000
0000a6  4ab8              LDR      r2,|L1.904|
0000a8  3a10              SUBS     r2,r2,#0x10
0000aa  60d1              STR      r1,[r2,#0xc]
0000ac  e049              B        |L1.322|
                  |L1.174|
;;;260      }
;;;261      else if (DMAy_Streamx == DMA2_Stream0)
0000ae  49ba              LDR      r1,|L1.920|
0000b0  4288              CMP      r0,r1
0000b2  d104              BNE      |L1.190|
;;;262      {
;;;263        /* Reset interrupt pending bits for DMA2 Stream0 */
;;;264        DMA2->LIFCR = DMA_Stream0_IT_MASK;
0000b4  213d              MOVS     r1,#0x3d
0000b6  4ab8              LDR      r2,|L1.920|
0000b8  3a08              SUBS     r2,r2,#8
0000ba  6011              STR      r1,[r2,#0]
0000bc  e041              B        |L1.322|
                  |L1.190|
;;;265      }
;;;266      else if (DMAy_Streamx == DMA2_Stream1)
0000be  49b6              LDR      r1,|L1.920|
0000c0  3118              ADDS     r1,r1,#0x18
0000c2  4288              CMP      r0,r1
0000c4  d105              BNE      |L1.210|
;;;267      {
;;;268        /* Reset interrupt pending bits for DMA2 Stream1 */
;;;269        DMA2->LIFCR = DMA_Stream1_IT_MASK;
0000c6  f44f6174          MOV      r1,#0xf40
0000ca  4ab3              LDR      r2,|L1.920|
0000cc  3a08              SUBS     r2,r2,#8
0000ce  6011              STR      r1,[r2,#0]
0000d0  e037              B        |L1.322|
                  |L1.210|
;;;270      }
;;;271      else if (DMAy_Streamx == DMA2_Stream2)
0000d2  49b1              LDR      r1,|L1.920|
0000d4  3130              ADDS     r1,r1,#0x30
0000d6  4288              CMP      r0,r1
0000d8  d105              BNE      |L1.230|
;;;272      {
;;;273        /* Reset interrupt pending bits for DMA2 Stream2 */
;;;274        DMA2->LIFCR = DMA_Stream2_IT_MASK;
0000da  f44f1174          MOV      r1,#0x3d0000
0000de  4aae              LDR      r2,|L1.920|
0000e0  3a08              SUBS     r2,r2,#8
0000e2  6011              STR      r1,[r2,#0]
0000e4  e02d              B        |L1.322|
                  |L1.230|
;;;275      }
;;;276      else if (DMAy_Streamx == DMA2_Stream3)
0000e6  49ac              LDR      r1,|L1.920|
0000e8  3148              ADDS     r1,r1,#0x48
0000ea  4288              CMP      r0,r1
0000ec  d105              BNE      |L1.250|
;;;277      {
;;;278        /* Reset interrupt pending bits for DMA2 Stream3 */
;;;279        DMA2->LIFCR = DMA_Stream3_IT_MASK;
0000ee  f04f6174          MOV      r1,#0xf400000
0000f2  4aa9              LDR      r2,|L1.920|
0000f4  3a08              SUBS     r2,r2,#8
0000f6  6011              STR      r1,[r2,#0]
0000f8  e023              B        |L1.322|
                  |L1.250|
;;;280      }
;;;281      else if (DMAy_Streamx == DMA2_Stream4)
0000fa  49a7              LDR      r1,|L1.920|
0000fc  3160              ADDS     r1,r1,#0x60
0000fe  4288              CMP      r0,r1
000100  d104              BNE      |L1.268|
;;;282      {
;;;283        /* Reset interrupt pending bits for DMA2 Stream4 */
;;;284        DMA2->HIFCR = DMA_Stream4_IT_MASK;
000102  49a2              LDR      r1,|L1.908|
000104  4aa4              LDR      r2,|L1.920|
000106  1f12              SUBS     r2,r2,#4
000108  6011              STR      r1,[r2,#0]
00010a  e01a              B        |L1.322|
                  |L1.268|
;;;285      }
;;;286      else if (DMAy_Streamx == DMA2_Stream5)
00010c  49a2              LDR      r1,|L1.920|
00010e  3178              ADDS     r1,r1,#0x78
000110  4288              CMP      r0,r1
000112  d104              BNE      |L1.286|
;;;287      {
;;;288        /* Reset interrupt pending bits for DMA2 Stream5 */
;;;289        DMA2->HIFCR = DMA_Stream5_IT_MASK;
000114  499e              LDR      r1,|L1.912|
000116  4aa0              LDR      r2,|L1.920|
000118  1f12              SUBS     r2,r2,#4
00011a  6011              STR      r1,[r2,#0]
00011c  e011              B        |L1.322|
                  |L1.286|
;;;290      }
;;;291      else if (DMAy_Streamx == DMA2_Stream6)
00011e  499e              LDR      r1,|L1.920|
000120  3190              ADDS     r1,r1,#0x90
000122  4288              CMP      r0,r1
000124  d104              BNE      |L1.304|
;;;292      {
;;;293        /* Reset interrupt pending bits for DMA2 Stream6 */
;;;294        DMA2->HIFCR = DMA_Stream6_IT_MASK;
000126  499b              LDR      r1,|L1.916|
000128  4a9b              LDR      r2,|L1.920|
00012a  1f12              SUBS     r2,r2,#4
00012c  6011              STR      r1,[r2,#0]
00012e  e008              B        |L1.322|
                  |L1.304|
;;;295      }
;;;296      else 
;;;297      {
;;;298        if (DMAy_Streamx == DMA2_Stream7)
000130  4999              LDR      r1,|L1.920|
000132  31a8              ADDS     r1,r1,#0xa8
000134  4288              CMP      r0,r1
000136  d104              BNE      |L1.322|
;;;299        {
;;;300          /* Reset interrupt pending bits for DMA2 Stream7 */
;;;301          DMA2->HIFCR = DMA_Stream7_IT_MASK;
000138  f04f513d          MOV      r1,#0x2f400000
00013c  4a96              LDR      r2,|L1.920|
00013e  1f12              SUBS     r2,r2,#4
000140  6011              STR      r1,[r2,#0]
                  |L1.322|
;;;302        }
;;;303      }
;;;304    }
000142  4770              BX       lr
;;;305    
                          ENDP

                  DMA_Init PROC
;;;316      */
;;;317    void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
000144  b510              PUSH     {r4,lr}
;;;318    {
;;;319      uint32_t tmpreg = 0;
000146  2200              MOVS     r2,#0
;;;320    
;;;321      /* Check the parameters */
;;;322      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;323      assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
;;;324      assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
;;;325      assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
;;;326      assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
;;;327      assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
;;;328      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
;;;329      assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
;;;330      assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
;;;331      assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
;;;332      assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
;;;333      assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
;;;334      assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
;;;335      assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
;;;336    
;;;337      /*------------------------- DMAy Streamx CR Configuration ------------------*/
;;;338      /* Get the DMAy_Streamx CR value */
;;;339      tmpreg = DMAy_Streamx->CR;
000148  6802              LDR      r2,[r0,#0]
;;;340    
;;;341      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
;;;342      tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
00014a  4b94              LDR      r3,|L1.924|
00014c  401a              ANDS     r2,r2,r3
;;;343                             DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
;;;344                             DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
;;;345                             DMA_SxCR_DIR));
;;;346    
;;;347      /* Configure DMAy Streamx: */
;;;348      /* Set CHSEL bits according to DMA_CHSEL value */
;;;349      /* Set DIR bits according to DMA_DIR value */
;;;350      /* Set PINC bit according to DMA_PeripheralInc value */
;;;351      /* Set MINC bit according to DMA_MemoryInc value */
;;;352      /* Set PSIZE bits according to DMA_PeripheralDataSize value */
;;;353      /* Set MSIZE bits according to DMA_MemoryDataSize value */
;;;354      /* Set CIRC bit according to DMA_Mode value */
;;;355      /* Set PL bits according to DMA_Priority value */
;;;356      /* Set MBURST bits according to DMA_MemoryBurst value */
;;;357      /* Set PBURST bits according to DMA_PeripheralBurst value */
;;;358      tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
00014e  68cc              LDR      r4,[r1,#0xc]
000150  680b              LDR      r3,[r1,#0]
000152  4323              ORRS     r3,r3,r4
000154  694c              LDR      r4,[r1,#0x14]
000156  4323              ORRS     r3,r3,r4
000158  698c              LDR      r4,[r1,#0x18]
00015a  4323              ORRS     r3,r3,r4
00015c  69cc              LDR      r4,[r1,#0x1c]
00015e  4323              ORRS     r3,r3,r4
000160  6a0c              LDR      r4,[r1,#0x20]
000162  4323              ORRS     r3,r3,r4
000164  6a4c              LDR      r4,[r1,#0x24]
000166  4323              ORRS     r3,r3,r4
000168  6a8c              LDR      r4,[r1,#0x28]
00016a  4323              ORRS     r3,r3,r4
00016c  6b4c              LDR      r4,[r1,#0x34]
00016e  4323              ORRS     r3,r3,r4
000170  6b8c              LDR      r4,[r1,#0x38]
000172  4323              ORRS     r3,r3,r4
000174  431a              ORRS     r2,r2,r3
;;;359                DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
;;;360                DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
;;;361                DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
;;;362                DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
;;;363    
;;;364      /* Write to DMAy Streamx CR register */
;;;365      DMAy_Streamx->CR = tmpreg;
000176  6002              STR      r2,[r0,#0]
;;;366    
;;;367      /*------------------------- DMAy Streamx FCR Configuration -----------------*/
;;;368      /* Get the DMAy_Streamx FCR value */
;;;369      tmpreg = DMAy_Streamx->FCR;
000178  6942              LDR      r2,[r0,#0x14]
;;;370    
;;;371      /* Clear DMDIS and FTH bits */
;;;372      tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
00017a  f0220207          BIC      r2,r2,#7
;;;373    
;;;374      /* Configure DMAy Streamx FIFO: 
;;;375        Set DMDIS bits according to DMA_FIFOMode value 
;;;376        Set FTH bits according to DMA_FIFOThreshold value */
;;;377      tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
00017e  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
000182  4323              ORRS     r3,r3,r4
000184  431a              ORRS     r2,r2,r3
;;;378    
;;;379      /* Write to DMAy Streamx CR */
;;;380      DMAy_Streamx->FCR = tmpreg;
000186  6142              STR      r2,[r0,#0x14]
;;;381    
;;;382      /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
;;;383      /* Write to DMAy Streamx NDTR register */
;;;384      DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
000188  690b              LDR      r3,[r1,#0x10]
00018a  6043              STR      r3,[r0,#4]
;;;385    
;;;386      /*------------------------- DMAy Streamx PAR Configuration -----------------*/
;;;387      /* Write to DMAy Streamx PAR */
;;;388      DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
00018c  684b              LDR      r3,[r1,#4]
00018e  6083              STR      r3,[r0,#8]
;;;389    
;;;390      /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
;;;391      /* Write to DMAy Streamx M0AR */
;;;392      DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
000190  688b              LDR      r3,[r1,#8]
000192  60c3              STR      r3,[r0,#0xc]
;;;393    }
000194  bd10              POP      {r4,pc}
;;;394    
                          ENDP

                  DMA_StructInit PROC
;;;400      */
;;;401    void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
000196  2100              MOVS     r1,#0
;;;402    {
;;;403      /*-------------- Reset DMA init structure parameters values ----------------*/
;;;404      /* Initialize the DMA_Channel member */
;;;405      DMA_InitStruct->DMA_Channel = 0;
000198  6001              STR      r1,[r0,#0]
;;;406    
;;;407      /* Initialize the DMA_PeripheralBaseAddr member */
;;;408      DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
00019a  6041              STR      r1,[r0,#4]
;;;409    
;;;410      /* Initialize the DMA_Memory0BaseAddr member */
;;;411      DMA_InitStruct->DMA_Memory0BaseAddr = 0;
00019c  6081              STR      r1,[r0,#8]
;;;412    
;;;413      /* Initialize the DMA_DIR member */
;;;414      DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
00019e  60c1              STR      r1,[r0,#0xc]
;;;415    
;;;416      /* Initialize the DMA_BufferSize member */
;;;417      DMA_InitStruct->DMA_BufferSize = 0;
0001a0  6101              STR      r1,[r0,#0x10]
;;;418    
;;;419      /* Initialize the DMA_PeripheralInc member */
;;;420      DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
0001a2  6141              STR      r1,[r0,#0x14]
;;;421    
;;;422      /* Initialize the DMA_MemoryInc member */
;;;423      DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
0001a4  6181              STR      r1,[r0,#0x18]
;;;424    
;;;425      /* Initialize the DMA_PeripheralDataSize member */
;;;426      DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
0001a6  61c1              STR      r1,[r0,#0x1c]
;;;427    
;;;428      /* Initialize the DMA_MemoryDataSize member */
;;;429      DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
0001a8  6201              STR      r1,[r0,#0x20]
;;;430    
;;;431      /* Initialize the DMA_Mode member */
;;;432      DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
0001aa  6241              STR      r1,[r0,#0x24]
;;;433    
;;;434      /* Initialize the DMA_Priority member */
;;;435      DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
0001ac  6281              STR      r1,[r0,#0x28]
;;;436    
;;;437      /* Initialize the DMA_FIFOMode member */
;;;438      DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
0001ae  62c1              STR      r1,[r0,#0x2c]
;;;439    
;;;440      /* Initialize the DMA_FIFOThreshold member */
;;;441      DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
0001b0  6301              STR      r1,[r0,#0x30]
;;;442    
;;;443      /* Initialize the DMA_MemoryBurst member */
;;;444      DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
0001b2  6341              STR      r1,[r0,#0x34]
;;;445    
;;;446      /* Initialize the DMA_PeripheralBurst member */
;;;447      DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
0001b4  6381              STR      r1,[r0,#0x38]
;;;448    }
0001b6  4770              BX       lr
;;;449    
                          ENDP

                  DMA_Cmd PROC
;;;475      */
;;;476    void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
0001b8  b121              CBZ      r1,|L1.452|
;;;477    {
;;;478      /* Check the parameters */
;;;479      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;480      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;481    
;;;482      if (NewState != DISABLE)
;;;483      {
;;;484        /* Enable the selected DMAy Streamx by setting EN bit */
;;;485        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
0001ba  6802              LDR      r2,[r0,#0]
0001bc  f0420201          ORR      r2,r2,#1
0001c0  6002              STR      r2,[r0,#0]
0001c2  e003              B        |L1.460|
                  |L1.452|
;;;486      }
;;;487      else
;;;488      {
;;;489        /* Disable the selected DMAy Streamx by clearing EN bit */
;;;490        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
0001c4  6802              LDR      r2,[r0,#0]
0001c6  f0220201          BIC      r2,r2,#1
0001ca  6002              STR      r2,[r0,#0]
                  |L1.460|
;;;491      }
;;;492    }
0001cc  4770              BX       lr
;;;493    
                          ENDP

                  DMA_PeriphIncOffsetSizeConfig PROC
;;;511      */
;;;512    void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
0001ce  b121              CBZ      r1,|L1.474|
;;;513    {
;;;514      /* Check the parameters */
;;;515      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;516      assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
;;;517    
;;;518      /* Check the needed Peripheral increment offset */
;;;519      if(DMA_Pincos != DMA_PINCOS_Psize)
;;;520      {
;;;521        /* Configure DMA_SxCR_PINCOS bit with the input parameter */
;;;522        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
0001d0  6802              LDR      r2,[r0,#0]
0001d2  f4424200          ORR      r2,r2,#0x8000
0001d6  6002              STR      r2,[r0,#0]
0001d8  e003              B        |L1.482|
                  |L1.474|
;;;523      }
;;;524      else
;;;525      {
;;;526        /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
;;;527        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
0001da  6802              LDR      r2,[r0,#0]
0001dc  f4224200          BIC      r2,r2,#0x8000
0001e0  6002              STR      r2,[r0,#0]
                  |L1.482|
;;;528      }
;;;529    }
0001e2  4770              BX       lr
;;;530    
                          ENDP

                  DMA_FlowControllerConfig PROC
;;;547      */
;;;548    void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
0001e4  b121              CBZ      r1,|L1.496|
;;;549    {
;;;550      /* Check the parameters */
;;;551      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;552      assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
;;;553    
;;;554      /* Check the needed flow controller  */
;;;555      if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
;;;556      {
;;;557        /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
;;;558        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
0001e6  6802              LDR      r2,[r0,#0]
0001e8  f0420220          ORR      r2,r2,#0x20
0001ec  6002              STR      r2,[r0,#0]
0001ee  e003              B        |L1.504|
                  |L1.496|
;;;559      }
;;;560      else
;;;561      {
;;;562        /* Clear the PFCTRL bit: Memory is the flow controller */
;;;563        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
0001f0  6802              LDR      r2,[r0,#0]
0001f2  f0220220          BIC      r2,r2,#0x20
0001f6  6002              STR      r2,[r0,#0]
                  |L1.504|
;;;564      }
;;;565    }
0001f8  4770              BX       lr
;;;566    /**
                          ENDP

                  DMA_SetCurrDataCounter PROC
;;;631      */
;;;632    void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
0001fa  6041              STR      r1,[r0,#4]
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;636    
;;;637      /* Write the number of data units to be transferred */
;;;638      DMAy_Streamx->NDTR = (uint16_t)Counter;
;;;639    }
0001fc  4770              BX       lr
;;;640    
                          ENDP

                  DMA_GetCurrDataCounter PROC
;;;646      */
;;;647    uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
0001fe  4601              MOV      r1,r0
;;;648    {
;;;649      /* Check the parameters */
;;;650      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;651    
;;;652      /* Return the number of remaining data units for DMAy Streamx */
;;;653      return ((uint16_t)(DMAy_Streamx->NDTR));
000200  6848              LDR      r0,[r1,#4]
000202  b280              UXTH     r0,r0
;;;654    }
000204  4770              BX       lr
;;;655    /**
                          ENDP

                  DMA_DoubleBufferModeConfig PROC
;;;723      */
;;;724    void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
000206  b122              CBZ      r2,|L1.530|
;;;725                                    uint32_t DMA_CurrentMemory)
;;;726    {  
;;;727      /* Check the parameters */
;;;728      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;729      assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
;;;730    
;;;731      if (DMA_CurrentMemory != DMA_Memory_0)
;;;732      {
;;;733        /* Set Memory 1 as current memory address */
;;;734        DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
000208  6803              LDR      r3,[r0,#0]
00020a  f4432300          ORR      r3,r3,#0x80000
00020e  6003              STR      r3,[r0,#0]
000210  e003              B        |L1.538|
                  |L1.530|
;;;735      }
;;;736      else
;;;737      {
;;;738        /* Set Memory 0 as current memory address */
;;;739        DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
000212  6803              LDR      r3,[r0,#0]
000214  f4232300          BIC      r3,r3,#0x80000
000218  6003              STR      r3,[r0,#0]
                  |L1.538|
;;;740      }
;;;741    
;;;742      /* Write to DMAy Streamx M1AR */
;;;743      DMAy_Streamx->M1AR = Memory1BaseAddr;
00021a  6101              STR      r1,[r0,#0x10]
;;;744    }
00021c  4770              BX       lr
;;;745    
                          ENDP

                  DMA_DoubleBufferModeCmd PROC
;;;754      */
;;;755    void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
00021e  b121              CBZ      r1,|L1.554|
;;;756    {  
;;;757      /* Check the parameters */
;;;758      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;759      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;760    
;;;761      /* Configure the Double Buffer mode */
;;;762      if (NewState != DISABLE)
;;;763      {
;;;764        /* Enable the Double buffer mode */
;;;765        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
000220  6802              LDR      r2,[r0,#0]
000222  f4422280          ORR      r2,r2,#0x40000
000226  6002              STR      r2,[r0,#0]
000228  e003              B        |L1.562|
                  |L1.554|
;;;766      }
;;;767      else
;;;768      {
;;;769        /* Disable the Double buffer mode */
;;;770        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
00022a  6802              LDR      r2,[r0,#0]
00022c  f4222280          BIC      r2,r2,#0x40000
000230  6002              STR      r2,[r0,#0]
                  |L1.562|
;;;771      }
;;;772    }
000232  4770              BX       lr
;;;773    
                          ENDP

                  DMA_MemoryTargetConfig PROC
;;;795      */
;;;796    void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
000234  b10a              CBZ      r2,|L1.570|
;;;797                               uint32_t DMA_MemoryTarget)
;;;798    {
;;;799      /* Check the parameters */
;;;800      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;801      assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
;;;802        
;;;803      /* Check the Memory target to be configured */
;;;804      if (DMA_MemoryTarget != DMA_Memory_0)
;;;805      {
;;;806        /* Write to DMAy Streamx M1AR */
;;;807        DMAy_Streamx->M1AR = MemoryBaseAddr;    
000236  6101              STR      r1,[r0,#0x10]
000238  e000              B        |L1.572|
                  |L1.570|
;;;808      }  
;;;809      else
;;;810      {
;;;811        /* Write to DMAy Streamx M0AR */
;;;812        DMAy_Streamx->M0AR = MemoryBaseAddr;  
00023a  60c1              STR      r1,[r0,#0xc]
                  |L1.572|
;;;813      }
;;;814    }
00023c  4770              BX       lr
;;;815    
                          ENDP

                  DMA_GetCurrentMemoryTarget PROC
;;;821      */
;;;822    uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
00023e  4601              MOV      r1,r0
;;;823    {
;;;824      uint32_t tmp = 0;
000240  2000              MOVS     r0,#0
;;;825      
;;;826      /* Check the parameters */
;;;827      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;828    
;;;829      /* Get the current memory target */
;;;830      if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
000242  680a              LDR      r2,[r1,#0]
000244  f4022200          AND      r2,r2,#0x80000
000248  b10a              CBZ      r2,|L1.590|
;;;831      {
;;;832        /* Current memory buffer used is Memory 1 */
;;;833        tmp = 1;
00024a  2001              MOVS     r0,#1
00024c  e000              B        |L1.592|
                  |L1.590|
;;;834      }  
;;;835      else
;;;836      {
;;;837        /* Current memory buffer used is Memory 0 */
;;;838        tmp = 0;    
00024e  2000              MOVS     r0,#0
                  |L1.592|
;;;839      }
;;;840      return tmp;
;;;841    }
000250  4770              BX       lr
;;;842    /**
                          ENDP

                  DMA_GetCmdStatus PROC
;;;930      */
;;;931    FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
000252  4601              MOV      r1,r0
;;;932    {
;;;933      FunctionalState state = DISABLE;
000254  2000              MOVS     r0,#0
;;;934    
;;;935      /* Check the parameters */
;;;936      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;937    
;;;938      if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
000256  680a              LDR      r2,[r1,#0]
000258  f0020201          AND      r2,r2,#1
00025c  b10a              CBZ      r2,|L1.610|
;;;939      {
;;;940        /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
;;;941        state = ENABLE;
00025e  2001              MOVS     r0,#1
000260  e000              B        |L1.612|
                  |L1.610|
;;;942      }
;;;943      else
;;;944      {
;;;945        /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
;;;946            all transfers are complete) */
;;;947        state = DISABLE;
000262  2000              MOVS     r0,#0
                  |L1.612|
;;;948      }
;;;949      return state;
;;;950    }
000264  4770              BX       lr
;;;951    
                          ENDP

                  DMA_GetFIFOStatus PROC
;;;964      */
;;;965    uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
000266  4601              MOV      r1,r0
;;;966    {
;;;967      uint32_t tmpreg = 0;
000268  2000              MOVS     r0,#0
;;;968     
;;;969      /* Check the parameters */
;;;970      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;971      
;;;972      /* Get the FIFO level bits */
;;;973      tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
00026a  694a              LDR      r2,[r1,#0x14]
00026c  f0020038          AND      r0,r2,#0x38
;;;974      
;;;975      return tmpreg;
;;;976    }
000270  4770              BX       lr
;;;977    
                          ENDP

                  DMA_GetFlagStatus PROC
;;;991      */
;;;992    FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
000272  b530              PUSH     {r4,r5,lr}
;;;993    {
000274  4603              MOV      r3,r0
000276  460a              MOV      r2,r1
;;;994      FlagStatus bitstatus = RESET;
000278  2000              MOVS     r0,#0
;;;995      DMA_TypeDef* DMAy;
;;;996      uint32_t tmpreg = 0;
00027a  2400              MOVS     r4,#0
;;;997    
;;;998      /* Check the parameters */
;;;999      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1000     assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
;;;1001   
;;;1002     /* Determine the DMA to which belongs the stream */
;;;1003     if (DMAy_Streamx < DMA2_Stream0)
00027c  4d46              LDR      r5,|L1.920|
00027e  42ab              CMP      r3,r5
000280  d202              BCS      |L1.648|
;;;1004     {
;;;1005       /* DMAy_Streamx belongs to DMA1 */
;;;1006       DMAy = DMA1; 
000282  4941              LDR      r1,|L1.904|
000284  3910              SUBS     r1,r1,#0x10
000286  e001              B        |L1.652|
                  |L1.648|
;;;1007     } 
;;;1008     else 
;;;1009     {
;;;1010       /* DMAy_Streamx belongs to DMA2 */
;;;1011       DMAy = DMA2; 
000288  4943              LDR      r1,|L1.920|
00028a  3910              SUBS     r1,r1,#0x10
                  |L1.652|
;;;1012     }
;;;1013   
;;;1014     /* Check if the flag is in HISR or LISR */
;;;1015     if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
00028c  f0025500          AND      r5,r2,#0x20000000
000290  b10d              CBZ      r5,|L1.662|
;;;1016     {
;;;1017       /* Get DMAy HISR register value */
;;;1018       tmpreg = DMAy->HISR;
000292  684c              LDR      r4,[r1,#4]
000294  e000              B        |L1.664|
                  |L1.662|
;;;1019     }
;;;1020     else
;;;1021     {
;;;1022       /* Get DMAy LISR register value */
;;;1023       tmpreg = DMAy->LISR;
000296  680c              LDR      r4,[r1,#0]
                  |L1.664|
;;;1024     }   
;;;1025    
;;;1026     /* Mask the reserved bits */
;;;1027     tmpreg &= (uint32_t)RESERVED_MASK;
000298  4d41              LDR      r5,|L1.928|
00029a  402c              ANDS     r4,r4,r5
;;;1028   
;;;1029     /* Check the status of the specified DMA flag */
;;;1030     if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
00029c  ea040502          AND      r5,r4,r2
0002a0  b10d              CBZ      r5,|L1.678|
;;;1031     {
;;;1032       /* DMA_FLAG is set */
;;;1033       bitstatus = SET;
0002a2  2001              MOVS     r0,#1
0002a4  e000              B        |L1.680|
                  |L1.678|
;;;1034     }
;;;1035     else
;;;1036     {
;;;1037       /* DMA_FLAG is reset */
;;;1038       bitstatus = RESET;
0002a6  2000              MOVS     r0,#0
                  |L1.680|
;;;1039     }
;;;1040   
;;;1041     /* Return the DMA_FLAG status */
;;;1042     return  bitstatus;
;;;1043   }
0002a8  bd30              POP      {r4,r5,pc}
;;;1044   
                          ENDP

                  DMA_ClearFlag PROC
;;;1058     */
;;;1059   void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
0002aa  4602              MOV      r2,r0
;;;1060   {
;;;1061     DMA_TypeDef* DMAy;
;;;1062   
;;;1063     /* Check the parameters */
;;;1064     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1065     assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
;;;1066   
;;;1067     /* Determine the DMA to which belongs the stream */
;;;1068     if (DMAy_Streamx < DMA2_Stream0)
0002ac  4b3a              LDR      r3,|L1.920|
0002ae  429a              CMP      r2,r3
0002b0  d202              BCS      |L1.696|
;;;1069     {
;;;1070       /* DMAy_Streamx belongs to DMA1 */
;;;1071       DMAy = DMA1; 
0002b2  4835              LDR      r0,|L1.904|
0002b4  3810              SUBS     r0,r0,#0x10
0002b6  e001              B        |L1.700|
                  |L1.696|
;;;1072     } 
;;;1073     else 
;;;1074     {
;;;1075       /* DMAy_Streamx belongs to DMA2 */
;;;1076       DMAy = DMA2; 
0002b8  4837              LDR      r0,|L1.920|
0002ba  3810              SUBS     r0,r0,#0x10
                  |L1.700|
;;;1077     }
;;;1078   
;;;1079     /* Check if LIFCR or HIFCR register is targeted */
;;;1080     if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
0002bc  f0015300          AND      r3,r1,#0x20000000
0002c0  b11b              CBZ      r3,|L1.714|
;;;1081     {
;;;1082       /* Set DMAy HIFCR register clear flag bits */
;;;1083       DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
0002c2  4b37              LDR      r3,|L1.928|
0002c4  400b              ANDS     r3,r3,r1
0002c6  60c3              STR      r3,[r0,#0xc]
0002c8  e002              B        |L1.720|
                  |L1.714|
;;;1084     }
;;;1085     else 
;;;1086     {
;;;1087       /* Set DMAy LIFCR register clear flag bits */
;;;1088       DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
0002ca  4b35              LDR      r3,|L1.928|
0002cc  400b              ANDS     r3,r3,r1
0002ce  6083              STR      r3,[r0,#8]
                  |L1.720|
;;;1089     }    
;;;1090   }
0002d0  4770              BX       lr
;;;1091   
                          ENDP

                  DMA_ITConfig PROC
;;;1105     */
;;;1106   void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
0002d2  b510              PUSH     {r4,lr}
;;;1107   {
;;;1108     /* Check the parameters */
;;;1109     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1110     assert_param(IS_DMA_CONFIG_IT(DMA_IT));
;;;1111     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1112   
;;;1113     /* Check if the DMA_IT parameter contains a FIFO interrupt */
;;;1114     if ((DMA_IT & DMA_IT_FE) != 0)
0002d4  f0010380          AND      r3,r1,#0x80
0002d8  b14b              CBZ      r3,|L1.750|
;;;1115     {
;;;1116       if (NewState != DISABLE)
0002da  b122              CBZ      r2,|L1.742|
;;;1117       {
;;;1118         /* Enable the selected DMA FIFO interrupts */
;;;1119         DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
0002dc  6943              LDR      r3,[r0,#0x14]
0002de  f0430380          ORR      r3,r3,#0x80
0002e2  6143              STR      r3,[r0,#0x14]
0002e4  e003              B        |L1.750|
                  |L1.742|
;;;1120       }    
;;;1121       else 
;;;1122       {
;;;1123         /* Disable the selected DMA FIFO interrupts */
;;;1124         DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
0002e6  6943              LDR      r3,[r0,#0x14]
0002e8  f0230380          BIC      r3,r3,#0x80
0002ec  6143              STR      r3,[r0,#0x14]
                  |L1.750|
;;;1125       }
;;;1126     }
;;;1127   
;;;1128     /* Check if the DMA_IT parameter contains a Transfer interrupt */
;;;1129     if (DMA_IT != DMA_IT_FE)
0002ee  2980              CMP      r1,#0x80
0002f0  d00b              BEQ      |L1.778|
;;;1130     {
;;;1131       if (NewState != DISABLE)
0002f2  b12a              CBZ      r2,|L1.768|
;;;1132       {
;;;1133         /* Enable the selected DMA transfer interrupts */
;;;1134         DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
0002f4  6803              LDR      r3,[r0,#0]
0002f6  f001041e          AND      r4,r1,#0x1e
0002fa  4323              ORRS     r3,r3,r4
0002fc  6003              STR      r3,[r0,#0]
0002fe  e004              B        |L1.778|
                  |L1.768|
;;;1135       }
;;;1136       else
;;;1137       {
;;;1138         /* Disable the selected DMA transfer interrupts */
;;;1139         DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
000300  6803              LDR      r3,[r0,#0]
000302  f001041e          AND      r4,r1,#0x1e
000306  43a3              BICS     r3,r3,r4
000308  6003              STR      r3,[r0,#0]
                  |L1.778|
;;;1140       }    
;;;1141     }
;;;1142   }
00030a  bd10              POP      {r4,pc}
;;;1143   
                          ENDP

                  DMA_GetITStatus PROC
;;;1157     */
;;;1158   ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
00030c  b570              PUSH     {r4-r6,lr}
;;;1159   {
00030e  4602              MOV      r2,r0
;;;1160     ITStatus bitstatus = RESET;
000310  2000              MOVS     r0,#0
;;;1161     DMA_TypeDef* DMAy;
;;;1162     uint32_t tmpreg = 0, enablestatus = 0;
000312  2400              MOVS     r4,#0
000314  2500              MOVS     r5,#0
;;;1163   
;;;1164     /* Check the parameters */
;;;1165     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1166     assert_param(IS_DMA_GET_IT(DMA_IT));
;;;1167    
;;;1168     /* Determine the DMA to which belongs the stream */
;;;1169     if (DMAy_Streamx < DMA2_Stream0)
000316  4e20              LDR      r6,|L1.920|
000318  42b2              CMP      r2,r6
00031a  d202              BCS      |L1.802|
;;;1170     {
;;;1171       /* DMAy_Streamx belongs to DMA1 */
;;;1172       DMAy = DMA1; 
00031c  4b1a              LDR      r3,|L1.904|
00031e  3b10              SUBS     r3,r3,#0x10
000320  e001              B        |L1.806|
                  |L1.802|
;;;1173     } 
;;;1174     else 
;;;1175     {
;;;1176       /* DMAy_Streamx belongs to DMA2 */
;;;1177       DMAy = DMA2; 
000322  4b1d              LDR      r3,|L1.920|
000324  3b10              SUBS     r3,r3,#0x10
                  |L1.806|
;;;1178     }
;;;1179   
;;;1180     /* Check if the interrupt enable bit is in the CR or FCR register */
;;;1181     if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
000326  4e1f              LDR      r6,|L1.932|
000328  400e              ANDS     r6,r6,r1
00032a  b136              CBZ      r6,|L1.826|
;;;1182     {
;;;1183       /* Get the interrupt enable position mask in CR register */
;;;1184       tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
00032c  261e              MOVS     r6,#0x1e
00032e  ea0624d1          AND      r4,r6,r1,LSR #11
;;;1185       
;;;1186       /* Check the enable bit in CR register */
;;;1187       enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
000332  6816              LDR      r6,[r2,#0]
000334  ea060504          AND      r5,r6,r4
000338  e002              B        |L1.832|
                  |L1.826|
;;;1188     }
;;;1189     else 
;;;1190     {
;;;1191       /* Check the enable bit in FCR register */
;;;1192       enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
00033a  6956              LDR      r6,[r2,#0x14]
00033c  f0060580          AND      r5,r6,#0x80
                  |L1.832|
;;;1193     }
;;;1194    
;;;1195     /* Check if the interrupt pending flag is in LISR or HISR */
;;;1196     if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
000340  f0015600          AND      r6,r1,#0x20000000
000344  b10e              CBZ      r6,|L1.842|
;;;1197     {
;;;1198       /* Get DMAy HISR register value */
;;;1199       tmpreg = DMAy->HISR ;
000346  685c              LDR      r4,[r3,#4]
000348  e000              B        |L1.844|
                  |L1.842|
;;;1200     }
;;;1201     else
;;;1202     {
;;;1203       /* Get DMAy LISR register value */
;;;1204       tmpreg = DMAy->LISR ;
00034a  681c              LDR      r4,[r3,#0]
                  |L1.844|
;;;1205     } 
;;;1206   
;;;1207     /* mask all reserved bits */
;;;1208     tmpreg &= (uint32_t)RESERVED_MASK;
00034c  4e14              LDR      r6,|L1.928|
00034e  4034              ANDS     r4,r4,r6
;;;1209   
;;;1210     /* Check the status of the specified DMA interrupt */
;;;1211     if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
000350  ea040601          AND      r6,r4,r1
000354  b116              CBZ      r6,|L1.860|
000356  b10d              CBZ      r5,|L1.860|
;;;1212     {
;;;1213       /* DMA_IT is set */
;;;1214       bitstatus = SET;
000358  2001              MOVS     r0,#1
00035a  e000              B        |L1.862|
                  |L1.860|
;;;1215     }
;;;1216     else
;;;1217     {
;;;1218       /* DMA_IT is reset */
;;;1219       bitstatus = RESET;
00035c  2000              MOVS     r0,#0
                  |L1.862|
;;;1220     }
;;;1221   
;;;1222     /* Return the DMA_IT status */
;;;1223     return  bitstatus;
;;;1224   }
00035e  bd70              POP      {r4-r6,pc}
;;;1225   
                          ENDP

                  DMA_ClearITPendingBit PROC
;;;1239     */
;;;1240   void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
000360  4602              MOV      r2,r0
;;;1241   {
;;;1242     DMA_TypeDef* DMAy;
;;;1243   
;;;1244     /* Check the parameters */
;;;1245     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1246     assert_param(IS_DMA_CLEAR_IT(DMA_IT));
;;;1247   
;;;1248     /* Determine the DMA to which belongs the stream */
;;;1249     if (DMAy_Streamx < DMA2_Stream0)
000362  4b0d              LDR      r3,|L1.920|
000364  429a              CMP      r2,r3
000366  d202              BCS      |L1.878|
;;;1250     {
;;;1251       /* DMAy_Streamx belongs to DMA1 */
;;;1252       DMAy = DMA1; 
000368  4807              LDR      r0,|L1.904|
00036a  3810              SUBS     r0,r0,#0x10
00036c  e001              B        |L1.882|
                  |L1.878|
;;;1253     } 
;;;1254     else 
;;;1255     {
;;;1256       /* DMAy_Streamx belongs to DMA2 */
;;;1257       DMAy = DMA2; 
00036e  480a              LDR      r0,|L1.920|
000370  3810              SUBS     r0,r0,#0x10
                  |L1.882|
;;;1258     }
;;;1259   
;;;1260     /* Check if LIFCR or HIFCR register is targeted */
;;;1261     if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
000372  f0015300          AND      r3,r1,#0x20000000
000376  b11b              CBZ      r3,|L1.896|
;;;1262     {
;;;1263       /* Set DMAy HIFCR register clear interrupt bits */
;;;1264       DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
000378  4b09              LDR      r3,|L1.928|
00037a  400b              ANDS     r3,r3,r1
00037c  60c3              STR      r3,[r0,#0xc]
00037e  e002              B        |L1.902|
                  |L1.896|
;;;1265     }
;;;1266     else 
;;;1267     {
;;;1268       /* Set DMAy LIFCR register clear interrupt bits */
;;;1269       DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
000380  4b07              LDR      r3,|L1.928|
000382  400b              ANDS     r3,r3,r1
000384  6083              STR      r3,[r0,#8]
                  |L1.902|
;;;1270     }   
;;;1271   }
000386  4770              BX       lr
;;;1272   
                          ENDP

                  |L1.904|
                          DCD      0x40026010
                  |L1.908|
                          DCD      0x2000003d
                  |L1.912|
                          DCD      0x20000f40
                  |L1.916|
                          DCD      0x203d0000
                  |L1.920|
                          DCD      0x40026410
                  |L1.924|
                          DCD      0xf01c803f
                  |L1.928|
                          DCD      0x0f7d0f7d
                  |L1.932|
                          DCD      0x0f3c0f3c

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_dma.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dma_c_e9b554c0____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_dma_c_e9b554c0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dma_c_e9b554c0____REVSH|
#line 128
|__asm___15_stm32f4xx_dma_c_e9b554c0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
