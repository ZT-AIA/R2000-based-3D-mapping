; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\tcp_out.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\tcp_out.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\tcp_out.crf ..\..\libraries\lwip-1.4.1\src\core\tcp_out.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
00000c  f1060014          ADD      r0,r6,#0x14
000010  4440              ADD      r0,r0,r8
000012  b281              UXTH     r1,r0
000014  2200              MOVS     r2,#0
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       pbuf_alloc
00001c  4607              MOV      r7,r0
;;;99       if (p != NULL) {
00001e  b347              CBZ      r7,|L1.114|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000020  bf00              NOP      
000022  bf00              NOP      
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
000024  687c              LDR      r4,[r7,#4]
;;;103        tcphdr->src = htons(pcb->local_port);
000026  8b68              LDRH     r0,[r5,#0x1a]
000028  f7fffffe          BL       lwip_htons
00002c  8020              STRH     r0,[r4,#0]
;;;104        tcphdr->dest = htons(pcb->remote_port);
00002e  8ba8              LDRH     r0,[r5,#0x1c]
000030  f7fffffe          BL       lwip_htons
000034  8060              STRH     r0,[r4,#2]
;;;105        tcphdr->seqno = seqno_be;
000036  f8c49004          STR      r9,[r4,#4]
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
00003a  6aa8              LDR      r0,[r5,#0x28]
00003c  f7fffffe          BL       lwip_htonl
000040  60a0              STR      r0,[r4,#8]
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
000042  46b2              MOV      r10,r6
000044  17f1              ASRS     r1,r6,#31
000046  eb067191          ADD      r1,r6,r1,LSR #30
00004a  1089              ASRS     r1,r1,#2
00004c  1d49              ADDS     r1,r1,#5
00004e  2210              MOVS     r2,#0x10
000050  ea423101          ORR      r1,r2,r1,LSL #12
000054  b288              UXTH     r0,r1
000056  f7fffffe          BL       lwip_htons
00005a  81a0              STRH     r0,[r4,#0xc]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
00005c  8de8              LDRH     r0,[r5,#0x2e]
00005e  f7fffffe          BL       lwip_htons
000062  81e0              STRH     r0,[r4,#0xe]
;;;109        tcphdr->chksum = 0;
000064  2000              MOVS     r0,#0
000066  8220              STRH     r0,[r4,#0x10]
;;;110        tcphdr->urgp = 0;
000068  8260              STRH     r0,[r4,#0x12]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00006a  8de9              LDRH     r1,[r5,#0x2e]
00006c  6aa8              LDR      r0,[r5,#0x28]
00006e  4408              ADD      r0,r0,r1
000070  6328              STR      r0,[r5,#0x30]
                  |L1.114|
;;;114      }
;;;115      return p;
000072  4638              MOV      r0,r7
;;;116    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;117    
                          ENDP

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000078  e92d5ff0          PUSH     {r4-r12,lr}
;;;160    {
00007c  4607              MOV      r7,r0
00007e  460e              MOV      r6,r1
000080  4691              MOV      r9,r2
000082  469a              MOV      r10,r3
000084  f8dd8028          LDR      r8,[sp,#0x28]
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000088  f0080001          AND      r0,r8,#1
00008c  b108              CBZ      r0,|L1.146|
00008e  2004              MOVS     r0,#4
000090  e000              B        |L1.148|
                  |L1.146|
000092  2000              MOVS     r0,#0
                  |L1.148|
000094  f0080102          AND      r1,r8,#2
000098  b109              CBZ      r1,|L1.158|
00009a  210c              MOVS     r1,#0xc
00009c  e000              B        |L1.160|
                  |L1.158|
00009e  2100              MOVS     r1,#0
                  |L1.160|
0000a0  1845              ADDS     r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
0000a2  2004              MOVS     r0,#4
0000a4  f7fffffe          BL       memp_malloc
0000a8  1e04              SUBS     r4,r0,#0
0000aa  d107              BNE      |L1.188|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
0000ac  bf00              NOP      
0000ae  bf00              NOP      
;;;166        pbuf_free(p);
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       pbuf_free
;;;167        return NULL;
0000b6  2000              MOVS     r0,#0
                  |L1.184|
;;;168      }
;;;169      seg->flags = optflags;
;;;170      seg->next = NULL;
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
;;;189        return NULL;
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
0000b8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.188|
0000bc  f884800c          STRB     r8,[r4,#0xc]          ;169
0000c0  2000              MOVS     r0,#0                 ;170
0000c2  6020              STR      r0,[r4,#0]            ;170
0000c4  6066              STR      r6,[r4,#4]            ;171
0000c6  8930              LDRH     r0,[r6,#8]            ;172
0000c8  1b40              SUBS     r0,r0,r5              ;172
0000ca  8120              STRH     r0,[r4,#8]            ;172
0000cc  2000              MOVS     r0,#0                 ;174
0000ce  8160              STRH     r0,[r4,#0xa]          ;174
0000d0  2114              MOVS     r1,#0x14              ;185
0000d2  4630              MOV      r0,r6                 ;185
0000d4  f7fffffe          BL       pbuf_header
0000d8  b130              CBZ      r0,|L1.232|
0000da  bf00              NOP                            ;186
0000dc  bf00              NOP                            ;186
0000de  4620              MOV      r0,r4                 ;188
0000e0  f7fffffe          BL       tcp_seg_free
0000e4  2000              MOVS     r0,#0                 ;189
0000e6  e7e7              B        |L1.184|
                  |L1.232|
0000e8  6860              LDR      r0,[r4,#4]            ;191
0000ea  6840              LDR      r0,[r0,#4]            ;191
0000ec  6120              STR      r0,[r4,#0x10]         ;191
0000ee  8b78              LDRH     r0,[r7,#0x1a]         ;192
0000f0  f7fffffe          BL       lwip_htons
0000f4  6921              LDR      r1,[r4,#0x10]         ;192
0000f6  8008              STRH     r0,[r1,#0]            ;192
0000f8  8bb8              LDRH     r0,[r7,#0x1c]         ;193
0000fa  f7fffffe          BL       lwip_htons
0000fe  6921              LDR      r1,[r4,#0x10]         ;193
000100  8048              STRH     r0,[r1,#2]            ;193
000102  4650              MOV      r0,r10                ;194
000104  f7fffffe          BL       lwip_htonl
000108  6921              LDR      r1,[r4,#0x10]         ;194
00010a  6048              STR      r0,[r1,#4]            ;194
00010c  46ab              MOV      r11,r5                ;196
00010e  17e9              ASRS     r1,r5,#31             ;196
000110  eb057191          ADD      r1,r5,r1,LSR #30      ;196
000114  1089              ASRS     r1,r1,#2              ;196
000116  1d49              ADDS     r1,r1,#5              ;196
000118  ea493101          ORR      r1,r9,r1,LSL #12      ;196
00011c  b288              UXTH     r0,r1                 ;196
00011e  f7fffffe          BL       lwip_htons
000122  6921              LDR      r1,[r4,#0x10]         ;196
000124  8188              STRH     r0,[r1,#0xc]          ;196
000126  2000              MOVS     r0,#0                 ;198
000128  6921              LDR      r1,[r4,#0x10]         ;198
00012a  8248              STRH     r0,[r1,#0x12]         ;198
00012c  4620              MOV      r0,r4                 ;199
00012e  e7c3              B        |L1.184|
;;;201    
                          ENDP

                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000130  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
000134  4604              MOV      r4,r0
000136  460d              MOV      r5,r1
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
000138  2700              MOVS     r7,#0
;;;727      u8_t optlen = 0;
00013a  46b8              MOV      r8,r7
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
00013c  bf00              NOP      
00013e  bf00              NOP      
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
000140  bf00              NOP      
000142  bf00              NOP      
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
000144  f8b40068          LDRH     r0,[r4,#0x68]
000148  2808              CMP      r0,#8
00014a  da05              BGE      |L1.344|
00014c  f8b40068          LDRH     r0,[r4,#0x68]
000150  f64f71fc          MOV      r1,#0xfffc
000154  4288              CMP      r0,r1
000156  d909              BLS      |L1.364|
                  |L1.344|
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
000158  bf00              NOP      
00015a  bf00              NOP      
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
;;;739        pcb->flags |= TF_NAGLEMEMERR;
00015c  7fa0              LDRB     r0,[r4,#0x1e]
00015e  f0400080          ORR      r0,r0,#0x80
000162  77a0              STRB     r0,[r4,#0x1e]
;;;740        return ERR_MEM;
000164  f04f30ff          MOV      r0,#0xffffffff
                  |L1.360|
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
;;;744        optflags = TF_SEG_OPTS_MSS;
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
000168  e8bd83f8          POP      {r3-r9,pc}
                  |L1.364|
00016c  f0050002          AND      r0,r5,#2              ;743
000170  b100              CBZ      r0,|L1.372|
000172  2701              MOVS     r7,#1                 ;744
                  |L1.372|
000174  f0070001          AND      r0,r7,#1              ;751
000178  b108              CBZ      r0,|L1.382|
00017a  2004              MOVS     r0,#4                 ;751
00017c  e000              B        |L1.384|
                  |L1.382|
00017e  2000              MOVS     r0,#0                 ;751
                  |L1.384|
000180  f0070102          AND      r1,r7,#2              ;751
000184  b109              CBZ      r1,|L1.394|
000186  210c              MOVS     r1,#0xc               ;751
000188  e000              B        |L1.396|
                  |L1.394|
00018a  2100              MOVS     r1,#0                 ;751
                  |L1.396|
00018c  eb000801          ADD      r8,r0,r1              ;751
000190  f8b40066          LDRH     r0,[r4,#0x66]         ;757
000194  b920              CBNZ     r0,|L1.416|
000196  bf00              NOP                            ;758
000198  bf00              NOP                            ;758
00019a  f04f30ff          MOV      r0,#0xffffffff        ;760
00019e  e7e3              B        |L1.360|
                  |L1.416|
0001a0  2200              MOVS     r2,#0                 ;764
0001a2  4641              MOV      r1,r8                 ;764
0001a4  4610              MOV      r0,r2                 ;764
0001a6  f7fffffe          BL       pbuf_alloc
0001aa  f1b00900          SUBS     r9,r0,#0              ;764
0001ae  d106              BNE      |L1.446|
0001b0  7fa0              LDRB     r0,[r4,#0x1e]         ;765
0001b2  f0400080          ORR      r0,r0,#0x80           ;765
0001b6  77a0              STRB     r0,[r4,#0x1e]         ;765
0001b8  f04f30ff          MOV      r0,#0xffffffff        ;767
0001bc  e7d4              B        |L1.360|
                  |L1.446|
0001be  bf00              NOP                            ;769
0001c0  bf00              NOP                            ;769
0001c2  9700              STR      r7,[sp,#0]            ;773
0001c4  462a              MOV      r2,r5                 ;773
0001c6  4649              MOV      r1,r9                 ;773
0001c8  4620              MOV      r0,r4                 ;773
0001ca  6de3              LDR      r3,[r4,#0x5c]         ;773
0001cc  f7fffffe          BL       tcp_create_segment
0001d0  1e06              SUBS     r6,r0,#0              ;773
0001d2  d105              BNE      |L1.480|
0001d4  7fa0              LDRB     r0,[r4,#0x1e]         ;774
0001d6  f0400080          ORR      r0,r0,#0x80           ;774
0001da  77a0              STRB     r0,[r4,#0x1e]         ;774
0001dc  1e70              SUBS     r0,r6,#1              ;776
0001de  e7c3              B        |L1.360|
                  |L1.480|
0001e0  bf00              NOP                            ;778
0001e2  bf00              NOP                            ;778
0001e4  bf00              NOP                            ;779
0001e6  bf00              NOP                            ;779
0001e8  bf00              NOP                            ;781
0001ea  bf00              NOP                            ;781
0001ec  6ee0              LDR      r0,[r4,#0x6c]         ;788
0001ee  b908              CBNZ     r0,|L1.500|
0001f0  66e6              STR      r6,[r4,#0x6c]         ;789
0001f2  e007              B        |L1.516|
                  |L1.500|
0001f4  6ee0              LDR      r0,[r4,#0x6c]         ;792
0001f6  e000              B        |L1.506|
                  |L1.504|
0001f8  6800              LDR      r0,[r0,#0]            ;792
                  |L1.506|
0001fa  6801              LDR      r1,[r0,#0]            ;792
0001fc  2900              CMP      r1,#0                 ;792
0001fe  d1fb              BNE      |L1.504|
000200  6006              STR      r6,[r0,#0]            ;793
000202  bf00              NOP                            ;794
                  |L1.516|
000204  2000              MOVS     r0,#0                 ;797
000206  f8a4006a          STRH     r0,[r4,#0x6a]         ;797
00020a  f0050002          AND      r0,r5,#2              ;801
00020e  b910              CBNZ     r0,|L1.534|
000210  f0050001          AND      r0,r5,#1              ;801
000214  b138              CBZ      r0,|L1.550|
                  |L1.534|
000216  6de0              LDR      r0,[r4,#0x5c]         ;802
000218  1c40              ADDS     r0,r0,#1              ;802
00021a  65e0              STR      r0,[r4,#0x5c]         ;802
00021c  f8b40066          LDRH     r0,[r4,#0x66]         ;804
000220  1e40              SUBS     r0,r0,#1              ;804
000222  f8a40066          STRH     r0,[r4,#0x66]         ;804
                  |L1.550|
000226  f0050001          AND      r0,r5,#1              ;806
00022a  b118              CBZ      r0,|L1.564|
00022c  7fa0              LDRB     r0,[r4,#0x1e]         ;807
00022e  f0400020          ORR      r0,r0,#0x20           ;807
000232  77a0              STRB     r0,[r4,#0x1e]         ;807
                  |L1.564|
000234  6870              LDR      r0,[r6,#4]            ;811
000236  f7fffffe          BL       pbuf_clen
00023a  f8b41068          LDRH     r1,[r4,#0x68]         ;811
00023e  4408              ADD      r0,r0,r1              ;811
000240  f8a40068          STRH     r0,[r4,#0x68]         ;811
000244  bf00              NOP                            ;812
000246  bf00              NOP                            ;812
000248  f8b40068          LDRH     r0,[r4,#0x68]         ;813
00024c  b108              CBZ      r0,|L1.594|
00024e  bf00              NOP                            ;814
000250  bf00              NOP                            ;814
                  |L1.594|
000252  2000              MOVS     r0,#0                 ;818
000254  e788              B        |L1.360|
;;;820    
                          ENDP

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000256  b570              PUSH     {r4-r6,lr}
;;;126    {
000258  4604              MOV      r4,r0
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
00025a  6ee0              LDR      r0,[r4,#0x6c]
00025c  b1d8              CBZ      r0,|L1.662|
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
00025e  6ee5              LDR      r5,[r4,#0x6c]
000260  e000              B        |L1.612|
                  |L1.610|
;;;131             last_unsent = last_unsent->next);
000262  682d              LDR      r5,[r5,#0]
                  |L1.612|
000264  6828              LDR      r0,[r5,#0]            ;130
000266  2800              CMP      r0,#0                 ;130
000268  d1fb              BNE      |L1.610|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
00026a  6929              LDR      r1,[r5,#0x10]
00026c  8988              LDRH     r0,[r1,#0xc]
00026e  f7fffffe          BL       lwip_ntohs
000272  f0000007          AND      r0,r0,#7
000276  b968              CBNZ     r0,|L1.660|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
000278  2001              MOVS     r0,#1
00027a  f7fffffe          BL       lwip_htons
00027e  6929              LDR      r1,[r5,#0x10]
000280  8989              LDRH     r1,[r1,#0xc]
000282  4308              ORRS     r0,r0,r1
000284  6929              LDR      r1,[r5,#0x10]
000286  8188              STRH     r0,[r1,#0xc]
;;;136          pcb->flags |= TF_FIN;
000288  7fa0              LDRB     r0,[r4,#0x1e]
00028a  f0400020          ORR      r0,r0,#0x20
00028e  77a0              STRB     r0,[r4,#0x1e]
;;;137          return ERR_OK;
000290  2000              MOVS     r0,#0
                  |L1.658|
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
;;;142    }
000292  bd70              POP      {r4-r6,pc}
                  |L1.660|
000294  bf00              NOP                            ;139
                  |L1.662|
000296  2101              MOVS     r1,#1                 ;141
000298  4620              MOV      r0,r4                 ;141
00029a  f7fffffe          BL       tcp_enqueue_flags
00029e  e7f8              B        |L1.658|
;;;143    
                          ENDP

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
0002a0  e92d5fff          PUSH     {r0-r12,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
0002a4  460c              MOV      r4,r1
0002a6  4616              MOV      r6,r2
0002a8  4698              MOV      r8,r3
0002aa  e9ddab0f          LDRD     r10,r11,[sp,#0x3c]
0002ae  9f0e              LDR      r7,[sp,#0x38]
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
0002b0  46a1              MOV      r9,r4
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
0002b2  42b4              CMP      r4,r6
0002b4  da1b              BGE      |L1.750|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
0002b6  f00a0002          AND      r0,r10,#2
0002ba  b950              CBNZ     r0,|L1.722|
;;;247            (!(pcb->flags & TF_NODELAY) &&
0002bc  7fb8              LDRB     r0,[r7,#0x1e]
0002be  f0000040          AND      r0,r0,#0x40
0002c2  b9a0              CBNZ     r0,|L1.750|
;;;248             (!first_seg ||
0002c4  f1bb0f00          CMP      r11,#0
0002c8  d003              BEQ      |L1.722|
;;;249              pcb->unsent != NULL ||
0002ca  6ef8              LDR      r0,[r7,#0x6c]
0002cc  b908              CBNZ     r0,|L1.722|
;;;250              pcb->unacked != NULL))) {
0002ce  6f38              LDR      r0,[r7,#0x70]
0002d0  b168              CBZ      r0,|L1.750|
                  |L1.722|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
0002d2  f20450b7          ADD      r0,r4,#0x5b7
0002d6  f0200003          BIC      r0,r0,#3
0002da  42b0              CMP      r0,r6
0002dc  dd01              BLE      |L1.738|
0002de  4630              MOV      r0,r6
0002e0  e003              B        |L1.746|
                  |L1.738|
0002e2  f20450b7          ADD      r0,r4,#0x5b7
0002e6  f0200003          BIC      r0,r0,#3
                  |L1.746|
0002ea  fa1ff980          UXTH     r9,r0
                  |L1.750|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
0002ee  2200              MOVS     r2,#0
0002f0  4649              MOV      r1,r9
0002f2  9800              LDR      r0,[sp,#0]
0002f4  f7fffffe          BL       pbuf_alloc
0002f8  4605              MOV      r5,r0
;;;256      if (p == NULL) {
0002fa  b91d              CBNZ     r5,|L1.772|
;;;257        return NULL;
0002fc  2000              MOVS     r0,#0
                  |L1.766|
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
;;;260      *oversize = p->len - length;
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
;;;263      return p;
;;;264    }
0002fe  b004              ADD      sp,sp,#0x10
000300  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.772|
000304  bf00              NOP                            ;259
000306  bf00              NOP                            ;259
000308  8968              LDRH     r0,[r5,#0xa]          ;260
00030a  1b00              SUBS     r0,r0,r4              ;260
00030c  f8a80000          STRH     r0,[r8,#0]            ;260
000310  812c              STRH     r4,[r5,#8]            ;262
000312  816c              STRH     r4,[r5,#0xa]          ;262
000314  4628              MOV      r0,r5                 ;263
000316  e7f2              B        |L1.766|
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000318  4602              MOV      r2,r0
;;;295    {
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
00031a  7e10              LDRB     r0,[r2,#0x18]
00031c  2804              CMP      r0,#4
00031e  d00d              BEQ      |L1.828|
;;;298          (pcb->state != CLOSE_WAIT) &&
000320  7e10              LDRB     r0,[r2,#0x18]
000322  2807              CMP      r0,#7
000324  d00a              BEQ      |L1.828|
;;;299          (pcb->state != SYN_SENT) &&
000326  7e10              LDRB     r0,[r2,#0x18]
000328  2802              CMP      r0,#2
00032a  d007              BEQ      |L1.828|
;;;300          (pcb->state != SYN_RCVD)) {
00032c  7e10              LDRB     r0,[r2,#0x18]
00032e  2803              CMP      r0,#3
000330  d004              BEQ      |L1.828|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
000332  bf00              NOP      
000334  bf00              NOP      
;;;302        return ERR_CONN;
000336  f06f000c          MVN      r0,#0xc
                  |L1.826|
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
00033a  4770              BX       lr
                  |L1.828|
00033c  b909              CBNZ     r1,|L1.834|
00033e  2000              MOVS     r0,#0                 ;304
000340  e7fb              B        |L1.826|
                  |L1.834|
000342  f8b20066          LDRH     r0,[r2,#0x66]         ;308
000346  4288              CMP      r0,r1                 ;308
000348  da08              BGE      |L1.860|
00034a  bf00              NOP                            ;309
00034c  bf00              NOP                            ;309
00034e  7f90              LDRB     r0,[r2,#0x1e]         ;311
000350  f0400080          ORR      r0,r0,#0x80           ;311
000354  7790              STRB     r0,[r2,#0x1e]         ;311
000356  f04f30ff          MOV      r0,#0xffffffff        ;312
00035a  e7ee              B        |L1.826|
                  |L1.860|
00035c  bf00              NOP                            ;315
00035e  bf00              NOP                            ;315
000360  f8b20068          LDRH     r0,[r2,#0x68]         ;320
000364  2808              CMP      r0,#8                 ;320
000366  da05              BGE      |L1.884|
000368  f8b20068          LDRH     r0,[r2,#0x68]         ;320
00036c  f64f73fc          MOV      r3,#0xfffc            ;320
000370  4298              CMP      r0,r3                 ;320
000372  d908              BLS      |L1.902|
                  |L1.884|
000374  bf00              NOP                            ;321
000376  bf00              NOP                            ;321
000378  7f90              LDRB     r0,[r2,#0x1e]         ;324
00037a  f0400080          ORR      r0,r0,#0x80           ;324
00037e  7790              STRB     r0,[r2,#0x1e]         ;324
000380  f04f30ff          MOV      r0,#0xffffffff        ;325
000384  e7d9              B        |L1.826|
                  |L1.902|
000386  f8b20068          LDRH     r0,[r2,#0x68]         ;327
00038a  b108              CBZ      r0,|L1.912|
00038c  bf00              NOP                            ;328
00038e  e001              B        |L1.916|
                  |L1.912|
000390  bf00              NOP                            ;331
000392  bf00              NOP                            ;331
                  |L1.916|
000394  2000              MOVS     r0,#0                 ;334
000396  e7d0              B        |L1.826|
;;;336    
                          ENDP

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000398  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
00039c  b08f              SUB      sp,sp,#0x3c
00039e  4604              MOV      r4,r0
0003a0  4617              MOV      r7,r2
;;;356      struct pbuf *concat_p = NULL;
0003a2  f04f0b00          MOV      r11,#0
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
0003a6  2500              MOVS     r5,#0
0003a8  46aa              MOV      r10,r5
0003aa  2000              MOVS     r0,#0
0003ac  900e              STR      r0,[sp,#0x38]
0003ae  900d              STR      r0,[sp,#0x34]
;;;358      u16_t pos = 0; /* position in 'arg' data */
0003b0  2600              MOVS     r6,#0
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
0003b2  900b              STR      r0,[sp,#0x2c]
;;;361      u8_t optflags = 0;
0003b4  900a              STR      r0,[sp,#0x28]
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
0003b6  9009              STR      r0,[sp,#0x24]
;;;364      u16_t oversize_used = 0;
0003b8  4680              MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
0003ba  f8b41062          LDRH     r1,[r4,#0x62]
0003be  eb0172d1          ADD      r2,r1,r1,LSR #31
0003c2  1052              ASRS     r2,r2,#1
0003c4  8ee3              LDRH     r3,[r4,#0x36]
0003c6  429a              CMP      r2,r3
0003c8  dd01              BLE      |L1.974|
0003ca  8ee2              LDRH     r2,[r4,#0x36]
0003cc  e004              B        |L1.984|
                  |L1.974|
0003ce  f8b40062          LDRH     r0,[r4,#0x62]
0003d2  eb0072d0          ADD      r2,r0,r0,LSR #31
0003d6  1052              ASRS     r2,r2,#1
                  |L1.984|
0003d8  b292              UXTH     r2,r2
0003da  9207              STR      r2,[sp,#0x1c]
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
0003dc  bf00              NOP      
0003de  bf00              NOP      
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
0003e0  bf00              NOP      
0003e2  9810              LDR      r0,[sp,#0x40]
0003e4  b920              CBNZ     r0,|L1.1008|
0003e6  f06f000d          MVN      r0,#0xd
                  |L1.1002|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
;;;386      if (err != ERR_OK) {
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
0003ea  b013              ADD      sp,sp,#0x4c
0003ec  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1008|
0003f0  bf00              NOP                            ;382
0003f2  4639              MOV      r1,r7                 ;385
0003f4  4620              MOV      r0,r4                 ;385
0003f6  f7fffffe          BL       tcp_write_checks
0003fa  9008              STR      r0,[sp,#0x20]         ;385
0003fc  9808              LDR      r0,[sp,#0x20]         ;386
0003fe  b108              CBZ      r0,|L1.1028|
000400  9808              LDR      r0,[sp,#0x20]         ;387
000402  e7f2              B        |L1.1002|
                  |L1.1028|
000404  f8b40068          LDRH     r0,[r4,#0x68]         ;389
000408  900c              STR      r0,[sp,#0x30]         ;389
00040a  6ee0              LDR      r0,[r4,#0x6c]         ;422
00040c  2800              CMP      r0,#0                 ;422
00040e  d073              BEQ      |L1.1272|
000410  6ee5              LDR      r5,[r4,#0x6c]         ;427
000412  e000              B        |L1.1046|
                  |L1.1044|
000414  682d              LDR      r5,[r5,#0]            ;428
                  |L1.1046|
000416  6828              LDR      r0,[r5,#0]            ;427
000418  2800              CMP      r0,#0                 ;427
00041a  d1fb              BNE      |L1.1044|
00041c  7b28              LDRB     r0,[r5,#0xc]          ;431
00041e  f0000001          AND      r0,r0,#1              ;431
000422  b108              CBZ      r0,|L1.1064|
000424  2004              MOVS     r0,#4                 ;431
000426  e000              B        |L1.1066|
                  |L1.1064|
000428  2000              MOVS     r0,#0                 ;431
                  |L1.1066|
00042a  7b29              LDRB     r1,[r5,#0xc]          ;431
00042c  f0010102          AND      r1,r1,#2              ;431
000430  b109              CBZ      r1,|L1.1078|
000432  210c              MOVS     r1,#0xc               ;431
000434  e000              B        |L1.1080|
                  |L1.1078|
000436  2100              MOVS     r1,#0                 ;431
                  |L1.1080|
000438  4408              ADD      r0,r0,r1              ;431
00043a  9006              STR      r0,[sp,#0x18]         ;431
00043c  8929              LDRH     r1,[r5,#8]            ;432
00043e  9806              LDR      r0,[sp,#0x18]         ;432
000440  4401              ADD      r1,r1,r0              ;432
000442  9807              LDR      r0,[sp,#0x1c]         ;432
000444  1a40              SUBS     r0,r0,r1              ;432
000446  fa1ff980          UXTH     r9,r0                 ;432
00044a  bf00              NOP                            ;444
00044c  bf00              NOP                            ;444
00044e  f8b4006a          LDRH     r0,[r4,#0x6a]         ;447
000452  9009              STR      r0,[sp,#0x24]         ;447
000454  f8bd0024          LDRH     r0,[sp,#0x24]         ;448
000458  2800              CMP      r0,#0                 ;448
00045a  dd18              BLE      |L1.1166|
00045c  bf00              NOP                            ;449
00045e  bf00              NOP                            ;449
000460  46aa              MOV      r10,r5                ;450
000462  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
000466  42b8              CMP      r0,r7                 ;451
000468  da02              BGE      |L1.1136|
00046a  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
00046e  e000              B        |L1.1138|
                  |L1.1136|
000470  4638              MOV      r0,r7                 ;451
                  |L1.1138|
000472  4680              MOV      r8,r0                 ;451
000474  eb060008          ADD      r0,r6,r8              ;452
000478  b286              UXTH     r6,r0                 ;452
00047a  f8bd0024          LDRH     r0,[sp,#0x24]         ;453
00047e  eba00008          SUB      r0,r0,r8              ;453
000482  b280              UXTH     r0,r0                 ;453
000484  9009              STR      r0,[sp,#0x24]         ;453
000486  eba90008          SUB      r0,r9,r8              ;454
00048a  fa1ff980          UXTH     r9,r0                 ;454
                  |L1.1166|
00048e  bf00              NOP                            ;457
000490  bf00              NOP                            ;457
000492  42be              CMP      r6,r7                 ;467
000494  da4b              BGE      |L1.1326|
000496  f1b90f00          CMP      r9,#0                 ;467
00049a  dd48              BLE      |L1.1326|
00049c  8928              LDRH     r0,[r5,#8]            ;467
00049e  2800              CMP      r0,#0                 ;467
0004a0  dd45              BLE      |L1.1326|
0004a2  1bb8              SUBS     r0,r7,r6              ;468
0004a4  4548              CMP      r0,r9                 ;468
0004a6  dd01              BLE      |L1.1196|
0004a8  4648              MOV      r0,r9                 ;468
0004aa  e000              B        |L1.1198|
                  |L1.1196|
0004ac  1bb8              SUBS     r0,r7,r6              ;468
                  |L1.1198|
0004ae  b280              UXTH     r0,r0                 ;468
0004b0  9005              STR      r0,[sp,#0x14]         ;468
0004b2  46aa              MOV      r10,r5                ;469
0004b4  9812              LDR      r0,[sp,#0x48]         ;474
0004b6  f0000001          AND      r0,r0,#1              ;474
0004ba  b1f0              CBZ      r0,|L1.1274|
0004bc  2101              MOVS     r1,#1                 ;476
0004be  9812              LDR      r0,[sp,#0x48]         ;476
0004c0  ab09              ADD      r3,sp,#0x24           ;476
0004c2  464a              MOV      r2,r9                 ;476
0004c4  e9cd4000          STRD     r4,r0,[sp,#0]         ;476
0004c8  9102              STR      r1,[sp,#8]            ;476
0004ca  2003              MOVS     r0,#3                 ;476
0004cc  9905              LDR      r1,[sp,#0x14]         ;476
0004ce  f7fffffe          BL       tcp_pbuf_prealloc
0004d2  f1b00b00          SUBS     r11,r0,#0             ;476
0004d6  d102              BNE      |L1.1246|
0004d8  bf00              NOP                            ;477
0004da  bf00              NOP                            ;477
0004dc  e12b              B        |L1.1846|
                  |L1.1246|
0004de  8968              LDRH     r0,[r5,#0xa]          ;483
0004e0  f8bd1024          LDRH     r1,[sp,#0x24]         ;483
0004e4  4408              ADD      r0,r0,r1              ;483
0004e6  8168              STRH     r0,[r5,#0xa]          ;483
0004e8  9a10              LDR      r2,[sp,#0x40]         ;485
0004ea  1991              ADDS     r1,r2,r6              ;485
0004ec  f8db0004          LDR      r0,[r11,#4]           ;485
0004f0  9a05              LDR      r2,[sp,#0x14]         ;485
0004f2  f7fffffe          BL       __aeabi_memcpy
0004f6  e00f              B        |L1.1304|
                  |L1.1272|
0004f8  e01a              B        |L1.1328|
                  |L1.1274|
0004fa  2201              MOVS     r2,#1                 ;491
0004fc  2003              MOVS     r0,#3                 ;491
0004fe  9905              LDR      r1,[sp,#0x14]         ;491
000500  f7fffffe          BL       pbuf_alloc
000504  f1b00b00          SUBS     r11,r0,#0             ;491
000508  d102              BNE      |L1.1296|
00050a  bf00              NOP                            ;492
00050c  bf00              NOP                            ;492
00050e  e112              B        |L1.1846|
                  |L1.1296|
000510  9810              LDR      r0,[sp,#0x40]         ;503
000512  4430              ADD      r0,r0,r6              ;503
000514  f8cb0004          STR      r0,[r11,#4]           ;503
                  |L1.1304|
000518  9805              LDR      r0,[sp,#0x14]         ;506
00051a  4430              ADD      r0,r0,r6              ;506
00051c  b286              UXTH     r6,r0                 ;506
00051e  4658              MOV      r0,r11                ;507
000520  f7fffffe          BL       pbuf_clen
000524  990c              LDR      r1,[sp,#0x30]         ;507
000526  4408              ADD      r0,r0,r1              ;507
000528  b280              UXTH     r0,r0                 ;507
00052a  900c              STR      r0,[sp,#0x30]         ;507
00052c  bf00              NOP                            ;508
                  |L1.1326|
00052e  e001              B        |L1.1332|
                  |L1.1328|
000530  bf00              NOP                            ;511
000532  bf00              NOP                            ;511
                  |L1.1332|
000534  e092              B        |L1.1628|
                  |L1.1334|
000536  1bb8              SUBS     r0,r7,r6              ;524
000538  b280              UXTH     r0,r0                 ;524
00053a  9006              STR      r0,[sp,#0x18]         ;524
00053c  990b              LDR      r1,[sp,#0x2c]         ;525
00053e  9807              LDR      r0,[sp,#0x1c]         ;525
000540  1a40              SUBS     r0,r0,r1              ;525
000542  b280              UXTH     r0,r0                 ;525
000544  9005              STR      r0,[sp,#0x14]         ;525
000546  e9dd1005          LDRD     r1,r0,[sp,#0x14]      ;526
00054a  4288              CMP      r0,r1                 ;526
00054c  dd01              BLE      |L1.1362|
00054e  9805              LDR      r0,[sp,#0x14]         ;526
000550  e000              B        |L1.1364|
                  |L1.1362|
000552  9806              LDR      r0,[sp,#0x18]         ;526
                  |L1.1364|
000554  9004              STR      r0,[sp,#0x10]         ;526
000556  9812              LDR      r0,[sp,#0x48]         ;532
000558  f0000001          AND      r0,r0,#1              ;532
00055c  b318              CBZ      r0,|L1.1446|
00055e  980d              LDR      r0,[sp,#0x34]         ;535
000560  b908              CBNZ     r0,|L1.1382|
000562  2101              MOVS     r1,#1                 ;535
000564  e000              B        |L1.1384|
                  |L1.1382|
000566  2100              MOVS     r1,#0                 ;535
                  |L1.1384|
000568  9812              LDR      r0,[sp,#0x48]         ;535
00056a  e9cd4000          STRD     r4,r0,[sp,#0]         ;535
00056e  9102              STR      r1,[sp,#8]            ;535
000570  9a0b              LDR      r2,[sp,#0x2c]         ;535
000572  9804              LDR      r0,[sp,#0x10]         ;535
000574  4410              ADD      r0,r0,r2              ;535
000576  b281              UXTH     r1,r0                 ;535
000578  ab09              ADD      r3,sp,#0x24           ;535
00057a  2000              MOVS     r0,#0                 ;535
00057c  9a07              LDR      r2,[sp,#0x1c]         ;535
00057e  f7fffffe          BL       tcp_pbuf_prealloc
000582  f1b00900          SUBS     r9,r0,#0              ;535
000586  d102              BNE      |L1.1422|
000588  bf00              NOP                            ;536
00058a  bf00              NOP                            ;536
00058c  e0d3              B        |L1.1846|
                  |L1.1422|
00058e  bf00              NOP                            ;539
000590  bf00              NOP                            ;539
000592  9a10              LDR      r2,[sp,#0x40]         ;541
000594  1991              ADDS     r1,r2,r6              ;541
000596  f8d93004          LDR      r3,[r9,#4]            ;541
00059a  9a0b              LDR      r2,[sp,#0x2c]         ;541
00059c  1898              ADDS     r0,r3,r2              ;541
00059e  9a04              LDR      r2,[sp,#0x10]         ;541
0005a0  f7fffffe          BL       __aeabi_memcpy
0005a4  e022              B        |L1.1516|
                  |L1.1446|
0005a6  bf00              NOP                            ;550
0005a8  bf00              NOP                            ;550
0005aa  2201              MOVS     r2,#1                 ;552
0005ac  2000              MOVS     r0,#0                 ;552
0005ae  9904              LDR      r1,[sp,#0x10]         ;552
0005b0  f7fffffe          BL       pbuf_alloc
0005b4  9003              STR      r0,[sp,#0xc]          ;552
0005b6  b910              CBNZ     r0,|L1.1470|
0005b8  bf00              NOP                            ;553
0005ba  bf00              NOP                            ;553
0005bc  e0bb              B        |L1.1846|
                  |L1.1470|
0005be  9810              LDR      r0,[sp,#0x40]         ;561
0005c0  1981              ADDS     r1,r0,r6              ;561
0005c2  9803              LDR      r0,[sp,#0xc]          ;561
0005c4  6041              STR      r1,[r0,#4]            ;561
0005c6  2200              MOVS     r2,#0                 ;564
0005c8  4610              MOV      r0,r2                 ;564
0005ca  990b              LDR      r1,[sp,#0x2c]         ;564
0005cc  f7fffffe          BL       pbuf_alloc
0005d0  f1b00900          SUBS     r9,r0,#0              ;564
0005d4  d105              BNE      |L1.1506|
0005d6  9803              LDR      r0,[sp,#0xc]          ;567
0005d8  f7fffffe          BL       pbuf_free
0005dc  bf00              NOP                            ;568
0005de  bf00              NOP                            ;568
0005e0  e0a9              B        |L1.1846|
                  |L1.1506|
0005e2  4648              MOV      r0,r9                 ;572
0005e4  9903              LDR      r1,[sp,#0xc]          ;572
0005e6  f7fffffe          BL       pbuf_cat
0005ea  bf00              NOP                            ;573
                  |L1.1516|
0005ec  4648              MOV      r0,r9                 ;575
0005ee  f7fffffe          BL       pbuf_clen
0005f2  990c              LDR      r1,[sp,#0x30]         ;575
0005f4  4408              ADD      r0,r0,r1              ;575
0005f6  b280              UXTH     r0,r0                 ;575
0005f8  900c              STR      r0,[sp,#0x30]         ;575
0005fa  980c              LDR      r0,[sp,#0x30]         ;580
0005fc  2808              CMP      r0,#8                 ;580
0005fe  dc04              BGT      |L1.1546|
000600  f64f71fc          MOV      r1,#0xfffc            ;580
000604  980c              LDR      r0,[sp,#0x30]         ;580
000606  4288              CMP      r0,r1                 ;580
000608  d905              BLS      |L1.1558|
                  |L1.1546|
00060a  bf00              NOP                            ;581
00060c  bf00              NOP                            ;581
00060e  4648              MOV      r0,r9                 ;582
000610  f7fffffe          BL       pbuf_free
000614  e08f              B        |L1.1846|
                  |L1.1558|
000616  980a              LDR      r0,[sp,#0x28]         ;586
000618  9000              STR      r0,[sp,#0]            ;586
00061a  6de0              LDR      r0,[r4,#0x5c]         ;586
00061c  1983              ADDS     r3,r0,r6              ;586
00061e  2200              MOVS     r2,#0                 ;586
000620  4649              MOV      r1,r9                 ;586
000622  4620              MOV      r0,r4                 ;586
000624  f7fffffe          BL       tcp_create_segment
000628  f1b00a00          SUBS     r10,r0,#0             ;586
00062c  d100              BNE      |L1.1584|
00062e  e082              B        |L1.1846|
                  |L1.1584|
000630  f8bd0024          LDRH     r0,[sp,#0x24]         ;590
000634  f8aa000a          STRH     r0,[r10,#0xa]         ;590
000638  980d              LDR      r0,[sp,#0x34]         ;599
00063a  b910              CBNZ     r0,|L1.1602|
00063c  f8cda034          STR      r10,[sp,#0x34]        ;600
000640  e004              B        |L1.1612|
                  |L1.1602|
000642  bf00              NOP                            ;603
000644  bf00              NOP                            ;603
000646  980e              LDR      r0,[sp,#0x38]         ;604
000648  f8c0a000          STR      r10,[r0,#0]           ;604
                  |L1.1612|
00064c  f8cda038          STR      r10,[sp,#0x38]        ;607
000650  bf00              NOP                            ;609
000652  bf00              NOP                            ;609
000654  9804              LDR      r0,[sp,#0x10]         ;613
000656  4430              ADD      r0,r0,r6              ;613
000658  b286              UXTH     r6,r0                 ;613
00065a  bf00              NOP                            ;614
                  |L1.1628|
00065c  42be              CMP      r6,r7                 ;522
00065e  f6ffaf6a          BLT      |L1.1334|
000662  f1b80f00          CMP      r8,#0                 ;626
000666  dd27              BLE      |L1.1720|
000668  f8d59004          LDR      r9,[r5,#4]            ;629
00066c  e017              B        |L1.1694|
                  |L1.1646|
00066e  f8b90008          LDRH     r0,[r9,#8]            ;630
000672  4440              ADD      r0,r0,r8              ;630
000674  f8a90008          STRH     r0,[r9,#8]            ;630
000678  f8d90000          LDR      r0,[r9,#0]            ;631
00067c  b968              CBNZ     r0,|L1.1690|
00067e  f8b9200a          LDRH     r2,[r9,#0xa]          ;632
000682  f8d91004          LDR      r1,[r9,#4]            ;632
000686  1888              ADDS     r0,r1,r2              ;632
000688  4642              MOV      r2,r8                 ;632
00068a  9910              LDR      r1,[sp,#0x40]         ;632
00068c  f7fffffe          BL       __aeabi_memcpy
000690  f8b9000a          LDRH     r0,[r9,#0xa]          ;633
000694  4440              ADD      r0,r0,r8              ;633
000696  f8a9000a          STRH     r0,[r9,#0xa]          ;633
                  |L1.1690|
00069a  f8d99000          LDR      r9,[r9,#0]            ;629
                  |L1.1694|
00069e  f1b90f00          CMP      r9,#0                 ;629
0006a2  d1e4              BNE      |L1.1646|
0006a4  8928              LDRH     r0,[r5,#8]            ;636
0006a6  4440              ADD      r0,r0,r8              ;636
0006a8  8128              STRH     r0,[r5,#8]            ;636
0006aa  bf00              NOP                            ;638
0006ac  bf00              NOP                            ;638
0006ae  8968              LDRH     r0,[r5,#0xa]          ;640
0006b0  eba00008          SUB      r0,r0,r8              ;640
0006b4  8168              STRH     r0,[r5,#0xa]          ;640
0006b6  bf00              NOP                            ;642
                  |L1.1720|
0006b8  f8bd0024          LDRH     r0,[sp,#0x24]         ;643
0006bc  f8a4006a          STRH     r0,[r4,#0x6a]         ;643
0006c0  f1bb0f00          CMP      r11,#0                ;649
0006c4  d00a              BEQ      |L1.1756|
0006c6  bf00              NOP                            ;650
0006c8  bf00              NOP                            ;650
0006ca  4659              MOV      r1,r11                ;652
0006cc  6868              LDR      r0,[r5,#4]            ;652
0006ce  f7fffffe          BL       pbuf_cat
0006d2  8928              LDRH     r0,[r5,#8]            ;653
0006d4  f8bb1008          LDRH     r1,[r11,#8]           ;653
0006d8  4408              ADD      r0,r0,r1              ;653
0006da  8128              STRH     r0,[r5,#8]            ;653
                  |L1.1756|
0006dc  b915              CBNZ     r5,|L1.1764|
0006de  980d              LDR      r0,[sp,#0x34]         ;668
0006e0  66e0              STR      r0,[r4,#0x6c]         ;668
0006e2  e001              B        |L1.1768|
                  |L1.1764|
0006e4  980d              LDR      r0,[sp,#0x34]         ;670
0006e6  6028              STR      r0,[r5,#0]            ;670
                  |L1.1768|
0006e8  f8540f5c          LDR      r0,[r4,#0x5c]!        ;676
0006ec  4438              ADD      r0,r0,r7              ;676
0006ee  6020              STR      r0,[r4,#0]            ;676
0006f0  8960              LDRH     r0,[r4,#0xa]          ;677
0006f2  1bc0              SUBS     r0,r0,r7              ;677
0006f4  8160              STRH     r0,[r4,#0xa]          ;677
0006f6  980c              LDR      r0,[sp,#0x30]         ;678
0006f8  81a0              STRH     r0,[r4,#0xc]          ;678
0006fa  3c5c              SUBS     r4,r4,#0x5c           ;678
0006fc  bf00              NOP                            ;680
0006fe  bf00              NOP                            ;680
000700  f8b40068          LDRH     r0,[r4,#0x68]         ;682
000704  b108              CBZ      r0,|L1.1802|
000706  bf00              NOP                            ;683
000708  bf00              NOP                            ;683
                  |L1.1802|
00070a  f1ba0f00          CMP      r10,#0                ;688
00070e  d010              BEQ      |L1.1842|
000710  f8da0010          LDR      r0,[r10,#0x10]        ;688
000714  b168              CBZ      r0,|L1.1842|
000716  9812              LDR      r0,[sp,#0x48]         ;688
000718  f0000002          AND      r0,r0,#2              ;688
00071c  b948              CBNZ     r0,|L1.1842|
00071e  2008              MOVS     r0,#8                 ;689
000720  f7fffffe          BL       lwip_htons
000724  f8da1010          LDR      r1,[r10,#0x10]        ;689
000728  8989              LDRH     r1,[r1,#0xc]          ;689
00072a  4308              ORRS     r0,r0,r1              ;689
00072c  f8da1010          LDR      r1,[r10,#0x10]        ;689
000730  8188              STRH     r0,[r1,#0xc]          ;689
                  |L1.1842|
000732  2000              MOVS     r0,#0                 ;692
000734  e659              B        |L1.1002|
                  |L1.1846|
000736  7fa0              LDRB     r0,[r4,#0x1e]         ;694
000738  f0400080          ORR      r0,r0,#0x80           ;694
00073c  77a0              STRB     r0,[r4,#0x1e]         ;694
00073e  f1bb0f00          CMP      r11,#0                ;697
000742  d002              BEQ      |L1.1866|
000744  4658              MOV      r0,r11                ;698
000746  f7fffffe          BL       pbuf_free
                  |L1.1866|
00074a  980d              LDR      r0,[sp,#0x34]         ;700
00074c  b110              CBZ      r0,|L1.1876|
00074e  980d              LDR      r0,[sp,#0x34]         ;701
000750  f7fffffe          BL       tcp_segs_free
                  |L1.1876|
000754  f8b40068          LDRH     r0,[r4,#0x68]         ;703
000758  b108              CBZ      r0,|L1.1886|
00075a  bf00              NOP                            ;704
00075c  bf00              NOP                            ;704
                  |L1.1886|
00075e  bf00              NOP                            ;707
000760  bf00              NOP                            ;707
000762  f04f30ff          MOV      r0,#0xffffffff        ;708
000766  e640              B        |L1.1002|
;;;710    
                          ENDP

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000768  e92d41fc          PUSH     {r2-r8,lr}
;;;843    {
00076c  4604              MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
00076e  2700              MOVS     r7,#0
;;;847    	(void)tcphdr;
;;;848    
;;;849    #if LWIP_TCP_TIMESTAMPS
;;;850      if (pcb->flags & TF_TIMESTAMP) {
;;;851        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;852      }
;;;853    #endif
;;;854    
;;;855      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000770  6d20              LDR      r0,[r4,#0x50]
000772  f7fffffe          BL       lwip_htonl
000776  4680              MOV      r8,r0
000778  4643              MOV      r3,r8
00077a  2200              MOVS     r2,#0
00077c  4639              MOV      r1,r7
00077e  4620              MOV      r0,r4
000780  f7fffffe          BL       tcp_output_alloc_header
000784  4605              MOV      r5,r0
;;;856      if (p == NULL) {
000786  b925              CBNZ     r5,|L1.1938|
;;;857        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
000788  bf00              NOP      
00078a  bf00              NOP      
;;;858        return ERR_BUF;
00078c  1eb8              SUBS     r0,r7,#2
                  |L1.1934|
;;;859      }
;;;860      tcphdr = (struct tcp_hdr *)p->payload;
;;;861      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;862                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;863      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;864      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;865    
;;;866      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;867    #if LWIP_TCP_TIMESTAMPS
;;;868      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;869    
;;;870      if (pcb->flags & TF_TIMESTAMP) {
;;;871        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;872      }
;;;873    #endif 
;;;874    
;;;875    #if CHECKSUM_GEN_TCP
;;;876      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
;;;877            IP_PROTO_TCP, p->tot_len);
;;;878    #endif
;;;879    #if LWIP_NETIF_HWADDRHINT
;;;880      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;881          IP_PROTO_TCP, &(pcb->addr_hint));
;;;882    #else /* LWIP_NETIF_HWADDRHINT*/
;;;883      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;884          IP_PROTO_TCP);
;;;885    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;886      pbuf_free(p);
;;;887    
;;;888      return ERR_OK;
;;;889    }
00078e  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1938|
000792  686e              LDR      r6,[r5,#4]            ;860
000794  bf00              NOP                            ;861
000796  bf00              NOP                            ;861
000798  7fa0              LDRB     r0,[r4,#0x1e]         ;864
00079a  f0200003          BIC      r0,r0,#3              ;864
00079e  77a0              STRB     r0,[r4,#0x1e]         ;864
0007a0  2106              MOVS     r1,#6                 ;883
0007a2  7a60              LDRB     r0,[r4,#9]            ;883
0007a4  e9cd0100          STRD     r0,r1,[sp,#0]         ;883
0007a8  7aa3              LDRB     r3,[r4,#0xa]          ;883
0007aa  1d22              ADDS     r2,r4,#4              ;883
0007ac  4621              MOV      r1,r4                 ;883
0007ae  4628              MOV      r0,r5                 ;883
0007b0  f7fffffe          BL       ip_output
0007b4  4628              MOV      r0,r5                 ;886
0007b6  f7fffffe          BL       pbuf_free
0007ba  2000              MOVS     r0,#0                 ;888
0007bc  e7e7              B        |L1.1934|
;;;890    
                          ENDP

                  tcp_output_segment PROC
;;;1049   static void
;;;1050   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
0007be  e92d47fc          PUSH     {r2-r10,lr}
;;;1051   {
0007c2  4605              MOV      r5,r0
0007c4  460c              MOV      r4,r1
;;;1052     u16_t len;
;;;1053     struct netif *netif;
;;;1054     u32_t *opts;
;;;1055   
;;;1056     /** @bug Exclude retransmitted segments from this count. */
;;;1057     snmp_inc_tcpoutsegs();
;;;1058   
;;;1059     /* The TCP header has already been constructed, but the ackno and
;;;1060      wnd fields remain. */
;;;1061     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
0007c6  6aa0              LDR      r0,[r4,#0x28]
0007c8  f7fffffe          BL       lwip_htonl
0007cc  6929              LDR      r1,[r5,#0x10]
0007ce  6088              STR      r0,[r1,#8]
;;;1062   
;;;1063     /* advertise our receive window size in this TCP segment */
;;;1064     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
0007d0  8de0              LDRH     r0,[r4,#0x2e]
0007d2  f7fffffe          BL       lwip_htons
0007d6  6929              LDR      r1,[r5,#0x10]
0007d8  81c8              STRH     r0,[r1,#0xe]
;;;1065   
;;;1066     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
0007da  8de1              LDRH     r1,[r4,#0x2e]
0007dc  6aa0              LDR      r0,[r4,#0x28]
0007de  4408              ADD      r0,r0,r1
0007e0  6320              STR      r0,[r4,#0x30]
;;;1067   
;;;1068     /* Add any requested options.  NB MSS option is only set on SYN
;;;1069        packets, so ignore it here */
;;;1070     opts = (u32_t *)(void *)(seg->tcphdr + 1);
0007e2  6928              LDR      r0,[r5,#0x10]
0007e4  f1000814          ADD      r8,r0,#0x14
;;;1071     if (seg->flags & TF_SEG_OPTS_MSS) {
0007e8  7b28              LDRB     r0,[r5,#0xc]
0007ea  f0000001          AND      r0,r0,#1
0007ee  b170              CBZ      r0,|L1.2062|
;;;1072       u16_t mss;
;;;1073   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1074       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
0007f0  1d21              ADDS     r1,r4,#4
0007f2  f24050b4          MOV      r0,#0x5b4
0007f6  f7fffffe          BL       tcp_eff_send_mss
0007fa  4681              MOV      r9,r0
;;;1075   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1076       mss = TCP_MSS;
;;;1077   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1078       *opts = TCP_BUILD_MSS_OPTION(mss);
0007fc  f0497001          ORR      r0,r9,#0x2040000
000800  f7fffffe          BL       lwip_htonl
000804  f8c80000          STR      r0,[r8,#0]
;;;1079       opts += 1;
000808  f1080804          ADD      r8,r8,#4
;;;1080     }
00080c  bf00              NOP      
                  |L1.2062|
;;;1081   #if LWIP_TCP_TIMESTAMPS
;;;1082     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1083   
;;;1084     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1085       tcp_build_timestamp_option(pcb, opts);
;;;1086       opts += 3;
;;;1087     }
;;;1088   #endif
;;;1089   
;;;1090     /* Set retransmission timer running if it is not currently enabled 
;;;1091        This must be set before checking the route. */
;;;1092     if (pcb->rtime == -1) {
00080e  f9b40034          LDRSH    r0,[r4,#0x34]
000812  1c40              ADDS     r0,r0,#1
000814  b908              CBNZ     r0,|L1.2074|
;;;1093       pcb->rtime = 0;
000816  2000              MOVS     r0,#0
000818  86a0              STRH     r0,[r4,#0x34]
                  |L1.2074|
;;;1094     }
;;;1095   
;;;1096     /* If we don't have a local IP address, we get one by
;;;1097        calling ip_route(). */
;;;1098     if (ip_addr_isany(&(pcb->local_ip))) {
00081a  b10c              CBZ      r4,|L1.2080|
00081c  6820              LDR      r0,[r4,#0]
00081e  b940              CBNZ     r0,|L1.2098|
                  |L1.2080|
;;;1099       netif = ip_route(&(pcb->remote_ip));
000820  1d20              ADDS     r0,r4,#4
000822  f7fffffe          BL       ip_route
000826  4606              MOV      r6,r0
;;;1100       if (netif == NULL) {
000828  b90e              CBNZ     r6,|L1.2094|
                  |L1.2090|
;;;1101         return;
;;;1102       }
;;;1103       ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;1104     }
;;;1105   
;;;1106     if (pcb->rttest == 0) {
;;;1107       pcb->rttest = tcp_ticks;
;;;1108       pcb->rtseq = ntohl(seg->tcphdr->seqno);
;;;1109   
;;;1110       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1111     }
;;;1112     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1113             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1114             seg->len));
;;;1115   
;;;1116     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1117   
;;;1118     seg->p->len -= len;
;;;1119     seg->p->tot_len -= len;
;;;1120   
;;;1121     seg->p->payload = seg->tcphdr;
;;;1122   
;;;1123     seg->tcphdr->chksum = 0;
;;;1124   #if CHECKSUM_GEN_TCP
;;;1125   #if TCP_CHECKSUM_ON_COPY
;;;1126     {
;;;1127       u32_t acc;
;;;1128   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1129       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1130              &(pcb->remote_ip),
;;;1131              IP_PROTO_TCP, seg->p->tot_len);
;;;1132   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1133       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1134         LWIP_ASSERT("data included but not checksummed",
;;;1135           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1136       }
;;;1137   
;;;1138       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1139       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1140                &(pcb->remote_ip),
;;;1141                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1142       /* add payload checksum */
;;;1143       if (seg->chksum_swapped) {
;;;1144         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1145         seg->chksum_swapped = 0;
;;;1146       }
;;;1147       acc += (u16_t)~(seg->chksum);
;;;1148       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1149   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1150       if (chksum_slow != seg->tcphdr->chksum) {
;;;1151         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1152                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1153                     seg->tcphdr->chksum, chksum_slow));
;;;1154         seg->tcphdr->chksum = chksum_slow;
;;;1155       }
;;;1156   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1157     }
;;;1158   #else /* TCP_CHECKSUM_ON_COPY */
;;;1159     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1160            &(pcb->remote_ip),
;;;1161            IP_PROTO_TCP, seg->p->tot_len);
;;;1162   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1163   #endif /* CHECKSUM_GEN_TCP */
;;;1164     TCP_STATS_INC(tcp.xmit);
;;;1165   
;;;1166   #if LWIP_NETIF_HWADDRHINT
;;;1167     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1168         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1169   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1170     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1171         IP_PROTO_TCP);
;;;1172   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1173   }
00082a  e8bd87fc          POP      {r2-r10,pc}
                  |L1.2094|
00082e  6870              LDR      r0,[r6,#4]            ;1103
000830  6020              STR      r0,[r4,#0]            ;1103
                  |L1.2098|
000832  6ba0              LDR      r0,[r4,#0x38]         ;1106
000834  b948              CBNZ     r0,|L1.2122|
000836  48fe              LDR      r0,|L1.3120|
000838  6800              LDR      r0,[r0,#0]            ;1107  ; tcp_ticks
00083a  63a0              STR      r0,[r4,#0x38]         ;1107
00083c  6929              LDR      r1,[r5,#0x10]         ;1108
00083e  6848              LDR      r0,[r1,#4]            ;1108
000840  f7fffffe          BL       lwip_ntohl
000844  63e0              STR      r0,[r4,#0x3c]         ;1108
000846  bf00              NOP                            ;1110
000848  bf00              NOP                            ;1110
                  |L1.2122|
00084a  bf00              NOP                            ;1112
00084c  bf00              NOP                            ;1112
00084e  8a28              LDRH     r0,[r5,#0x10]         ;1116
000850  6869              LDR      r1,[r5,#4]            ;1116
000852  8889              LDRH     r1,[r1,#4]            ;1116
000854  1a40              SUBS     r0,r0,r1              ;1116
000856  b287              UXTH     r7,r0                 ;1116
000858  6868              LDR      r0,[r5,#4]            ;1118
00085a  8940              LDRH     r0,[r0,#0xa]          ;1118
00085c  1bc0              SUBS     r0,r0,r7              ;1118
00085e  6869              LDR      r1,[r5,#4]            ;1118
000860  8148              STRH     r0,[r1,#0xa]          ;1118
000862  6868              LDR      r0,[r5,#4]            ;1119
000864  8900              LDRH     r0,[r0,#8]            ;1119
000866  1bc0              SUBS     r0,r0,r7              ;1119
000868  6869              LDR      r1,[r5,#4]            ;1119
00086a  8108              STRH     r0,[r1,#8]            ;1119
00086c  6869              LDR      r1,[r5,#4]            ;1121
00086e  6928              LDR      r0,[r5,#0x10]         ;1121
000870  6048              STR      r0,[r1,#4]            ;1121
000872  2000              MOVS     r0,#0                 ;1123
000874  6929              LDR      r1,[r5,#0x10]         ;1123
000876  8208              STRH     r0,[r1,#0x10]         ;1123
000878  2106              MOVS     r1,#6                 ;1170
00087a  7a60              LDRB     r0,[r4,#9]            ;1170
00087c  e9cd0100          STRD     r0,r1,[sp,#0]         ;1170
000880  7aa3              LDRB     r3,[r4,#0xa]          ;1170
000882  1d22              ADDS     r2,r4,#4              ;1170
000884  4621              MOV      r1,r4                 ;1170
000886  6868              LDR      r0,[r5,#4]            ;1170
000888  f7fffffe          BL       ip_output
00088c  bf00              NOP      
00088e  e7cc              B        |L1.2090|
;;;1174   
                          ENDP

                  tcp_output PROC
;;;898    err_t
;;;899    tcp_output(struct tcp_pcb *pcb)
000890  e92d47f0          PUSH     {r4-r10,lr}
;;;900    {
000894  4604              MOV      r4,r0
;;;901      struct tcp_seg *seg, *useg;
;;;902      u32_t wnd, snd_nxt;
;;;903    #if TCP_CWND_DEBUG
;;;904      s16_t i = 0;
;;;905    #endif /* TCP_CWND_DEBUG */
;;;906    
;;;907      /* pcb->state LISTEN not allowed here */
;;;908      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000896  bf00              NOP      
000898  bf00              NOP      
;;;909        pcb->state != LISTEN);
;;;910    
;;;911      /* First, check if we are invoked by the TCP input processing
;;;912         code. If so, we do not output anything. Instead, we rely on the
;;;913         input processing code to call us when input processing is done
;;;914         with. */
;;;915      if (tcp_input_pcb == pcb) {
00089a  48e6              LDR      r0,|L1.3124|
00089c  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
00089e  42a0              CMP      r0,r4
0008a0  d102              BNE      |L1.2216|
;;;916        return ERR_OK;
0008a2  2000              MOVS     r0,#0
                  |L1.2212|
;;;917      }
;;;918    
;;;919      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;920    
;;;921      seg = pcb->unsent;
;;;922    
;;;923      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;924       * because the ->unsent queue is empty or because the window does
;;;925       * not allow it), construct an empty ACK segment and send it.
;;;926       *
;;;927       * If data is to be sent, we will just piggyback the ACK (see below).
;;;928       */
;;;929      if (pcb->flags & TF_ACK_NOW &&
;;;930         (seg == NULL ||
;;;931          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;932         return tcp_send_empty_ack(pcb);
;;;933      }
;;;934    
;;;935      /* useg should point to last segment on unacked queue */
;;;936      useg = pcb->unacked;
;;;937      if (useg != NULL) {
;;;938        for (; useg->next != NULL; useg = useg->next);
;;;939      }
;;;940    
;;;941    #if TCP_OUTPUT_DEBUG
;;;942      if (seg == NULL) {
;;;943        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;944                                       (void*)pcb->unsent));
;;;945      }
;;;946    #endif /* TCP_OUTPUT_DEBUG */
;;;947    #if TCP_CWND_DEBUG
;;;948      if (seg == NULL) {
;;;949        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;950                                     ", cwnd %"U16_F", wnd %"U32_F
;;;951                                     ", seg == NULL, ack %"U32_F"\n",
;;;952                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;953      } else {
;;;954        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;955                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;956                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;957                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;958                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;959                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;960      }
;;;961    #endif /* TCP_CWND_DEBUG */
;;;962      /* data available and window allows it to be sent? */
;;;963      while (seg != NULL &&
;;;964             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;965        LWIP_ASSERT("RST not expected here!", 
;;;966                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;967        /* Stop sending if the nagle algorithm would prevent it
;;;968         * Don't stop:
;;;969         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;970         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;971         *   either seg->next != NULL or pcb->unacked == NULL;
;;;972         *   RST is no sent using tcp_write/tcp_output.
;;;973         */
;;;974        if((tcp_do_output_nagle(pcb) == 0) &&
;;;975          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;976          break;
;;;977        }
;;;978    #if TCP_CWND_DEBUG
;;;979        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;980                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;981                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;982                                pcb->lastack,
;;;983                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;984        ++i;
;;;985    #endif /* TCP_CWND_DEBUG */
;;;986    
;;;987        pcb->unsent = seg->next;
;;;988    
;;;989        if (pcb->state != SYN_SENT) {
;;;990          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;991          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;992        }
;;;993    
;;;994        tcp_output_segment(seg, pcb);
;;;995        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;996        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;997          pcb->snd_nxt = snd_nxt;
;;;998        }
;;;999        /* put segment on unacknowledged list if length > 0 */
;;;1000       if (TCP_TCPLEN(seg) > 0) {
;;;1001         seg->next = NULL;
;;;1002         /* unacked list is empty? */
;;;1003         if (pcb->unacked == NULL) {
;;;1004           pcb->unacked = seg;
;;;1005           useg = seg;
;;;1006         /* unacked list is not empty? */
;;;1007         } else {
;;;1008           /* In the case of fast retransmit, the packet should not go to the tail
;;;1009            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1010            * this case. -STJ Jul 27, 2004 */
;;;1011           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1012             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1013             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1014             while (*cur_seg &&
;;;1015               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1016                 cur_seg = &((*cur_seg)->next );
;;;1017             }
;;;1018             seg->next = (*cur_seg);
;;;1019             (*cur_seg) = seg;
;;;1020           } else {
;;;1021             /* add segment to tail of unacked list */
;;;1022             useg->next = seg;
;;;1023             useg = useg->next;
;;;1024           }
;;;1025         }
;;;1026       /* do not queue empty segments on the unacked list */
;;;1027       } else {
;;;1028         tcp_seg_free(seg);
;;;1029       }
;;;1030       seg = pcb->unsent;
;;;1031     }
;;;1032   #if TCP_OVERSIZE
;;;1033     if (pcb->unsent == NULL) {
;;;1034       /* last unsent has been removed, reset unsent_oversize */
;;;1035       pcb->unsent_oversize = 0;
;;;1036     }
;;;1037   #endif /* TCP_OVERSIZE */
;;;1038   
;;;1039     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1040     return ERR_OK;
;;;1041   }
0008a4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.2216|
0008a8  f8b40060          LDRH     r0,[r4,#0x60]         ;919
0008ac  f8b4104c          LDRH     r1,[r4,#0x4c]         ;919
0008b0  4288              CMP      r0,r1                 ;919
0008b2  da02              BGE      |L1.2234|
0008b4  f8b40060          LDRH     r0,[r4,#0x60]         ;919
0008b8  e001              B        |L1.2238|
                  |L1.2234|
0008ba  f8b4004c          LDRH     r0,[r4,#0x4c]         ;919
                  |L1.2238|
0008be  4681              MOV      r9,r0                 ;919
0008c0  6ee5              LDR      r5,[r4,#0x6c]         ;921
0008c2  7fa0              LDRB     r0,[r4,#0x1e]         ;929
0008c4  f0000002          AND      r0,r0,#2              ;929
0008c8  b170              CBZ      r0,|L1.2280|
0008ca  b14d              CBZ      r5,|L1.2272|
0008cc  6929              LDR      r1,[r5,#0x10]         ;931
0008ce  6848              LDR      r0,[r1,#4]            ;931
0008d0  f7fffffe          BL       lwip_ntohl
0008d4  6ca1              LDR      r1,[r4,#0x48]         ;931
0008d6  1a40              SUBS     r0,r0,r1              ;931
0008d8  8929              LDRH     r1,[r5,#8]            ;931
0008da  4408              ADD      r0,r0,r1              ;931
0008dc  4548              CMP      r0,r9                 ;931
0008de  d903              BLS      |L1.2280|
                  |L1.2272|
0008e0  4620              MOV      r0,r4                 ;932
0008e2  f7fffffe          BL       tcp_send_empty_ack
0008e6  e7dd              B        |L1.2212|
                  |L1.2280|
0008e8  6f26              LDR      r6,[r4,#0x70]         ;936
0008ea  b126              CBZ      r6,|L1.2294|
0008ec  e000              B        |L1.2288|
                  |L1.2286|
0008ee  6836              LDR      r6,[r6,#0]            ;938
                  |L1.2288|
0008f0  6830              LDR      r0,[r6,#0]            ;938
0008f2  2800              CMP      r0,#0                 ;938
0008f4  d1fb              BNE      |L1.2286|
                  |L1.2294|
0008f6  e091              B        |L1.2588|
                  |L1.2296|
0008f8  bf00              NOP                            ;965
0008fa  6929              LDR      r1,[r5,#0x10]         ;965
0008fc  8988              LDRH     r0,[r1,#0xc]          ;965
0008fe  f7fffffe          BL       lwip_ntohs
000902  bf00              NOP                            ;965
000904  6f20              LDR      r0,[r4,#0x70]         ;974
000906  b1a0              CBZ      r0,|L1.2354|
000908  7fa0              LDRB     r0,[r4,#0x1e]         ;974
00090a  f0000044          AND      r0,r0,#0x44           ;974
00090e  b980              CBNZ     r0,|L1.2354|
000910  6ee0              LDR      r0,[r4,#0x6c]         ;974
000912  b138              CBZ      r0,|L1.2340|
000914  6ee0              LDR      r0,[r4,#0x6c]         ;974
000916  6800              LDR      r0,[r0,#0]            ;974
000918  b958              CBNZ     r0,|L1.2354|
00091a  6ee0              LDR      r0,[r4,#0x6c]         ;974
00091c  8900              LDRH     r0,[r0,#8]            ;974
00091e  8ee1              LDRH     r1,[r4,#0x36]         ;974
000920  4288              CMP      r0,r1                 ;974
000922  da06              BGE      |L1.2354|
                  |L1.2340|
000924  f8b40066          LDRH     r0,[r4,#0x66]         ;974
000928  b118              CBZ      r0,|L1.2354|
00092a  f8b40068          LDRH     r0,[r4,#0x68]         ;974
00092e  2808              CMP      r0,#8                 ;974
000930  db01              BLT      |L1.2358|
                  |L1.2354|
000932  2001              MOVS     r0,#1                 ;974
000934  e000              B        |L1.2360|
                  |L1.2358|
000936  2000              MOVS     r0,#0                 ;974
                  |L1.2360|
000938  b920              CBNZ     r0,|L1.2372|
00093a  7fa0              LDRB     r0,[r4,#0x1e]         ;975
00093c  f00000a0          AND      r0,r0,#0xa0           ;975
000940  b900              CBNZ     r0,|L1.2372|
000942  e077              B        |L1.2612|
                  |L1.2372|
000944  6828              LDR      r0,[r5,#0]            ;987
000946  66e0              STR      r0,[r4,#0x6c]         ;987
000948  7e20              LDRB     r0,[r4,#0x18]         ;989
00094a  2802              CMP      r0,#2                 ;989
00094c  d00b              BEQ      |L1.2406|
00094e  2010              MOVS     r0,#0x10              ;990
000950  f7fffffe          BL       lwip_htons
000954  6929              LDR      r1,[r5,#0x10]         ;990
000956  8989              LDRH     r1,[r1,#0xc]          ;990
000958  4308              ORRS     r0,r0,r1              ;990
00095a  6929              LDR      r1,[r5,#0x10]         ;990
00095c  8188              STRH     r0,[r1,#0xc]          ;990
00095e  7fa0              LDRB     r0,[r4,#0x1e]         ;991
000960  f0200003          BIC      r0,r0,#3              ;991
000964  77a0              STRB     r0,[r4,#0x1e]         ;991
                  |L1.2406|
000966  4621              MOV      r1,r4                 ;994
000968  4628              MOV      r0,r5                 ;994
00096a  f7fffffe          BL       tcp_output_segment
00096e  6929              LDR      r1,[r5,#0x10]         ;995
000970  6848              LDR      r0,[r1,#4]            ;995
000972  f7fffffe          BL       lwip_ntohl
000976  4607              MOV      r7,r0                 ;995
000978  6929              LDR      r1,[r5,#0x10]         ;995
00097a  8988              LDRH     r0,[r1,#0xc]          ;995
00097c  f7fffffe          BL       lwip_ntohs
000980  f0000003          AND      r0,r0,#3              ;995
000984  b108              CBZ      r0,|L1.2442|
000986  2001              MOVS     r0,#1                 ;995
000988  e000              B        |L1.2444|
                  |L1.2442|
00098a  2000              MOVS     r0,#0                 ;995
                  |L1.2444|
00098c  8929              LDRH     r1,[r5,#8]            ;995
00098e  4408              ADD      r0,r0,r1              ;995
000990  eb070800          ADD      r8,r7,r0              ;995
000994  6d20              LDR      r0,[r4,#0x50]         ;996
000996  ebb00008          SUBS     r0,r0,r8              ;996
00099a  d501              BPL      |L1.2464|
00099c  f8c48050          STR      r8,[r4,#0x50]         ;997
                  |L1.2464|
0009a0  6929              LDR      r1,[r5,#0x10]         ;1000
0009a2  8988              LDRH     r0,[r1,#0xc]          ;1000
0009a4  f7fffffe          BL       lwip_ntohs
0009a8  f0000003          AND      r0,r0,#3              ;1000
0009ac  b108              CBZ      r0,|L1.2482|
0009ae  2001              MOVS     r0,#1                 ;1000
0009b0  e000              B        |L1.2484|
                  |L1.2482|
0009b2  2000              MOVS     r0,#0                 ;1000
                  |L1.2484|
0009b4  8929              LDRH     r1,[r5,#8]            ;1000
0009b6  4408              ADD      r0,r0,r1              ;1000
0009b8  2800              CMP      r0,#0                 ;1000
0009ba  dd2b              BLE      |L1.2580|
0009bc  2000              MOVS     r0,#0                 ;1001
0009be  6028              STR      r0,[r5,#0]            ;1001
0009c0  6f20              LDR      r0,[r4,#0x70]         ;1003
0009c2  b910              CBNZ     r0,|L1.2506|
0009c4  6725              STR      r5,[r4,#0x70]         ;1004
0009c6  462e              MOV      r6,r5                 ;1005
0009c8  e027              B        |L1.2586|
                  |L1.2506|
0009ca  6929              LDR      r1,[r5,#0x10]         ;1011
0009cc  6848              LDR      r0,[r1,#4]            ;1011
0009ce  f7fffffe          BL       lwip_ntohl
0009d2  4607              MOV      r7,r0                 ;1011
0009d4  6931              LDR      r1,[r6,#0x10]         ;1011
0009d6  6848              LDR      r0,[r1,#4]            ;1011
0009d8  f7fffffe          BL       lwip_ntohl
0009dc  1a38              SUBS     r0,r7,r0              ;1011
0009de  d516              BPL      |L1.2574|
0009e0  f1040770          ADD      r7,r4,#0x70           ;1013
0009e4  e000              B        |L1.2536|
                  |L1.2534|
0009e6  683f              LDR      r7,[r7,#0]            ;1016
                  |L1.2536|
0009e8  6838              LDR      r0,[r7,#0]            ;1014
0009ea  b160              CBZ      r0,|L1.2566|
0009ec  6839              LDR      r1,[r7,#0]            ;1015
0009ee  6909              LDR      r1,[r1,#0x10]         ;1015
0009f0  6848              LDR      r0,[r1,#4]            ;1015
0009f2  f7fffffe          BL       lwip_ntohl
0009f6  4682              MOV      r10,r0                ;1015
0009f8  6929              LDR      r1,[r5,#0x10]         ;1015
0009fa  6848              LDR      r0,[r1,#4]            ;1015
0009fc  f7fffffe          BL       lwip_ntohl
000a00  ebba0000          SUBS     r0,r10,r0             ;1015
000a04  d4ef              BMI      |L1.2534|
                  |L1.2566|
000a06  6838              LDR      r0,[r7,#0]            ;1018
000a08  6028              STR      r0,[r5,#0]            ;1018
000a0a  603d              STR      r5,[r7,#0]            ;1019
000a0c  e005              B        |L1.2586|
                  |L1.2574|
000a0e  6035              STR      r5,[r6,#0]            ;1022
000a10  6836              LDR      r6,[r6,#0]            ;1023
000a12  e002              B        |L1.2586|
                  |L1.2580|
000a14  4628              MOV      r0,r5                 ;1028
000a16  f7fffffe          BL       tcp_seg_free
                  |L1.2586|
000a1a  6ee5              LDR      r5,[r4,#0x6c]         ;1030
                  |L1.2588|
000a1c  b155              CBZ      r5,|L1.2612|
000a1e  6929              LDR      r1,[r5,#0x10]         ;964
000a20  6848              LDR      r0,[r1,#4]            ;964
000a22  f7fffffe          BL       lwip_ntohl
000a26  6ca1              LDR      r1,[r4,#0x48]         ;964
000a28  1a40              SUBS     r0,r0,r1              ;964
000a2a  8929              LDRH     r1,[r5,#8]            ;964
000a2c  4408              ADD      r0,r0,r1              ;964
000a2e  4548              CMP      r0,r9                 ;964
000a30  f67faf62          BLS      |L1.2296|
                  |L1.2612|
000a34  bf00              NOP                            ;976
000a36  6ee0              LDR      r0,[r4,#0x6c]         ;1033
000a38  b910              CBNZ     r0,|L1.2624|
000a3a  2000              MOVS     r0,#0                 ;1035
000a3c  f8a4006a          STRH     r0,[r4,#0x6a]         ;1035
                  |L1.2624|
000a40  7fa0              LDRB     r0,[r4,#0x1e]         ;1039
000a42  f0200080          BIC      r0,r0,#0x80           ;1039
000a46  77a0              STRB     r0,[r4,#0x1e]         ;1039
000a48  2000              MOVS     r0,#0                 ;1040
000a4a  e72b              B        |L1.2212|
;;;1042   
                          ENDP

                  tcp_rst PROC
;;;1195   void
;;;1196   tcp_rst(u32_t seqno, u32_t ackno,
000a4c  e92d5ffc          PUSH     {r2-r12,lr}
;;;1197     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1198     u16_t local_port, u16_t remote_port)
;;;1199   {
000a50  4681              MOV      r9,r0
000a52  460e              MOV      r6,r1
000a54  4617              MOV      r7,r2
000a56  4698              MOV      r8,r3
000a58  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
;;;1200     struct pbuf *p;
;;;1201     struct tcp_hdr *tcphdr;
;;;1202     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000a5c  2200              MOVS     r2,#0
000a5e  2114              MOVS     r1,#0x14
000a60  2001              MOVS     r0,#1
000a62  f7fffffe          BL       pbuf_alloc
000a66  4605              MOV      r5,r0
;;;1203     if (p == NULL) {
000a68  b91d              CBNZ     r5,|L1.2674|
;;;1204         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
000a6a  bf00              NOP      
000a6c  bf00              NOP      
                  |L1.2670|
;;;1205         return;
;;;1206     }
;;;1207     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
;;;1208                 (p->len >= sizeof(struct tcp_hdr)));
;;;1209   
;;;1210     tcphdr = (struct tcp_hdr *)p->payload;
;;;1211     tcphdr->src = htons(local_port);
;;;1212     tcphdr->dest = htons(remote_port);
;;;1213     tcphdr->seqno = htonl(seqno);
;;;1214     tcphdr->ackno = htonl(ackno);
;;;1215     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
;;;1216     tcphdr->wnd = PP_HTONS(TCP_WND);
;;;1217     tcphdr->chksum = 0;
;;;1218     tcphdr->urgp = 0;
;;;1219   
;;;1220   #if CHECKSUM_GEN_TCP
;;;1221     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
;;;1222                 IP_PROTO_TCP, p->tot_len);
;;;1223   #endif
;;;1224     TCP_STATS_INC(tcp.xmit);
;;;1225     snmp_inc_tcpoutrsts();
;;;1226      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1227     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
;;;1228     pbuf_free(p);
;;;1229     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1230   }
000a6e  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.2674|
000a72  bf00              NOP                            ;1207
000a74  bf00              NOP                            ;1207
000a76  686c              LDR      r4,[r5,#4]            ;1210
000a78  4650              MOV      r0,r10                ;1211
000a7a  f7fffffe          BL       lwip_htons
000a7e  8020              STRH     r0,[r4,#0]            ;1211
000a80  4658              MOV      r0,r11                ;1212
000a82  f7fffffe          BL       lwip_htons
000a86  8060              STRH     r0,[r4,#2]            ;1212
000a88  4648              MOV      r0,r9                 ;1213
000a8a  f7fffffe          BL       lwip_htonl
000a8e  6060              STR      r0,[r4,#4]            ;1213
000a90  4630              MOV      r0,r6                 ;1214
000a92  f7fffffe          BL       lwip_htonl
000a96  60a0              STR      r0,[r4,#8]            ;1214
000a98  f2450014          MOV      r0,#0x5014            ;1215
000a9c  f7fffffe          BL       lwip_htons
000aa0  81a0              STRH     r0,[r4,#0xc]          ;1215
000aa2  f24d0016          MOV      r0,#0xd016            ;1216
000aa6  81e0              STRH     r0,[r4,#0xe]          ;1216
000aa8  2000              MOVS     r0,#0                 ;1217
000aaa  8220              STRH     r0,[r4,#0x10]         ;1217
000aac  8260              STRH     r0,[r4,#0x12]         ;1218
000aae  2006              MOVS     r0,#6                 ;1227
000ab0  2100              MOVS     r1,#0                 ;1227
000ab2  23ff              MOVS     r3,#0xff              ;1227
000ab4  4642              MOV      r2,r8                 ;1227
000ab6  e9cd1000          STRD     r1,r0,[sp,#0]         ;1227
000aba  4639              MOV      r1,r7                 ;1227
000abc  4628              MOV      r0,r5                 ;1227
000abe  f7fffffe          BL       ip_output
000ac2  4628              MOV      r0,r5                 ;1228
000ac4  f7fffffe          BL       pbuf_free
000ac8  bf00              NOP                            ;1229
000aca  bf00              NOP                            ;1229
000acc  bf00              NOP      
000ace  e7ce              B        |L1.2670|
;;;1231   
                          ENDP

                  tcp_rexmit_rto PROC
;;;1239   void
;;;1240   tcp_rexmit_rto(struct tcp_pcb *pcb)
000ad0  b570              PUSH     {r4-r6,lr}
;;;1241   {
000ad2  4604              MOV      r4,r0
;;;1242     struct tcp_seg *seg;
;;;1243   
;;;1244     if (pcb->unacked == NULL) {
000ad4  6f20              LDR      r0,[r4,#0x70]
000ad6  b900              CBNZ     r0,|L1.2778|
                  |L1.2776|
;;;1245       return;
;;;1246     }
;;;1247   
;;;1248     /* Move all unacked segments to the head of the unsent queue */
;;;1249     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
;;;1250     /* concatenate unsent queue after unacked queue */
;;;1251     seg->next = pcb->unsent;
;;;1252     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1253     pcb->unsent = pcb->unacked;
;;;1254     /* unacked queue is now empty */
;;;1255     pcb->unacked = NULL;
;;;1256     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1257   
;;;1258     /* increment number of retransmissions */
;;;1259     ++pcb->nrtx;
;;;1260   
;;;1261     /* Don't take any RTT measurements after retransmitting. */
;;;1262     pcb->rttest = 0;
;;;1263   
;;;1264     /* Do the actual retransmission */
;;;1265     tcp_output(pcb);
;;;1266   }
000ad8  bd70              POP      {r4-r6,pc}
                  |L1.2778|
000ada  6f25              LDR      r5,[r4,#0x70]         ;1249
000adc  e000              B        |L1.2784|
                  |L1.2782|
000ade  682d              LDR      r5,[r5,#0]            ;1249
                  |L1.2784|
000ae0  6828              LDR      r0,[r5,#0]            ;1249
000ae2  2800              CMP      r0,#0                 ;1249
000ae4  d1fb              BNE      |L1.2782|
000ae6  6ee0              LDR      r0,[r4,#0x6c]         ;1251
000ae8  6028              STR      r0,[r5,#0]            ;1251
000aea  6f20              LDR      r0,[r4,#0x70]         ;1253
000aec  66e0              STR      r0,[r4,#0x6c]         ;1253
000aee  2000              MOVS     r0,#0                 ;1255
000af0  6720              STR      r0,[r4,#0x70]         ;1255
000af2  f8940046          LDRB     r0,[r4,#0x46]         ;1259
000af6  1c40              ADDS     r0,r0,#1              ;1259
000af8  f8840046          STRB     r0,[r4,#0x46]         ;1259
000afc  2000              MOVS     r0,#0                 ;1262
000afe  63a0              STR      r0,[r4,#0x38]         ;1262
000b00  4620              MOV      r0,r4                 ;1265
000b02  f7fffffe          BL       tcp_output
000b06  bf00              NOP      
000b08  e7e6              B        |L1.2776|
;;;1267   
                          ENDP

                  tcp_rexmit PROC
;;;1275   void
;;;1276   tcp_rexmit(struct tcp_pcb *pcb)
000b0a  e92d41f0          PUSH     {r4-r8,lr}
;;;1277   {
000b0e  4604              MOV      r4,r0
;;;1278     struct tcp_seg *seg;
;;;1279     struct tcp_seg **cur_seg;
;;;1280   
;;;1281     if (pcb->unacked == NULL) {
000b10  6f20              LDR      r0,[r4,#0x70]
000b12  b908              CBNZ     r0,|L1.2840|
                  |L1.2836|
;;;1282       return;
;;;1283     }
;;;1284   
;;;1285     /* Move the first unacked segment to the unsent queue */
;;;1286     /* Keep the unsent queue sorted. */
;;;1287     seg = pcb->unacked;
;;;1288     pcb->unacked = seg->next;
;;;1289   
;;;1290     cur_seg = &(pcb->unsent);
;;;1291     while (*cur_seg &&
;;;1292       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1293         cur_seg = &((*cur_seg)->next );
;;;1294     }
;;;1295     seg->next = *cur_seg;
;;;1296     *cur_seg = seg;
;;;1297   #if TCP_OVERSIZE
;;;1298     if (seg->next == NULL) {
;;;1299       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1300       pcb->unsent_oversize = 0;
;;;1301     }
;;;1302   #endif /* TCP_OVERSIZE */
;;;1303   
;;;1304     ++pcb->nrtx;
;;;1305   
;;;1306     /* Don't take any rtt measurements after retransmitting. */
;;;1307     pcb->rttest = 0;
;;;1308   
;;;1309     /* Do the actual retransmission. */
;;;1310     snmp_inc_tcpretranssegs();
;;;1311     /* No need to call tcp_output: we are always called from tcp_input()
;;;1312        and thus tcp_output directly returns. */
;;;1313   }
000b14  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2840|
000b18  6f25              LDR      r5,[r4,#0x70]         ;1287
000b1a  6828              LDR      r0,[r5,#0]            ;1288
000b1c  6720              STR      r0,[r4,#0x70]         ;1288
000b1e  f104066c          ADD      r6,r4,#0x6c           ;1290
000b22  e000              B        |L1.2854|
                  |L1.2852|
000b24  6836              LDR      r6,[r6,#0]            ;1293
                  |L1.2854|
000b26  6830              LDR      r0,[r6,#0]            ;1291
000b28  b158              CBZ      r0,|L1.2882|
000b2a  6831              LDR      r1,[r6,#0]            ;1292
000b2c  6909              LDR      r1,[r1,#0x10]         ;1292
000b2e  6848              LDR      r0,[r1,#4]            ;1292
000b30  f7fffffe          BL       lwip_ntohl
000b34  4607              MOV      r7,r0                 ;1292
000b36  6929              LDR      r1,[r5,#0x10]         ;1292
000b38  6848              LDR      r0,[r1,#4]            ;1292
000b3a  f7fffffe          BL       lwip_ntohl
000b3e  1a38              SUBS     r0,r7,r0              ;1292
000b40  d4f0              BMI      |L1.2852|
                  |L1.2882|
000b42  6830              LDR      r0,[r6,#0]            ;1295
000b44  6028              STR      r0,[r5,#0]            ;1295
000b46  6035              STR      r5,[r6,#0]            ;1296
000b48  6828              LDR      r0,[r5,#0]            ;1298
000b4a  b910              CBNZ     r0,|L1.2898|
000b4c  2000              MOVS     r0,#0                 ;1300
000b4e  f8a4006a          STRH     r0,[r4,#0x6a]         ;1300
                  |L1.2898|
000b52  f8940046          LDRB     r0,[r4,#0x46]         ;1304
000b56  1c40              ADDS     r0,r0,#1              ;1304
000b58  f8840046          STRB     r0,[r4,#0x46]         ;1304
000b5c  2000              MOVS     r0,#0                 ;1307
000b5e  63a0              STR      r0,[r4,#0x38]         ;1307
000b60  bf00              NOP      
000b62  e7d7              B        |L1.2836|
;;;1314   
                          ENDP

                  tcp_rexmit_fast PROC
;;;1321   void 
;;;1322   tcp_rexmit_fast(struct tcp_pcb *pcb)
000b64  b510              PUSH     {r4,lr}
;;;1323   {
000b66  4604              MOV      r4,r0
;;;1324     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000b68  6f20              LDR      r0,[r4,#0x70]
000b6a  b3b0              CBZ      r0,|L1.3034|
000b6c  7fa0              LDRB     r0,[r4,#0x1e]
000b6e  f0000004          AND      r0,r0,#4
000b72  bb90              CBNZ     r0,|L1.3034|
;;;1325       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1326       LWIP_DEBUGF(TCP_FR_DEBUG, 
000b74  bf00              NOP      
000b76  bf00              NOP      
;;;1327                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1328                    "), fast retransmit %"U32_F"\n",
;;;1329                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1330                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1331       tcp_rexmit(pcb);
000b78  4620              MOV      r0,r4
000b7a  f7fffffe          BL       tcp_rexmit
;;;1332   
;;;1333       /* Set ssthresh to half of the minimum of the current
;;;1334        * cwnd and the advertised window */
;;;1335       if (pcb->cwnd > pcb->snd_wnd) {
000b7e  f8b4004c          LDRH     r0,[r4,#0x4c]
000b82  f8b41060          LDRH     r1,[r4,#0x60]
000b86  4288              CMP      r0,r1
000b88  dd07              BLE      |L1.2970|
;;;1336         pcb->ssthresh = pcb->snd_wnd / 2;
000b8a  f8b40060          LDRH     r0,[r4,#0x60]
000b8e  eb0071d0          ADD      r1,r0,r0,LSR #31
000b92  1049              ASRS     r1,r1,#1
000b94  f8a4104e          STRH     r1,[r4,#0x4e]
000b98  e006              B        |L1.2984|
                  |L1.2970|
;;;1337       } else {
;;;1338         pcb->ssthresh = pcb->cwnd / 2;
000b9a  f8b4004c          LDRH     r0,[r4,#0x4c]
000b9e  eb0071d0          ADD      r1,r0,r0,LSR #31
000ba2  1049              ASRS     r1,r1,#1
000ba4  f8a4104e          STRH     r1,[r4,#0x4e]
                  |L1.2984|
;;;1339       }
;;;1340       
;;;1341       /* The minimum value for ssthresh should be 2 MSS */
;;;1342       if (pcb->ssthresh < 2*pcb->mss) {
000ba8  f8b4004e          LDRH     r0,[r4,#0x4e]
000bac  8ee1              LDRH     r1,[r4,#0x36]
000bae  0049              LSLS     r1,r1,#1
000bb0  4288              CMP      r0,r1
000bb2  da06              BGE      |L1.3010|
;;;1343         LWIP_DEBUGF(TCP_FR_DEBUG, 
000bb4  bf00              NOP      
000bb6  bf00              NOP      
;;;1344                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1345                      " should be min 2 mss %"U16_F"...\n",
;;;1346                      pcb->ssthresh, 2*pcb->mss));
;;;1347         pcb->ssthresh = 2*pcb->mss;
000bb8  8ee0              LDRH     r0,[r4,#0x36]
000bba  0440              LSLS     r0,r0,#17
000bbc  0c00              LSRS     r0,r0,#16
000bbe  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L1.3010|
;;;1348       }
;;;1349       
;;;1350       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
000bc2  f8b4004e          LDRH     r0,[r4,#0x4e]
000bc6  8ee1              LDRH     r1,[r4,#0x36]
000bc8  2203              MOVS     r2,#3
000bca  fb020001          MLA      r0,r2,r1,r0
000bce  f8a4004c          STRH     r0,[r4,#0x4c]
;;;1351       pcb->flags |= TF_INFR;
000bd2  7fa0              LDRB     r0,[r4,#0x1e]
000bd4  f0400004          ORR      r0,r0,#4
000bd8  77a0              STRB     r0,[r4,#0x1e]
                  |L1.3034|
;;;1352     } 
;;;1353   }
000bda  bd10              POP      {r4,pc}
;;;1354   
                          ENDP

                  tcp_keepalive PROC
;;;1364   void
;;;1365   tcp_keepalive(struct tcp_pcb *pcb)
000bdc  e92d41fc          PUSH     {r2-r8,lr}
;;;1366   {
000be0  4604              MOV      r4,r0
;;;1367     struct pbuf *p;
;;;1368     struct tcp_hdr *tcphdr;
;;;1369   	(void)tcphdr;
;;;1370   
;;;1371     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
000be2  bf00              NOP      
000be4  bf00              NOP      
;;;1372                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1373                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1374   
;;;1375     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
000be6  bf00              NOP      
000be8  bf00              NOP      
;;;1376                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1377      
;;;1378     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
000bea  6d21              LDR      r1,[r4,#0x50]
000bec  1e48              SUBS     r0,r1,#1
000bee  f7fffffe          BL       lwip_htonl
000bf2  4607              MOV      r7,r0
000bf4  463b              MOV      r3,r7
000bf6  2200              MOVS     r2,#0
000bf8  4611              MOV      r1,r2
000bfa  4620              MOV      r0,r4
000bfc  f7fffffe          BL       tcp_output_alloc_header
000c00  4605              MOV      r5,r0
;;;1379     if(p == NULL) {
000c02  b91d              CBNZ     r5,|L1.3084|
;;;1380       LWIP_DEBUGF(TCP_DEBUG, 
000c04  bf00              NOP      
000c06  bf00              NOP      
                  |L1.3080|
;;;1381                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1382       return;
;;;1383     }
;;;1384     tcphdr = (struct tcp_hdr *)p->payload;
;;;1385   
;;;1386   #if CHECKSUM_GEN_TCP
;;;1387     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1388                                         IP_PROTO_TCP, p->tot_len);
;;;1389   #endif
;;;1390     TCP_STATS_INC(tcp.xmit);
;;;1391   
;;;1392     /* Send output to IP */
;;;1393   #if LWIP_NETIF_HWADDRHINT
;;;1394     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1395       &(pcb->addr_hint));
;;;1396   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1397     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1398   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1399   
;;;1400     pbuf_free(p);
;;;1401   
;;;1402     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1403                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1404   }
000c08  e8bd81fc          POP      {r2-r8,pc}
                  |L1.3084|
000c0c  686e              LDR      r6,[r5,#4]            ;1384
000c0e  2006              MOVS     r0,#6                 ;1397
000c10  2100              MOVS     r1,#0                 ;1397
000c12  e9cd1000          STRD     r1,r0,[sp,#0]         ;1397
000c16  7aa3              LDRB     r3,[r4,#0xa]          ;1397
000c18  1d22              ADDS     r2,r4,#4              ;1397
000c1a  4621              MOV      r1,r4                 ;1397
000c1c  4628              MOV      r0,r5                 ;1397
000c1e  f7fffffe          BL       ip_output
000c22  4628              MOV      r0,r5                 ;1400
000c24  f7fffffe          BL       pbuf_free
000c28  bf00              NOP                            ;1402
000c2a  bf00              NOP                            ;1402
000c2c  bf00              NOP      
000c2e  e7eb              B        |L1.3080|
                  |L1.3120|
                          DCD      tcp_ticks
                  |L1.3124|
                          DCD      tcp_input_pcb
                          ENDP

                  tcp_zero_window_probe PROC
;;;1415   void
;;;1416   tcp_zero_window_probe(struct tcp_pcb *pcb)
000c38  e92d47fc          PUSH     {r2-r10,lr}
;;;1417   {
000c3c  4605              MOV      r5,r0
;;;1418     struct pbuf *p;
;;;1419     struct tcp_hdr *tcphdr;
;;;1420     struct tcp_seg *seg;
;;;1421     u16_t len;
;;;1422     u8_t is_fin;
;;;1423   
;;;1424     LWIP_DEBUGF(TCP_DEBUG, 
000c3e  bf00              NOP      
000c40  bf00              NOP      
;;;1425                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1426                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1427                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1428                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1429   
;;;1430     LWIP_DEBUGF(TCP_DEBUG, 
000c42  bf00              NOP      
000c44  bf00              NOP      
;;;1431                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1432                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1433                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1434   
;;;1435     seg = pcb->unacked;
000c46  6f2c              LDR      r4,[r5,#0x70]
;;;1436   
;;;1437     if(seg == NULL) {
000c48  b904              CBNZ     r4,|L1.3148|
;;;1438       seg = pcb->unsent;
000c4a  6eec              LDR      r4,[r5,#0x6c]
                  |L1.3148|
;;;1439     }
;;;1440     if(seg == NULL) {
000c4c  b90c              CBNZ     r4,|L1.3154|
                  |L1.3150|
;;;1441       return;
;;;1442     }
;;;1443   
;;;1444     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
;;;1445     /* we want to send one seqno: either FIN or data (no options) */
;;;1446     len = is_fin ? 0 : 1;
;;;1447   
;;;1448     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
;;;1449     if(p == NULL) {
;;;1450       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1451       return;
;;;1452     }
;;;1453     tcphdr = (struct tcp_hdr *)p->payload;
;;;1454   
;;;1455     if (is_fin) {
;;;1456       /* FIN segment, no data */
;;;1457       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
;;;1458     } else {
;;;1459       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1460       char *d = ((char *)p->payload + TCP_HLEN);
;;;1461       /* Depending on whether the segment has already been sent (unacked) or not
;;;1462          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1463          Ensure we copy the first TCP data byte: */
;;;1464       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;1465     }
;;;1466   
;;;1467   #if CHECKSUM_GEN_TCP
;;;1468     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1469                                         IP_PROTO_TCP, p->tot_len);
;;;1470   #endif
;;;1471     TCP_STATS_INC(tcp.xmit);
;;;1472   
;;;1473     /* Send output to IP */
;;;1474   #if LWIP_NETIF_HWADDRHINT
;;;1475     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1476       &(pcb->addr_hint));
;;;1477   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1478     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1479   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1480   
;;;1481     pbuf_free(p);
;;;1482   
;;;1483     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1484                             " ackno %"U32_F".\n",
;;;1485                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1486   }
000c4e  e8bd87fc          POP      {r2-r10,pc}
                  |L1.3154|
000c52  6921              LDR      r1,[r4,#0x10]         ;1444
000c54  8988              LDRH     r0,[r1,#0xc]          ;1444
000c56  f7fffffe          BL       lwip_ntohs
000c5a  f0000001          AND      r0,r0,#1              ;1444
000c5e  b118              CBZ      r0,|L1.3176|
000c60  8920              LDRH     r0,[r4,#8]            ;1444
000c62  b908              CBNZ     r0,|L1.3176|
000c64  2001              MOVS     r0,#1                 ;1444
000c66  e000              B        |L1.3178|
                  |L1.3176|
000c68  2000              MOVS     r0,#0                 ;1444
                  |L1.3178|
000c6a  4680              MOV      r8,r0                 ;1444
000c6c  f1b80f00          CMP      r8,#0                 ;1446
000c70  d101              BNE      |L1.3190|
000c72  2001              MOVS     r0,#1                 ;1446
000c74  e000              B        |L1.3192|
                  |L1.3190|
000c76  2000              MOVS     r0,#0                 ;1446
                  |L1.3192|
000c78  4681              MOV      r9,r0                 ;1446
000c7a  6920              LDR      r0,[r4,#0x10]         ;1448
000c7c  6843              LDR      r3,[r0,#4]            ;1448
000c7e  464a              MOV      r2,r9                 ;1448
000c80  2100              MOVS     r1,#0                 ;1448
000c82  4628              MOV      r0,r5                 ;1448
000c84  f7fffffe          BL       tcp_output_alloc_header
000c88  4606              MOV      r6,r0                 ;1448
000c8a  b916              CBNZ     r6,|L1.3218|
000c8c  bf00              NOP                            ;1450
000c8e  bf00              NOP                            ;1450
000c90  e7dd              B        |L1.3150|
                  |L1.3218|
000c92  6877              LDR      r7,[r6,#4]            ;1453
000c94  f1b80f00          CMP      r8,#0                 ;1455
000c98  d009              BEQ      |L1.3246|
000c9a  2011              MOVS     r0,#0x11              ;1457
000c9c  f7fffffe          BL       lwip_htons
000ca0  89b9              LDRH     r1,[r7,#0xc]          ;1457
000ca2  f24c02ff          MOV      r2,#0xc0ff            ;1457
000ca6  4011              ANDS     r1,r1,r2              ;1457
000ca8  4308              ORRS     r0,r0,r1              ;1457
000caa  81b8              STRH     r0,[r7,#0xc]          ;1457
000cac  e00d              B        |L1.3274|
                  |L1.3246|
000cae  6870              LDR      r0,[r6,#4]            ;1460
000cb0  f1000a14          ADD      r10,r0,#0x14          ;1460
000cb4  6861              LDR      r1,[r4,#4]            ;1464
000cb6  8909              LDRH     r1,[r1,#8]            ;1464
000cb8  8922              LDRH     r2,[r4,#8]            ;1464
000cba  1a89              SUBS     r1,r1,r2              ;1464
000cbc  b28b              UXTH     r3,r1                 ;1464
000cbe  2201              MOVS     r2,#1                 ;1464
000cc0  4651              MOV      r1,r10                ;1464
000cc2  6860              LDR      r0,[r4,#4]            ;1464
000cc4  f7fffffe          BL       pbuf_copy_partial
000cc8  bf00              NOP                            ;1465
                  |L1.3274|
000cca  2006              MOVS     r0,#6                 ;1478
000ccc  2100              MOVS     r1,#0                 ;1478
000cce  e9cd1000          STRD     r1,r0,[sp,#0]         ;1478
000cd2  7aab              LDRB     r3,[r5,#0xa]          ;1478
000cd4  1d2a              ADDS     r2,r5,#4              ;1478
000cd6  4629              MOV      r1,r5                 ;1478
000cd8  4630              MOV      r0,r6                 ;1478
000cda  f7fffffe          BL       ip_output
000cde  4630              MOV      r0,r6                 ;1481
000ce0  f7fffffe          BL       pbuf_free
000ce4  bf00              NOP                            ;1483
000ce6  bf00              NOP                            ;1483
000ce8  bf00              NOP      
000cea  e7b0              B        |L1.3150|
;;;1487   #endif /* LWIP_TCP */
                          ENDP

