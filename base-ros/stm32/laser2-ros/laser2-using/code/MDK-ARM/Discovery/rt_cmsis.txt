; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\rt_cmsis.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\rt_cmsis.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\rt_cmsis.crf ..\..\libraries\rtx-v4.73\SRC\rt_CMSIS.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_ms2tick PROC
;;;426    /// Convert timeout in millisec to system ticks
;;;427    static uint32_t rt_ms2tick (uint32_t millisec) {
000000  4601              MOV      r1,r0
;;;428      uint32_t tick;
;;;429    
;;;430      if (millisec == osWaitForever) return 0xFFFF; // Indefinite timeout
000002  1c48              ADDS     r0,r1,#1
000004  b910              CBNZ     r0,|L1.12|
000006  f64f70ff          MOV      r0,#0xffff
                  |L1.10|
;;;431      if (millisec > 4000000) return 0xFFFE;        // Max ticks supported
;;;432    
;;;433      tick = ((1000 * millisec) + os_clockrate - 1)  / os_clockrate;
;;;434      if (tick > 0xFFFE) return 0xFFFE;
;;;435      
;;;436      return tick;
;;;437    }
00000a  4770              BX       lr
                  |L1.12|
00000c  48fa              LDR      r0,|L1.1016|
00000e  4281              CMP      r1,r0                 ;431
000010  d902              BLS      |L1.24|
000012  f64f70fe          MOV      r0,#0xfffe            ;431
000016  e7f8              B        |L1.10|
                  |L1.24|
000018  48f8              LDR      r0,|L1.1020|
00001a  6800              LDR      r0,[r0,#0]            ;433  ; os_clockrate
00001c  f44f737a          MOV      r3,#0x3e8             ;433
000020  fb030001          MLA      r0,r3,r1,r0           ;433
000024  1e40              SUBS     r0,r0,#1              ;433
000026  4bf5              LDR      r3,|L1.1020|
000028  681b              LDR      r3,[r3,#0]            ;433  ; os_clockrate
00002a  fbb0f2f3          UDIV     r2,r0,r3              ;433
00002e  f64f70fe          MOV      r0,#0xfffe            ;434
000032  4282              CMP      r2,r0                 ;434
000034  d900              BLS      |L1.56|
000036  e7e8              B        |L1.10|
                  |L1.56|
000038  4610              MOV      r0,r2                 ;436
00003a  e7e6              B        |L1.10|
;;;438    
                          ENDP

                  rt_tid2ptcb PROC
;;;439    /// Convert Thread ID to TCB pointer
;;;440    static P_TCB rt_tid2ptcb (osThreadId thread_id) {
00003c  4601              MOV      r1,r0
;;;441      P_TCB ptcb;
;;;442    
;;;443      if (thread_id == NULL) return NULL;
00003e  b909              CBNZ     r1,|L1.68|
000040  2000              MOVS     r0,#0
                  |L1.66|
;;;444    
;;;445      if ((uint32_t)thread_id & 3) return NULL;
;;;446    
;;;447    #ifdef OS_SECTIONS_LINK_INFO
;;;448      if ((os_section_id$$Base != 0) && (os_section_id$$Limit != 0)) {
;;;449        if (thread_id  < (osThreadId)os_section_id$$Base)  return NULL;
;;;450        if (thread_id >= (osThreadId)os_section_id$$Limit) return NULL;
;;;451      }
;;;452    #endif
;;;453    
;;;454      ptcb = thread_id;
;;;455    
;;;456      if (ptcb->cb_type != TCB) return NULL;
;;;457    
;;;458      return ptcb;
;;;459    }
000042  4770              BX       lr
                  |L1.68|
000044  f0010003          AND      r0,r1,#3              ;445
000048  b108              CBZ      r0,|L1.78|
00004a  2000              MOVS     r0,#0                 ;445
00004c  e7f9              B        |L1.66|
                  |L1.78|
00004e  460a              MOV      r2,r1                 ;454
000050  7810              LDRB     r0,[r2,#0]            ;456
000052  b108              CBZ      r0,|L1.88|
000054  2000              MOVS     r0,#0                 ;456
000056  e7f4              B        |L1.66|
                  |L1.88|
000058  4610              MOV      r0,r2                 ;458
00005a  e7f2              B        |L1.66|
;;;460    
                          ENDP

                  rt_id2obj PROC
;;;461    /// Convert ID pointer to Object pointer
;;;462    static void *rt_id2obj (void *id) {
00005c  4601              MOV      r1,r0
;;;463    
;;;464      if ((uint32_t)id & 3) return NULL;
00005e  f0010003          AND      r0,r1,#3
000062  b108              CBZ      r0,|L1.104|
000064  2000              MOVS     r0,#0
                  |L1.102|
;;;465    
;;;466    #ifdef OS_SECTIONS_LINK_INFO
;;;467      if ((os_section_id$$Base != 0) && (os_section_id$$Limit != 0)) {
;;;468        if (id  < (void *)os_section_id$$Base)  return NULL;
;;;469        if (id >= (void *)os_section_id$$Limit) return NULL;
;;;470      }
;;;471    #endif
;;;472    
;;;473      return id;
;;;474    }
000066  4770              BX       lr
                  |L1.104|
000068  4608              MOV      r0,r1                 ;473
00006a  e7fc              B        |L1.102|
;;;475    
                          ENDP

                  sysThreadError PROC
;;;629    /// Set Thread Error (for Create functions which return IDs)
;;;630    static void sysThreadError (osStatus status) {
00006c  4770              BX       lr
;;;631      // To Do
;;;632    }
;;;633    
                          ENDP

                  svcThreadGetId PROC
;;;696    /// Return the thread ID of the current running thread
;;;697    osThreadId svcThreadGetId (void) {
00006e  b510              PUSH     {r4,lr}
;;;698      OS_TID tsk;
;;;699    
;;;700      tsk = rt_tsk_self();
000070  f7fffffe          BL       rt_tsk_self
000074  4604              MOV      r4,r0
;;;701      if (tsk == 0) return NULL;
000076  b90c              CBNZ     r4,|L1.124|
000078  2000              MOVS     r0,#0
                  |L1.122|
;;;702      return (P_TCB)os_active_TCB[tsk - 1];
;;;703    }
00007a  bd10              POP      {r4,pc}
                  |L1.124|
00007c  1e60              SUBS     r0,r4,#1              ;702
00007e  49e0              LDR      r1,|L1.1024|
000080  f8510020          LDR      r0,[r1,r0,LSL #2]     ;702
000084  e7f9              B        |L1.122|
;;;704    
                          ENDP

                  svcThreadTerminate PROC
;;;705    /// Terminate execution of a thread and remove it from ActiveThreads
;;;706    osStatus svcThreadTerminate (osThreadId thread_id) {
000086  e92d41f0          PUSH     {r4-r8,lr}
00008a  4607              MOV      r7,r0
;;;707      OS_RESULT res;
;;;708      P_TCB     ptcb;
;;;709      void     *stk;
;;;710    
;;;711      ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       rt_tid2ptcb
000092  4604              MOV      r4,r0
;;;712      if (ptcb == NULL) return osErrorParameter;
000094  b914              CBNZ     r4,|L1.156|
000096  2080              MOVS     r0,#0x80
                  |L1.152|
;;;713    
;;;714      stk = ptcb->priv_stack ? ptcb->stack : NULL;  // Private stack
;;;715    
;;;716      res = rt_tsk_delete(ptcb->task_id);           // Delete task
;;;717    
;;;718      if (res == OS_R_NOK) return osErrorResource;  // Delete task failed
;;;719    
;;;720      if (stk != NULL) {                            
;;;721        rt_free_mem(os_stack_mem, stk);             // Free private stack
;;;722      }
;;;723    
;;;724      return osOK;
;;;725    }
000098  e8bd81f0          POP      {r4-r8,pc}
                  |L1.156|
00009c  8ce0              LDRH     r0,[r4,#0x26]         ;714
00009e  b108              CBZ      r0,|L1.164|
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;714
0000a2  e000              B        |L1.166|
                  |L1.164|
0000a4  2000              MOVS     r0,#0                 ;714
                  |L1.166|
0000a6  4606              MOV      r6,r0                 ;714
0000a8  78e0              LDRB     r0,[r4,#3]            ;716
0000aa  f7fffffe          BL       rt_tsk_delete
0000ae  4605              MOV      r5,r0                 ;716
0000b0  2dff              CMP      r5,#0xff              ;718
0000b2  d101              BNE      |L1.184|
0000b4  2081              MOVS     r0,#0x81              ;718
0000b6  e7ef              B        |L1.152|
                  |L1.184|
0000b8  b11e              CBZ      r6,|L1.194|
0000ba  4631              MOV      r1,r6                 ;721
0000bc  48d1              LDR      r0,|L1.1028|
0000be  f7fffffe          BL       rt_free_mem
                  |L1.194|
0000c2  2000              MOVS     r0,#0                 ;724
0000c4  e7e8              B        |L1.152|
;;;726    
                          ENDP

                  osThreadExit PROC
;;;810    /// Auto Terminate Thread on exit (used implicitly when thread exists)
;;;811    __NO_RETURN void osThreadExit (void) { 
0000c6  bf00              NOP      
0000c8  f2af0c5d          ADR      r12,svcThreadGetId + 1
0000cc  df00              SVC      #0x0
;;;812      __svcThreadTerminate(__svcThreadGetId()); 
0000ce  4604              MOV      r4,r0
0000d0  4620              MOV      r0,r4
0000d2  f2af0c4d          ADR      r12,svcThreadTerminate + 1
0000d6  df00              SVC      #0x0
;;;813      for (;;);                                     // Should never come here
0000d8  bf00              NOP      
                  |L1.218|
0000da  e7fe              B        |L1.218|
;;;814    }
;;;815    
                          ENDP

                  svcThreadCreate PROC
;;;646    /// Create a thread and add it to Active Threads and set it to state READY
;;;647    osThreadId svcThreadCreate (const osThreadDef_t *thread_def, void *argument) {
0000dc  e92d41f0          PUSH     {r4-r8,lr}
0000e0  4604              MOV      r4,r0
0000e2  4688              MOV      r8,r1
;;;648      P_TCB  ptcb;
;;;649      OS_TID tsk;
;;;650      void  *stk;
;;;651    
;;;652      if ((thread_def == NULL) ||
0000e4  b154              CBZ      r4,|L1.252|
;;;653          (thread_def->pthread == NULL) ||
0000e6  6820              LDR      r0,[r4,#0]
0000e8  b140              CBZ      r0,|L1.252|
;;;654          (thread_def->tpriority < osPriorityIdle) ||
0000ea  f9b40004          LDRSH    r0,[r4,#4]
0000ee  f1100f03          CMN      r0,#3
0000f2  db03              BLT      |L1.252|
;;;655          (thread_def->tpriority > osPriorityRealtime)) {
0000f4  f9b40004          LDRSH    r0,[r4,#4]
0000f8  2803              CMP      r0,#3
0000fa  dd05              BLE      |L1.264|
                  |L1.252|
;;;656        sysThreadError(osErrorParameter); 
0000fc  2080              MOVS     r0,#0x80
0000fe  f7fffffe          BL       sysThreadError
;;;657        return NULL; 
000102  2000              MOVS     r0,#0
                  |L1.260|
;;;658      }
;;;659    
;;;660      if (thread_def->stacksize != 0) {             // Custom stack size
;;;661        stk = rt_alloc_mem(                         // Allocate stack
;;;662          os_stack_mem,
;;;663          thread_def->stacksize
;;;664        );
;;;665        if (stk == NULL) { 
;;;666          sysThreadError(osErrorNoMemory);          // Out of memory
;;;667          return NULL;
;;;668        }
;;;669      } else {                                      // Default stack size
;;;670        stk = NULL;
;;;671      }
;;;672    
;;;673      tsk = rt_tsk_create(                          // Create task
;;;674        (FUNCP)thread_def->pthread,                 // Task function pointer
;;;675        (thread_def->tpriority-osPriorityIdle+1) |  // Task priority
;;;676        (thread_def->stacksize << 8),               // Task stack size in bytes
;;;677        stk,                                        // Pointer to task's stack
;;;678        argument                                    // Argument to the task
;;;679      );
;;;680    
;;;681      if (tsk == 0) {                               // Invalid task ID
;;;682        if (stk != NULL) {
;;;683          rt_free_mem(os_stack_mem, stk);           // Free allocated stack
;;;684        }
;;;685        sysThreadError(osErrorNoMemory);            // Create task failed (Out of memory)
;;;686        return NULL;
;;;687      }
;;;688    
;;;689      ptcb = (P_TCB)os_active_TCB[tsk - 1];         // TCB pointer
;;;690    
;;;691      *((uint32_t *)ptcb->tsk_stack + 13) = (uint32_t)osThreadExit;
;;;692    
;;;693      return ptcb;
;;;694    }
000104  e8bd81f0          POP      {r4-r8,pc}
                  |L1.264|
000108  68e0              LDR      r0,[r4,#0xc]          ;660
00010a  b150              CBZ      r0,|L1.290|
00010c  48bd              LDR      r0,|L1.1028|
00010e  68e1              LDR      r1,[r4,#0xc]          ;661
000110  f7fffffe          BL       rt_alloc_mem
000114  4605              MOV      r5,r0                 ;661
000116  b92d              CBNZ     r5,|L1.292|
000118  2085              MOVS     r0,#0x85              ;666
00011a  f7fffffe          BL       sysThreadError
00011e  2000              MOVS     r0,#0                 ;667
000120  e7f0              B        |L1.260|
                  |L1.290|
000122  2500              MOVS     r5,#0                 ;670
                  |L1.292|
000124  f9b42004          LDRSH    r2,[r4,#4]            ;673
000128  1d12              ADDS     r2,r2,#4              ;673
00012a  68e3              LDR      r3,[r4,#0xc]          ;673
00012c  ea422103          ORR      r1,r2,r3,LSL #8       ;673
000130  4643              MOV      r3,r8                 ;673
000132  462a              MOV      r2,r5                 ;673
000134  6820              LDR      r0,[r4,#0]            ;673
000136  f7fffffe          BL       rt_tsk_create
00013a  4606              MOV      r6,r0                 ;673
00013c  b94e              CBNZ     r6,|L1.338|
00013e  b11d              CBZ      r5,|L1.328|
000140  4629              MOV      r1,r5                 ;683
000142  48b0              LDR      r0,|L1.1028|
000144  f7fffffe          BL       rt_free_mem
                  |L1.328|
000148  2085              MOVS     r0,#0x85              ;685
00014a  f7fffffe          BL       sysThreadError
00014e  2000              MOVS     r0,#0                 ;686
000150  e7d8              B        |L1.260|
                  |L1.338|
000152  1e70              SUBS     r0,r6,#1              ;689
000154  49aa              LDR      r1,|L1.1024|
000156  f8517020          LDR      r7,[r1,r0,LSL #2]     ;689
00015a  f2af0095          ADR      r0,osThreadExit + 1
00015e  6ab9              LDR      r1,[r7,#0x28]         ;691
000160  6348              STR      r0,[r1,#0x34]         ;691
000162  4638              MOV      r0,r7                 ;693
000164  e7ce              B        |L1.260|
;;;695    
                          ENDP

                  svcMessageCreate PROC
;;;1691   /// Create and Initialize Message Queue
;;;1692   osMessageQId svcMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id) {
000166  b570              PUSH     {r4-r6,lr}
000168  4604              MOV      r4,r0
00016a  460d              MOV      r5,r1
;;;1693   
;;;1694     if ((queue_def == NULL) ||
00016c  b11c              CBZ      r4,|L1.374|
;;;1695         (queue_def->queue_sz == 0) ||
00016e  6820              LDR      r0,[r4,#0]
000170  b108              CBZ      r0,|L1.374|
;;;1696         (queue_def->pool == NULL)) {
000172  6860              LDR      r0,[r4,#4]
000174  b920              CBNZ     r0,|L1.384|
                  |L1.374|
;;;1697       sysThreadError(osErrorParameter);
000176  2080              MOVS     r0,#0x80
000178  f7fffffe          BL       sysThreadError
;;;1698       return NULL;
00017c  2000              MOVS     r0,#0
                  |L1.382|
;;;1699     }
;;;1700     
;;;1701     if (((P_MCB)queue_def->pool)->cb_type != 0) {
;;;1702       sysThreadError(osErrorParameter);
;;;1703       return NULL;
;;;1704     }
;;;1705   
;;;1706     rt_mbx_init(queue_def->pool, 4*(queue_def->queue_sz + 4));
;;;1707   
;;;1708     return queue_def->pool;
;;;1709   }
00017e  bd70              POP      {r4-r6,pc}
                  |L1.384|
000180  6860              LDR      r0,[r4,#4]            ;1701
000182  7800              LDRB     r0,[r0,#0]            ;1701
000184  b120              CBZ      r0,|L1.400|
000186  2080              MOVS     r0,#0x80              ;1702
000188  f7fffffe          BL       sysThreadError
00018c  2000              MOVS     r0,#0                 ;1703
00018e  e7f6              B        |L1.382|
                  |L1.400|
000190  8822              LDRH     r2,[r4,#0]            ;1706
000192  1d12              ADDS     r2,r2,#4              ;1706
000194  0492              LSLS     r2,r2,#18             ;1706
000196  0c11              LSRS     r1,r2,#16             ;1706
000198  6860              LDR      r0,[r4,#4]            ;1706
00019a  f7fffffe          BL       rt_mbx_init
00019e  6860              LDR      r0,[r4,#4]            ;1708
0001a0  e7ed              B        |L1.382|
;;;1710   
                          ENDP

                  svcKernelInitialize PROC
;;;494    /// Initialize the RTOS Kernel for creating objects
;;;495    osStatus svcKernelInitialize (void) {
0001a2  b510              PUSH     {r4,lr}
;;;496      int ret;
;;;497    
;;;498      if (!os_initialized) {
0001a4  4898              LDR      r0,|L1.1032|
0001a6  7800              LDRB     r0,[r0,#0]  ; os_initialized
0001a8  b980              CBNZ     r0,|L1.460|
;;;499    
;;;500        // Init Thread Stack Memory (must be 8-byte aligned)
;;;501        if ((uint32_t)os_stack_mem & 7) return osErrorNoMemory;
0001aa  4896              LDR      r0,|L1.1028|
0001ac  f0000007          AND      r0,r0,#7
0001b0  b108              CBZ      r0,|L1.438|
0001b2  2085              MOVS     r0,#0x85
                  |L1.436|
;;;502        ret = rt_init_mem(os_stack_mem, os_stack_sz);
;;;503        if (ret != 0) return osErrorNoMemory;
;;;504    
;;;505        rt_sys_init();                              // RTX System Initialization
;;;506      }
;;;507    
;;;508      os_tsk.run->prio = 255;                       // Highest priority
;;;509    
;;;510      if (!os_initialized) {
;;;511        // Create OS Timers resources (Message Queue & Thread)
;;;512        osMessageQId_osTimerMessageQ = svcMessageCreate (&os_messageQ_def_osTimerMessageQ, NULL);
;;;513        osThreadId_osTimerThread = svcThreadCreate(&os_thread_def_osTimerThread, NULL);
;;;514      }
;;;515    
;;;516      sysThreadError(osOK);
;;;517    
;;;518      os_initialized = 1;
;;;519      os_running = 0;
;;;520    
;;;521      return osOK;
;;;522    }
0001b4  bd10              POP      {r4,pc}
                  |L1.438|
0001b6  4895              LDR      r0,|L1.1036|
0001b8  6801              LDR      r1,[r0,#0]            ;502  ; os_stack_sz
0001ba  4892              LDR      r0,|L1.1028|
0001bc  f7fffffe          BL       rt_init_mem
0001c0  4604              MOV      r4,r0                 ;502
0001c2  b10c              CBZ      r4,|L1.456|
0001c4  2085              MOVS     r0,#0x85              ;503
0001c6  e7f5              B        |L1.436|
                  |L1.456|
0001c8  f7fffffe          BL       rt_sys_init
                  |L1.460|
0001cc  20ff              MOVS     r0,#0xff              ;508
0001ce  4990              LDR      r1,|L1.1040|
0001d0  6809              LDR      r1,[r1,#0]            ;508  ; os_tsk
0001d2  7088              STRB     r0,[r1,#2]            ;508
0001d4  488c              LDR      r0,|L1.1032|
0001d6  7800              LDRB     r0,[r0,#0]            ;510  ; os_initialized
0001d8  b958              CBNZ     r0,|L1.498|
0001da  2100              MOVS     r1,#0                 ;512
0001dc  488d              LDR      r0,|L1.1044|
0001de  f7fffffe          BL       svcMessageCreate
0001e2  498d              LDR      r1,|L1.1048|
0001e4  6008              STR      r0,[r1,#0]            ;512  ; osMessageQId_osTimerMessageQ
0001e6  2100              MOVS     r1,#0                 ;513
0001e8  488c              LDR      r0,|L1.1052|
0001ea  f7fffffe          BL       svcThreadCreate
0001ee  498c              LDR      r1,|L1.1056|
0001f0  6008              STR      r0,[r1,#0]            ;513  ; osThreadId_osTimerThread
                  |L1.498|
0001f2  2000              MOVS     r0,#0                 ;516
0001f4  f7fffffe          BL       sysThreadError
0001f8  2001              MOVS     r0,#1                 ;518
0001fa  4983              LDR      r1,|L1.1032|
0001fc  7008              STRB     r0,[r1,#0]            ;518
0001fe  2000              MOVS     r0,#0                 ;519
000200  4988              LDR      r1,|L1.1060|
000202  7008              STRB     r0,[r1,#0]            ;519
000204  bf00              NOP                            ;521
000206  e7d5              B        |L1.436|
;;;523    
                          ENDP

                  svcKernelStart PROC
;;;524    /// Start the RTOS Kernel
;;;525    osStatus svcKernelStart (void) {
000208  b510              PUSH     {r4,lr}
;;;526    
;;;527      if (os_running) return osOK;
00020a  4886              LDR      r0,|L1.1060|
00020c  7800              LDRB     r0,[r0,#0]  ; os_running
00020e  b108              CBZ      r0,|L1.532|
000210  2000              MOVS     r0,#0
                  |L1.530|
;;;528    
;;;529      rt_tsk_prio(0, os_tsk.run->prio_base);        // Restore priority
;;;530      if (os_tsk.run->task_id == 0xFF) {            // Idle Thread
;;;531        __set_PSP(os_tsk.run->tsk_stack + 8*4);     // Setup PSP
;;;532      }
;;;533      if (os_tsk.new == NULL) {                     // Force context switch
;;;534        os_tsk.new = os_tsk.run;
;;;535        os_tsk.run = NULL;
;;;536      }
;;;537    
;;;538      rt_sys_start();
;;;539    
;;;540      os_running = 1;
;;;541    
;;;542      return osOK;
;;;543    }
000212  bd10              POP      {r4,pc}
                  |L1.532|
000214  487e              LDR      r0,|L1.1040|
000216  6800              LDR      r0,[r0,#0]            ;529  ; os_tsk
000218  f8901024          LDRB     r1,[r0,#0x24]         ;529
00021c  2000              MOVS     r0,#0                 ;529
00021e  f7fffffe          BL       rt_tsk_prio
000222  487b              LDR      r0,|L1.1040|
000224  6800              LDR      r0,[r0,#0]            ;530  ; os_tsk
000226  78c0              LDRB     r0,[r0,#3]            ;530
000228  28ff              CMP      r0,#0xff              ;530
00022a  d108              BNE      |L1.574|
00022c  4978              LDR      r1,|L1.1040|
00022e  6809              LDR      r1,[r1,#0]            ;531  ; os_tsk
000230  6a89              LDR      r1,[r1,#0x28]         ;531
000232  f1010020          ADD      r0,r1,#0x20           ;531
000236  f3808809          MSR      PSP,r0                ;531
00023a  bf00              NOP                            ;531
00023c  bf00              NOP                            ;531
                  |L1.574|
00023e  4874              LDR      r0,|L1.1040|
000240  6840              LDR      r0,[r0,#4]            ;533  ; os_tsk
000242  b928              CBNZ     r0,|L1.592|
000244  4872              LDR      r0,|L1.1040|
000246  6800              LDR      r0,[r0,#0]            ;534  ; os_tsk
000248  4971              LDR      r1,|L1.1040|
00024a  6048              STR      r0,[r1,#4]            ;534  ; os_tsk
00024c  2000              MOVS     r0,#0                 ;535
00024e  6008              STR      r0,[r1,#0]            ;535  ; os_tsk
                  |L1.592|
000250  f7fffffe          BL       rt_sys_start
000254  2001              MOVS     r0,#1                 ;540
000256  4973              LDR      r1,|L1.1060|
000258  7008              STRB     r0,[r1,#0]            ;540
00025a  2000              MOVS     r0,#0                 ;542
00025c  e7d9              B        |L1.530|
;;;544    
                          ENDP

                  svcKernelRunning PROC
;;;545    /// Check if the RTOS kernel is already started
;;;546    int32_t svcKernelRunning (void) {
00025e  4871              LDR      r0,|L1.1060|
;;;547      return os_running;
000260  7800              LDRB     r0,[r0,#0]  ; os_running
;;;548    }
000262  4770              BX       lr
;;;549    
                          ENDP

                  svcKernelSysTick PROC
;;;550    /// Get the RTOS kernel system timer counter
;;;551    uint32_t svcKernelSysTick (void) {
000264  b570              PUSH     {r4-r6,lr}
;;;552      uint32_t tick, tick0;
;;;553    
;;;554      tick = os_tick_val();
000266  f7fffffe          BL       os_tick_val
00026a  4604              MOV      r4,r0
;;;555      if (os_tick_ovf()) {
00026c  f7fffffe          BL       os_tick_ovf
000270  b170              CBZ      r0,|L1.656|
;;;556        tick0 = os_tick_val();
000272  f7fffffe          BL       os_tick_val
000276  4605              MOV      r5,r0
;;;557        if (tick0 < tick) tick = tick0;
000278  42a5              CMP      r5,r4
00027a  d200              BCS      |L1.638|
00027c  462c              MOV      r4,r5
                  |L1.638|
;;;558        tick += (os_trv + 1) * (os_time + 1);
00027e  486a              LDR      r0,|L1.1064|
000280  6800              LDR      r0,[r0,#0]  ; os_trv
000282  1c40              ADDS     r0,r0,#1
000284  4969              LDR      r1,|L1.1068|
000286  6809              LDR      r1,[r1,#0]  ; os_time
000288  1c49              ADDS     r1,r1,#1
00028a  fb004401          MLA      r4,r0,r1,r4
00028e  e006              B        |L1.670|
                  |L1.656|
;;;559      } else {
;;;560        tick += (os_trv + 1) *  os_time;
000290  4865              LDR      r0,|L1.1064|
000292  6800              LDR      r0,[r0,#0]  ; os_trv
000294  1c40              ADDS     r0,r0,#1
000296  4965              LDR      r1,|L1.1068|
000298  6809              LDR      r1,[r1,#0]  ; os_time
00029a  fb004401          MLA      r4,r0,r1,r4
                  |L1.670|
;;;561      }
;;;562    
;;;563      return tick;
00029e  4620              MOV      r0,r4
;;;564    }
0002a0  bd70              POP      {r4-r6,pc}
;;;565    
                          ENDP

                  osKernelInitialize PROC
;;;568    /// Initialize the RTOS Kernel for creating objects
;;;569    osStatus osKernelInitialize (void) {
0002a2  b510              PUSH     {r4,lr}
;;;570      if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
0002a4  f7fffffe          BL       __get_IPSR
0002a8  b108              CBZ      r0,|L1.686|
0002aa  2082              MOVS     r0,#0x82
                  |L1.684|
;;;571      if ((__get_CONTROL() & 1) == 0) {             // Privileged mode
;;;572        return   svcKernelInitialize();
;;;573      } else {
;;;574        return __svcKernelInitialize();
;;;575      }
;;;576    }
0002ac  bd10              POP      {r4,pc}
                  |L1.686|
0002ae  f7fffffe          BL       __get_CONTROL
0002b2  f0000001          AND      r0,r0,#1              ;571
0002b6  b910              CBNZ     r0,|L1.702|
0002b8  f7fffffe          BL       svcKernelInitialize
0002bc  e7f6              B        |L1.684|
                  |L1.702|
0002be  bf00              NOP                            ;574
0002c0  f2af1c21          ADR      r12,svcKernelInitialize + 1
0002c4  df00              SVC      #0x0                  ;574
0002c6  bf00              NOP                            ;574
0002c8  e7f0              B        |L1.684|
;;;577    
                          ENDP

                  osKernelStart PROC
;;;578    /// Start the RTOS Kernel
;;;579    osStatus osKernelStart (void) {
0002ca  b500              PUSH     {lr}
0002cc  b089              SUB      sp,sp,#0x24
;;;580      uint32_t stack[8];
;;;581    
;;;582      if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
0002ce  f7fffffe          BL       __get_IPSR
0002d2  b110              CBZ      r0,|L1.730|
0002d4  2082              MOVS     r0,#0x82
                  |L1.726|
;;;583      switch (__get_CONTROL() & 0x03) {
;;;584        case 0x00:                                  // Privileged Thread mode & MSP
;;;585          __set_PSP((uint32_t)(stack + 8));         // Initial PSP
;;;586          if (os_flags & 1) {                       
;;;587            __set_CONTROL(0x02);                    // Set Privileged Thread mode & PSP
;;;588          } else {
;;;589            __set_CONTROL(0x03);                    // Set Unprivileged Thread mode & PSP
;;;590          }
;;;591          __DSB();
;;;592          __ISB();
;;;593          break;
;;;594        case 0x01:                                  // Unprivileged Thread mode & MSP
;;;595          return osErrorOS;
;;;596        case 0x02:                                  // Privileged Thread mode & PSP
;;;597          if ((os_flags & 1) == 0) {                // Unprivileged Thread mode requested
;;;598            __set_CONTROL(0x03);                    // Set Unprivileged Thread mode & PSP
;;;599            __DSB();
;;;600            __ISB();
;;;601          }
;;;602          break;
;;;603        case 0x03:                                  // Unprivileged Thread mode & PSP
;;;604          if  (os_flags & 1) return osErrorOS;      // Privileged Thread mode requested
;;;605          break;
;;;606      }
;;;607      return __svcKernelStart();
;;;608    }
0002d6  b009              ADD      sp,sp,#0x24
0002d8  bd00              POP      {pc}
                  |L1.730|
0002da  f7fffffe          BL       __get_CONTROL
0002de  f0000003          AND      r0,r0,#3              ;583
0002e2  b130              CBZ      r0,|L1.754|
0002e4  2801              CMP      r0,#1                 ;583
0002e6  d01c              BEQ      |L1.802|
0002e8  2802              CMP      r0,#2                 ;583
0002ea  d01c              BEQ      |L1.806|
0002ec  2803              CMP      r0,#3                 ;583
0002ee  d130              BNE      |L1.850|
0002f0  e027              B        |L1.834|
                  |L1.754|
0002f2  a809              ADD      r0,sp,#0x24           ;585
0002f4  f3808809          MSR      PSP,r0                ;585
0002f8  bf00              NOP                            ;585
0002fa  484d              LDR      r0,|L1.1072|
0002fc  7800              LDRB     r0,[r0,#0]            ;586  ; os_flags
0002fe  f0000001          AND      r0,r0,#1              ;586
000302  b120              CBZ      r0,|L1.782|
000304  2002              MOVS     r0,#2                 ;587
000306  f3808814          MSR      CONTROL,r0            ;587
00030a  bf00              NOP                            ;587
00030c  e004              B        |L1.792|
                  |L1.782|
00030e  2003              MOVS     r0,#3                 ;589
000310  f3808814          MSR      CONTROL,r0            ;589
000314  bf00              NOP                            ;589
000316  bf00              NOP                            ;589
                  |L1.792|
000318  f3bf8f4f          DSB                            ;591
00031c  f3bf8f6f          ISB                            ;592
000320  e017              B        |L1.850|
                  |L1.802|
000322  20ff              MOVS     r0,#0xff              ;595
000324  e7d7              B        |L1.726|
                  |L1.806|
000326  4842              LDR      r0,|L1.1072|
000328  7800              LDRB     r0,[r0,#0]            ;597  ; os_flags
00032a  f0000001          AND      r0,r0,#1              ;597
00032e  b938              CBNZ     r0,|L1.832|
000330  2003              MOVS     r0,#3                 ;598
000332  f3808814          MSR      CONTROL,r0            ;598
000336  bf00              NOP                            ;598
000338  f3bf8f4f          DSB                            ;599
00033c  f3bf8f6f          ISB                            ;600
                  |L1.832|
000340  e007              B        |L1.850|
                  |L1.834|
000342  483b              LDR      r0,|L1.1072|
000344  7800              LDRB     r0,[r0,#0]            ;604  ; os_flags
000346  f0000001          AND      r0,r0,#1              ;604
00034a  b108              CBZ      r0,|L1.848|
00034c  20ff              MOVS     r0,#0xff              ;604
00034e  e7c2              B        |L1.726|
                  |L1.848|
000350  bf00              NOP                            ;605
                  |L1.850|
000352  bf00              NOP                            ;593
000354  bf00              NOP                            ;607
000356  f2af1c4f          ADR      r12,svcKernelStart + 1
00035a  df00              SVC      #0x0                  ;607
00035c  bf00              NOP                            ;607
00035e  e7ba              B        |L1.726|
;;;609    
                          ENDP

                  osKernelRunning PROC
;;;610    /// Check if the RTOS kernel is already started
;;;611    int32_t osKernelRunning (void) {
000360  b510              PUSH     {r4,lr}
;;;612      if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {
000362  f7fffffe          BL       __get_IPSR
000366  b920              CBNZ     r0,|L1.882|
000368  f7fffffe          BL       __get_CONTROL
00036c  f0000001          AND      r0,r0,#1
000370  b910              CBNZ     r0,|L1.888|
                  |L1.882|
;;;613        // in ISR or Privileged
;;;614        return os_running;
000372  482c              LDR      r0,|L1.1060|
000374  7800              LDRB     r0,[r0,#0]  ; os_running
                  |L1.886|
;;;615      } else {
;;;616        return __svcKernelRunning();
;;;617      }
;;;618    }
000376  bd10              POP      {r4,pc}
                  |L1.888|
000378  bf00              NOP                            ;616
00037a  f2af1c1d          ADR      r12,svcKernelRunning + 1
00037e  df00              SVC      #0x0                  ;616
000380  bf00              NOP                            ;616
000382  e7f8              B        |L1.886|
;;;619    
                          ENDP

                  osKernelSysTick PROC
;;;620    /// Get the RTOS kernel system timer counter
;;;621    uint32_t osKernelSysTick (void) {
000384  b510              PUSH     {r4,lr}
;;;622      if (__get_IPSR() != 0) return 0;              // Not allowed in ISR
000386  f7fffffe          BL       __get_IPSR
00038a  b108              CBZ      r0,|L1.912|
00038c  2000              MOVS     r0,#0
                  |L1.910|
;;;623      return __svcKernelSysTick();
;;;624    }
00038e  bd10              POP      {r4,pc}
                  |L1.912|
000390  bf00              NOP                            ;623
000392  f2af1c2f          ADR      r12,svcKernelSysTick + 1
000396  df00              SVC      #0x0                  ;623
000398  bf00              NOP                            ;623
00039a  e7f8              B        |L1.910|
;;;625    
                          ENDP

                  svcThreadYield PROC
;;;727    /// Pass control to next thread that is in state READY
;;;728    osStatus svcThreadYield (void) {
00039c  b510              PUSH     {r4,lr}
;;;729      rt_tsk_pass();                                // Pass control to next task
00039e  f7fffffe          BL       rt_tsk_pass
;;;730      return osOK;
0003a2  2000              MOVS     r0,#0
;;;731    }
0003a4  bd10              POP      {r4,pc}
;;;732    
                          ENDP

                  svcThreadSetPriority PROC
;;;733    /// Change priority of an active thread
;;;734    osStatus svcThreadSetPriority (osThreadId thread_id, osPriority priority) {
0003a6  e92d41f0          PUSH     {r4-r8,lr}
0003aa  4607              MOV      r7,r0
0003ac  460c              MOV      r4,r1
;;;735      OS_RESULT res;
;;;736      P_TCB     ptcb;
;;;737    
;;;738      ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer
0003ae  4638              MOV      r0,r7
0003b0  f7fffffe          BL       rt_tid2ptcb
0003b4  4606              MOV      r6,r0
;;;739      if (ptcb == NULL) return osErrorParameter;
0003b6  b916              CBNZ     r6,|L1.958|
0003b8  2080              MOVS     r0,#0x80
                  |L1.954|
;;;740    
;;;741      if ((priority < osPriorityIdle) || (priority > osPriorityRealtime)) {
;;;742        return osErrorValue;
;;;743      }
;;;744    
;;;745      res = rt_tsk_prio(                            // Change task priority
;;;746        ptcb->task_id,                              // Task ID
;;;747        priority - osPriorityIdle + 1               // New task priority
;;;748      );
;;;749    
;;;750      if (res == OS_R_NOK) return osErrorResource;  // Change task priority failed
;;;751    
;;;752      return osOK;
;;;753    }
0003ba  e8bd81f0          POP      {r4-r8,pc}
                  |L1.958|
0003be  f1140f03          CMN      r4,#3                 ;741
0003c2  db01              BLT      |L1.968|
0003c4  2c03              CMP      r4,#3                 ;741
0003c6  dd01              BLE      |L1.972|
                  |L1.968|
0003c8  2086              MOVS     r0,#0x86              ;742
0003ca  e7f6              B        |L1.954|
                  |L1.972|
0003cc  1d22              ADDS     r2,r4,#4              ;745
0003ce  b2d1              UXTB     r1,r2                 ;745
0003d0  78f0              LDRB     r0,[r6,#3]            ;745
0003d2  f7fffffe          BL       rt_tsk_prio
0003d6  4605              MOV      r5,r0                 ;745
0003d8  2dff              CMP      r5,#0xff              ;750
0003da  d101              BNE      |L1.992|
0003dc  2081              MOVS     r0,#0x81              ;750
0003de  e7ec              B        |L1.954|
                  |L1.992|
0003e0  2000              MOVS     r0,#0                 ;752
0003e2  e7ea              B        |L1.954|
;;;754    
                          ENDP

                  svcThreadGetPriority PROC
;;;755    /// Get current priority of an active thread
;;;756    osPriority svcThreadGetPriority (osThreadId thread_id) {
0003e4  b570              PUSH     {r4-r6,lr}
0003e6  4605              MOV      r5,r0
;;;757      P_TCB ptcb;
;;;758    
;;;759      ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer
0003e8  4628              MOV      r0,r5
0003ea  f7fffffe          BL       rt_tid2ptcb
0003ee  4604              MOV      r4,r0
;;;760      if (ptcb == NULL) return osPriorityError;
0003f0  b90c              CBNZ     r4,|L1.1014|
0003f2  2084              MOVS     r0,#0x84
;;;761    
;;;762      return (osPriority)(ptcb->prio - 1 + osPriorityIdle); 
;;;763    }
0003f4  bd70              POP      {r4-r6,pc}
                  |L1.1014|
0003f6  e01d              B        |L1.1076|
                  |L1.1016|
                          DCD      0x003d0900
                  |L1.1020|
                          DCD      os_clockrate
                  |L1.1024|
                          DCD      os_active_TCB
                  |L1.1028|
                          DCD      os_stack_mem
                  |L1.1032|
                          DCD      os_initialized
                  |L1.1036|
                          DCD      os_stack_sz
                  |L1.1040|
                          DCD      os_tsk
                  |L1.1044|
                          DCD      os_messageQ_def_osTimerMessageQ
                  |L1.1048|
                          DCD      osMessageQId_osTimerMessageQ
                  |L1.1052|
                          DCD      os_thread_def_osTimerThread
                  |L1.1056|
                          DCD      osThreadId_osTimerThread
                  |L1.1060|
                          DCD      os_running
                  |L1.1064|
                          DCD      os_trv
                  |L1.1068|
                          DCD      os_time
                  |L1.1072|
                          DCD      os_flags
                  |L1.1076|
000434  78a0              LDRB     r0,[r4,#2]            ;762
000436  1f00              SUBS     r0,r0,#4              ;762
000438  bd70              POP      {r4-r6,pc}
;;;764    
                          ENDP

                  osThreadCreate PROC
;;;768    /// Create a thread and add it to Active Threads and set it to state READY
;;;769    osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument) {
00043a  b570              PUSH     {r4-r6,lr}
00043c  4605              MOV      r5,r0
00043e  460c              MOV      r4,r1
;;;770      if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
000440  f7fffffe          BL       __get_IPSR
000444  b108              CBZ      r0,|L1.1098|
000446  2000              MOVS     r0,#0
                  |L1.1096|
;;;771      if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;772        // Privileged and not running
;;;773        return   svcThreadCreate(thread_def, argument);
;;;774      } else {
;;;775        return __svcThreadCreate(thread_def, argument);
;;;776      }
;;;777    }
000448  bd70              POP      {r4-r6,pc}
                  |L1.1098|
00044a  f7fffffe          BL       __get_CONTROL
00044e  f0000001          AND      r0,r0,#1              ;771
000452  b938              CBNZ     r0,|L1.1124|
000454  48f8              LDR      r0,|L1.2104|
000456  7800              LDRB     r0,[r0,#0]            ;771  ; os_running
000458  b920              CBNZ     r0,|L1.1124|
00045a  4621              MOV      r1,r4                 ;773
00045c  4628              MOV      r0,r5                 ;773
00045e  f7fffffe          BL       svcThreadCreate
000462  e7f1              B        |L1.1096|
                  |L1.1124|
000464  bf00              NOP                            ;775
000466  4621              MOV      r1,r4                 ;775
000468  4628              MOV      r0,r5                 ;775
00046a  f2af3c8f          ADR      r12,svcThreadCreate + 1
00046e  df00              SVC      #0x0                  ;775
000470  bf00              NOP                            ;775
000472  e7e9              B        |L1.1096|
;;;778    
                          ENDP

                  osThreadGetId PROC
;;;779    /// Return the thread ID of the current running thread
;;;780    osThreadId osThreadGetId (void) {
000474  b510              PUSH     {r4,lr}
;;;781      if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
000476  f7fffffe          BL       __get_IPSR
00047a  b108              CBZ      r0,|L1.1152|
00047c  2000              MOVS     r0,#0
                  |L1.1150|
;;;782      return __svcThreadGetId();
;;;783    }
00047e  bd10              POP      {r4,pc}
                  |L1.1152|
000480  bf00              NOP                            ;782
000482  f2af4c15          ADR      r12,svcThreadGetId + 1
000486  df00              SVC      #0x0                  ;782
000488  bf00              NOP                            ;782
00048a  e7f8              B        |L1.1150|
;;;784    
                          ENDP

                  osThreadTerminate PROC
;;;785    /// Terminate execution of a thread and remove it from ActiveThreads
;;;786    osStatus osThreadTerminate (osThreadId thread_id) {
00048c  b510              PUSH     {r4,lr}
00048e  4604              MOV      r4,r0
;;;787      if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000490  f7fffffe          BL       __get_IPSR
000494  b108              CBZ      r0,|L1.1178|
000496  2082              MOVS     r0,#0x82
                  |L1.1176|
;;;788      return __svcThreadTerminate(thread_id);
;;;789    }
000498  bd10              POP      {r4,pc}
                  |L1.1178|
00049a  bf00              NOP                            ;788
00049c  4620              MOV      r0,r4                 ;788
00049e  f2af4c19          ADR      r12,svcThreadTerminate + 1
0004a2  df00              SVC      #0x0                  ;788
0004a4  bf00              NOP                            ;788
0004a6  e7f7              B        |L1.1176|
;;;790    
                          ENDP

                  osThreadYield PROC
;;;791    /// Pass control to next thread that is in state READY
;;;792    osStatus osThreadYield (void) {
0004a8  b510              PUSH     {r4,lr}
;;;793      if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
0004aa  f7fffffe          BL       __get_IPSR
0004ae  b108              CBZ      r0,|L1.1204|
0004b0  2082              MOVS     r0,#0x82
                  |L1.1202|
;;;794      return __svcThreadYield();
;;;795    }
0004b2  bd10              POP      {r4,pc}
                  |L1.1204|
0004b4  bf00              NOP                            ;794
0004b6  f2af1c1b          ADR      r12,svcThreadYield + 1
0004ba  df00              SVC      #0x0                  ;794
0004bc  bf00              NOP                            ;794
0004be  e7f8              B        |L1.1202|
;;;796    
                          ENDP

                  osThreadSetPriority PROC
;;;797    /// Change priority of an active thread
;;;798    osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority) {
0004c0  b570              PUSH     {r4-r6,lr}
0004c2  4605              MOV      r5,r0
0004c4  460c              MOV      r4,r1
;;;799      if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
0004c6  f7fffffe          BL       __get_IPSR
0004ca  b108              CBZ      r0,|L1.1232|
0004cc  2082              MOVS     r0,#0x82
                  |L1.1230|
;;;800      return __svcThreadSetPriority(thread_id, priority);
;;;801    }
0004ce  bd70              POP      {r4-r6,pc}
                  |L1.1232|
0004d0  bf00              NOP                            ;800
0004d2  4621              MOV      r1,r4                 ;800
0004d4  4628              MOV      r0,r5                 ;800
0004d6  f2af1c31          ADR      r12,svcThreadSetPriority + 1
0004da  df00              SVC      #0x0                  ;800
0004dc  bf00              NOP                            ;800
0004de  e7f6              B        |L1.1230|
;;;802    
                          ENDP

                  osThreadGetPriority PROC
;;;803    /// Get current priority of an active thread
;;;804    osPriority osThreadGetPriority (osThreadId thread_id) {
0004e0  b510              PUSH     {r4,lr}
0004e2  4604              MOV      r4,r0
;;;805      if (__get_IPSR() != 0) return osPriorityError;// Not allowed in ISR
0004e4  f7fffffe          BL       __get_IPSR
0004e8  b108              CBZ      r0,|L1.1262|
0004ea  2084              MOVS     r0,#0x84
                  |L1.1260|
;;;806      return __svcThreadGetPriority(thread_id);
;;;807    }
0004ec  bd10              POP      {r4,pc}
                  |L1.1262|
0004ee  bf00              NOP                            ;806
0004f0  4620              MOV      r0,r4                 ;806
0004f2  f2af1c0f          ADR      r12,svcThreadGetPriority + 1
0004f6  df00              SVC      #0x0                  ;806
0004f8  bf00              NOP                            ;806
0004fa  e7f7              B        |L1.1260|
;;;808    
                          ENDP

                  svcDelay PROC
;;;827    /// Wait for Timeout (Time Delay)
;;;828    osStatus svcDelay (uint32_t millisec) {
0004fc  b570              PUSH     {r4-r6,lr}
0004fe  4604              MOV      r4,r0
;;;829      if (millisec == 0) return osOK;
000500  b90c              CBNZ     r4,|L1.1286|
000502  2000              MOVS     r0,#0
                  |L1.1284|
;;;830      rt_dly_wait(rt_ms2tick(millisec));
;;;831      return osEventTimeout;
;;;832    }
000504  bd70              POP      {r4-r6,pc}
                  |L1.1286|
000506  4620              MOV      r0,r4                 ;830
000508  f7fffffe          BL       rt_ms2tick
00050c  b285              UXTH     r5,r0                 ;830
00050e  4628              MOV      r0,r5                 ;830
000510  f7fffffe          BL       rt_dly_wait
000514  2040              MOVS     r0,#0x40              ;831
000516  e7f5              B        |L1.1284|
;;;833    
                          ENDP

                  osDelay PROC
;;;855    /// Wait for Timeout (Time Delay)
;;;856    osStatus osDelay (uint32_t millisec) {
000518  b510              PUSH     {r4,lr}
00051a  4604              MOV      r4,r0
;;;857      if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
00051c  f7fffffe          BL       __get_IPSR
000520  b108              CBZ      r0,|L1.1318|
000522  2082              MOVS     r0,#0x82
                  |L1.1316|
;;;858      return __svcDelay(millisec);
;;;859    }
000524  bd10              POP      {r4,pc}
                  |L1.1318|
000526  bf00              NOP                            ;858
000528  4620              MOV      r0,r4                 ;858
00052a  f2af0c2f          ADR      r12,svcDelay + 1
00052e  df00              SVC      #0x0                  ;858
000530  bf00              NOP                            ;858
000532  e7f7              B        |L1.1316|
;;;860    
                          ENDP

                  osWait PROC
;;;861    /// Wait for Signal, Message, Mail, or Timeout
;;;862    os_InRegs osEvent osWait (uint32_t millisec) {
000534  b50e              PUSH     {r1-r3,lr}
000536  4603              MOV      r3,r0
;;;863      osEvent ret;
;;;864    
;;;865    #if osFeature_Wait == 0
;;;866      ret.status = osErrorOS;
000538  20ff              MOVS     r0,#0xff
00053a  9000              STR      r0,[sp,#0]
;;;867      return ret;
00053c  e89d0007          LDM      sp,{r0-r2}
;;;868    #else
;;;869      if (__get_IPSR() != 0) {                      // Not allowed in ISR
;;;870        ret.status = osErrorISR;
;;;871        return ret;
;;;872      }
;;;873      return __svcWait(millisec);
;;;874    #endif
;;;875    }
000540  b003              ADD      sp,sp,#0xc
000542  bd00              POP      {pc}
;;;876    
                          ENDP

                  rt_timer_insert PROC
;;;904    // Insert Timer into the list sorted by time
;;;905    static void rt_timer_insert (os_timer_cb *pt, uint32_t tcnt) {
000544  b530              PUSH     {r4,r5,lr}
000546  4602              MOV      r2,r0
;;;906      os_timer_cb *p, *prev;
;;;907    
;;;908      prev = NULL;
000548  2300              MOVS     r3,#0
;;;909      p = os_timer_head;
00054a  4cbc              LDR      r4,|L1.2108|
00054c  6820              LDR      r0,[r4,#0]  ; os_timer_head
;;;910      while (p != NULL) {
00054e  e007              B        |L1.1376|
                  |L1.1360|
;;;911        if (tcnt < p->tcnt) break;
000550  8904              LDRH     r4,[r0,#8]
000552  428c              CMP      r4,r1
000554  d900              BLS      |L1.1368|
000556  e005              B        |L1.1380|
                  |L1.1368|
;;;912        tcnt -= p->tcnt;
000558  8904              LDRH     r4,[r0,#8]
00055a  1b09              SUBS     r1,r1,r4
;;;913        prev = p;
00055c  4603              MOV      r3,r0
;;;914        p = p->next;
00055e  6800              LDR      r0,[r0,#0]
                  |L1.1376|
000560  2800              CMP      r0,#0                 ;910
000562  d1f5              BNE      |L1.1360|
                  |L1.1380|
000564  bf00              NOP                            ;911
;;;915      }
;;;916      pt->next = p;
000566  6010              STR      r0,[r2,#0]
;;;917      pt->tcnt = (uint16_t)tcnt;
000568  8111              STRH     r1,[r2,#8]
;;;918      if (p != NULL) {
00056a  b118              CBZ      r0,|L1.1396|
;;;919        p->tcnt -= pt->tcnt;
00056c  8904              LDRH     r4,[r0,#8]
00056e  8915              LDRH     r5,[r2,#8]
000570  1b64              SUBS     r4,r4,r5
000572  8104              STRH     r4,[r0,#8]
                  |L1.1396|
;;;920      }
;;;921      if (prev != NULL) {
000574  b10b              CBZ      r3,|L1.1402|
;;;922        prev->next = pt;
000576  601a              STR      r2,[r3,#0]
000578  e001              B        |L1.1406|
                  |L1.1402|
;;;923      } else {
;;;924        os_timer_head = pt;
00057a  4cb0              LDR      r4,|L1.2108|
00057c  6022              STR      r2,[r4,#0]  ; os_timer_head
                  |L1.1406|
;;;925      }
;;;926    }
00057e  bd30              POP      {r4,r5,pc}
;;;927    
                          ENDP

                  rt_timer_remove PROC
;;;928    // Remove Timer from the list
;;;929    static int rt_timer_remove (os_timer_cb *pt) {
000580  b510              PUSH     {r4,lr}
000582  4601              MOV      r1,r0
;;;930      os_timer_cb *p, *prev;
;;;931    
;;;932      prev = NULL;
000584  2300              MOVS     r3,#0
;;;933      p = os_timer_head;
000586  48ad              LDR      r0,|L1.2108|
000588  6802              LDR      r2,[r0,#0]  ; os_timer_head
;;;934      while (p != NULL) {
00058a  e004              B        |L1.1430|
                  |L1.1420|
;;;935        if (p == pt) break;
00058c  428a              CMP      r2,r1
00058e  d100              BNE      |L1.1426|
000590  e003              B        |L1.1434|
                  |L1.1426|
;;;936        prev = p;
000592  4613              MOV      r3,r2
;;;937        p = p->next;
000594  6812              LDR      r2,[r2,#0]
                  |L1.1430|
000596  2a00              CMP      r2,#0                 ;934
000598  d1f8              BNE      |L1.1420|
                  |L1.1434|
00059a  bf00              NOP                            ;935
;;;938      }
;;;939      if (p == NULL) return -1;
00059c  b912              CBNZ     r2,|L1.1444|
00059e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1442|
;;;940      if (prev != NULL) {
;;;941        prev->next = pt->next;
;;;942      } else {
;;;943        os_timer_head = pt->next;
;;;944      }
;;;945      if (pt->next != NULL) {
;;;946        pt->next->tcnt += pt->tcnt;
;;;947      }
;;;948    
;;;949      return 0;
;;;950    }
0005a2  bd10              POP      {r4,pc}
                  |L1.1444|
0005a4  b113              CBZ      r3,|L1.1452|
0005a6  6808              LDR      r0,[r1,#0]            ;941
0005a8  6018              STR      r0,[r3,#0]            ;941
0005aa  e002              B        |L1.1458|
                  |L1.1452|
0005ac  4ca3              LDR      r4,|L1.2108|
0005ae  6808              LDR      r0,[r1,#0]            ;943
0005b0  6020              STR      r0,[r4,#0]            ;943  ; os_timer_head
                  |L1.1458|
0005b2  6808              LDR      r0,[r1,#0]            ;945
0005b4  b128              CBZ      r0,|L1.1474|
0005b6  6808              LDR      r0,[r1,#0]            ;946
0005b8  8900              LDRH     r0,[r0,#8]            ;946
0005ba  890c              LDRH     r4,[r1,#8]            ;946
0005bc  4420              ADD      r0,r0,r4              ;946
0005be  680c              LDR      r4,[r1,#0]            ;946
0005c0  8120              STRH     r0,[r4,#8]            ;946
                  |L1.1474|
0005c2  2000              MOVS     r0,#0                 ;949
0005c4  e7ed              B        |L1.1442|
;;;951    
                          ENDP

                  svcTimerCreate PROC
;;;962    /// Create timer
;;;963    osTimerId svcTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument) {
0005c6  e92d41f0          PUSH     {r4-r8,lr}
0005ca  4605              MOV      r5,r0
0005cc  460e              MOV      r6,r1
0005ce  4617              MOV      r7,r2
;;;964      os_timer_cb *pt;
;;;965    
;;;966      if ((timer_def == NULL) || (timer_def->ptimer == NULL)) {
0005d0  b10d              CBZ      r5,|L1.1494|
0005d2  6828              LDR      r0,[r5,#0]
0005d4  b928              CBNZ     r0,|L1.1506|
                  |L1.1494|
;;;967        sysThreadError(osErrorParameter);
0005d6  2080              MOVS     r0,#0x80
0005d8  f7fffffe          BL       sysThreadError
;;;968        return NULL;
0005dc  2000              MOVS     r0,#0
                  |L1.1502|
;;;969      }
;;;970    
;;;971      pt = timer_def->timer;
;;;972      if (pt == NULL) {
;;;973        sysThreadError(osErrorParameter);
;;;974        return NULL;
;;;975      }
;;;976    
;;;977      if ((type != osTimerOnce) && (type != osTimerPeriodic)) {
;;;978        sysThreadError(osErrorValue);
;;;979        return NULL;
;;;980      }
;;;981    
;;;982      if (osThreadId_osTimerThread == NULL) {
;;;983        sysThreadError(osErrorResource);
;;;984        return NULL;
;;;985      }
;;;986    
;;;987      if (pt->state != osTimerInvalid){
;;;988        sysThreadError(osErrorResource);
;;;989        return NULL;
;;;990      }
;;;991    
;;;992      pt->next  = NULL;
;;;993      pt->state = osTimerStopped;
;;;994      pt->type  =  (uint8_t)type;
;;;995      pt->arg   = argument;
;;;996      pt->timer = timer_def;
;;;997    
;;;998      return (osTimerId)pt;
;;;999    }
0005de  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1506|
0005e2  686c              LDR      r4,[r5,#4]            ;971
0005e4  b924              CBNZ     r4,|L1.1520|
0005e6  2080              MOVS     r0,#0x80              ;973
0005e8  f7fffffe          BL       sysThreadError
0005ec  2000              MOVS     r0,#0                 ;974
0005ee  e7f6              B        |L1.1502|
                  |L1.1520|
0005f0  b136              CBZ      r6,|L1.1536|
0005f2  2e01              CMP      r6,#1                 ;977
0005f4  d004              BEQ      |L1.1536|
0005f6  2086              MOVS     r0,#0x86              ;978
0005f8  f7fffffe          BL       sysThreadError
0005fc  2000              MOVS     r0,#0                 ;979
0005fe  e7ee              B        |L1.1502|
                  |L1.1536|
000600  488f              LDR      r0,|L1.2112|
000602  6800              LDR      r0,[r0,#0]            ;982  ; osThreadId_osTimerThread
000604  b920              CBNZ     r0,|L1.1552|
000606  2081              MOVS     r0,#0x81              ;983
000608  f7fffffe          BL       sysThreadError
00060c  2000              MOVS     r0,#0                 ;984
00060e  e7e6              B        |L1.1502|
                  |L1.1552|
000610  7920              LDRB     r0,[r4,#4]            ;987
000612  b120              CBZ      r0,|L1.1566|
000614  2081              MOVS     r0,#0x81              ;988
000616  f7fffffe          BL       sysThreadError
00061a  2000              MOVS     r0,#0                 ;989
00061c  e7df              B        |L1.1502|
                  |L1.1566|
00061e  2000              MOVS     r0,#0                 ;992
000620  6020              STR      r0,[r4,#0]            ;992
000622  2001              MOVS     r0,#1                 ;993
000624  7120              STRB     r0,[r4,#4]            ;993
000626  7166              STRB     r6,[r4,#5]            ;994
000628  60e7              STR      r7,[r4,#0xc]          ;995
00062a  6125              STR      r5,[r4,#0x10]         ;996
00062c  4620              MOV      r0,r4                 ;998
00062e  e7d6              B        |L1.1502|
;;;1000   
                          ENDP

                  svcTimerStart PROC
;;;1001   /// Start or restart timer
;;;1002   osStatus svcTimerStart (osTimerId timer_id, uint32_t millisec) {
000630  e92d41f0          PUSH     {r4-r8,lr}
000634  4607              MOV      r7,r0
000636  460e              MOV      r6,r1
;;;1003     os_timer_cb *pt;
;;;1004     uint32_t     tcnt;
;;;1005   
;;;1006     pt = rt_id2obj(timer_id);
000638  4638              MOV      r0,r7
00063a  f7fffffe          BL       rt_id2obj
00063e  4604              MOV      r4,r0
;;;1007     if (pt == NULL) return osErrorParameter;
000640  b914              CBNZ     r4,|L1.1608|
000642  2080              MOVS     r0,#0x80
                  |L1.1604|
;;;1008   
;;;1009     tcnt = rt_ms2tick(millisec);
;;;1010     if (tcnt == 0) return osErrorValue;
;;;1011   
;;;1012     switch (pt->state) {
;;;1013       case osTimerRunning:
;;;1014         if (rt_timer_remove(pt) != 0) {
;;;1015           return osErrorResource;
;;;1016         }
;;;1017         break;
;;;1018       case osTimerStopped:
;;;1019         pt->state = osTimerRunning;
;;;1020         pt->icnt  = (uint16_t)tcnt;
;;;1021         break;
;;;1022       default:
;;;1023         return osErrorResource;
;;;1024     }
;;;1025     
;;;1026     rt_timer_insert(pt, tcnt);
;;;1027   
;;;1028     return osOK;
;;;1029   }
000644  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1608|
000648  4630              MOV      r0,r6                 ;1009
00064a  f7fffffe          BL       rt_ms2tick
00064e  4605              MOV      r5,r0                 ;1009
000650  b90d              CBNZ     r5,|L1.1622|
000652  2086              MOVS     r0,#0x86              ;1010
000654  e7f6              B        |L1.1604|
                  |L1.1622|
000656  7920              LDRB     r0,[r4,#4]            ;1012
000658  2801              CMP      r0,#1                 ;1012
00065a  d008              BEQ      |L1.1646|
00065c  2802              CMP      r0,#2                 ;1012
00065e  d10a              BNE      |L1.1654|
000660  4620              MOV      r0,r4                 ;1014
000662  f7fffffe          BL       rt_timer_remove
000666  b108              CBZ      r0,|L1.1644|
000668  2081              MOVS     r0,#0x81              ;1015
00066a  e7eb              B        |L1.1604|
                  |L1.1644|
00066c  e005              B        |L1.1658|
                  |L1.1646|
00066e  2002              MOVS     r0,#2                 ;1019
000670  7120              STRB     r0,[r4,#4]            ;1019
000672  8165              STRH     r5,[r4,#0xa]          ;1020
000674  e001              B        |L1.1658|
                  |L1.1654|
000676  2081              MOVS     r0,#0x81              ;1023
000678  e7e4              B        |L1.1604|
                  |L1.1658|
00067a  bf00              NOP                            ;1017
00067c  4629              MOV      r1,r5                 ;1026
00067e  4620              MOV      r0,r4                 ;1026
000680  f7fffffe          BL       rt_timer_insert
000684  2000              MOVS     r0,#0                 ;1028
000686  e7dd              B        |L1.1604|
;;;1030   
                          ENDP

                  svcTimerStop PROC
;;;1031   /// Stop timer
;;;1032   osStatus svcTimerStop (osTimerId timer_id) {
000688  b570              PUSH     {r4-r6,lr}
00068a  4605              MOV      r5,r0
;;;1033     os_timer_cb *pt;
;;;1034   
;;;1035     pt = rt_id2obj(timer_id);
00068c  4628              MOV      r0,r5
00068e  f7fffffe          BL       rt_id2obj
000692  4604              MOV      r4,r0
;;;1036     if (pt == NULL) return osErrorParameter;
000694  b90c              CBNZ     r4,|L1.1690|
000696  2080              MOVS     r0,#0x80
                  |L1.1688|
;;;1037   
;;;1038     if (pt->state != osTimerRunning) return osErrorResource;
;;;1039   
;;;1040     pt->state = osTimerStopped;
;;;1041   
;;;1042     if (rt_timer_remove(pt) != 0) {
;;;1043       return osErrorResource;
;;;1044     }
;;;1045   
;;;1046     return osOK;
;;;1047   }
000698  bd70              POP      {r4-r6,pc}
                  |L1.1690|
00069a  7920              LDRB     r0,[r4,#4]            ;1038
00069c  2802              CMP      r0,#2                 ;1038
00069e  d001              BEQ      |L1.1700|
0006a0  2081              MOVS     r0,#0x81              ;1038
0006a2  e7f9              B        |L1.1688|
                  |L1.1700|
0006a4  2001              MOVS     r0,#1                 ;1040
0006a6  7120              STRB     r0,[r4,#4]            ;1040
0006a8  4620              MOV      r0,r4                 ;1042
0006aa  f7fffffe          BL       rt_timer_remove
0006ae  b108              CBZ      r0,|L1.1716|
0006b0  2081              MOVS     r0,#0x81              ;1043
0006b2  e7f1              B        |L1.1688|
                  |L1.1716|
0006b4  2000              MOVS     r0,#0                 ;1046
0006b6  e7ef              B        |L1.1688|
;;;1048   
                          ENDP

                  svcTimerDelete PROC
;;;1049   /// Delete timer
;;;1050   osStatus svcTimerDelete (osTimerId timer_id) {
0006b8  b570              PUSH     {r4-r6,lr}
0006ba  4605              MOV      r5,r0
;;;1051     os_timer_cb *pt;
;;;1052   
;;;1053     pt = rt_id2obj(timer_id);
0006bc  4628              MOV      r0,r5
0006be  f7fffffe          BL       rt_id2obj
0006c2  4604              MOV      r4,r0
;;;1054     if (pt == NULL) return osErrorParameter;
0006c4  b90c              CBNZ     r4,|L1.1738|
0006c6  2080              MOVS     r0,#0x80
                  |L1.1736|
;;;1055   
;;;1056     switch (pt->state) {
;;;1057       case osTimerRunning:
;;;1058         rt_timer_remove(pt);
;;;1059         break;
;;;1060       case osTimerStopped:
;;;1061         break;
;;;1062       default:
;;;1063         return osErrorResource;
;;;1064     }
;;;1065   
;;;1066     pt->state = osTimerInvalid;
;;;1067   
;;;1068     return osOK;
;;;1069   }
0006c8  bd70              POP      {r4-r6,pc}
                  |L1.1738|
0006ca  7920              LDRB     r0,[r4,#4]            ;1056
0006cc  2801              CMP      r0,#1                 ;1056
0006ce  d005              BEQ      |L1.1756|
0006d0  2802              CMP      r0,#2                 ;1056
0006d2  d104              BNE      |L1.1758|
0006d4  4620              MOV      r0,r4                 ;1058
0006d6  f7fffffe          BL       rt_timer_remove
0006da  e002              B        |L1.1762|
                  |L1.1756|
0006dc  e001              B        |L1.1762|
                  |L1.1758|
0006de  2081              MOVS     r0,#0x81              ;1063
0006e0  e7f2              B        |L1.1736|
                  |L1.1762|
0006e2  bf00              NOP                            ;1059
0006e4  2000              MOVS     r0,#0                 ;1066
0006e6  7120              STRB     r0,[r4,#4]            ;1066
0006e8  bf00              NOP                            ;1068
0006ea  e7ed              B        |L1.1736|
;;;1070   
                          ENDP

                  svcTimerCall PROC
;;;1071   /// Get timer callback parameters
;;;1072   os_InRegs osCallback_type svcTimerCall (osTimerId timer_id) {
0006ec  b57c              PUSH     {r2-r6,lr}
0006ee  4605              MOV      r5,r0
;;;1073     os_timer_cb *pt;
;;;1074     osCallback   ret;
;;;1075   
;;;1076     pt = rt_id2obj(timer_id);
0006f0  4628              MOV      r0,r5
0006f2  f7fffffe          BL       rt_id2obj
0006f6  4604              MOV      r4,r0
;;;1077     if (pt == NULL) {
0006f8  b92c              CBNZ     r4,|L1.1798|
;;;1078       ret.fp  = NULL;
0006fa  2000              MOVS     r0,#0
0006fc  9000              STR      r0,[sp,#0]
;;;1079       ret.arg = NULL;
0006fe  9001              STR      r0,[sp,#4]
;;;1080       return osCallback_ret;
000700  e9dd0100          LDRD     r0,r1,[sp,#0]
                  |L1.1796|
;;;1081     }
;;;1082   
;;;1083     ret.fp  = (void *)pt->timer->ptimer;
;;;1084     ret.arg = pt->arg;
;;;1085   
;;;1086     return osCallback_ret;
;;;1087   }
000704  bd7c              POP      {r2-r6,pc}
                  |L1.1798|
000706  6920              LDR      r0,[r4,#0x10]         ;1083
000708  6800              LDR      r0,[r0,#0]            ;1083
00070a  9000              STR      r0,[sp,#0]            ;1083
00070c  68e0              LDR      r0,[r4,#0xc]          ;1084
00070e  9001              STR      r0,[sp,#4]            ;1084
000710  e9dd0100          LDRD     r0,r1,[sp,#0]         ;1086
000714  e7f6              B        |L1.1796|
;;;1088   
                          ENDP

                  isrMessagePut PROC
;;;1758   /// Put a Message to a Queue
;;;1759   static __INLINE osStatus isrMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {
000716  b570              PUSH     {r4-r6,lr}
000718  4604              MOV      r4,r0
00071a  460e              MOV      r6,r1
00071c  4615              MOV      r5,r2
;;;1760   
;;;1761     if ((queue_id == NULL) || (millisec != 0)) {
00071e  b104              CBZ      r4,|L1.1826|
000720  b10d              CBZ      r5,|L1.1830|
                  |L1.1826|
;;;1762       return osErrorParameter;
000722  2080              MOVS     r0,#0x80
                  |L1.1828|
;;;1763     }
;;;1764   
;;;1765     if (((P_MCB)queue_id)->cb_type != MCB) return osErrorParameter;
;;;1766   
;;;1767     if (rt_mbx_check(queue_id) == 0) {            // Check if Queue is full
;;;1768       return osErrorResource;
;;;1769     }
;;;1770   
;;;1771     isr_mbx_send(queue_id, (void *)info);
;;;1772   
;;;1773     return osOK;
;;;1774   }
000724  bd70              POP      {r4-r6,pc}
                  |L1.1830|
000726  7820              LDRB     r0,[r4,#0]            ;1765
000728  2801              CMP      r0,#1                 ;1765
00072a  d001              BEQ      |L1.1840|
00072c  2080              MOVS     r0,#0x80              ;1765
00072e  e7f9              B        |L1.1828|
                  |L1.1840|
000730  4620              MOV      r0,r4                 ;1767
000732  f7fffffe          BL       rt_mbx_check
000736  b908              CBNZ     r0,|L1.1852|
000738  2081              MOVS     r0,#0x81              ;1768
00073a  e7f3              B        |L1.1828|
                  |L1.1852|
00073c  4631              MOV      r1,r6                 ;1771
00073e  4620              MOV      r0,r4                 ;1771
000740  f7fffffe          BL       isr_mbx_send
000744  2000              MOVS     r0,#0                 ;1773
000746  e7ed              B        |L1.1828|
;;;1775   
                          ENDP

                  sysTimerTick PROC
;;;1091   /// Timer Tick (called each SysTick)
;;;1092   void sysTimerTick (void) {
000748  b570              PUSH     {r4-r6,lr}
;;;1093     os_timer_cb *pt, *p;
;;;1094   
;;;1095     p = os_timer_head;
00074a  483c              LDR      r0,|L1.2108|
00074c  6804              LDR      r4,[r0,#0]  ; os_timer_head
;;;1096     if (p == NULL) return;
00074e  b904              CBNZ     r4,|L1.1874|
                  |L1.1872|
;;;1097   
;;;1098     p->tcnt--;
;;;1099     while ((p != NULL) && (p->tcnt == 0)) {
;;;1100       pt = p;
;;;1101       p = p->next;
;;;1102       os_timer_head = p;
;;;1103       isrMessagePut(osMessageQId_osTimerMessageQ, (uint32_t)pt, 0);
;;;1104       if (pt->type == osTimerPeriodic) {
;;;1105         rt_timer_insert(pt, pt->icnt);
;;;1106       } else {
;;;1107         pt->state = osTimerStopped;
;;;1108       }
;;;1109     }
;;;1110   }
000750  bd70              POP      {r4-r6,pc}
                  |L1.1874|
000752  8920              LDRH     r0,[r4,#8]            ;1098
000754  1e40              SUBS     r0,r0,#1              ;1098
000756  8120              STRH     r0,[r4,#8]            ;1098
000758  e013              B        |L1.1922|
                  |L1.1882|
00075a  4625              MOV      r5,r4                 ;1100
00075c  6824              LDR      r4,[r4,#0]            ;1101
00075e  4837              LDR      r0,|L1.2108|
000760  6004              STR      r4,[r0,#0]            ;1102  ; os_timer_head
000762  2200              MOVS     r2,#0                 ;1103
000764  4629              MOV      r1,r5                 ;1103
000766  4837              LDR      r0,|L1.2116|
000768  6800              LDR      r0,[r0,#0]            ;1103  ; osMessageQId_osTimerMessageQ
00076a  f7fffffe          BL       isrMessagePut
00076e  7968              LDRB     r0,[r5,#5]            ;1104
000770  2801              CMP      r0,#1                 ;1104
000772  d104              BNE      |L1.1918|
000774  8969              LDRH     r1,[r5,#0xa]          ;1105
000776  4628              MOV      r0,r5                 ;1105
000778  f7fffffe          BL       rt_timer_insert
00077c  e001              B        |L1.1922|
                  |L1.1918|
00077e  2001              MOVS     r0,#1                 ;1107
000780  7128              STRB     r0,[r5,#4]            ;1107
                  |L1.1922|
000782  b114              CBZ      r4,|L1.1930|
000784  8920              LDRH     r0,[r4,#8]            ;1099
000786  2800              CMP      r0,#0                 ;1099
000788  d0e7              BEQ      |L1.1882|
                  |L1.1930|
00078a  bf00              NOP      
00078c  e7e0              B        |L1.1872|
;;;1111   
                          ENDP

                  sysUserTimerWakeupTime PROC
;;;1112   /// Get user timers wake-up time 
;;;1113   uint32_t sysUserTimerWakeupTime (void) {
00078e  482b              LDR      r0,|L1.2108|
;;;1114   
;;;1115     if (os_timer_head) {
000790  6800              LDR      r0,[r0,#0]  ; os_timer_head
000792  b118              CBZ      r0,|L1.1948|
;;;1116       return os_timer_head->tcnt;
000794  4829              LDR      r0,|L1.2108|
000796  6800              LDR      r0,[r0,#0]  ; os_timer_head
000798  8900              LDRH     r0,[r0,#8]
                  |L1.1946|
;;;1117     }
;;;1118     return 0xFFFF;
;;;1119   }
00079a  4770              BX       lr
                  |L1.1948|
00079c  f64f70ff          MOV      r0,#0xffff            ;1118
0007a0  e7fb              B        |L1.1946|
;;;1120   
                          ENDP

                  sysUserTimerUpdate PROC
;;;1121   /// Update user timers on resume
;;;1122   void sysUserTimerUpdate (uint32_t sleep_time) {
0007a2  b510              PUSH     {r4,lr}
0007a4  4604              MOV      r4,r0
;;;1123   
;;;1124     while (os_timer_head && sleep_time) {
0007a6  e017              B        |L1.2008|
                  |L1.1960|
;;;1125       if (sleep_time >= os_timer_head->tcnt) {
0007a8  4824              LDR      r0,|L1.2108|
0007aa  6800              LDR      r0,[r0,#0]  ; os_timer_head
0007ac  8900              LDRH     r0,[r0,#8]
0007ae  42a0              CMP      r0,r4
0007b0  d80a              BHI      |L1.1992|
;;;1126         sleep_time -= os_timer_head->tcnt;
0007b2  4822              LDR      r0,|L1.2108|
0007b4  6800              LDR      r0,[r0,#0]  ; os_timer_head
0007b6  8900              LDRH     r0,[r0,#8]
0007b8  1a24              SUBS     r4,r4,r0
;;;1127         os_timer_head->tcnt = 1;
0007ba  2001              MOVS     r0,#1
0007bc  491f              LDR      r1,|L1.2108|
0007be  6809              LDR      r1,[r1,#0]  ; os_timer_head
0007c0  8108              STRH     r0,[r1,#8]
;;;1128         sysTimerTick();
0007c2  f7fffffe          BL       sysTimerTick
0007c6  e007              B        |L1.2008|
                  |L1.1992|
;;;1129       } else {
;;;1130         os_timer_head->tcnt -= sleep_time;
0007c8  481c              LDR      r0,|L1.2108|
0007ca  6800              LDR      r0,[r0,#0]  ; os_timer_head
0007cc  8900              LDRH     r0,[r0,#8]
0007ce  1b00              SUBS     r0,r0,r4
0007d0  491a              LDR      r1,|L1.2108|
0007d2  6809              LDR      r1,[r1,#0]  ; os_timer_head
0007d4  8108              STRH     r0,[r1,#8]
;;;1131         break;
0007d6  e004              B        |L1.2018|
                  |L1.2008|
0007d8  4818              LDR      r0,|L1.2108|
0007da  6800              LDR      r0,[r0,#0]            ;1124  ; os_timer_head
0007dc  b108              CBZ      r0,|L1.2018|
0007de  2c00              CMP      r4,#0                 ;1124
0007e0  d1e2              BNE      |L1.1960|
                  |L1.2018|
0007e2  bf00              NOP      
;;;1132       }
;;;1133     }
;;;1134   }
0007e4  bd10              POP      {r4,pc}
;;;1135   
                          ENDP

                  osTimerCreate PROC
;;;1139   /// Create timer
;;;1140   osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument) {
0007e6  b570              PUSH     {r4-r6,lr}
0007e8  4604              MOV      r4,r0
0007ea  460d              MOV      r5,r1
0007ec  4616              MOV      r6,r2
;;;1141     if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
0007ee  f7fffffe          BL       __get_IPSR
0007f2  b108              CBZ      r0,|L1.2040|
0007f4  2000              MOVS     r0,#0
                  |L1.2038|
;;;1142     if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;1143       // Privileged and not running
;;;1144       return   svcTimerCreate(timer_def, type, argument);
;;;1145     } else {
;;;1146       return __svcTimerCreate(timer_def, type, argument);
;;;1147     }
;;;1148   }
0007f6  bd70              POP      {r4-r6,pc}
                  |L1.2040|
0007f8  f7fffffe          BL       __get_CONTROL
0007fc  f0000001          AND      r0,r0,#1              ;1142
000800  b940              CBNZ     r0,|L1.2068|
000802  480d              LDR      r0,|L1.2104|
000804  7800              LDRB     r0,[r0,#0]            ;1142  ; os_running
000806  b928              CBNZ     r0,|L1.2068|
000808  4632              MOV      r2,r6                 ;1144
00080a  4629              MOV      r1,r5                 ;1144
00080c  4620              MOV      r0,r4                 ;1144
00080e  f7fffffe          BL       svcTimerCreate
000812  e7f0              B        |L1.2038|
                  |L1.2068|
000814  bf00              NOP                            ;1146
000816  4632              MOV      r2,r6                 ;1146
000818  4629              MOV      r1,r5                 ;1146
00081a  4620              MOV      r0,r4                 ;1146
00081c  f2af2c59          ADR      r12,svcTimerCreate + 1
000820  df00              SVC      #0x0                  ;1146
000822  bf00              NOP                            ;1146
000824  e7e7              B        |L1.2038|
;;;1149   
                          ENDP

                  osTimerStart PROC
;;;1150   /// Start or restart timer
;;;1151   osStatus osTimerStart (osTimerId timer_id, uint32_t millisec) {
000826  b570              PUSH     {r4-r6,lr}
000828  4605              MOV      r5,r0
00082a  460c              MOV      r4,r1
;;;1152     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
00082c  f7fffffe          BL       __get_IPSR
000830  b150              CBZ      r0,|L1.2120|
000832  2082              MOVS     r0,#0x82
                  |L1.2100|
;;;1153     return __svcTimerStart(timer_id, millisec);
;;;1154   }
000834  bd70              POP      {r4-r6,pc}
000836  0000              DCW      0x0000
                  |L1.2104|
                          DCD      os_running
                  |L1.2108|
                          DCD      os_timer_head
                  |L1.2112|
                          DCD      osThreadId_osTimerThread
                  |L1.2116|
                          DCD      osMessageQId_osTimerMessageQ
                  |L1.2120|
000848  bf00              NOP                            ;1153
00084a  4621              MOV      r1,r4                 ;1153
00084c  4628              MOV      r0,r5                 ;1153
00084e  f2af2c1f          ADR      r12,svcTimerStart + 1
000852  df00              SVC      #0x0                  ;1153
000854  bf00              NOP                            ;1153
000856  e7ed              B        |L1.2100|
;;;1155   
                          ENDP

                  osTimerStop PROC
;;;1156   /// Stop timer
;;;1157   osStatus osTimerStop (osTimerId timer_id) {
000858  b510              PUSH     {r4,lr}
00085a  4604              MOV      r4,r0
;;;1158     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
00085c  f7fffffe          BL       __get_IPSR
000860  b108              CBZ      r0,|L1.2150|
000862  2082              MOVS     r0,#0x82
                  |L1.2148|
;;;1159     return __svcTimerStop(timer_id);
;;;1160   }
000864  bd10              POP      {r4,pc}
                  |L1.2150|
000866  bf00              NOP                            ;1159
000868  4620              MOV      r0,r4                 ;1159
00086a  f2af1ce3          ADR      r12,svcTimerStop + 1
00086e  df00              SVC      #0x0                  ;1159
000870  bf00              NOP                            ;1159
000872  e7f7              B        |L1.2148|
;;;1161   
                          ENDP

                  osTimerDelete PROC
;;;1162   /// Delete timer
;;;1163   osStatus osTimerDelete (osTimerId timer_id) {
000874  b510              PUSH     {r4,lr}
000876  4604              MOV      r4,r0
;;;1164     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000878  f7fffffe          BL       __get_IPSR
00087c  b108              CBZ      r0,|L1.2178|
00087e  2082              MOVS     r0,#0x82
                  |L1.2176|
;;;1165     return __svcTimerDelete(timer_id);
;;;1166   }
000880  bd10              POP      {r4,pc}
                  |L1.2178|
000882  bf00              NOP                            ;1165
000884  4620              MOV      r0,r4                 ;1165
000886  f2af1ccf          ADR      r12,svcTimerDelete + 1
00088a  df00              SVC      #0x0                  ;1165
00088c  bf00              NOP                            ;1165
00088e  e7f7              B        |L1.2176|
;;;1167   
                          ENDP

                  osTimerCall PROC
;;;1169   /// Get timer callback parameters (used by OS Timer Thread)
;;;1170   os_InRegs osCallback osTimerCall (osTimerId timer_id) { 
000890  b51f              PUSH     {r0-r4,lr}
000892  4604              MOV      r4,r0
;;;1171     return __svcTimerCall(timer_id); 
000894  bf00              NOP      
000896  4620              MOV      r0,r4
000898  f2af1caf          ADR      r12,svcTimerCall + 1
00089c  df00              SVC      #0x0
00089e  e9cd0100          STRD     r0,r1,[sp,#0]
0008a2  e9cd0102          STRD     r0,r1,[sp,#8]
;;;1172   }
0008a6  b004              ADD      sp,sp,#0x10
0008a8  bd10              POP      {r4,pc}
;;;1173   
                          ENDP

                  svcMessageGet PROC
;;;1728   /// Get a Message or Wait for a Message from a Queue
;;;1729   os_InRegs osEvent_type svcMessageGet (osMessageQId queue_id, uint32_t millisec) {
0008aa  b5fe              PUSH     {r1-r7,lr}
0008ac  4604              MOV      r4,r0
0008ae  460d              MOV      r5,r1
;;;1730     OS_RESULT res;
;;;1731     osEvent   ret;
;;;1732   
;;;1733     if (queue_id == NULL) {
0008b0  b92c              CBNZ     r4,|L1.2238|
;;;1734       ret.status = osErrorParameter;
0008b2  2080              MOVS     r0,#0x80
0008b4  9000              STR      r0,[sp,#0]
;;;1735       return osEvent_ret_status;
0008b6  e89d0007          LDM      sp,{r0-r2}
                  |L1.2234|
;;;1736     }
;;;1737   
;;;1738     if (((P_MCB)queue_id)->cb_type != MCB) {
;;;1739       ret.status = osErrorParameter;
;;;1740       return osEvent_ret_status;
;;;1741     }
;;;1742   
;;;1743     res = rt_mbx_wait(queue_id, &ret.value.p, rt_ms2tick(millisec));
;;;1744     
;;;1745     if (res == OS_R_TMO) {
;;;1746       ret.status = millisec ? osEventTimeout : osOK;
;;;1747       return osEvent_ret_value;
;;;1748     }
;;;1749   
;;;1750     ret.status = osEventMessage;
;;;1751   
;;;1752     return osEvent_ret_value;
;;;1753   }
0008ba  b003              ADD      sp,sp,#0xc
0008bc  bdf0              POP      {r4-r7,pc}
                  |L1.2238|
0008be  7820              LDRB     r0,[r4,#0]            ;1738
0008c0  2801              CMP      r0,#1                 ;1738
0008c2  d004              BEQ      |L1.2254|
0008c4  2080              MOVS     r0,#0x80              ;1739
0008c6  9000              STR      r0,[sp,#0]            ;1739
0008c8  e89d0007          LDM      sp,{r0-r2}            ;1740
0008cc  e7f5              B        |L1.2234|
                  |L1.2254|
0008ce  4628              MOV      r0,r5                 ;1743
0008d0  f7fffffe          BL       rt_ms2tick
0008d4  b287              UXTH     r7,r0                 ;1743
0008d6  463a              MOV      r2,r7                 ;1743
0008d8  a901              ADD      r1,sp,#4              ;1743
0008da  4620              MOV      r0,r4                 ;1743
0008dc  f7fffffe          BL       rt_mbx_wait
0008e0  4606              MOV      r6,r0                 ;1743
0008e2  2e01              CMP      r6,#1                 ;1745
0008e4  d107              BNE      |L1.2294|
0008e6  b10d              CBZ      r5,|L1.2284|
0008e8  2040              MOVS     r0,#0x40              ;1746
0008ea  e000              B        |L1.2286|
                  |L1.2284|
0008ec  2000              MOVS     r0,#0                 ;1746
                  |L1.2286|
0008ee  9000              STR      r0,[sp,#0]            ;1746
0008f0  e89d0007          LDM      sp,{r0-r2}            ;1747
0008f4  e7e1              B        |L1.2234|
                  |L1.2294|
0008f6  2010              MOVS     r0,#0x10              ;1750
0008f8  9000              STR      r0,[sp,#0]            ;1750
0008fa  e89d0007          LDM      sp,{r0-r2}            ;1752
0008fe  e7dc              B        |L1.2234|
;;;1754   
                          ENDP

                  osMessageGet PROC
;;;1826   /// Get a Message or Wait for a Message from a Queue
;;;1827   os_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec) {
000900  e92d41f0          PUSH     {r4-r8,lr}
000904  b08a              SUB      sp,sp,#0x28
000906  4604              MOV      r4,r0
000908  460d              MOV      r5,r1
;;;1828     if (__get_IPSR() != 0) {                      // in ISR
00090a  f7fffffe          BL       __get_IPSR
00090e  b338              CBZ      r0,|L1.2400|
;;;1829       return   isrMessageGet(queue_id, millisec);
000910  4626              MOV      r6,r4
000912  46a8              MOV      r8,r5
000914  b116              CBZ      r6,|L1.2332|
000916  f1b80f00          CMP      r8,#0
00091a  d004              BEQ      |L1.2342|
                  |L1.2332|
00091c  2080              MOVS     r0,#0x80
00091e  9004              STR      r0,[sp,#0x10]
000920  a804              ADD      r0,sp,#0x10
000922  c807              LDM      r0,{r0-r2}
000924  e017              B        |L1.2390|
                  |L1.2342|
000926  7830              LDRB     r0,[r6,#0]
000928  2801              CMP      r0,#1
00092a  d004              BEQ      |L1.2358|
00092c  2080              MOVS     r0,#0x80
00092e  9004              STR      r0,[sp,#0x10]
000930  a804              ADD      r0,sp,#0x10
000932  c807              LDM      r0,{r0-r2}
000934  e00f              B        |L1.2390|
                  |L1.2358|
000936  a905              ADD      r1,sp,#0x14
000938  4630              MOV      r0,r6
00093a  f7fffffe          BL       isr_mbx_receive
00093e  4607              MOV      r7,r0
000940  2f04              CMP      r7,#4
000942  d004              BEQ      |L1.2382|
000944  2000              MOVS     r0,#0
000946  9004              STR      r0,[sp,#0x10]
000948  a804              ADD      r0,sp,#0x10
00094a  c807              LDM      r0,{r0-r2}
00094c  e003              B        |L1.2390|
                  |L1.2382|
00094e  2010              MOVS     r0,#0x10
000950  9004              STR      r0,[sp,#0x10]
000952  a804              ADD      r0,sp,#0x10
000954  c807              LDM      r0,{r0-r2}
                  |L1.2390|
000956  ab07              ADD      r3,sp,#0x1c
000958  c307              STM      r3!,{r0-r2}
                  |L1.2394|
;;;1830     } else {                                      // in Thread
;;;1831       return __svcMessageGet(queue_id, millisec);
;;;1832     }
;;;1833   }
00095a  b00a              ADD      sp,sp,#0x28
00095c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2400|
000960  bf00              NOP                            ;1831
000962  4629              MOV      r1,r5                 ;1831
000964  4620              MOV      r0,r4                 ;1831
000966  f2af0cbd          ADR      r12,svcMessageGet + 1
00096a  df00              SVC      #0x0                  ;1831
00096c  ab01              ADD      r3,sp,#4              ;1831
00096e  c307              STM      r3!,{r0-r2}           ;1831
000970  ab04              ADD      r3,sp,#0x10           ;1831
000972  c307              STM      r3!,{r0-r2}           ;1831
000974  e7f1              B        |L1.2394|
;;;1834   
                          ENDP

                  osTimerThread PROC
;;;1175   // Timer Thread
;;;1176   __NO_RETURN void osTimerThread (void const *argument) {
000976  b086              SUB      sp,sp,#0x18
;;;1177     osCallback cb;
;;;1178     osEvent    evt;
;;;1179   
;;;1180     for (;;) {
000978  bf00              NOP      
                  |L1.2426|
;;;1181       evt = osMessageGet(osMessageQId_osTimerMessageQ, osWaitForever);
00097a  f04f31ff          MOV      r1,#0xffffffff
00097e  48f7              LDR      r0,|L1.3420|
000980  6800              LDR      r0,[r0,#0]  ; osMessageQId_osTimerMessageQ
000982  f7fffffe          BL       osMessageGet
000986  ab01              ADD      r3,sp,#4
000988  c307              STM      r3!,{r0-r2}
;;;1182       if (evt.status == osEventMessage) {
00098a  9801              LDR      r0,[sp,#4]
00098c  2810              CMP      r0,#0x10
00098e  d1f4              BNE      |L1.2426|
;;;1183         cb = osTimerCall(evt.value.p);
000990  9802              LDR      r0,[sp,#8]
000992  f7fffffe          BL       osTimerCall
000996  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;1184         if (cb.fp != NULL) {
00099a  9804              LDR      r0,[sp,#0x10]
00099c  2800              CMP      r0,#0
00099e  d0ec              BEQ      |L1.2426|
;;;1185           (*(os_ptimer)cb.fp)(cb.arg);
0009a0  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0009a4  4788              BLX      r1
0009a6  e7e8              B        |L1.2426|
;;;1186         }
;;;1187       }
;;;1188     }
;;;1189   }
;;;1190   
                          ENDP

                  svcSignalSet PROC
;;;1201   /// Set the specified Signal Flags of an active thread
;;;1202   int32_t svcSignalSet (osThreadId thread_id, int32_t signals) {
0009a8  e92d41f0          PUSH     {r4-r8,lr}
0009ac  4607              MOV      r7,r0
0009ae  460c              MOV      r4,r1
;;;1203     P_TCB   ptcb;
;;;1204     int32_t sig;
;;;1205   
;;;1206     ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer
0009b0  4638              MOV      r0,r7
0009b2  f7fffffe          BL       rt_tid2ptcb
0009b6  4605              MOV      r5,r0
;;;1207     if (ptcb == NULL) return 0x80000000;
0009b8  b91d              CBNZ     r5,|L1.2498|
0009ba  f04f4000          MOV      r0,#0x80000000
                  |L1.2494|
;;;1208   
;;;1209     if (signals & (0xFFFFFFFF << osFeature_Signals)) return 0x80000000;
;;;1210   
;;;1211     sig = ptcb->events;                           // Previous signal flags
;;;1212   
;;;1213     rt_evt_set(signals, ptcb->task_id);           // Set event flags
;;;1214   
;;;1215     return sig;
;;;1216   }
0009be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2498|
0009c2  0c20              LSRS     r0,r4,#16             ;1209
0009c4  0400              LSLS     r0,r0,#16             ;1209
0009c6  b110              CBZ      r0,|L1.2510|
0009c8  f04f4000          MOV      r0,#0x80000000        ;1209
0009cc  e7f7              B        |L1.2494|
                  |L1.2510|
0009ce  8b2e              LDRH     r6,[r5,#0x18]         ;1211
0009d0  78e9              LDRB     r1,[r5,#3]            ;1213
0009d2  b2a0              UXTH     r0,r4                 ;1213
0009d4  f7fffffe          BL       rt_evt_set
0009d8  4630              MOV      r0,r6                 ;1215
0009da  e7f0              B        |L1.2494|
;;;1217   
                          ENDP

                  svcSignalClear PROC
;;;1218   /// Clear the specified Signal Flags of an active thread
;;;1219   int32_t svcSignalClear (osThreadId thread_id, int32_t signals) {
0009dc  e92d41f0          PUSH     {r4-r8,lr}
0009e0  4607              MOV      r7,r0
0009e2  460c              MOV      r4,r1
;;;1220     P_TCB   ptcb;
;;;1221     int32_t sig;
;;;1222   
;;;1223     ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer
0009e4  4638              MOV      r0,r7
0009e6  f7fffffe          BL       rt_tid2ptcb
0009ea  4605              MOV      r5,r0
;;;1224     if (ptcb == NULL) return 0x80000000;
0009ec  b91d              CBNZ     r5,|L1.2550|
0009ee  f04f4000          MOV      r0,#0x80000000
                  |L1.2546|
;;;1225   
;;;1226     if (signals & (0xFFFFFFFF << osFeature_Signals)) return 0x80000000;
;;;1227   
;;;1228     sig = ptcb->events;                           // Previous signal flags
;;;1229   
;;;1230     rt_evt_clr(signals, ptcb->task_id);           // Clear event flags
;;;1231   
;;;1232     return sig;
;;;1233   }
0009f2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2550|
0009f6  0c20              LSRS     r0,r4,#16             ;1226
0009f8  0400              LSLS     r0,r0,#16             ;1226
0009fa  b110              CBZ      r0,|L1.2562|
0009fc  f04f4000          MOV      r0,#0x80000000        ;1226
000a00  e7f7              B        |L1.2546|
                  |L1.2562|
000a02  8b2e              LDRH     r6,[r5,#0x18]         ;1228
000a04  78e9              LDRB     r1,[r5,#3]            ;1230
000a06  b2a0              UXTH     r0,r4                 ;1230
000a08  f7fffffe          BL       rt_evt_clr
000a0c  4630              MOV      r0,r6                 ;1232
000a0e  e7f0              B        |L1.2546|
;;;1234   
                          ENDP

                  svcSignalWait PROC
;;;1235   /// Wait for one or more Signal Flags to become signaled for the current RUNNING thread
;;;1236   os_InRegs osEvent_type svcSignalWait (int32_t signals, uint32_t millisec) {
000a10  b5fe              PUSH     {r1-r7,lr}
000a12  4604              MOV      r4,r0
000a14  460e              MOV      r6,r1
;;;1237     OS_RESULT res;
;;;1238     osEvent   ret;
;;;1239   
;;;1240     if (signals & (0xFFFFFFFF << osFeature_Signals)) {
000a16  0c20              LSRS     r0,r4,#16
000a18  0400              LSLS     r0,r0,#16
000a1a  b128              CBZ      r0,|L1.2600|
;;;1241       ret.status = osErrorValue;
000a1c  2086              MOVS     r0,#0x86
000a1e  9000              STR      r0,[sp,#0]
;;;1242       return osEvent_ret_status;
000a20  e89d0007          LDM      sp,{r0-r2}
                  |L1.2596|
;;;1243     }
;;;1244   
;;;1245     if (signals != 0) {                           // Wait for all specified signals
;;;1246       res = rt_evt_wait(signals, rt_ms2tick(millisec), __TRUE);
;;;1247     } else {                                      // Wait for any signal
;;;1248       res = rt_evt_wait(0xFFFF,  rt_ms2tick(millisec), __FALSE);
;;;1249     }
;;;1250   
;;;1251     if (res == OS_R_EVT) {
;;;1252       ret.status = osEventSignal;
;;;1253       ret.value.signals = signals ? signals : os_tsk.run->waits;
;;;1254     } else {
;;;1255       ret.status = millisec ? osEventTimeout : osOK;
;;;1256       ret.value.signals = 0;
;;;1257     }
;;;1258   
;;;1259     return osEvent_ret_value;
;;;1260   }
000a24  b003              ADD      sp,sp,#0xc
000a26  bdf0              POP      {r4-r7,pc}
                  |L1.2600|
000a28  b154              CBZ      r4,|L1.2624|
000a2a  4630              MOV      r0,r6                 ;1246
000a2c  f7fffffe          BL       rt_ms2tick
000a30  b287              UXTH     r7,r0                 ;1246
000a32  b2a0              UXTH     r0,r4                 ;1246
000a34  2201              MOVS     r2,#1                 ;1246
000a36  4639              MOV      r1,r7                 ;1246
000a38  f7fffffe          BL       rt_evt_wait
000a3c  4605              MOV      r5,r0                 ;1246
000a3e  e00a              B        |L1.2646|
                  |L1.2624|
000a40  4630              MOV      r0,r6                 ;1248
000a42  f7fffffe          BL       rt_ms2tick
000a46  b287              UXTH     r7,r0                 ;1248
000a48  2200              MOVS     r2,#0                 ;1248
000a4a  4639              MOV      r1,r7                 ;1248
000a4c  f64f70ff          MOV      r0,#0xffff            ;1248
000a50  f7fffffe          BL       rt_evt_wait
000a54  4605              MOV      r5,r0                 ;1248
                  |L1.2646|
000a56  2d02              CMP      r5,#2                 ;1251
000a58  d109              BNE      |L1.2670|
000a5a  2008              MOVS     r0,#8                 ;1252
000a5c  9000              STR      r0,[sp,#0]            ;1252
000a5e  b10c              CBZ      r4,|L1.2660|
000a60  4620              MOV      r0,r4                 ;1253
000a62  e002              B        |L1.2666|
                  |L1.2660|
000a64  48be              LDR      r0,|L1.3424|
000a66  6800              LDR      r0,[r0,#0]            ;1253  ; os_tsk
000a68  8b40              LDRH     r0,[r0,#0x1a]         ;1253
                  |L1.2666|
000a6a  9001              STR      r0,[sp,#4]            ;1253
000a6c  e006              B        |L1.2684|
                  |L1.2670|
000a6e  b10e              CBZ      r6,|L1.2676|
000a70  2040              MOVS     r0,#0x40              ;1255
000a72  e000              B        |L1.2678|
                  |L1.2676|
000a74  2000              MOVS     r0,#0                 ;1255
                  |L1.2678|
000a76  9000              STR      r0,[sp,#0]            ;1255
000a78  2000              MOVS     r0,#0                 ;1256
000a7a  9001              STR      r0,[sp,#4]            ;1256
                  |L1.2684|
000a7c  e89d0007          LDM      sp,{r0-r2}            ;1259
000a80  e7d0              B        |L1.2596|
;;;1261   
                          ENDP

                  osSignalSet PROC
;;;1285   /// Set the specified Signal Flags of an active thread
;;;1286   int32_t osSignalSet (osThreadId thread_id, int32_t signals) {
000a82  e92d47f0          PUSH     {r4-r10,lr}
000a86  4604              MOV      r4,r0
000a88  460d              MOV      r5,r1
;;;1287     if (__get_IPSR() != 0) {                      // in ISR
000a8a  f7fffffe          BL       __get_IPSR
000a8e  b1c0              CBZ      r0,|L1.2754|
;;;1288       return   isrSignalSet(thread_id, signals); 
000a90  46a0              MOV      r8,r4
000a92  462e              MOV      r6,r5
000a94  4640              MOV      r0,r8
000a96  f7fffffe          BL       rt_tid2ptcb
000a9a  4607              MOV      r7,r0
000a9c  b917              CBNZ     r7,|L1.2724|
000a9e  f04f4000          MOV      r0,#0x80000000
000aa2  e00c              B        |L1.2750|
                  |L1.2724|
000aa4  0c30              LSRS     r0,r6,#16
000aa6  0400              LSLS     r0,r0,#16
000aa8  b110              CBZ      r0,|L1.2736|
000aaa  f04f4000          MOV      r0,#0x80000000
000aae  e006              B        |L1.2750|
                  |L1.2736|
000ab0  f8b79018          LDRH     r9,[r7,#0x18]
000ab4  78f9              LDRB     r1,[r7,#3]
000ab6  b2b0              UXTH     r0,r6
000ab8  f7fffffe          BL       isr_evt_set
000abc  4648              MOV      r0,r9
                  |L1.2750|
;;;1289     } else {                                      // in Thread
;;;1290       return __svcSignalSet(thread_id, signals);
;;;1291     }
;;;1292   }
000abe  e8bd87f0          POP      {r4-r10,pc}
                  |L1.2754|
000ac2  bf00              NOP                            ;1290
000ac4  4629              MOV      r1,r5                 ;1290
000ac6  4620              MOV      r0,r4                 ;1290
000ac8  f2af1c23          ADR      r12,svcSignalSet + 1
000acc  df00              SVC      #0x0                  ;1290
000ace  bf00              NOP                            ;1290
000ad0  e7f5              B        |L1.2750|
;;;1293   
                          ENDP

                  osSignalClear PROC
;;;1294   /// Clear the specified Signal Flags of an active thread
;;;1295   int32_t osSignalClear (osThreadId thread_id, int32_t signals) {
000ad2  b570              PUSH     {r4-r6,lr}
000ad4  4605              MOV      r5,r0
000ad6  460c              MOV      r4,r1
;;;1296     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000ad8  f7fffffe          BL       __get_IPSR
000adc  b108              CBZ      r0,|L1.2786|
000ade  2082              MOVS     r0,#0x82
                  |L1.2784|
;;;1297     return __svcSignalClear(thread_id, signals);
;;;1298   }
000ae0  bd70              POP      {r4-r6,pc}
                  |L1.2786|
000ae2  bf00              NOP                            ;1297
000ae4  4621              MOV      r1,r4                 ;1297
000ae6  4628              MOV      r0,r5                 ;1297
000ae8  f2af1c0f          ADR      r12,svcSignalClear + 1
000aec  df00              SVC      #0x0                  ;1297
000aee  bf00              NOP                            ;1297
000af0  e7f6              B        |L1.2784|
;;;1299   
                          ENDP

                  osSignalWait PROC
;;;1300   /// Wait for one or more Signal Flags to become signaled for the current RUNNING thread
;;;1301   os_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec) {
000af2  b530              PUSH     {r4,r5,lr}
000af4  b089              SUB      sp,sp,#0x24
000af6  4604              MOV      r4,r0
000af8  460d              MOV      r5,r1
;;;1302     osEvent ret;
;;;1303   
;;;1304     if (__get_IPSR() != 0) {                      // Not allowed in ISR
000afa  f7fffffe          BL       __get_IPSR
000afe  b128              CBZ      r0,|L1.2828|
;;;1305       ret.status = osErrorISR;
000b00  2082              MOVS     r0,#0x82
000b02  9006              STR      r0,[sp,#0x18]
;;;1306       return ret;
000b04  a806              ADD      r0,sp,#0x18
000b06  c807              LDM      r0,{r0-r2}
                  |L1.2824|
;;;1307     }
;;;1308     return __svcSignalWait(signals, millisec);
;;;1309   }
000b08  b009              ADD      sp,sp,#0x24
000b0a  bd30              POP      {r4,r5,pc}
                  |L1.2828|
000b0c  bf00              NOP                            ;1308
000b0e  4629              MOV      r1,r5                 ;1308
000b10  4620              MOV      r0,r4                 ;1308
000b12  f2af1c03          ADR      r12,svcSignalWait + 1
000b16  df00              SVC      #0x0                  ;1308
000b18  e88d0007          STM      sp,{r0-r2}            ;1308
000b1c  ab03              ADD      r3,sp,#0xc            ;1308
000b1e  c307              STM      r3!,{r0-r2}           ;1308
000b20  e7f2              B        |L1.2824|
;;;1310   
                          ENDP

                  svcMutexCreate PROC
;;;1322   /// Create and Initialize a Mutex object
;;;1323   osMutexId svcMutexCreate (const osMutexDef_t *mutex_def) {
000b22  b570              PUSH     {r4-r6,lr}
000b24  4605              MOV      r5,r0
;;;1324     OS_ID mut;
;;;1325   
;;;1326     if (mutex_def == NULL) {
000b26  b925              CBNZ     r5,|L1.2866|
;;;1327       sysThreadError(osErrorParameter);
000b28  2080              MOVS     r0,#0x80
000b2a  f7fffffe          BL       sysThreadError
;;;1328       return NULL;
000b2e  2000              MOVS     r0,#0
                  |L1.2864|
;;;1329     }
;;;1330   
;;;1331     mut = mutex_def->mutex;
;;;1332     if (mut == NULL) {
;;;1333       sysThreadError(osErrorParameter);
;;;1334       return NULL;
;;;1335     }
;;;1336   
;;;1337     if (((P_MUCB)mut)->cb_type != 0) {
;;;1338       sysThreadError(osErrorParameter);
;;;1339       return NULL;
;;;1340     }
;;;1341   
;;;1342     rt_mut_init(mut);                             // Initialize Mutex
;;;1343   
;;;1344     return mut;
;;;1345   }
000b30  bd70              POP      {r4-r6,pc}
                  |L1.2866|
000b32  682c              LDR      r4,[r5,#0]            ;1331
000b34  b924              CBNZ     r4,|L1.2880|
000b36  2080              MOVS     r0,#0x80              ;1333
000b38  f7fffffe          BL       sysThreadError
000b3c  2000              MOVS     r0,#0                 ;1334
000b3e  e7f7              B        |L1.2864|
                  |L1.2880|
000b40  7820              LDRB     r0,[r4,#0]            ;1337
000b42  b120              CBZ      r0,|L1.2894|
000b44  2080              MOVS     r0,#0x80              ;1338
000b46  f7fffffe          BL       sysThreadError
000b4a  2000              MOVS     r0,#0                 ;1339
000b4c  e7f0              B        |L1.2864|
                  |L1.2894|
000b4e  4620              MOV      r0,r4                 ;1342
000b50  f7fffffe          BL       rt_mut_init
000b54  4620              MOV      r0,r4                 ;1344
000b56  e7eb              B        |L1.2864|
;;;1346   
                          ENDP

                  svcMutexWait PROC
;;;1347   /// Wait until a Mutex becomes available
;;;1348   osStatus svcMutexWait (osMutexId mutex_id, uint32_t millisec) {
000b58  e92d41f0          PUSH     {r4-r8,lr}
000b5c  4607              MOV      r7,r0
000b5e  460c              MOV      r4,r1
;;;1349     OS_ID     mut;
;;;1350     OS_RESULT res;
;;;1351   
;;;1352     mut = rt_id2obj(mutex_id);
000b60  4638              MOV      r0,r7
000b62  f7fffffe          BL       rt_id2obj
000b66  4605              MOV      r5,r0
;;;1353     if (mut == NULL) return osErrorParameter;
000b68  b915              CBNZ     r5,|L1.2928|
000b6a  2080              MOVS     r0,#0x80
                  |L1.2924|
;;;1354   
;;;1355     if (((P_MUCB)mut)->cb_type != MUCB) return osErrorParameter;
;;;1356   
;;;1357     res = rt_mut_wait(mut, rt_ms2tick(millisec)); // Wait for Mutex
;;;1358   
;;;1359     if (res == OS_R_TMO) {
;;;1360       return (millisec ? osErrorTimeoutResource : osErrorResource);
;;;1361     }
;;;1362   
;;;1363     return osOK;
;;;1364   }
000b6c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2928|
000b70  7828              LDRB     r0,[r5,#0]            ;1355
000b72  2803              CMP      r0,#3                 ;1355
000b74  d001              BEQ      |L1.2938|
000b76  2080              MOVS     r0,#0x80              ;1355
000b78  e7f8              B        |L1.2924|
                  |L1.2938|
000b7a  4620              MOV      r0,r4                 ;1357
000b7c  f7fffffe          BL       rt_ms2tick
000b80  fa1ff880          UXTH     r8,r0                 ;1357
000b84  4641              MOV      r1,r8                 ;1357
000b86  4628              MOV      r0,r5                 ;1357
000b88  f7fffffe          BL       rt_mut_wait
000b8c  4606              MOV      r6,r0                 ;1357
000b8e  2e01              CMP      r6,#1                 ;1359
000b90  d104              BNE      |L1.2972|
000b92  b10c              CBZ      r4,|L1.2968|
000b94  20c1              MOVS     r0,#0xc1              ;1360
000b96  e7e9              B        |L1.2924|
                  |L1.2968|
000b98  2081              MOVS     r0,#0x81              ;1360
000b9a  e7e7              B        |L1.2924|
                  |L1.2972|
000b9c  2000              MOVS     r0,#0                 ;1363
000b9e  e7e5              B        |L1.2924|
;;;1365   
                          ENDP

                  svcMutexRelease PROC
;;;1366   /// Release a Mutex that was obtained with osMutexWait
;;;1367   osStatus svcMutexRelease (osMutexId mutex_id) {
000ba0  b570              PUSH     {r4-r6,lr}
000ba2  4606              MOV      r6,r0
;;;1368     OS_ID     mut;
;;;1369     OS_RESULT res;
;;;1370   
;;;1371     mut = rt_id2obj(mutex_id);
000ba4  4630              MOV      r0,r6
000ba6  f7fffffe          BL       rt_id2obj
000baa  4604              MOV      r4,r0
;;;1372     if (mut == NULL) return osErrorParameter;
000bac  b90c              CBNZ     r4,|L1.2994|
000bae  2080              MOVS     r0,#0x80
                  |L1.2992|
;;;1373   
;;;1374     if (((P_MUCB)mut)->cb_type != MUCB) return osErrorParameter;
;;;1375   
;;;1376     res = rt_mut_release(mut);                    // Release Mutex
;;;1377   
;;;1378     if (res == OS_R_NOK) return osErrorResource;  // Thread not owner or Zero Counter
;;;1379   
;;;1380     return osOK;
;;;1381   }
000bb0  bd70              POP      {r4-r6,pc}
                  |L1.2994|
000bb2  7820              LDRB     r0,[r4,#0]            ;1374
000bb4  2803              CMP      r0,#3                 ;1374
000bb6  d001              BEQ      |L1.3004|
000bb8  2080              MOVS     r0,#0x80              ;1374
000bba  e7f9              B        |L1.2992|
                  |L1.3004|
000bbc  4620              MOV      r0,r4                 ;1376
000bbe  f7fffffe          BL       rt_mut_release
000bc2  4605              MOV      r5,r0                 ;1376
000bc4  2dff              CMP      r5,#0xff              ;1378
000bc6  d101              BNE      |L1.3020|
000bc8  2081              MOVS     r0,#0x81              ;1378
000bca  e7f1              B        |L1.2992|
                  |L1.3020|
000bcc  2000              MOVS     r0,#0                 ;1380
000bce  e7ef              B        |L1.2992|
;;;1382   
                          ENDP

                  svcMutexDelete PROC
;;;1383   /// Delete a Mutex that was created by osMutexCreate
;;;1384   osStatus svcMutexDelete (osMutexId mutex_id) {
000bd0  b570              PUSH     {r4-r6,lr}
000bd2  4605              MOV      r5,r0
;;;1385     OS_ID mut;
;;;1386   
;;;1387     mut = rt_id2obj(mutex_id);
000bd4  4628              MOV      r0,r5
000bd6  f7fffffe          BL       rt_id2obj
000bda  4604              MOV      r4,r0
;;;1388     if (mut == NULL) return osErrorParameter;
000bdc  b90c              CBNZ     r4,|L1.3042|
000bde  2080              MOVS     r0,#0x80
                  |L1.3040|
;;;1389   
;;;1390     if (((P_MUCB)mut)->cb_type != MUCB) return osErrorParameter;
;;;1391   
;;;1392     rt_mut_delete(mut);                           // Release Mutex
;;;1393   
;;;1394     return osOK;
;;;1395   }
000be0  bd70              POP      {r4-r6,pc}
                  |L1.3042|
000be2  7820              LDRB     r0,[r4,#0]            ;1390
000be4  2803              CMP      r0,#3                 ;1390
000be6  d001              BEQ      |L1.3052|
000be8  2080              MOVS     r0,#0x80              ;1390
000bea  e7f9              B        |L1.3040|
                  |L1.3052|
000bec  4620              MOV      r0,r4                 ;1392
000bee  f7fffffe          BL       rt_mut_delete
000bf2  2000              MOVS     r0,#0                 ;1394
000bf4  e7f4              B        |L1.3040|
;;;1396   
                          ENDP

                  osMutexCreate PROC
;;;1400   /// Create and Initialize a Mutex object
;;;1401   osMutexId osMutexCreate (const osMutexDef_t *mutex_def) {
000bf6  b510              PUSH     {r4,lr}
000bf8  4604              MOV      r4,r0
;;;1402     if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
000bfa  f7fffffe          BL       __get_IPSR
000bfe  b108              CBZ      r0,|L1.3076|
000c00  2000              MOVS     r0,#0
                  |L1.3074|
;;;1403     if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;1404       // Privileged and not running
;;;1405       return    svcMutexCreate(mutex_def);
;;;1406     } else {
;;;1407       return __svcMutexCreate(mutex_def);
;;;1408     }
;;;1409   }
000c02  bd10              POP      {r4,pc}
                  |L1.3076|
000c04  f7fffffe          BL       __get_CONTROL
000c08  f0000001          AND      r0,r0,#1              ;1403
000c0c  b930              CBNZ     r0,|L1.3100|
000c0e  4855              LDR      r0,|L1.3428|
000c10  7800              LDRB     r0,[r0,#0]            ;1403  ; os_running
000c12  b918              CBNZ     r0,|L1.3100|
000c14  4620              MOV      r0,r4                 ;1405
000c16  f7fffffe          BL       svcMutexCreate
000c1a  e7f2              B        |L1.3074|
                  |L1.3100|
000c1c  bf00              NOP                            ;1407
000c1e  4620              MOV      r0,r4                 ;1407
000c20  f2af1c01          ADR      r12,svcMutexCreate + 1
000c24  df00              SVC      #0x0                  ;1407
000c26  bf00              NOP                            ;1407
000c28  e7eb              B        |L1.3074|
;;;1410   
                          ENDP

                  osMutexWait PROC
;;;1411   /// Wait until a Mutex becomes available
;;;1412   osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec) {
000c2a  b570              PUSH     {r4-r6,lr}
000c2c  4605              MOV      r5,r0
000c2e  460c              MOV      r4,r1
;;;1413     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000c30  f7fffffe          BL       __get_IPSR
000c34  b108              CBZ      r0,|L1.3130|
000c36  2082              MOVS     r0,#0x82
                  |L1.3128|
;;;1414     return __svcMutexWait(mutex_id, millisec);
;;;1415   }
000c38  bd70              POP      {r4-r6,pc}
                  |L1.3130|
000c3a  bf00              NOP                            ;1414
000c3c  4621              MOV      r1,r4                 ;1414
000c3e  4628              MOV      r0,r5                 ;1414
000c40  f2af0ceb          ADR      r12,svcMutexWait + 1
000c44  df00              SVC      #0x0                  ;1414
000c46  bf00              NOP                            ;1414
000c48  e7f6              B        |L1.3128|
;;;1416   
                          ENDP

                  osMutexRelease PROC
;;;1417   /// Release a Mutex that was obtained with osMutexWait
;;;1418   osStatus osMutexRelease (osMutexId mutex_id) {
000c4a  b510              PUSH     {r4,lr}
000c4c  4604              MOV      r4,r0
;;;1419     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000c4e  f7fffffe          BL       __get_IPSR
000c52  b108              CBZ      r0,|L1.3160|
000c54  2082              MOVS     r0,#0x82
                  |L1.3158|
;;;1420     return __svcMutexRelease(mutex_id);
;;;1421   }
000c56  bd10              POP      {r4,pc}
                  |L1.3160|
000c58  bf00              NOP                            ;1420
000c5a  4620              MOV      r0,r4                 ;1420
000c5c  f2af0cbf          ADR      r12,svcMutexRelease + 1
000c60  df00              SVC      #0x0                  ;1420
000c62  bf00              NOP                            ;1420
000c64  e7f7              B        |L1.3158|
;;;1422   
                          ENDP

                  osMutexDelete PROC
;;;1423   /// Delete a Mutex that was created by osMutexCreate
;;;1424   osStatus osMutexDelete (osMutexId mutex_id) {
000c66  b510              PUSH     {r4,lr}
000c68  4604              MOV      r4,r0
;;;1425     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000c6a  f7fffffe          BL       __get_IPSR
000c6e  b108              CBZ      r0,|L1.3188|
000c70  2082              MOVS     r0,#0x82
                  |L1.3186|
;;;1426     return __svcMutexDelete(mutex_id);
;;;1427   }
000c72  bd10              POP      {r4,pc}
                  |L1.3188|
000c74  bf00              NOP                            ;1426
000c76  4620              MOV      r0,r4                 ;1426
000c78  f2af0cab          ADR      r12,svcMutexDelete + 1
000c7c  df00              SVC      #0x0                  ;1426
000c7e  bf00              NOP                            ;1426
000c80  e7f7              B        |L1.3186|
;;;1428   
                          ENDP

                  svcSemaphoreCreate PROC
;;;1440   /// Create and Initialize a Semaphore object
;;;1441   osSemaphoreId svcSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count) {
000c82  b570              PUSH     {r4-r6,lr}
000c84  4605              MOV      r5,r0
000c86  460e              MOV      r6,r1
;;;1442     OS_ID sem;
;;;1443   
;;;1444     if (semaphore_def == NULL) {
000c88  b925              CBNZ     r5,|L1.3220|
;;;1445       sysThreadError(osErrorParameter);
000c8a  2080              MOVS     r0,#0x80
000c8c  f7fffffe          BL       sysThreadError
;;;1446       return NULL;
000c90  2000              MOVS     r0,#0
                  |L1.3218|
;;;1447     }
;;;1448   
;;;1449     sem = semaphore_def->semaphore;
;;;1450     if (sem == NULL) {
;;;1451       sysThreadError(osErrorParameter);
;;;1452       return NULL;
;;;1453     }
;;;1454   
;;;1455     if (((P_SCB)sem)->cb_type != 0) {
;;;1456       sysThreadError(osErrorParameter);
;;;1457       return NULL;
;;;1458     }
;;;1459   
;;;1460     if (count > osFeature_Semaphore) {
;;;1461       sysThreadError(osErrorValue);
;;;1462       return NULL;
;;;1463     }
;;;1464   
;;;1465     rt_sem_init(sem, count);                      // Initialize Semaphore
;;;1466     
;;;1467     return sem;
;;;1468   }
000c92  bd70              POP      {r4-r6,pc}
                  |L1.3220|
000c94  682c              LDR      r4,[r5,#0]            ;1449
000c96  b924              CBNZ     r4,|L1.3234|
000c98  2080              MOVS     r0,#0x80              ;1451
000c9a  f7fffffe          BL       sysThreadError
000c9e  2000              MOVS     r0,#0                 ;1452
000ca0  e7f7              B        |L1.3218|
                  |L1.3234|
000ca2  7820              LDRB     r0,[r4,#0]            ;1455
000ca4  b120              CBZ      r0,|L1.3248|
000ca6  2080              MOVS     r0,#0x80              ;1456
000ca8  f7fffffe          BL       sysThreadError
000cac  2000              MOVS     r0,#0                 ;1457
000cae  e7f0              B        |L1.3218|
                  |L1.3248|
000cb0  f5b63f80          CMP      r6,#0x10000           ;1460
000cb4  db04              BLT      |L1.3264|
000cb6  2086              MOVS     r0,#0x86              ;1461
000cb8  f7fffffe          BL       sysThreadError
000cbc  2000              MOVS     r0,#0                 ;1462
000cbe  e7e8              B        |L1.3218|
                  |L1.3264|
000cc0  b2b1              UXTH     r1,r6                 ;1465
000cc2  4620              MOV      r0,r4                 ;1465
000cc4  f7fffffe          BL       rt_sem_init
000cc8  4620              MOV      r0,r4                 ;1467
000cca  e7e2              B        |L1.3218|
;;;1469   
                          ENDP

                  svcSemaphoreWait PROC
;;;1470   /// Wait until a Semaphore becomes available
;;;1471   int32_t svcSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec) {
000ccc  e92d41f0          PUSH     {r4-r8,lr}
000cd0  4607              MOV      r7,r0
000cd2  460e              MOV      r6,r1
;;;1472     OS_ID     sem;
;;;1473     OS_RESULT res;
;;;1474   
;;;1475     sem = rt_id2obj(semaphore_id);
000cd4  4638              MOV      r0,r7
000cd6  f7fffffe          BL       rt_id2obj
000cda  4604              MOV      r4,r0
;;;1476     if (sem == NULL) return -1;
000cdc  b91c              CBNZ     r4,|L1.3302|
000cde  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3298|
;;;1477   
;;;1478     if (((P_SCB)sem)->cb_type != SCB) return -1;
;;;1479   
;;;1480     res = rt_sem_wait(sem, rt_ms2tick(millisec)); // Wait for Semaphore
;;;1481   
;;;1482     if (res == OS_R_TMO) return 0;                // Timeout
;;;1483   
;;;1484     return (((P_SCB)sem)->tokens + 1);
;;;1485   }
000ce2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3302|
000ce6  7820              LDRB     r0,[r4,#0]            ;1478
000ce8  2802              CMP      r0,#2                 ;1478
000cea  d002              BEQ      |L1.3314|
000cec  f04f30ff          MOV      r0,#0xffffffff        ;1478
000cf0  e7f7              B        |L1.3298|
                  |L1.3314|
000cf2  4630              MOV      r0,r6                 ;1480
000cf4  f7fffffe          BL       rt_ms2tick
000cf8  fa1ff880          UXTH     r8,r0                 ;1480
000cfc  4641              MOV      r1,r8                 ;1480
000cfe  4620              MOV      r0,r4                 ;1480
000d00  f7fffffe          BL       rt_sem_wait
000d04  4605              MOV      r5,r0                 ;1480
000d06  2d01              CMP      r5,#1                 ;1482
000d08  d101              BNE      |L1.3342|
000d0a  2000              MOVS     r0,#0                 ;1482
000d0c  e7e9              B        |L1.3298|
                  |L1.3342|
000d0e  8860              LDRH     r0,[r4,#2]            ;1484
000d10  1c40              ADDS     r0,r0,#1              ;1484
000d12  e7e6              B        |L1.3298|
;;;1486   
                          ENDP

                  svcSemaphoreRelease PROC
;;;1487   /// Release a Semaphore
;;;1488   osStatus svcSemaphoreRelease (osSemaphoreId semaphore_id) {
000d14  b570              PUSH     {r4-r6,lr}
000d16  4605              MOV      r5,r0
;;;1489     OS_ID sem;
;;;1490   
;;;1491     sem = rt_id2obj(semaphore_id);
000d18  4628              MOV      r0,r5
000d1a  f7fffffe          BL       rt_id2obj
000d1e  4604              MOV      r4,r0
;;;1492     if (sem == NULL) return osErrorParameter;
000d20  b90c              CBNZ     r4,|L1.3366|
000d22  2080              MOVS     r0,#0x80
                  |L1.3364|
;;;1493   
;;;1494     if (((P_SCB)sem)->cb_type != SCB) return osErrorParameter;
;;;1495   
;;;1496     if (((P_SCB)sem)->tokens == osFeature_Semaphore) return osErrorResource;
;;;1497     
;;;1498     rt_sem_send(sem);                             // Release Semaphore
;;;1499   
;;;1500     return osOK;
;;;1501   }
000d24  bd70              POP      {r4-r6,pc}
                  |L1.3366|
000d26  7820              LDRB     r0,[r4,#0]            ;1494
000d28  2802              CMP      r0,#2                 ;1494
000d2a  d001              BEQ      |L1.3376|
000d2c  2080              MOVS     r0,#0x80              ;1494
000d2e  e7f9              B        |L1.3364|
                  |L1.3376|
000d30  8860              LDRH     r0,[r4,#2]            ;1496
000d32  f64f71ff          MOV      r1,#0xffff            ;1496
000d36  4288              CMP      r0,r1                 ;1496
000d38  d101              BNE      |L1.3390|
000d3a  2081              MOVS     r0,#0x81              ;1496
000d3c  e7f2              B        |L1.3364|
                  |L1.3390|
000d3e  4620              MOV      r0,r4                 ;1498
000d40  f7fffffe          BL       rt_sem_send
000d44  2000              MOVS     r0,#0                 ;1500
000d46  e7ed              B        |L1.3364|
;;;1502   
                          ENDP

                  svcSemaphoreDelete PROC
;;;1503   /// Delete a Semaphore that was created by osSemaphoreCreate
;;;1504   osStatus svcSemaphoreDelete (osSemaphoreId semaphore_id) {
000d48  b570              PUSH     {r4-r6,lr}
000d4a  4605              MOV      r5,r0
;;;1505     OS_ID sem;
;;;1506   
;;;1507     sem = rt_id2obj(semaphore_id);
000d4c  4628              MOV      r0,r5
000d4e  f7fffffe          BL       rt_id2obj
000d52  4604              MOV      r4,r0
;;;1508     if (sem == NULL) return osErrorParameter;
000d54  b944              CBNZ     r4,|L1.3432|
000d56  2080              MOVS     r0,#0x80
                  |L1.3416|
;;;1509   
;;;1510     if (((P_SCB)sem)->cb_type != SCB) return osErrorParameter;
;;;1511   
;;;1512     rt_sem_delete(sem);                           // Delete Semaphore
;;;1513   
;;;1514     return osOK;
;;;1515   }
000d58  bd70              POP      {r4-r6,pc}
000d5a  0000              DCW      0x0000
                  |L1.3420|
                          DCD      osMessageQId_osTimerMessageQ
                  |L1.3424|
                          DCD      os_tsk
                  |L1.3428|
                          DCD      os_running
                  |L1.3432|
000d68  7820              LDRB     r0,[r4,#0]            ;1510
000d6a  2802              CMP      r0,#2                 ;1510
000d6c  d001              BEQ      |L1.3442|
000d6e  2080              MOVS     r0,#0x80              ;1510
000d70  e7f2              B        |L1.3416|
                  |L1.3442|
000d72  4620              MOV      r0,r4                 ;1512
000d74  f7fffffe          BL       rt_sem_delete
000d78  2000              MOVS     r0,#0                 ;1514
000d7a  e7ed              B        |L1.3416|
;;;1516   
                          ENDP

                  osSemaphoreCreate PROC
;;;1539   /// Create and Initialize a Semaphore object
;;;1540   osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count) {
000d7c  b570              PUSH     {r4-r6,lr}
000d7e  4605              MOV      r5,r0
000d80  460c              MOV      r4,r1
;;;1541     if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
000d82  f7fffffe          BL       __get_IPSR
000d86  b108              CBZ      r0,|L1.3468|
000d88  2000              MOVS     r0,#0
                  |L1.3466|
;;;1542     if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;1543       // Privileged and not running
;;;1544       return   svcSemaphoreCreate(semaphore_def, count);
;;;1545     } else {
;;;1546       return __svcSemaphoreCreate(semaphore_def, count);
;;;1547     }
;;;1548   }
000d8a  bd70              POP      {r4-r6,pc}
                  |L1.3468|
000d8c  f7fffffe          BL       __get_CONTROL
000d90  f0000001          AND      r0,r0,#1              ;1542
000d94  b938              CBNZ     r0,|L1.3494|
000d96  48f9              LDR      r0,|L1.4476|
000d98  7800              LDRB     r0,[r0,#0]            ;1542  ; os_running
000d9a  b920              CBNZ     r0,|L1.3494|
000d9c  4621              MOV      r1,r4                 ;1544
000d9e  4628              MOV      r0,r5                 ;1544
000da0  f7fffffe          BL       svcSemaphoreCreate
000da4  e7f1              B        |L1.3466|
                  |L1.3494|
000da6  bf00              NOP                            ;1546
000da8  4621              MOV      r1,r4                 ;1546
000daa  4628              MOV      r0,r5                 ;1546
000dac  f2af1c2d          ADR      r12,svcSemaphoreCreate + 1
000db0  df00              SVC      #0x0                  ;1546
000db2  bf00              NOP                            ;1546
000db4  e7e9              B        |L1.3466|
;;;1549   
                          ENDP

                  osSemaphoreWait PROC
;;;1550   /// Wait until a Semaphore becomes available
;;;1551   int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec) {
000db6  b570              PUSH     {r4-r6,lr}
000db8  4605              MOV      r5,r0
000dba  460c              MOV      r4,r1
;;;1552     if (__get_IPSR() != 0) return -1;             // Not allowed in ISR
000dbc  f7fffffe          BL       __get_IPSR
000dc0  b110              CBZ      r0,|L1.3528|
000dc2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3526|
;;;1553     return __svcSemaphoreWait(semaphore_id, millisec);
;;;1554   }
000dc6  bd70              POP      {r4-r6,pc}
                  |L1.3528|
000dc8  bf00              NOP                            ;1553
000dca  4621              MOV      r1,r4                 ;1553
000dcc  4628              MOV      r0,r5                 ;1553
000dce  f2af1c03          ADR      r12,svcSemaphoreWait + 1
000dd2  df00              SVC      #0x0                  ;1553
000dd4  bf00              NOP                            ;1553
000dd6  e7f6              B        |L1.3526|
;;;1555   
                          ENDP

                  osSemaphoreRelease PROC
;;;1556   /// Release a Semaphore
;;;1557   osStatus osSemaphoreRelease (osSemaphoreId semaphore_id) {
000dd8  b570              PUSH     {r4-r6,lr}
000dda  4604              MOV      r4,r0
;;;1558     if (__get_IPSR() != 0) {                      // in ISR
000ddc  f7fffffe          BL       __get_IPSR
000de0  b1c0              CBZ      r0,|L1.3604|
;;;1559       return   isrSemaphoreRelease(semaphore_id);
000de2  4626              MOV      r6,r4
000de4  4630              MOV      r0,r6
000de6  f7fffffe          BL       rt_id2obj
000dea  4605              MOV      r5,r0
000dec  b90d              CBNZ     r5,|L1.3570|
000dee  2080              MOVS     r0,#0x80
000df0  e00f              B        |L1.3602|
                  |L1.3570|
000df2  7828              LDRB     r0,[r5,#0]
000df4  2802              CMP      r0,#2
000df6  d001              BEQ      |L1.3580|
000df8  2080              MOVS     r0,#0x80
000dfa  e00a              B        |L1.3602|
                  |L1.3580|
000dfc  8868              LDRH     r0,[r5,#2]
000dfe  f64f71ff          MOV      r1,#0xffff
000e02  4288              CMP      r0,r1
000e04  d101              BNE      |L1.3594|
000e06  2081              MOVS     r0,#0x81
000e08  e003              B        |L1.3602|
                  |L1.3594|
000e0a  4628              MOV      r0,r5
000e0c  f7fffffe          BL       isr_sem_send
000e10  2000              MOVS     r0,#0
                  |L1.3602|
;;;1560     } else {                                      // in Thread
;;;1561       return __svcSemaphoreRelease(semaphore_id);
;;;1562     }
;;;1563   }
000e12  bd70              POP      {r4-r6,pc}
                  |L1.3604|
000e14  bf00              NOP                            ;1561
000e16  4620              MOV      r0,r4                 ;1561
000e18  f2af1c07          ADR      r12,svcSemaphoreRelease + 1
000e1c  df00              SVC      #0x0                  ;1561
000e1e  bf00              NOP                            ;1561
000e20  e7f7              B        |L1.3602|
;;;1564   
                          ENDP

                  osSemaphoreDelete PROC
;;;1565   /// Delete a Semaphore that was created by osSemaphoreCreate
;;;1566   osStatus osSemaphoreDelete (osSemaphoreId semaphore_id) {
000e22  b510              PUSH     {r4,lr}
000e24  4604              MOV      r4,r0
;;;1567     if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR
000e26  f7fffffe          BL       __get_IPSR
000e2a  b108              CBZ      r0,|L1.3632|
000e2c  2082              MOVS     r0,#0x82
                  |L1.3630|
;;;1568     return __svcSemaphoreDelete(semaphore_id);
;;;1569   }
000e2e  bd10              POP      {r4,pc}
                  |L1.3632|
000e30  bf00              NOP                            ;1568
000e32  4620              MOV      r0,r4                 ;1568
000e34  f2af0cef          ADR      r12,svcSemaphoreDelete + 1
000e38  df00              SVC      #0x0                  ;1568
000e3a  bf00              NOP                            ;1568
000e3c  e7f7              B        |L1.3630|
;;;1570   
                          ENDP

                  rt_clr_box PROC
;;;1576   // Clear Memory Box (Zero init)
;;;1577   static void rt_clr_box (void *box_mem, void *box) {
000e3e  b510              PUSH     {r4,lr}
000e40  4603              MOV      r3,r0
;;;1578     uint32_t *p, n;
;;;1579   
;;;1580     if (box) {
000e42  b139              CBZ      r1,|L1.3668|
;;;1581       p = box;
000e44  4608              MOV      r0,r1
;;;1582       for (n = ((P_BM)box_mem)->blk_size; n; n -= 4) {
000e46  689a              LDR      r2,[r3,#8]
000e48  e002              B        |L1.3664|
                  |L1.3658|
;;;1583         *p++ = 0;
000e4a  2400              MOVS     r4,#0
000e4c  c010              STM      r0!,{r4}
000e4e  1f12              SUBS     r2,r2,#4              ;1582
                  |L1.3664|
000e50  2a00              CMP      r2,#0                 ;1582
000e52  d1fa              BNE      |L1.3658|
                  |L1.3668|
;;;1584       }
;;;1585     }
;;;1586   }
000e54  bd10              POP      {r4,pc}
;;;1587   
                          ENDP

                  svcPoolCreate PROC
;;;1595   /// Create and Initialize memory pool
;;;1596   osPoolId svcPoolCreate (const osPoolDef_t *pool_def) {
000e56  b570              PUSH     {r4-r6,lr}
000e58  4604              MOV      r4,r0
;;;1597     uint32_t blk_sz;
;;;1598   
;;;1599     if ((pool_def == NULL) ||
000e5a  b12c              CBZ      r4,|L1.3688|
;;;1600         (pool_def->pool_sz == 0) ||
000e5c  6820              LDR      r0,[r4,#0]
000e5e  b118              CBZ      r0,|L1.3688|
;;;1601         (pool_def->item_sz == 0) ||
000e60  6860              LDR      r0,[r4,#4]
000e62  b108              CBZ      r0,|L1.3688|
;;;1602         (pool_def->pool == NULL)) {
000e64  68a0              LDR      r0,[r4,#8]
000e66  b920              CBNZ     r0,|L1.3698|
                  |L1.3688|
;;;1603       sysThreadError(osErrorParameter);
000e68  2080              MOVS     r0,#0x80
000e6a  f7fffffe          BL       sysThreadError
;;;1604       return NULL;
000e6e  2000              MOVS     r0,#0
                  |L1.3696|
;;;1605     }
;;;1606   
;;;1607     blk_sz = (pool_def->item_sz + 3) & ~3;
;;;1608   
;;;1609     _init_box(pool_def->pool, sizeof(struct OS_BM) + pool_def->pool_sz * blk_sz, blk_sz);
;;;1610   
;;;1611     return pool_def->pool;
;;;1612   }
000e70  bd70              POP      {r4-r6,pc}
                  |L1.3698|
000e72  6860              LDR      r0,[r4,#4]            ;1607
000e74  1cc0              ADDS     r0,r0,#3              ;1607
000e76  f0200503          BIC      r5,r0,#3              ;1607
000e7a  6822              LDR      r2,[r4,#0]            ;1609
000e7c  436a              MULS     r2,r5,r2              ;1609
000e7e  f102010c          ADD      r1,r2,#0xc            ;1609
000e82  462a              MOV      r2,r5                 ;1609
000e84  68a0              LDR      r0,[r4,#8]            ;1609
000e86  f7fffffe          BL       _init_box
000e8a  68a0              LDR      r0,[r4,#8]            ;1611
000e8c  e7f0              B        |L1.3696|
;;;1613   
                          ENDP

                  sysPoolAlloc PROC
;;;1614   /// Allocate a memory block from a memory pool
;;;1615   void *sysPoolAlloc (osPoolId pool_id, uint32_t clr) {
000e8e  b570              PUSH     {r4-r6,lr}
000e90  4604              MOV      r4,r0
000e92  460d              MOV      r5,r1
;;;1616     void *ptr;
;;;1617   
;;;1618     if (pool_id == NULL) return NULL;
000e94  b90c              CBNZ     r4,|L1.3738|
000e96  2000              MOVS     r0,#0
                  |L1.3736|
;;;1619   
;;;1620     ptr = rt_alloc_box(pool_id);
;;;1621     if (clr) {
;;;1622       rt_clr_box(pool_id, ptr);
;;;1623     }
;;;1624   
;;;1625     return ptr;
;;;1626   }
000e98  bd70              POP      {r4-r6,pc}
                  |L1.3738|
000e9a  4620              MOV      r0,r4                 ;1620
000e9c  f7fffffe          BL       rt_alloc_box
000ea0  4606              MOV      r6,r0                 ;1620
000ea2  b11d              CBZ      r5,|L1.3756|
000ea4  4631              MOV      r1,r6                 ;1622
000ea6  4620              MOV      r0,r4                 ;1622
000ea8  f7fffffe          BL       rt_clr_box
                  |L1.3756|
000eac  4630              MOV      r0,r6                 ;1625
000eae  e7f3              B        |L1.3736|
;;;1627   
                          ENDP

                  sysPoolFree PROC
;;;1628   /// Return an allocated memory block back to a specific memory pool
;;;1629   osStatus sysPoolFree (osPoolId pool_id, void *block) {
000eb0  b570              PUSH     {r4-r6,lr}
000eb2  4605              MOV      r5,r0
000eb4  460e              MOV      r6,r1
;;;1630     int32_t res;
;;;1631       
;;;1632     if (pool_id == NULL) return osErrorParameter;
000eb6  b90d              CBNZ     r5,|L1.3772|
000eb8  2080              MOVS     r0,#0x80
                  |L1.3770|
;;;1633   
;;;1634     res = rt_free_box(pool_id, block);
;;;1635     if (res != 0) return osErrorValue;
;;;1636   
;;;1637     return osOK;
;;;1638   }
000eba  bd70              POP      {r4-r6,pc}
                  |L1.3772|
000ebc  4631              MOV      r1,r6                 ;1634
000ebe  4628              MOV      r0,r5                 ;1634
000ec0  f7fffffe          BL       rt_free_box
000ec4  4604              MOV      r4,r0                 ;1634
000ec6  b10c              CBZ      r4,|L1.3788|
000ec8  2086              MOVS     r0,#0x86              ;1635
000eca  e7f6              B        |L1.3770|
                  |L1.3788|
000ecc  2000              MOVS     r0,#0                 ;1637
000ece  e7f4              B        |L1.3770|
;;;1639   
                          ENDP

                  osPoolCreate PROC
;;;1643   /// Create and Initialize memory pool
;;;1644   osPoolId osPoolCreate (const osPoolDef_t *pool_def) {
000ed0  b510              PUSH     {r4,lr}
000ed2  4604              MOV      r4,r0
;;;1645     if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
000ed4  f7fffffe          BL       __get_IPSR
000ed8  b108              CBZ      r0,|L1.3806|
000eda  2000              MOVS     r0,#0
                  |L1.3804|
;;;1646     if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;1647       // Privileged and not running
;;;1648       return   svcPoolCreate(pool_def);
;;;1649     } else {
;;;1650       return __svcPoolCreate(pool_def);
;;;1651     }
;;;1652   }
000edc  bd10              POP      {r4,pc}
                  |L1.3806|
000ede  f7fffffe          BL       __get_CONTROL
000ee2  f0000001          AND      r0,r0,#1              ;1646
000ee6  b930              CBNZ     r0,|L1.3830|
000ee8  48a4              LDR      r0,|L1.4476|
000eea  7800              LDRB     r0,[r0,#0]            ;1646  ; os_running
000eec  b918              CBNZ     r0,|L1.3830|
000eee  4620              MOV      r0,r4                 ;1648
000ef0  f7fffffe          BL       svcPoolCreate
000ef4  e7f2              B        |L1.3804|
                  |L1.3830|
000ef6  bf00              NOP                            ;1650
000ef8  4620              MOV      r0,r4                 ;1650
000efa  f2af0ca5          ADR      r12,svcPoolCreate + 1
000efe  df00              SVC      #0x0                  ;1650
000f00  bf00              NOP                            ;1650
000f02  e7eb              B        |L1.3804|
;;;1653   
                          ENDP

                  osPoolAlloc PROC
;;;1654   /// Allocate a memory block from a memory pool
;;;1655   void *osPoolAlloc (osPoolId pool_id) {
000f04  b570              PUSH     {r4-r6,lr}
000f06  4604              MOV      r4,r0
;;;1656     if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {    // in ISR or Privileged
000f08  f7fffffe          BL       __get_IPSR
000f0c  b920              CBNZ     r0,|L1.3864|
000f0e  f7fffffe          BL       __get_CONTROL
000f12  f0000001          AND      r0,r0,#1
000f16  b920              CBNZ     r0,|L1.3874|
                  |L1.3864|
;;;1657       return   sysPoolAlloc(pool_id, 0);
000f18  2100              MOVS     r1,#0
000f1a  4620              MOV      r0,r4
000f1c  f7fffffe          BL       sysPoolAlloc
                  |L1.3872|
;;;1658     } else {                                      // in Thread
;;;1659       return __sysPoolAlloc(pool_id, 0);
;;;1660     }
;;;1661   }
000f20  bd70              POP      {r4-r6,pc}
                  |L1.3874|
000f22  2500              MOVS     r5,#0                 ;1659
000f24  4629              MOV      r1,r5                 ;1659
000f26  4620              MOV      r0,r4                 ;1659
000f28  f2af0c9d          ADR      r12,sysPoolAlloc + 1
000f2c  df00              SVC      #0x0                  ;1659
000f2e  bf00              NOP                            ;1659
000f30  e7f6              B        |L1.3872|
;;;1662   
                          ENDP

                  osPoolCAlloc PROC
;;;1663   /// Allocate a memory block from a memory pool and set memory block to zero
;;;1664   void *osPoolCAlloc (osPoolId pool_id) {
000f32  b570              PUSH     {r4-r6,lr}
000f34  4604              MOV      r4,r0
;;;1665     if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {    // in ISR or Privileged
000f36  f7fffffe          BL       __get_IPSR
000f3a  b920              CBNZ     r0,|L1.3910|
000f3c  f7fffffe          BL       __get_CONTROL
000f40  f0000001          AND      r0,r0,#1
000f44  b920              CBNZ     r0,|L1.3920|
                  |L1.3910|
;;;1666       return   sysPoolAlloc(pool_id, 1);
000f46  2101              MOVS     r1,#1
000f48  4620              MOV      r0,r4
000f4a  f7fffffe          BL       sysPoolAlloc
                  |L1.3918|
;;;1667     } else {                                      // in Thread
;;;1668       return __sysPoolAlloc(pool_id, 1);
;;;1669     }
;;;1670   }
000f4e  bd70              POP      {r4-r6,pc}
                  |L1.3920|
000f50  2501              MOVS     r5,#1                 ;1668
000f52  4629              MOV      r1,r5                 ;1668
000f54  4620              MOV      r0,r4                 ;1668
000f56  f2af0cc9          ADR      r12,sysPoolAlloc + 1
000f5a  df00              SVC      #0x0                  ;1668
000f5c  bf00              NOP                            ;1668
000f5e  e7f6              B        |L1.3918|
;;;1671   
                          ENDP

                  osPoolFree PROC
;;;1672   /// Return an allocated memory block back to a specific memory pool
;;;1673   osStatus osPoolFree (osPoolId pool_id, void *block) {
000f60  b570              PUSH     {r4-r6,lr}
000f62  4605              MOV      r5,r0
000f64  460c              MOV      r4,r1
;;;1674     if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {    // in ISR or Privileged
000f66  f7fffffe          BL       __get_IPSR
000f6a  b920              CBNZ     r0,|L1.3958|
000f6c  f7fffffe          BL       __get_CONTROL
000f70  f0000001          AND      r0,r0,#1
000f74  b920              CBNZ     r0,|L1.3968|
                  |L1.3958|
;;;1675       return   sysPoolFree(pool_id, block);
000f76  4621              MOV      r1,r4
000f78  4628              MOV      r0,r5
000f7a  f7fffffe          BL       sysPoolFree
                  |L1.3966|
;;;1676     } else {                                      // in Thread
;;;1677       return __sysPoolFree(pool_id, block);
;;;1678     }
;;;1679   }
000f7e  bd70              POP      {r4-r6,pc}
                  |L1.3968|
000f80  bf00              NOP                            ;1677
000f82  4621              MOV      r1,r4                 ;1677
000f84  4628              MOV      r0,r5                 ;1677
000f86  f2af0cd7          ADR      r12,sysPoolFree + 1
000f8a  df00              SVC      #0x0                  ;1677
000f8c  bf00              NOP                            ;1677
000f8e  e7f6              B        |L1.3966|
;;;1680   
                          ENDP

                  svcMessagePut PROC
;;;1711   /// Put a Message to a Queue
;;;1712   osStatus svcMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {
000f90  e92d41f0          PUSH     {r4-r8,lr}
000f94  4604              MOV      r4,r0
000f96  460f              MOV      r7,r1
000f98  4615              MOV      r5,r2
;;;1713     OS_RESULT res;
;;;1714   
;;;1715     if (queue_id == NULL) return osErrorParameter;
000f9a  b914              CBNZ     r4,|L1.4002|
000f9c  2080              MOVS     r0,#0x80
                  |L1.3998|
;;;1716   
;;;1717     if (((P_MCB)queue_id)->cb_type != MCB) return osErrorParameter;
;;;1718   
;;;1719     res = rt_mbx_send(queue_id, (void *)info, rt_ms2tick(millisec));
;;;1720   
;;;1721     if (res == OS_R_TMO) {
;;;1722       return (millisec ? osErrorTimeoutResource : osErrorResource);
;;;1723     }
;;;1724   
;;;1725     return osOK;
;;;1726   }
000f9e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4002|
000fa2  7820              LDRB     r0,[r4,#0]            ;1717
000fa4  2801              CMP      r0,#1                 ;1717
000fa6  d001              BEQ      |L1.4012|
000fa8  2080              MOVS     r0,#0x80              ;1717
000faa  e7f8              B        |L1.3998|
                  |L1.4012|
000fac  4628              MOV      r0,r5                 ;1719
000fae  f7fffffe          BL       rt_ms2tick
000fb2  fa1ff880          UXTH     r8,r0                 ;1719
000fb6  4642              MOV      r2,r8                 ;1719
000fb8  4639              MOV      r1,r7                 ;1719
000fba  4620              MOV      r0,r4                 ;1719
000fbc  f7fffffe          BL       rt_mbx_send
000fc0  4606              MOV      r6,r0                 ;1719
000fc2  2e01              CMP      r6,#1                 ;1721
000fc4  d104              BNE      |L1.4048|
000fc6  b10d              CBZ      r5,|L1.4044|
000fc8  20c1              MOVS     r0,#0xc1              ;1722
000fca  e7e8              B        |L1.3998|
                  |L1.4044|
000fcc  2081              MOVS     r0,#0x81              ;1722
000fce  e7e6              B        |L1.3998|
                  |L1.4048|
000fd0  2000              MOVS     r0,#0                 ;1725
000fd2  e7e4              B        |L1.3998|
;;;1727   
                          ENDP

                  osMessageCreate PROC
;;;1806   /// Create and Initialize Message Queue
;;;1807   osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id) {
000fd4  b570              PUSH     {r4-r6,lr}
000fd6  4605              MOV      r5,r0
000fd8  460c              MOV      r4,r1
;;;1808     if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
000fda  f7fffffe          BL       __get_IPSR
000fde  b108              CBZ      r0,|L1.4068|
000fe0  2000              MOVS     r0,#0
                  |L1.4066|
;;;1809     if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;1810       // Privileged and not running
;;;1811       return   svcMessageCreate(queue_def, thread_id);
;;;1812     } else {
;;;1813       return __svcMessageCreate(queue_def, thread_id);
;;;1814     }
;;;1815   }
000fe2  bd70              POP      {r4-r6,pc}
                  |L1.4068|
000fe4  f7fffffe          BL       __get_CONTROL
000fe8  f0000001          AND      r0,r0,#1              ;1809
000fec  b938              CBNZ     r0,|L1.4094|
000fee  4863              LDR      r0,|L1.4476|
000ff0  7800              LDRB     r0,[r0,#0]            ;1809  ; os_running
000ff2  b920              CBNZ     r0,|L1.4094|
000ff4  4621              MOV      r1,r4                 ;1811
000ff6  4628              MOV      r0,r5                 ;1811
000ff8  f7fffffe          BL       svcMessageCreate
000ffc  e7f1              B        |L1.4066|
                  |L1.4094|
000ffe  bf00              NOP                            ;1813
001000  4621              MOV      r1,r4                 ;1813
001002  4628              MOV      r0,r5                 ;1813
001004  f6af6ca1          ADR      r12,svcMessageCreate + 1
001008  df00              SVC      #0x0                  ;1813
00100a  bf00              NOP                            ;1813
00100c  e7e9              B        |L1.4066|
;;;1816   
                          ENDP

                  osMessagePut PROC
;;;1817   /// Put a Message to a Queue
;;;1818   osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {
00100e  b570              PUSH     {r4-r6,lr}
001010  4606              MOV      r6,r0
001012  460c              MOV      r4,r1
001014  4615              MOV      r5,r2
;;;1819     if (__get_IPSR() != 0) {                      // in ISR
001016  f7fffffe          BL       __get_IPSR
00101a  b128              CBZ      r0,|L1.4136|
;;;1820       return   isrMessagePut(queue_id, info, millisec);
00101c  462a              MOV      r2,r5
00101e  4621              MOV      r1,r4
001020  4630              MOV      r0,r6
001022  f7fffffe          BL       isrMessagePut
                  |L1.4134|
;;;1821     } else {                                      // in Thread
;;;1822       return __svcMessagePut(queue_id, info, millisec);
;;;1823     }
;;;1824   }
001026  bd70              POP      {r4-r6,pc}
                  |L1.4136|
001028  bf00              NOP                            ;1822
00102a  462a              MOV      r2,r5                 ;1822
00102c  4621              MOV      r1,r4                 ;1822
00102e  4630              MOV      r0,r6                 ;1822
001030  f2af0ca3          ADR      r12,svcMessagePut + 1
001034  df00              SVC      #0x0                  ;1822
001036  bf00              NOP                            ;1822
001038  e7f5              B        |L1.4134|
;;;1825   
                          ENDP

                  svcMailCreate PROC
;;;1845   /// Create and Initialize mail queue
;;;1846   osMailQId svcMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id) {
00103a  e92d41f0          PUSH     {r4-r8,lr}
00103e  4604              MOV      r4,r0
001040  4688              MOV      r8,r1
;;;1847     uint32_t blk_sz;
;;;1848     P_MCB    pmcb;
;;;1849     void    *pool;
;;;1850   
;;;1851     if ((queue_def == NULL) ||
001042  b12c              CBZ      r4,|L1.4176|
;;;1852         (queue_def->queue_sz == 0) ||
001044  6820              LDR      r0,[r4,#0]
001046  b118              CBZ      r0,|L1.4176|
;;;1853         (queue_def->item_sz  == 0) ||
001048  6860              LDR      r0,[r4,#4]
00104a  b108              CBZ      r0,|L1.4176|
;;;1854         (queue_def->pool == NULL)) {
00104c  68a0              LDR      r0,[r4,#8]
00104e  b928              CBNZ     r0,|L1.4188|
                  |L1.4176|
;;;1855       sysThreadError(osErrorParameter);
001050  2080              MOVS     r0,#0x80
001052  f7fffffe          BL       sysThreadError
;;;1856       return NULL;
001056  2000              MOVS     r0,#0
                  |L1.4184|
;;;1857     }
;;;1858   
;;;1859     pmcb = *(((void **)queue_def->pool) + 0);
;;;1860     pool = *(((void **)queue_def->pool) + 1);
;;;1861   
;;;1862     if ((pool == NULL) || (pmcb == NULL) || (pmcb->cb_type != 0)) {
;;;1863       sysThreadError(osErrorParameter);
;;;1864       return NULL;
;;;1865     }
;;;1866   
;;;1867     blk_sz = (queue_def->item_sz + 3) & ~3;
;;;1868   
;;;1869     _init_box(pool, sizeof(struct OS_BM) + queue_def->queue_sz * blk_sz, blk_sz);
;;;1870   
;;;1871     rt_mbx_init(pmcb, 4*(queue_def->queue_sz + 4));
;;;1872   
;;;1873     return queue_def->pool;
;;;1874   }
001058  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4188|
00105c  68a0              LDR      r0,[r4,#8]            ;1859
00105e  6805              LDR      r5,[r0,#0]            ;1859
001060  68a0              LDR      r0,[r4,#8]            ;1860
001062  6847              LDR      r7,[r0,#4]            ;1860
001064  b117              CBZ      r7,|L1.4204|
001066  b10d              CBZ      r5,|L1.4204|
001068  7828              LDRB     r0,[r5,#0]            ;1862
00106a  b120              CBZ      r0,|L1.4214|
                  |L1.4204|
00106c  2080              MOVS     r0,#0x80              ;1863
00106e  f7fffffe          BL       sysThreadError
001072  2000              MOVS     r0,#0                 ;1864
001074  e7f0              B        |L1.4184|
                  |L1.4214|
001076  6860              LDR      r0,[r4,#4]            ;1867
001078  1cc0              ADDS     r0,r0,#3              ;1867
00107a  f0200603          BIC      r6,r0,#3              ;1867
00107e  6820              LDR      r0,[r4,#0]            ;1869
001080  4370              MULS     r0,r6,r0              ;1869
001082  f100010c          ADD      r1,r0,#0xc            ;1869
001086  4632              MOV      r2,r6                 ;1869
001088  4638              MOV      r0,r7                 ;1869
00108a  f7fffffe          BL       _init_box
00108e  8820              LDRH     r0,[r4,#0]            ;1871
001090  1d00              ADDS     r0,r0,#4              ;1871
001092  0480              LSLS     r0,r0,#18             ;1871
001094  0c01              LSRS     r1,r0,#16             ;1871
001096  4628              MOV      r0,r5                 ;1871
001098  f7fffffe          BL       rt_mbx_init
00109c  68a0              LDR      r0,[r4,#8]            ;1873
00109e  e7db              B        |L1.4184|
;;;1875   
                          ENDP

                  sysMailAlloc PROC
;;;1876   /// Allocate a memory block from a mail
;;;1877   void *sysMailAlloc (osMailQId queue_id, uint32_t millisec, uint32_t isr, uint32_t clr) {
0010a0  e92d5ff0          PUSH     {r4-r12,lr}
0010a4  4605              MOV      r5,r0
0010a6  460e              MOV      r6,r1
0010a8  4691              MOV      r9,r2
0010aa  469a              MOV      r10,r3
;;;1878     P_MCB pmcb;
;;;1879     void *pool;
;;;1880     void *mem;
;;;1881   
;;;1882     if (queue_id == NULL) return NULL;
0010ac  b915              CBNZ     r5,|L1.4276|
0010ae  2000              MOVS     r0,#0
                  |L1.4272|
;;;1883   
;;;1884     pmcb = *(((void **)queue_id) + 0);
;;;1885     pool = *(((void **)queue_id) + 1);
;;;1886   
;;;1887     if ((pool == NULL) || (pmcb == NULL)) return NULL;
;;;1888   
;;;1889     if (isr && (millisec != 0)) return NULL;
;;;1890   
;;;1891     mem = rt_alloc_box(pool);
;;;1892     if (clr) {
;;;1893       rt_clr_box(pool, mem);
;;;1894     }
;;;1895   
;;;1896     if ((mem == NULL) && (millisec != 0)) {
;;;1897       // Put Task to sleep when Memory not available
;;;1898       if (pmcb->p_lnk != NULL) {
;;;1899         rt_put_prio((P_XCB)pmcb, os_tsk.run);
;;;1900       } else {
;;;1901         pmcb->p_lnk = os_tsk.run;
;;;1902         os_tsk.run->p_lnk = NULL;
;;;1903         os_tsk.run->p_rlnk = (P_TCB)pmcb;
;;;1904         // Task is waiting to allocate a message
;;;1905         pmcb->state = 3;
;;;1906       }
;;;1907       rt_block(rt_ms2tick(millisec), WAIT_MBX);
;;;1908     }
;;;1909   
;;;1910     return mem;  
;;;1911   }
0010b0  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.4276|
0010b4  682c              LDR      r4,[r5,#0]            ;1884
0010b6  f8d58004          LDR      r8,[r5,#4]            ;1885
0010ba  f1b80f00          CMP      r8,#0                 ;1887
0010be  d000              BEQ      |L1.4290|
0010c0  b90c              CBNZ     r4,|L1.4294|
                  |L1.4290|
0010c2  2000              MOVS     r0,#0                 ;1887
0010c4  e7f4              B        |L1.4272|
                  |L1.4294|
0010c6  f1b90f00          CMP      r9,#0                 ;1889
0010ca  d002              BEQ      |L1.4306|
0010cc  b10e              CBZ      r6,|L1.4306|
0010ce  2000              MOVS     r0,#0                 ;1889
0010d0  e7ee              B        |L1.4272|
                  |L1.4306|
0010d2  4640              MOV      r0,r8                 ;1891
0010d4  f7fffffe          BL       rt_alloc_box
0010d8  4607              MOV      r7,r0                 ;1891
0010da  f1ba0f00          CMP      r10,#0                ;1892
0010de  d003              BEQ      |L1.4328|
0010e0  4639              MOV      r1,r7                 ;1893
0010e2  4640              MOV      r0,r8                 ;1893
0010e4  f7fffffe          BL       rt_clr_box
                  |L1.4328|
0010e8  b9ef              CBNZ     r7,|L1.4390|
0010ea  b1e6              CBZ      r6,|L1.4390|
0010ec  6860              LDR      r0,[r4,#4]            ;1898
0010ee  b128              CBZ      r0,|L1.4348|
0010f0  4823              LDR      r0,|L1.4480|
0010f2  6801              LDR      r1,[r0,#0]            ;1899  ; os_tsk
0010f4  4620              MOV      r0,r4                 ;1899
0010f6  f7fffffe          BL       rt_put_prio
0010fa  e00b              B        |L1.4372|
                  |L1.4348|
0010fc  4820              LDR      r0,|L1.4480|
0010fe  6800              LDR      r0,[r0,#0]            ;1901  ; os_tsk
001100  6060              STR      r0,[r4,#4]            ;1901
001102  2000              MOVS     r0,#0                 ;1902
001104  491e              LDR      r1,|L1.4480|
001106  6809              LDR      r1,[r1,#0]            ;1902  ; os_tsk
001108  6048              STR      r0,[r1,#4]            ;1902
00110a  481d              LDR      r0,|L1.4480|
00110c  6800              LDR      r0,[r0,#0]            ;1903  ; os_tsk
00110e  6084              STR      r4,[r0,#8]            ;1903
001110  2003              MOVS     r0,#3                 ;1905
001112  7060              STRB     r0,[r4,#1]            ;1905
                  |L1.4372|
001114  4630              MOV      r0,r6                 ;1907
001116  f7fffffe          BL       rt_ms2tick
00111a  fa1ffb80          UXTH     r11,r0                ;1907
00111e  2108              MOVS     r1,#8                 ;1907
001120  4658              MOV      r0,r11                ;1907
001122  f7fffffe          BL       rt_block
                  |L1.4390|
001126  4638              MOV      r0,r7                 ;1910
001128  e7c2              B        |L1.4272|
;;;1912   
                          ENDP

                  sysMailFree PROC
;;;1913   /// Free a memory block from a mail
;;;1914   osStatus sysMailFree (osMailQId queue_id, void *mail, uint32_t isr) {
00112a  e92d5ff0          PUSH     {r4-r12,lr}
00112e  4605              MOV      r5,r0
001130  468a              MOV      r10,r1
001132  4691              MOV      r9,r2
;;;1915     P_MCB   pmcb;
;;;1916     P_TCB   ptcb;
;;;1917     void   *pool;
;;;1918     void   *mem;
;;;1919     int32_t res;
;;;1920   
;;;1921     if (queue_id == NULL) return osErrorParameter;
001134  b915              CBNZ     r5,|L1.4412|
001136  2080              MOVS     r0,#0x80
                  |L1.4408|
;;;1922   
;;;1923     pmcb = *(((void **)queue_id) + 0);
;;;1924     pool = *(((void **)queue_id) + 1);
;;;1925   
;;;1926     if ((pmcb == NULL) || (pool == NULL)) return osErrorParameter;
;;;1927   
;;;1928     res = rt_free_box(pool, mail);
;;;1929   
;;;1930     if (res != 0) return osErrorValue;
;;;1931   
;;;1932     if ((pmcb->p_lnk != NULL) && (pmcb->state == 3)) {
;;;1933       // Task is waiting to allocate a message
;;;1934       if (isr) {
;;;1935         rt_psq_enq (pmcb, (U32)pool);
;;;1936         rt_psh_req ();
;;;1937       } else {
;;;1938         mem = rt_alloc_box(pool);
;;;1939         if (mem != NULL) {
;;;1940           ptcb = rt_get_first((P_XCB)pmcb);
;;;1941           rt_ret_val(ptcb, (U32)mem);
;;;1942           rt_rmv_dly(ptcb);
;;;1943           rt_dispatch(ptcb);
;;;1944         }
;;;1945       }
;;;1946     }
;;;1947   
;;;1948     return osOK;
;;;1949   }
001138  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.4412|
00113c  682c              LDR      r4,[r5,#0]            ;1923
00113e  686e              LDR      r6,[r5,#4]            ;1924
001140  b104              CBZ      r4,|L1.4420|
001142  b90e              CBNZ     r6,|L1.4424|
                  |L1.4420|
001144  2080              MOVS     r0,#0x80              ;1926
001146  e7f7              B        |L1.4408|
                  |L1.4424|
001148  4651              MOV      r1,r10                ;1928
00114a  4630              MOV      r0,r6                 ;1928
00114c  f7fffffe          BL       rt_free_box
001150  4680              MOV      r8,r0                 ;1928
001152  f1b80f00          CMP      r8,#0                 ;1930
001156  d001              BEQ      |L1.4444|
001158  2086              MOVS     r0,#0x86              ;1930
00115a  e7ed              B        |L1.4408|
                  |L1.4444|
00115c  6860              LDR      r0,[r4,#4]            ;1932
00115e  b320              CBZ      r0,|L1.4522|
001160  7860              LDRB     r0,[r4,#1]            ;1932
001162  2803              CMP      r0,#3                 ;1932
001164  d121              BNE      |L1.4522|
001166  f1b90f00          CMP      r9,#0                 ;1934
00116a  d00b              BEQ      |L1.4484|
00116c  4631              MOV      r1,r6                 ;1935
00116e  4620              MOV      r0,r4                 ;1935
001170  f7fffffe          BL       rt_psq_enq
001174  f7fffffe          BL       rt_psh_req
001178  e017              B        |L1.4522|
00117a  0000              DCW      0x0000
                  |L1.4476|
                          DCD      os_running
                  |L1.4480|
                          DCD      os_tsk
                  |L1.4484|
001184  4630              MOV      r0,r6                 ;1938
001186  f7fffffe          BL       rt_alloc_box
00118a  4607              MOV      r7,r0                 ;1938
00118c  b16f              CBZ      r7,|L1.4522|
00118e  4620              MOV      r0,r4                 ;1940
001190  f7fffffe          BL       rt_get_first
001194  4683              MOV      r11,r0                ;1940
001196  4639              MOV      r1,r7                 ;1941
001198  4658              MOV      r0,r11                ;1941
00119a  f7fffffe          BL       rt_ret_val
00119e  4658              MOV      r0,r11                ;1942
0011a0  f7fffffe          BL       rt_rmv_dly
0011a4  4658              MOV      r0,r11                ;1943
0011a6  f7fffffe          BL       rt_dispatch
                  |L1.4522|
0011aa  2000              MOVS     r0,#0                 ;1948
0011ac  e7c4              B        |L1.4408|
;;;1950   
                          ENDP

                  osMailCreate PROC
;;;1954   /// Create and Initialize mail queue
;;;1955   osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id) {
0011ae  b570              PUSH     {r4-r6,lr}
0011b0  4605              MOV      r5,r0
0011b2  460c              MOV      r4,r1
;;;1956     if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR
0011b4  f7fffffe          BL       __get_IPSR
0011b8  b108              CBZ      r0,|L1.4542|
0011ba  2000              MOVS     r0,#0
                  |L1.4540|
;;;1957     if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {
;;;1958       // Privileged and not running
;;;1959       return   svcMailCreate(queue_def, thread_id);
;;;1960     } else {
;;;1961       return __svcMailCreate(queue_def, thread_id);
;;;1962     }
;;;1963   }
0011bc  bd70              POP      {r4-r6,pc}
                  |L1.4542|
0011be  f7fffffe          BL       __get_CONTROL
0011c2  f0000001          AND      r0,r0,#1              ;1957
0011c6  b938              CBNZ     r0,|L1.4568|
0011c8  4849              LDR      r0,|L1.4848|
0011ca  7800              LDRB     r0,[r0,#0]            ;1957  ; os_running
0011cc  b920              CBNZ     r0,|L1.4568|
0011ce  4621              MOV      r1,r4                 ;1959
0011d0  4628              MOV      r0,r5                 ;1959
0011d2  f7fffffe          BL       svcMailCreate
0011d6  e7f1              B        |L1.4540|
                  |L1.4568|
0011d8  bf00              NOP                            ;1961
0011da  4621              MOV      r1,r4                 ;1961
0011dc  4628              MOV      r0,r5                 ;1961
0011de  f2af1ca5          ADR      r12,svcMailCreate + 1
0011e2  df00              SVC      #0x0                  ;1961
0011e4  bf00              NOP                            ;1961
0011e6  e7e9              B        |L1.4540|
;;;1964   
                          ENDP

                  osMailAlloc PROC
;;;1965   /// Allocate a memory block from a mail
;;;1966   void *osMailAlloc (osMailQId queue_id, uint32_t millisec) {
0011e8  e92d41f0          PUSH     {r4-r8,lr}
0011ec  4605              MOV      r5,r0
0011ee  460c              MOV      r4,r1
;;;1967     if (__get_IPSR() != 0) {                      // in ISR
0011f0  f7fffffe          BL       __get_IPSR
0011f4  b138              CBZ      r0,|L1.4614|
;;;1968       return   sysMailAlloc(queue_id, millisec, 1, 0);
0011f6  2300              MOVS     r3,#0
0011f8  2201              MOVS     r2,#1
0011fa  4621              MOV      r1,r4
0011fc  4628              MOV      r0,r5
0011fe  f7fffffe          BL       sysMailAlloc
                  |L1.4610|
;;;1969     } else {                                      // in Thread
;;;1970       return __sysMailAlloc(queue_id, millisec, 0, 0);
;;;1971     }
;;;1972   }
001202  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4614|
001206  2600              MOVS     r6,#0                 ;1970
001208  4637              MOV      r7,r6                 ;1970
00120a  463b              MOV      r3,r7                 ;1970
00120c  4632              MOV      r2,r6                 ;1970
00120e  4621              MOV      r1,r4                 ;1970
001210  4628              MOV      r0,r5                 ;1970
001212  f2af1c73          ADR      r12,sysMailAlloc + 1
001216  df00              SVC      #0x0                  ;1970
001218  bf00              NOP                            ;1970
00121a  e7f2              B        |L1.4610|
;;;1973   
                          ENDP

                  osMailCAlloc PROC
;;;1974   /// Allocate a memory block from a mail and set memory block to zero
;;;1975   void *osMailCAlloc (osMailQId queue_id, uint32_t millisec) {
00121c  e92d41f0          PUSH     {r4-r8,lr}
001220  4605              MOV      r5,r0
001222  460c              MOV      r4,r1
;;;1976     if (__get_IPSR() != 0) {                      // in ISR
001224  f7fffffe          BL       __get_IPSR
001228  b138              CBZ      r0,|L1.4666|
;;;1977       return   sysMailAlloc(queue_id, millisec, 1, 1);
00122a  2301              MOVS     r3,#1
00122c  461a              MOV      r2,r3
00122e  4621              MOV      r1,r4
001230  4628              MOV      r0,r5
001232  f7fffffe          BL       sysMailAlloc
                  |L1.4662|
;;;1978     } else {                                      // in Thread
;;;1979       return __sysMailAlloc(queue_id, millisec, 0, 1);
;;;1980     }
;;;1981   }
001236  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4666|
00123a  2600              MOVS     r6,#0                 ;1979
00123c  2701              MOVS     r7,#1                 ;1979
00123e  463b              MOV      r3,r7                 ;1979
001240  4632              MOV      r2,r6                 ;1979
001242  4621              MOV      r1,r4                 ;1979
001244  4628              MOV      r0,r5                 ;1979
001246  f2af1ca7          ADR      r12,sysMailAlloc + 1
00124a  df00              SVC      #0x0                  ;1979
00124c  bf00              NOP                            ;1979
00124e  e7f2              B        |L1.4662|
;;;1982   
                          ENDP

                  osMailFree PROC
;;;1983   /// Free a memory block from a mail
;;;1984   osStatus osMailFree (osMailQId queue_id, void *mail) {
001250  b570              PUSH     {r4-r6,lr}
001252  4605              MOV      r5,r0
001254  460c              MOV      r4,r1
;;;1985     if (__get_IPSR() != 0) {                      // in ISR
001256  f7fffffe          BL       __get_IPSR
00125a  b128              CBZ      r0,|L1.4712|
;;;1986       return   sysMailFree(queue_id, mail, 1);
00125c  2201              MOVS     r2,#1
00125e  4621              MOV      r1,r4
001260  4628              MOV      r0,r5
001262  f7fffffe          BL       sysMailFree
                  |L1.4710|
;;;1987     } else {                                      // in Thread
;;;1988       return __sysMailFree(queue_id, mail, 0);
;;;1989     }
;;;1990   }
001266  bd70              POP      {r4-r6,pc}
                  |L1.4712|
001268  2600              MOVS     r6,#0                 ;1988
00126a  4632              MOV      r2,r6                 ;1988
00126c  4621              MOV      r1,r4                 ;1988
00126e  4628              MOV      r0,r5                 ;1988
001270  f2af1c49          ADR      r12,sysMailFree + 1
001274  df00              SVC      #0x0                  ;1988
001276  bf00              NOP                            ;1988
001278  e7f5              B        |L1.4710|
;;;1991   
                          ENDP

                  osMailPut PROC
;;;1992   /// Put a mail to a queue
;;;1993   osStatus osMailPut (osMailQId queue_id, void *mail) {
00127a  b570              PUSH     {r4-r6,lr}
00127c  4604              MOV      r4,r0
00127e  460d              MOV      r5,r1
;;;1994     if (queue_id == NULL) return osErrorParameter;
001280  b90c              CBNZ     r4,|L1.4742|
001282  2080              MOVS     r0,#0x80
                  |L1.4740|
;;;1995     if (mail == NULL)     return osErrorValue;
;;;1996     return osMessagePut(*((void **)queue_id), (uint32_t)mail, 0);
;;;1997   }
001284  bd70              POP      {r4-r6,pc}
                  |L1.4742|
001286  b90d              CBNZ     r5,|L1.4748|
001288  2086              MOVS     r0,#0x86              ;1995
00128a  e7fb              B        |L1.4740|
                  |L1.4748|
00128c  2200              MOVS     r2,#0                 ;1996
00128e  4629              MOV      r1,r5                 ;1996
001290  6820              LDR      r0,[r4,#0]            ;1996
001292  f7fffffe          BL       osMessagePut
001296  e7f5              B        |L1.4740|
;;;1998   
                          ENDP

                  osMailGet PROC
;;;1999   /// Get a mail from a queue
;;;2000   os_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec) {
001298  b53e              PUSH     {r1-r5,lr}
00129a  4604              MOV      r4,r0
00129c  460d              MOV      r5,r1
;;;2001     osEvent ret;
;;;2002   
;;;2003     if (queue_id == NULL) {
00129e  b92c              CBNZ     r4,|L1.4780|
;;;2004       ret.status = osErrorParameter;
0012a0  2080              MOVS     r0,#0x80
0012a2  9000              STR      r0,[sp,#0]
;;;2005       return ret;
0012a4  e89d0007          LDM      sp,{r0-r2}
                  |L1.4776|
;;;2006     }
;;;2007   
;;;2008     ret = osMessageGet(*((void **)queue_id), millisec);
;;;2009     if (ret.status == osEventMessage) ret.status = osEventMail;
;;;2010   
;;;2011     return ret;
;;;2012   }
0012a8  b003              ADD      sp,sp,#0xc
0012aa  bd30              POP      {r4,r5,pc}
                  |L1.4780|
0012ac  4629              MOV      r1,r5                 ;2008
0012ae  6820              LDR      r0,[r4,#0]            ;2008
0012b0  f7fffffe          BL       osMessageGet
0012b4  e88d0007          STM      sp,{r0-r2}            ;2008
0012b8  9800              LDR      r0,[sp,#0]            ;2009
0012ba  2810              CMP      r0,#0x10              ;2009
0012bc  d101              BNE      |L1.4802|
0012be  2020              MOVS     r0,#0x20              ;2009
0012c0  9000              STR      r0,[sp,#0]            ;2009
                  |L1.4802|
0012c2  e89d0007          LDM      sp,{r0-r2}            ;2011
0012c6  e7ef              B        |L1.4776|
;;;2013   
                          ENDP

                  os_suspend PROC
;;;2024   /// Suspends the OS task scheduler
;;;2025   uint32_t os_suspend (void) {
0012c8  bf00              NOP      
0012ca  f8dfc028          LDR      r12,|L1.4852|
0012ce  df00              SVC      #0x0
;;;2026     return __rt_suspend();
;;;2027   }
0012d0  4770              BX       lr
;;;2028   
                          ENDP

                  os_resume PROC
;;;2029   /// Resumes the OS task scheduler
;;;2030   void os_resume (uint32_t sleep_time) {
0012d2  b510              PUSH     {r4,lr}
0012d4  4604              MOV      r4,r0
;;;2031     __rt_resume(sleep_time);
0012d6  bf00              NOP      
0012d8  4620              MOV      r0,r4
0012da  f8dfc01c          LDR      r12,|L1.4856|
0012de  df00              SVC      #0x0
0012e0  bf00              NOP      
;;;2032   }
0012e2  bd10              POP      {r4,pc}
                          ENDP

                  __get_CONTROL PROC
;;;49      */
;;;50     static __INLINE uint32_t __get_CONTROL(void)
0012e4  f3ef8014          MRS      r0,CONTROL
;;;51     {
;;;52       register uint32_t __regControl         __ASM("control");
;;;53       return(__regControl);
;;;54     }
0012e8  4770              BX       lr
;;;55     
                          ENDP

                  __get_IPSR PROC
;;;75      */
;;;76     static __INLINE uint32_t __get_IPSR(void)
0012ea  f3ef8005          MRS      r0,IPSR
;;;77     {
;;;78       register uint32_t __regIPSR          __ASM("ipsr");
;;;79       return(__regIPSR);
;;;80     }
0012ee  4770              BX       lr
;;;81     
                          ENDP

                  |L1.4848|
                          DCD      os_running
                  |L1.4852|
                          DCD      rt_suspend
                  |L1.4856|
                          DCD      rt_resume

                          AREA ||.data||, DATA, ALIGN=2

                  os_initialized
000000  00                DCB      0x00
                  os_running
000001  000000            DCB      0x00,0x00,0x00
                  os_timer_head
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\rtx-v4.73\\SRC\\rt_CMSIS.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_rt_CMSIS_c_8216d75d____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_rt_CMSIS_c_8216d75d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_rt_CMSIS_c_8216d75d____REVSH|
#line 128
|__asm___10_rt_CMSIS_c_8216d75d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
