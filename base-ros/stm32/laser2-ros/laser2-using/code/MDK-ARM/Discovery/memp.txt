; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\memp.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\memp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\memp.crf ..\..\libraries\lwip-1.4.1\src\core\memp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  memp_init PROC
;;;337    void
;;;338    memp_init(void)
000000  b510              PUSH     {r4,lr}
;;;339    {
;;;340      struct memp *memp;
;;;341      u16_t i, j;
;;;342    
;;;343      for (i = 0; i < MEMP_MAX; ++i) {
000002  2000              MOVS     r0,#0
000004  e001              B        |L1.10|
                  |L1.6|
000006  1c43              ADDS     r3,r0,#1
000008  b298              UXTH     r0,r3
                  |L1.10|
00000a  280d              CMP      r0,#0xd
00000c  dbfb              BLT      |L1.6|
;;;344        MEMP_STATS_AVAIL(used, i, 0);
;;;345        MEMP_STATS_AVAIL(max, i, 0);
;;;346        MEMP_STATS_AVAIL(err, i, 0);
;;;347        MEMP_STATS_AVAIL(avail, i, memp_num[i]);
;;;348      }
;;;349    
;;;350    #if !MEMP_SEPARATE_POOLS
;;;351      memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
00000e  4b2c              LDR      r3,|L1.192|
000010  f0230103          BIC      r1,r3,#3
;;;352    #endif /* !MEMP_SEPARATE_POOLS */
;;;353      /* for every pool: */
;;;354      for (i = 0; i < MEMP_MAX; ++i) {
000014  2000              MOVS     r0,#0
000016  e019              B        |L1.76|
                  |L1.24|
;;;355        memp_tab[i] = NULL;
000018  2300              MOVS     r3,#0
00001a  4c2a              LDR      r4,|L1.196|
00001c  f8443020          STR      r3,[r4,r0,LSL #2]
;;;356    #if MEMP_SEPARATE_POOLS
;;;357        memp = (struct memp*)memp_bases[i];
;;;358    #endif /* MEMP_SEPARATE_POOLS */
;;;359        /* create a linked list of memp elements */
;;;360        for (j = 0; j < memp_num[i]; ++j) {
000020  2200              MOVS     r2,#0
000022  e00c              B        |L1.62|
                  |L1.36|
;;;361          memp->next = memp_tab[i];
000024  4b27              LDR      r3,|L1.196|
000026  f8533020          LDR      r3,[r3,r0,LSL #2]
00002a  600b              STR      r3,[r1,#0]
;;;362          memp_tab[i] = memp;
00002c  4b25              LDR      r3,|L1.196|
00002e  f8431020          STR      r1,[r3,r0,LSL #2]
;;;363          memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
000032  4b25              LDR      r3,|L1.200|
000034  f8333010          LDRH     r3,[r3,r0,LSL #1]
000038  4419              ADD      r1,r1,r3
00003a  1c53              ADDS     r3,r2,#1              ;360
00003c  b29a              UXTH     r2,r3                 ;360
                  |L1.62|
00003e  4b23              LDR      r3,|L1.204|
000040  f8333010          LDRH     r3,[r3,r0,LSL #1]     ;360
000044  4293              CMP      r3,r2                 ;360
000046  dced              BGT      |L1.36|
000048  1c43              ADDS     r3,r0,#1              ;354
00004a  b298              UXTH     r0,r3                 ;354
                  |L1.76|
00004c  280d              CMP      r0,#0xd               ;354
00004e  dbe3              BLT      |L1.24|
;;;364    #if MEMP_OVERFLOW_CHECK
;;;365            + MEMP_SANITY_REGION_AFTER_ALIGNED
;;;366    #endif
;;;367          );
;;;368        }
;;;369      }
;;;370    #if MEMP_OVERFLOW_CHECK
;;;371      memp_overflow_init();
;;;372      /* check everything a first time to see if it worked */
;;;373      memp_overflow_check_all();
;;;374    #endif /* MEMP_OVERFLOW_CHECK */
;;;375    }
000050  bd10              POP      {r4,pc}
;;;376    
                          ENDP

                  memp_malloc PROC
;;;389    #if !MEMP_OVERFLOW_CHECK
;;;390    memp_malloc(memp_t type)
000052  b570              PUSH     {r4-r6,lr}
;;;391    #else
;;;392    memp_malloc_fn(memp_t type, const char* file, const int line)
;;;393    #endif
;;;394    {
000054  4605              MOV      r5,r0
;;;395      struct memp *memp;
;;;396      SYS_ARCH_DECL_PROTECT(old_level);
;;;397     
;;;398      LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
000056  bf00              NOP      
000058  2d0d              CMP      r5,#0xd
00005a  db01              BLT      |L1.96|
00005c  2000              MOVS     r0,#0
                  |L1.94|
;;;399    
;;;400      SYS_ARCH_PROTECT(old_level);
;;;401    #if MEMP_OVERFLOW_CHECK >= 2
;;;402      memp_overflow_check_all();
;;;403    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;404    
;;;405      memp = memp_tab[type];
;;;406      
;;;407      if (memp != NULL) {
;;;408        memp_tab[type] = memp->next;
;;;409    #if MEMP_OVERFLOW_CHECK
;;;410        memp->next = NULL;
;;;411        memp->file = file;
;;;412        memp->line = line;
;;;413    #endif /* MEMP_OVERFLOW_CHECK */
;;;414        MEMP_STATS_INC_USED(used, type);
;;;415        LWIP_ASSERT("memp_malloc: memp properly aligned",
;;;416                    ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
;;;417        memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
;;;418      } else {
;;;419        LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
;;;420        MEMP_STATS_INC(err, type);
;;;421      }
;;;422    
;;;423      SYS_ARCH_UNPROTECT(old_level);
;;;424    
;;;425      return memp;
;;;426    }
00005e  bd70              POP      {r4-r6,pc}
                  |L1.96|
000060  bf00              NOP                            ;398
000062  f7fffffe          BL       sys_arch_protect
000066  4606              MOV      r6,r0                 ;400
000068  4816              LDR      r0,|L1.196|
00006a  f8504025          LDR      r4,[r0,r5,LSL #2]     ;405
00006e  b134              CBZ      r4,|L1.126|
000070  4914              LDR      r1,|L1.196|
000072  6820              LDR      r0,[r4,#0]            ;408
000074  f8410025          STR      r0,[r1,r5,LSL #2]     ;408
000078  bf00              NOP                            ;415
00007a  bf00              NOP                            ;415
00007c  e001              B        |L1.130|
                  |L1.126|
00007e  bf00              NOP                            ;419
000080  bf00              NOP                            ;419
                  |L1.130|
000082  4630              MOV      r0,r6                 ;423
000084  f7fffffe          BL       sys_arch_unprotect
000088  4620              MOV      r0,r4                 ;425
00008a  e7e8              B        |L1.94|
;;;427    
                          ENDP

                  memp_free PROC
;;;434    void
;;;435    memp_free(memp_t type, void *mem)
00008c  e92d41f0          PUSH     {r4-r8,lr}
;;;436    {
000090  4604              MOV      r4,r0
000092  460d              MOV      r5,r1
;;;437      struct memp *memp;
;;;438      SYS_ARCH_DECL_PROTECT(old_level);
;;;439    
;;;440      if (mem == NULL) {
000094  b90d              CBNZ     r5,|L1.154|
                  |L1.150|
;;;441        return;
;;;442      }
;;;443      LWIP_ASSERT("memp_free: mem properly aligned",
;;;444                    ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);
;;;445    
;;;446      memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
;;;447    
;;;448      SYS_ARCH_PROTECT(old_level);
;;;449    #if MEMP_OVERFLOW_CHECK
;;;450    #if MEMP_OVERFLOW_CHECK >= 2
;;;451      memp_overflow_check_all();
;;;452    #else
;;;453      memp_overflow_check_element_overflow(memp, type);
;;;454      memp_overflow_check_element_underflow(memp, type);
;;;455    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;456    #endif /* MEMP_OVERFLOW_CHECK */
;;;457    
;;;458      MEMP_STATS_DEC(used, type); 
;;;459      
;;;460      memp->next = memp_tab[type]; 
;;;461      memp_tab[type] = memp;
;;;462    
;;;463    #if MEMP_SANITY_CHECK
;;;464      LWIP_ASSERT("memp sanity", memp_sanity());
;;;465    #endif /* MEMP_SANITY_CHECK */
;;;466    
;;;467      SYS_ARCH_UNPROTECT(old_level);
;;;468    }
000096  e8bd81f0          POP      {r4-r8,pc}
                  |L1.154|
00009a  bf00              NOP                            ;443
00009c  bf00              NOP                            ;443
00009e  462e              MOV      r6,r5                 ;446
0000a0  f7fffffe          BL       sys_arch_protect
0000a4  4607              MOV      r7,r0                 ;448
0000a6  4807              LDR      r0,|L1.196|
0000a8  f8500024          LDR      r0,[r0,r4,LSL #2]     ;460
0000ac  6030              STR      r0,[r6,#0]            ;460
0000ae  4805              LDR      r0,|L1.196|
0000b0  f8406024          STR      r6,[r0,r4,LSL #2]     ;461
0000b4  4638              MOV      r0,r7                 ;467
0000b6  f7fffffe          BL       sys_arch_unprotect
0000ba  bf00              NOP      
0000bc  e7eb              B        |L1.150|
;;;469    
                          ENDP

0000be  0000              DCW      0x0000
                  |L1.192|
                          DCD      memp_memory+0x3
                  |L1.196|
                          DCD      memp_tab
                  |L1.200|
                          DCD      memp_sizes
                  |L1.204|
                          DCD      memp_num

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  memp_tab
                          %        52
                  memp_memory
                          %        31715

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  memp_sizes
000000  001c0024          DCW      0x001c,0x0024
000004  00940020          DCW      0x0094,0x0020
000008  00140010          DCW      0x0014,0x0010
00000c  00e80014          DCW      0x00e8,0x0014
000010  00140014          DCW      0x0014,0x0014
000014  00100018          DCW      0x0010,0x0018
000018  0604              DCW      0x0604
                  memp_num
00001a  0004              DCW      0x0004
00001c  00080004          DCW      0x0008,0x0004
000020  00040010          DCW      0x0004,0x0010
000024  00020014          DCW      0x0002,0x0014
000028  00080008          DCW      0x0008,0x0008
00002c  00080006          DCW      0x0008,0x0006
000030  00100010          DCW      0x0010,0x0010

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5241575f          DCB      "RAW_PCB",0
000004  50434200
000008  5544505f          DCB      "UDP_PCB",0
00000c  50434200
000010  5443505f          DCB      "TCP_PCB",0
000014  50434200
000018  5443505f          DCB      "TCP_PCB_LISTEN",0
00001c  5043425f
000020  4c495354
000024  454e00  
000027  00                DCB      0
000028  5443505f          DCB      "TCP_SEG",0
00002c  53454700
000030  4e455442          DCB      "NETBUF",0
000034  554600  
000037  00                DCB      0
000038  4e455443          DCB      "NETCONN",0
00003c  4f4e4e00
000040  54435049          DCB      "TCPIP_MSG_API",0
000044  505f4d53
000048  475f4150
00004c  4900    
00004e  00                DCB      0
00004f  00                DCB      0
000050  54435049          DCB      "TCPIP_MSG_INPKT",0
000054  505f4d53
000058  475f494e
00005c  504b5400
000060  49474d50          DCB      "IGMP_GROUP",0
000064  5f47524f
000068  555000  
00006b  00                DCB      0
00006c  5359535f          DCB      "SYS_TIMEOUT",0
000070  54494d45
000074  4f555400
000078  50425546          DCB      "PBUF_REF/ROM",0
00007c  5f524546
000080  2f524f4d
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
000088  50425546          DCB      "PBUF_POOL",0
00008c  5f504f4f
000090  4c00    

                          AREA ||.data||, DATA, ALIGN=2

                  memp_desc
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x18
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x30
                          DCD      ||.conststring||+0x38
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x50
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                          DCD      ||.conststring||+0x78
                          DCD      ||.conststring||+0x88
