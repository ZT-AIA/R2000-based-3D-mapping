; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\rt_mailbox.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\rt_mailbox.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\rt_mailbox.crf ..\..\libraries\rtx-v4.73\SRC\rt_Mailbox.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  rt_mbx_init PROC
;;;51     
;;;52     void rt_mbx_init (OS_ID mailbox, U16 mbx_size) {
000000  460a              MOV      r2,r1
;;;53       /* Initialize a mailbox */
;;;54       P_MCB p_MCB = mailbox;
000002  4601              MOV      r1,r0
;;;55     
;;;56       p_MCB->cb_type = MCB;
000004  2301              MOVS     r3,#1
000006  700b              STRB     r3,[r1,#0]
;;;57       p_MCB->state   = 0;
000008  2300              MOVS     r3,#0
00000a  704b              STRB     r3,[r1,#1]
;;;58       p_MCB->isr_st  = 0;
00000c  708b              STRB     r3,[r1,#2]
;;;59       p_MCB->p_lnk   = NULL;
00000e  604b              STR      r3,[r1,#4]
;;;60       p_MCB->first   = 0;
000010  810b              STRH     r3,[r1,#8]
;;;61       p_MCB->last    = 0;
000012  814b              STRH     r3,[r1,#0xa]
;;;62       p_MCB->count   = 0;
000014  818b              STRH     r3,[r1,#0xc]
;;;63       p_MCB->size    = (mbx_size + sizeof(void *) - sizeof(struct OS_MCB)) /
000016  f1a20310          SUB      r3,r2,#0x10
00001a  f3c3038f          UBFX     r3,r3,#2,#16
00001e  81cb              STRH     r3,[r1,#0xe]
;;;64                                                          (U32)sizeof (void *);
;;;65     }
000020  4770              BX       lr
;;;66     
                          ENDP

                  rt_mbx_send PROC
;;;69     
;;;70     OS_RESULT rt_mbx_send (OS_ID mailbox, void *p_msg, U16 timeout) {
000022  e92d41f0          PUSH     {r4-r8,lr}
000026  4606              MOV      r6,r0
000028  460d              MOV      r5,r1
00002a  4617              MOV      r7,r2
;;;71       /* Send message to a mailbox */
;;;72       P_MCB p_MCB = mailbox;
00002c  4634              MOV      r4,r6
;;;73       P_TCB p_TCB;
;;;74     
;;;75       if ((p_MCB->p_lnk != NULL) && (p_MCB->state == 1)) {
00002e  6860              LDR      r0,[r4,#4]
000030  b190              CBZ      r0,|L1.88|
000032  7860              LDRB     r0,[r4,#1]
000034  2801              CMP      r0,#1
000036  d10f              BNE      |L1.88|
;;;76         /* A task is waiting for message */
;;;77         p_TCB = rt_get_first ((P_XCB)p_MCB);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       rt_get_first
00003e  4680              MOV      r8,r0
;;;78     #ifdef __CMSIS_RTOS
;;;79         rt_ret_val2(p_TCB, 0x10/*osEventMessage*/, (U32)p_msg);
000040  462a              MOV      r2,r5
000042  2110              MOVS     r1,#0x10
000044  4640              MOV      r0,r8
000046  f7fffffe          BL       rt_ret_val2
;;;80     #else
;;;81         *p_TCB->msg = p_msg;
;;;82         rt_ret_val (p_TCB, OS_R_MBX);
;;;83     #endif
;;;84         rt_rmv_dly (p_TCB);
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       rt_rmv_dly
;;;85         rt_dispatch (p_TCB);
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       rt_dispatch
000056  e03f              B        |L1.216|
                  |L1.88|
;;;86       }
;;;87       else {
;;;88         /* Store message in mailbox queue */
;;;89         if (p_MCB->count == p_MCB->size) {
000058  89a0              LDRH     r0,[r4,#0xc]
00005a  89e1              LDRH     r1,[r4,#0xe]
00005c  4288              CMP      r0,r1
00005e  d120              BNE      |L1.162|
;;;90           /* No free message entry, wait for one. If message queue is full, */
;;;91           /* then no task is waiting for message. The 'p_MCB->p_lnk' list   */
;;;92           /* pointer can now be reused for send message waits task list.    */
;;;93           if (timeout == 0) {
000060  b917              CBNZ     r7,|L1.104|
;;;94             return (OS_R_TMO);
000062  2001              MOVS     r0,#1
                  |L1.100|
;;;95           }
;;;96           if (p_MCB->p_lnk != NULL) {
;;;97             rt_put_prio ((P_XCB)p_MCB, os_tsk.run);
;;;98           }
;;;99           else {
;;;100            p_MCB->p_lnk = os_tsk.run;
;;;101            os_tsk.run->p_lnk  = NULL;
;;;102            os_tsk.run->p_rlnk = (P_TCB)p_MCB;
;;;103            /* Task is waiting to send a message */      
;;;104            p_MCB->state = 2;
;;;105          }
;;;106          os_tsk.run->msg = p_msg;
;;;107          rt_block (timeout, WAIT_MBX);
;;;108          return (OS_R_TMO);
;;;109        }
;;;110        /* Yes, there is a free entry in a mailbox. */
;;;111        p_MCB->msg[p_MCB->first] = p_msg;
;;;112        rt_inc (&p_MCB->count);
;;;113        if (++p_MCB->first == p_MCB->size) {
;;;114          p_MCB->first = 0;
;;;115        }
;;;116      }
;;;117      return (OS_R_OK);
;;;118    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L1.104|
000068  6860              LDR      r0,[r4,#4]            ;96
00006a  b128              CBZ      r0,|L1.120|
00006c  48b6              LDR      r0,|L1.840|
00006e  6801              LDR      r1,[r0,#0]            ;97  ; os_tsk
000070  4620              MOV      r0,r4                 ;97
000072  f7fffffe          BL       rt_put_prio
000076  e00b              B        |L1.144|
                  |L1.120|
000078  48b3              LDR      r0,|L1.840|
00007a  6800              LDR      r0,[r0,#0]            ;100  ; os_tsk
00007c  6060              STR      r0,[r4,#4]            ;100
00007e  2000              MOVS     r0,#0                 ;101
000080  49b1              LDR      r1,|L1.840|
000082  6809              LDR      r1,[r1,#0]            ;101  ; os_tsk
000084  6048              STR      r0,[r1,#4]            ;101
000086  48b0              LDR      r0,|L1.840|
000088  6800              LDR      r0,[r0,#0]            ;102  ; os_tsk
00008a  6084              STR      r4,[r0,#8]            ;102
00008c  2002              MOVS     r0,#2                 ;104
00008e  7060              STRB     r0,[r4,#1]            ;104
                  |L1.144|
000090  48ad              LDR      r0,|L1.840|
000092  6800              LDR      r0,[r0,#0]            ;106  ; os_tsk
000094  61c5              STR      r5,[r0,#0x1c]         ;106
000096  2108              MOVS     r1,#8                 ;107
000098  4638              MOV      r0,r7                 ;107
00009a  f7fffffe          BL       rt_block
00009e  2001              MOVS     r0,#1                 ;108
0000a0  e7e0              B        |L1.100|
                  |L1.162|
0000a2  8921              LDRH     r1,[r4,#8]            ;111
0000a4  f1040010          ADD      r0,r4,#0x10           ;111
0000a8  f8405021          STR      r5,[r0,r1,LSL #2]     ;111
0000ac  bf00              NOP                            ;112
                  |L1.174|
0000ae  f104000c          ADD      r0,r4,#0xc            ;112
0000b2  e8d00f5f          LDREXH   r0,[r0]               ;112
0000b6  1c40              ADDS     r0,r0,#1              ;112
0000b8  b281              UXTH     r1,r0                 ;112
0000ba  f104000c          ADD      r0,r4,#0xc            ;112
0000be  e8c01f52          STREXH   r2,r1,[r0]            ;112
0000c2  2a00              CMP      r2,#0                 ;112
0000c4  d1f3              BNE      |L1.174|
0000c6  8920              LDRH     r0,[r4,#8]            ;113
0000c8  1c40              ADDS     r0,r0,#1              ;113
0000ca  b280              UXTH     r0,r0                 ;113
0000cc  8120              STRH     r0,[r4,#8]            ;113
0000ce  89e1              LDRH     r1,[r4,#0xe]          ;113
0000d0  4288              CMP      r0,r1                 ;113
0000d2  d101              BNE      |L1.216|
0000d4  2000              MOVS     r0,#0                 ;114
0000d6  8120              STRH     r0,[r4,#8]            ;114
                  |L1.216|
0000d8  2000              MOVS     r0,#0                 ;117
0000da  e7c3              B        |L1.100|
;;;119    
                          ENDP

                  rt_mbx_wait PROC
;;;122    
;;;123    OS_RESULT rt_mbx_wait (OS_ID mailbox, void **message, U16 timeout) {
0000dc  e92d41f0          PUSH     {r4-r8,lr}
0000e0  4605              MOV      r5,r0
0000e2  4688              MOV      r8,r1
0000e4  4616              MOV      r6,r2
;;;124      /* Receive a message; possibly wait for it */
;;;125      P_MCB p_MCB = mailbox;
0000e6  462c              MOV      r4,r5
;;;126      P_TCB p_TCB;
;;;127    
;;;128      /* If a message is available in the fifo buffer */
;;;129      /* remove it from the fifo buffer and return. */
;;;130      if (p_MCB->count) {
0000e8  89a0              LDRH     r0,[r4,#0xc]
0000ea  2800              CMP      r0,#0
0000ec  d042              BEQ      |L1.372|
;;;131        *message = p_MCB->msg[p_MCB->last];
0000ee  8961              LDRH     r1,[r4,#0xa]
0000f0  f1040010          ADD      r0,r4,#0x10
0000f4  f8500021          LDR      r0,[r0,r1,LSL #2]
0000f8  f8c80000          STR      r0,[r8,#0]
;;;132        if (++p_MCB->last == p_MCB->size) {
0000fc  8960              LDRH     r0,[r4,#0xa]
0000fe  1c40              ADDS     r0,r0,#1
000100  b280              UXTH     r0,r0
000102  8160              STRH     r0,[r4,#0xa]
000104  89e1              LDRH     r1,[r4,#0xe]
000106  4288              CMP      r0,r1
000108  d101              BNE      |L1.270|
;;;133          p_MCB->last = 0;
00010a  2000              MOVS     r0,#0
00010c  8160              STRH     r0,[r4,#0xa]
                  |L1.270|
;;;134        }
;;;135        if ((p_MCB->p_lnk != NULL) && (p_MCB->state == 2)) {
00010e  6860              LDR      r0,[r4,#4]
000110  b300              CBZ      r0,|L1.340|
000112  7860              LDRB     r0,[r4,#1]
000114  2802              CMP      r0,#2
000116  d11d              BNE      |L1.340|
;;;136          /* A task is waiting to send message */
;;;137          p_TCB = rt_get_first ((P_XCB)p_MCB);
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       rt_get_first
00011e  4607              MOV      r7,r0
;;;138    #ifdef __CMSIS_RTOS
;;;139          rt_ret_val(p_TCB, 0/*osOK*/);
000120  2100              MOVS     r1,#0
000122  4638              MOV      r0,r7
000124  f7fffffe          BL       rt_ret_val
;;;140    #else
;;;141          rt_ret_val(p_TCB, OS_R_OK);
;;;142    #endif
;;;143          p_MCB->msg[p_MCB->first] = p_TCB->msg;
000128  8922              LDRH     r2,[r4,#8]
00012a  f1040010          ADD      r0,r4,#0x10
00012e  69f9              LDR      r1,[r7,#0x1c]
000130  f8401022          STR      r1,[r0,r2,LSL #2]
;;;144          if (++p_MCB->first == p_MCB->size) {
000134  8920              LDRH     r0,[r4,#8]
000136  1c40              ADDS     r0,r0,#1
000138  b280              UXTH     r0,r0
00013a  8120              STRH     r0,[r4,#8]
00013c  89e1              LDRH     r1,[r4,#0xe]
00013e  4288              CMP      r0,r1
000140  d101              BNE      |L1.326|
;;;145            p_MCB->first = 0;
000142  2000              MOVS     r0,#0
000144  8120              STRH     r0,[r4,#8]
                  |L1.326|
;;;146          }
;;;147          rt_rmv_dly (p_TCB);
000146  4638              MOV      r0,r7
000148  f7fffffe          BL       rt_rmv_dly
;;;148          rt_dispatch (p_TCB);
00014c  4638              MOV      r0,r7
00014e  f7fffffe          BL       rt_dispatch
000152  e00c              B        |L1.366|
                  |L1.340|
;;;149        }
;;;150        else {
;;;151          rt_dec (&p_MCB->count);
000154  bf00              NOP      
                  |L1.342|
000156  f104000c          ADD      r0,r4,#0xc
00015a  e8d00f5f          LDREXH   r0,[r0]
00015e  1e40              SUBS     r0,r0,#1
000160  b281              UXTH     r1,r0
000162  f104000c          ADD      r0,r4,#0xc
000166  e8c01f52          STREXH   r2,r1,[r0]
00016a  2a00              CMP      r2,#0
00016c  d1f3              BNE      |L1.342|
                  |L1.366|
;;;152        }
;;;153        return (OS_R_OK);
00016e  2000              MOVS     r0,#0
                  |L1.368|
;;;154      }
;;;155      /* No message available: wait for one */
;;;156      if (timeout == 0) {
;;;157        return (OS_R_TMO);
;;;158      }
;;;159      if (p_MCB->p_lnk != NULL) {
;;;160        rt_put_prio ((P_XCB)p_MCB, os_tsk.run);
;;;161      }
;;;162      else {
;;;163        p_MCB->p_lnk = os_tsk.run;
;;;164        os_tsk.run->p_lnk = NULL;
;;;165        os_tsk.run->p_rlnk = (P_TCB)p_MCB;
;;;166        /* Task is waiting to receive a message */      
;;;167        p_MCB->state = 1;
;;;168      }
;;;169      rt_block(timeout, WAIT_MBX);
;;;170    #ifndef __CMSIS_RTOS
;;;171      os_tsk.run->msg = message;
;;;172    #endif
;;;173      return (OS_R_TMO);
;;;174    }
000170  e8bd81f0          POP      {r4-r8,pc}
                  |L1.372|
000174  b90e              CBNZ     r6,|L1.378|
000176  2001              MOVS     r0,#1                 ;157
000178  e7fa              B        |L1.368|
                  |L1.378|
00017a  6860              LDR      r0,[r4,#4]            ;159
00017c  b128              CBZ      r0,|L1.394|
00017e  4872              LDR      r0,|L1.840|
000180  6801              LDR      r1,[r0,#0]            ;160  ; os_tsk
000182  4620              MOV      r0,r4                 ;160
000184  f7fffffe          BL       rt_put_prio
000188  e00b              B        |L1.418|
                  |L1.394|
00018a  486f              LDR      r0,|L1.840|
00018c  6800              LDR      r0,[r0,#0]            ;163  ; os_tsk
00018e  6060              STR      r0,[r4,#4]            ;163
000190  2000              MOVS     r0,#0                 ;164
000192  496d              LDR      r1,|L1.840|
000194  6809              LDR      r1,[r1,#0]            ;164  ; os_tsk
000196  6048              STR      r0,[r1,#4]            ;164
000198  486b              LDR      r0,|L1.840|
00019a  6800              LDR      r0,[r0,#0]            ;165  ; os_tsk
00019c  6084              STR      r4,[r0,#8]            ;165
00019e  2001              MOVS     r0,#1                 ;167
0001a0  7060              STRB     r0,[r4,#1]            ;167
                  |L1.418|
0001a2  2108              MOVS     r1,#8                 ;169
0001a4  4630              MOV      r0,r6                 ;169
0001a6  f7fffffe          BL       rt_block
0001aa  2001              MOVS     r0,#1                 ;173
0001ac  e7e0              B        |L1.368|
;;;175    
                          ENDP

                  rt_mbx_check PROC
;;;178    
;;;179    OS_RESULT rt_mbx_check (OS_ID mailbox) {
0001ae  4601              MOV      r1,r0
;;;180      /* Check for free space in a mailbox. Returns the number of messages     */
;;;181      /* that can be stored to a mailbox. It returns 0 when mailbox is full.   */
;;;182      P_MCB p_MCB = mailbox;
0001b0  460a              MOV      r2,r1
;;;183    
;;;184      return (p_MCB->size - p_MCB->count);
0001b2  89d0              LDRH     r0,[r2,#0xe]
0001b4  8993              LDRH     r3,[r2,#0xc]
0001b6  1ac0              SUBS     r0,r0,r3
;;;185    }
0001b8  4770              BX       lr
;;;186    
                          ENDP

                  isr_mbx_send PROC
;;;189    
;;;190    void isr_mbx_send (OS_ID mailbox, void *p_msg) {
0001ba  b570              PUSH     {r4-r6,lr}
0001bc  4604              MOV      r4,r0
0001be  460d              MOV      r5,r1
;;;191      /* Same function as "os_mbx_send", but to be called by ISRs. */
;;;192      P_MCB p_MCB = mailbox;
0001c0  4626              MOV      r6,r4
;;;193    
;;;194      rt_psq_enq (p_MCB, (U32)p_msg);
0001c2  4629              MOV      r1,r5
0001c4  4630              MOV      r0,r6
0001c6  f7fffffe          BL       rt_psq_enq
;;;195      rt_psh_req ();
0001ca  f7fffffe          BL       rt_psh_req
;;;196    }
0001ce  bd70              POP      {r4-r6,pc}
;;;197    
                          ENDP

                  isr_mbx_receive PROC
;;;200    
;;;201    OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message) {
0001d0  b570              PUSH     {r4-r6,lr}
0001d2  4605              MOV      r5,r0
0001d4  460e              MOV      r6,r1
;;;202      /* Receive a message in the interrupt function. The interrupt function   */
;;;203      /* should not wait for a message since this would block the rtx os.      */
;;;204      P_MCB p_MCB = mailbox;
0001d6  462c              MOV      r4,r5
;;;205    
;;;206      if (p_MCB->count) {
0001d8  89a0              LDRH     r0,[r4,#0xc]
0001da  b330              CBZ      r0,|L1.554|
;;;207        /* A message is available in the fifo buffer. */
;;;208        *message = p_MCB->msg[p_MCB->last];
0001dc  8961              LDRH     r1,[r4,#0xa]
0001de  f1040010          ADD      r0,r4,#0x10
0001e2  f8500021          LDR      r0,[r0,r1,LSL #2]
0001e6  6030              STR      r0,[r6,#0]
;;;209        if (p_MCB->state == 2) {
0001e8  7860              LDRB     r0,[r4,#1]
0001ea  2802              CMP      r0,#2
0001ec  d105              BNE      |L1.506|
;;;210          /* A task is locked waiting to send message */
;;;211          rt_psq_enq (p_MCB, 0);
0001ee  2100              MOVS     r1,#0
0001f0  4620              MOV      r0,r4
0001f2  f7fffffe          BL       rt_psq_enq
;;;212          rt_psh_req ();
0001f6  f7fffffe          BL       rt_psh_req
                  |L1.506|
;;;213        }
;;;214        rt_dec (&p_MCB->count);
0001fa  bf00              NOP      
                  |L1.508|
0001fc  f104000c          ADD      r0,r4,#0xc
000200  e8d00f5f          LDREXH   r0,[r0]
000204  1e40              SUBS     r0,r0,#1
000206  b281              UXTH     r1,r0
000208  f104000c          ADD      r0,r4,#0xc
00020c  e8c01f52          STREXH   r2,r1,[r0]
000210  2a00              CMP      r2,#0
000212  d1f3              BNE      |L1.508|
;;;215        if (++p_MCB->last == p_MCB->size) {
000214  8960              LDRH     r0,[r4,#0xa]
000216  1c40              ADDS     r0,r0,#1
000218  b280              UXTH     r0,r0
00021a  8160              STRH     r0,[r4,#0xa]
00021c  89e1              LDRH     r1,[r4,#0xe]
00021e  4288              CMP      r0,r1
000220  d101              BNE      |L1.550|
;;;216          p_MCB->last = 0;
000222  2000              MOVS     r0,#0
000224  8160              STRH     r0,[r4,#0xa]
                  |L1.550|
;;;217        }
;;;218        return (OS_R_MBX);
000226  2004              MOVS     r0,#4
                  |L1.552|
;;;219      }
;;;220      return (OS_R_OK);
;;;221    }
000228  bd70              POP      {r4-r6,pc}
                  |L1.554|
00022a  2000              MOVS     r0,#0                 ;220
00022c  e7fc              B        |L1.552|
;;;222    
                          ENDP

                  rt_mbx_psh PROC
;;;225    
;;;226    void rt_mbx_psh (P_MCB p_CB, void *p_msg) {
00022e  e92d41f0          PUSH     {r4-r8,lr}
000232  4604              MOV      r4,r0
000234  460e              MOV      r6,r1
;;;227      /* Store the message to the mailbox queue or pass it to task directly. */
;;;228      P_TCB p_TCB;
;;;229      void *mem;
;;;230    
;;;231      if (p_CB->p_lnk != NULL) switch (p_CB->state) {
000236  6860              LDR      r0,[r4,#4]
000238  2800              CMP      r0,#0
00023a  d060              BEQ      |L1.766|
00023c  7860              LDRB     r0,[r4,#1]
00023e  2801              CMP      r0,#1
000240  d049              BEQ      |L1.726|
000242  2802              CMP      r0,#2
000244  d019              BEQ      |L1.634|
000246  2803              CMP      r0,#3
000248  d158              BNE      |L1.764|
;;;232    #ifdef __CMSIS_RTOS
;;;233        case 3:
;;;234          /* Task is waiting to allocate memory, remove it from the waiting list */
;;;235          mem = rt_alloc_box(p_msg);
00024a  4630              MOV      r0,r6
00024c  f7fffffe          BL       rt_alloc_box
000250  4607              MOV      r7,r0
;;;236          if (mem == NULL) break;
000252  b907              CBNZ     r7,|L1.598|
000254  e052              B        |L1.764|
                  |L1.598|
;;;237          p_TCB = rt_get_first ((P_XCB)p_CB);
000256  4620              MOV      r0,r4
000258  f7fffffe          BL       rt_get_first
00025c  4605              MOV      r5,r0
;;;238          rt_ret_val(p_TCB, (U32)mem);
00025e  4639              MOV      r1,r7
000260  4628              MOV      r0,r5
000262  f7fffffe          BL       rt_ret_val
;;;239          p_TCB->state = READY;
000266  2001              MOVS     r0,#1
000268  7068              STRB     r0,[r5,#1]
;;;240          rt_rmv_dly (p_TCB);
00026a  4628              MOV      r0,r5
00026c  f7fffffe          BL       rt_rmv_dly
;;;241          rt_put_prio (&os_rdy, p_TCB);
000270  4629              MOV      r1,r5
000272  4836              LDR      r0,|L1.844|
000274  f7fffffe          BL       rt_put_prio
;;;242          break;
000278  e040              B        |L1.764|
                  |L1.634|
;;;243    #endif
;;;244        case 2:
;;;245          /* Task is waiting to send a message, remove it from the waiting list */
;;;246          p_TCB = rt_get_first ((P_XCB)p_CB);
00027a  4620              MOV      r0,r4
00027c  f7fffffe          BL       rt_get_first
000280  4605              MOV      r5,r0
;;;247    #ifdef __CMSIS_RTOS
;;;248          rt_ret_val(p_TCB, 0/*osOK*/);
000282  2100              MOVS     r1,#0
000284  4628              MOV      r0,r5
000286  f7fffffe          BL       rt_ret_val
;;;249    #else
;;;250          rt_ret_val(p_TCB, OS_R_OK);
;;;251    #endif
;;;252          p_CB->msg[p_CB->first] = p_TCB->msg;
00028a  8922              LDRH     r2,[r4,#8]
00028c  f1040010          ADD      r0,r4,#0x10
000290  69e9              LDR      r1,[r5,#0x1c]
000292  f8401022          STR      r1,[r0,r2,LSL #2]
;;;253          rt_inc (&p_CB->count);
000296  bf00              NOP      
                  |L1.664|
000298  f104000c          ADD      r0,r4,#0xc
00029c  e8d00f5f          LDREXH   r0,[r0]
0002a0  1c40              ADDS     r0,r0,#1
0002a2  b281              UXTH     r1,r0
0002a4  f104000c          ADD      r0,r4,#0xc
0002a8  e8c01f52          STREXH   r2,r1,[r0]
0002ac  2a00              CMP      r2,#0
0002ae  d1f3              BNE      |L1.664|
;;;254          if (++p_CB->first == p_CB->size) {
0002b0  8920              LDRH     r0,[r4,#8]
0002b2  1c40              ADDS     r0,r0,#1
0002b4  b280              UXTH     r0,r0
0002b6  8120              STRH     r0,[r4,#8]
0002b8  89e1              LDRH     r1,[r4,#0xe]
0002ba  4288              CMP      r0,r1
0002bc  d101              BNE      |L1.706|
;;;255            p_CB->first = 0;
0002be  2000              MOVS     r0,#0
0002c0  8120              STRH     r0,[r4,#8]
                  |L1.706|
;;;256          }
;;;257          p_TCB->state = READY;
0002c2  2001              MOVS     r0,#1
0002c4  7068              STRB     r0,[r5,#1]
;;;258          rt_rmv_dly (p_TCB);
0002c6  4628              MOV      r0,r5
0002c8  f7fffffe          BL       rt_rmv_dly
;;;259          rt_put_prio (&os_rdy, p_TCB);
0002cc  4629              MOV      r1,r5
0002ce  481f              LDR      r0,|L1.844|
0002d0  f7fffffe          BL       rt_put_prio
;;;260          break;
0002d4  e012              B        |L1.764|
                  |L1.726|
;;;261        case 1:
;;;262          /* Task is waiting for a message, pass the message to the task directly */
;;;263          p_TCB = rt_get_first ((P_XCB)p_CB);
0002d6  4620              MOV      r0,r4
0002d8  f7fffffe          BL       rt_get_first
0002dc  4605              MOV      r5,r0
;;;264    #ifdef __CMSIS_RTOS
;;;265          rt_ret_val2(p_TCB, 0x10/*osEventMessage*/, (U32)p_msg);
0002de  4632              MOV      r2,r6
0002e0  2110              MOVS     r1,#0x10
0002e2  4628              MOV      r0,r5
0002e4  f7fffffe          BL       rt_ret_val2
;;;266    #else
;;;267          *p_TCB->msg = p_msg;
;;;268          rt_ret_val (p_TCB, OS_R_MBX);
;;;269    #endif
;;;270          p_TCB->state = READY;
0002e8  2001              MOVS     r0,#1
0002ea  7068              STRB     r0,[r5,#1]
;;;271          rt_rmv_dly (p_TCB);
0002ec  4628              MOV      r0,r5
0002ee  f7fffffe          BL       rt_rmv_dly
;;;272          rt_put_prio (&os_rdy, p_TCB);
0002f2  4629              MOV      r1,r5
0002f4  4815              LDR      r0,|L1.844|
0002f6  f7fffffe          BL       rt_put_prio
;;;273          break;
0002fa  bf00              NOP      
                  |L1.764|
0002fc  e022              B        |L1.836|
                  |L1.766|
;;;274      } else {
;;;275        /* No task is waiting for a message, store it to the mailbox queue */
;;;276        if (p_CB->count < p_CB->size) {
0002fe  89a0              LDRH     r0,[r4,#0xc]
000300  89e1              LDRH     r1,[r4,#0xe]
000302  4288              CMP      r0,r1
000304  da1b              BGE      |L1.830|
;;;277          p_CB->msg[p_CB->first] = p_msg;
000306  8921              LDRH     r1,[r4,#8]
000308  f1040010          ADD      r0,r4,#0x10
00030c  f8406021          STR      r6,[r0,r1,LSL #2]
;;;278          rt_inc (&p_CB->count);
000310  bf00              NOP      
                  |L1.786|
000312  f104000c          ADD      r0,r4,#0xc
000316  e8d00f5f          LDREXH   r0,[r0]
00031a  1c40              ADDS     r0,r0,#1
00031c  b281              UXTH     r1,r0
00031e  f104000c          ADD      r0,r4,#0xc
000322  e8c01f52          STREXH   r2,r1,[r0]
000326  2a00              CMP      r2,#0
000328  d1f3              BNE      |L1.786|
;;;279          if (++p_CB->first == p_CB->size) {
00032a  8920              LDRH     r0,[r4,#8]
00032c  1c40              ADDS     r0,r0,#1
00032e  b280              UXTH     r0,r0
000330  8120              STRH     r0,[r4,#8]
000332  89e1              LDRH     r1,[r4,#0xe]
000334  4288              CMP      r0,r1
000336  d105              BNE      |L1.836|
;;;280            p_CB->first = 0;
000338  2000              MOVS     r0,#0
00033a  8120              STRH     r0,[r4,#8]
00033c  e002              B        |L1.836|
                  |L1.830|
;;;281          }
;;;282        }
;;;283        else {
;;;284          os_error (OS_ERR_MBX_OVF);
00033e  2003              MOVS     r0,#3
000340  f7fffffe          BL       os_error
                  |L1.836|
;;;285        }
;;;286      }
;;;287    }
000344  e8bd81f0          POP      {r4-r8,pc}
;;;288    
                          ENDP

                  |L1.840|
                          DCD      os_tsk
                  |L1.844|
                          DCD      os_rdy
