; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\raw.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\raw.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\raw.crf ..\..\libraries\lwip-1.4.1\src\core\raw.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  raw_input PROC
;;;75     u8_t
;;;76     raw_input(struct pbuf *p, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;77     {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
;;;78       struct raw_pcb *pcb, *prev;
;;;79       struct ip_hdr *iphdr;
;;;80       s16_t proto;
;;;81       u8_t eaten = 0;
000008  2700              MOVS     r7,#0
;;;82     
;;;83       LWIP_UNUSED_ARG(inp);
;;;84     
;;;85       iphdr = (struct ip_hdr *)p->payload;
00000a  f8d58004          LDR      r8,[r5,#4]
;;;86       proto = IPH_PROTO(iphdr);
00000e  f8989009          LDRB     r9,[r8,#9]
;;;87     
;;;88       prev = NULL;
000012  2600              MOVS     r6,#0
;;;89       pcb = raw_pcbs;
000014  4867              LDR      r0,|L1.436|
000016  6804              LDR      r4,[r0,#0]  ; raw_pcbs
;;;90       /* loop through all raw pcbs until the packet is eaten by one */
;;;91       /* this allows multiple pcbs to match against the packet by design */
;;;92       while ((eaten == 0) && (pcb != NULL)) {
000018  e01f              B        |L1.90|
                  |L1.26|
;;;93         if ((pcb->protocol == proto) &&
00001a  7c20              LDRB     r0,[r4,#0x10]
00001c  4548              CMP      r0,r9
00001e  d11a              BNE      |L1.86|
;;;94             (ip_addr_isany(&pcb->local_ip) ||
000020  b134              CBZ      r4,|L1.48|
000022  6820              LDR      r0,[r4,#0]
000024  b120              CBZ      r0,|L1.48|
;;;95              ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
000026  4964              LDR      r1,|L1.440|
000028  6820              LDR      r0,[r4,#0]
00002a  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
00002c  4288              CMP      r0,r1
00002e  d112              BNE      |L1.86|
                  |L1.48|
;;;96     #if IP_SOF_BROADCAST_RECV
;;;97           /* broadcast filter? */
;;;98           if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
;;;99     #endif /* IP_SOF_BROADCAST_RECV */
;;;100          {
;;;101            /* receive callback function available? */
;;;102            if (pcb->recv != NULL) {
000030  6960              LDR      r0,[r4,#0x14]
000032  b180              CBZ      r0,|L1.86|
;;;103              /* the receive callback function did not eat the packet? */
;;;104              if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
000034  4b61              LDR      r3,|L1.444|
000036  462a              MOV      r2,r5
000038  4621              MOV      r1,r4
00003a  e9d4c005          LDRD     r12,r0,[r4,#0x14]
00003e  47e0              BLX      r12
000040  b148              CBZ      r0,|L1.86|
;;;105                /* receive function ate the packet */
;;;106                p = NULL;
000042  2500              MOVS     r5,#0
;;;107                eaten = 1;
000044  2701              MOVS     r7,#1
;;;108                if (prev != NULL) {
000046  b136              CBZ      r6,|L1.86|
;;;109                /* move the pcb to the front of raw_pcbs so that is
;;;110                   found faster next time */
;;;111                  prev->next = pcb->next;
000048  68e0              LDR      r0,[r4,#0xc]
00004a  60f0              STR      r0,[r6,#0xc]
;;;112                  pcb->next = raw_pcbs;
00004c  4859              LDR      r0,|L1.436|
00004e  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000050  60e0              STR      r0,[r4,#0xc]
;;;113                  raw_pcbs = pcb;
000052  4858              LDR      r0,|L1.436|
000054  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L1.86|
;;;114                }
;;;115              }
;;;116            }
;;;117            /* no receive callback function was set for this raw PCB */
;;;118          }
;;;119          /* drop the packet */
;;;120        }
;;;121        prev = pcb;
000056  4626              MOV      r6,r4
;;;122        pcb = pcb->next;
000058  68e4              LDR      r4,[r4,#0xc]
                  |L1.90|
00005a  b90f              CBNZ     r7,|L1.96|
00005c  2c00              CMP      r4,#0                 ;92
00005e  d1dc              BNE      |L1.26|
                  |L1.96|
;;;123      }
;;;124      return eaten;
000060  4638              MOV      r0,r7
;;;125    }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;126    
                          ENDP

                  raw_bind PROC
;;;141    err_t
;;;142    raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
000066  4602              MOV      r2,r0
;;;143    {
;;;144      ip_addr_set(&pcb->local_ip, ipaddr);
000068  b909              CBNZ     r1,|L1.110|
00006a  2000              MOVS     r0,#0
00006c  e000              B        |L1.112|
                  |L1.110|
00006e  6808              LDR      r0,[r1,#0]
                  |L1.112|
000070  6010              STR      r0,[r2,#0]
;;;145      return ERR_OK;
000072  2000              MOVS     r0,#0
;;;146    }
000074  4770              BX       lr
;;;147    
                          ENDP

                  raw_connect PROC
;;;161    err_t
;;;162    raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
000076  4602              MOV      r2,r0
;;;163    {
;;;164      ip_addr_set(&pcb->remote_ip, ipaddr);
000078  b909              CBNZ     r1,|L1.126|
00007a  2000              MOVS     r0,#0
00007c  e000              B        |L1.128|
                  |L1.126|
00007e  6808              LDR      r0,[r1,#0]
                  |L1.128|
000080  6050              STR      r0,[r2,#4]
;;;165      return ERR_OK;
000082  2000              MOVS     r0,#0
;;;166    }
000084  4770              BX       lr
;;;167    
                          ENDP

                  raw_recv PROC
;;;182    void
;;;183    raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
000086  6141              STR      r1,[r0,#0x14]
;;;184    {
;;;185      /* remember recv() callback and user data */
;;;186      pcb->recv = recv;
;;;187      pcb->recv_arg = recv_arg;
000088  6182              STR      r2,[r0,#0x18]
;;;188    }
00008a  4770              BX       lr
;;;189    
                          ENDP

                  raw_sendto PROC
;;;202    err_t
;;;203    raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
00008c  e92d4ffe          PUSH     {r1-r11,lr}
;;;204    {
000090  4604              MOV      r4,r0
000092  460d              MOV      r5,r1
000094  4691              MOV      r9,r2
;;;205      err_t err;
;;;206      struct netif *netif;
;;;207      ip_addr_t *src_ip;
;;;208      struct pbuf *q; /* q will be sent down the stack */
;;;209      
;;;210      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
000096  bf00              NOP      
000098  bf00              NOP      
;;;211      
;;;212      /* not enough space to add an IP header to first pbuf in given p chain? */
;;;213      if (pbuf_header(p, IP_HLEN)) {
00009a  2114              MOVS     r1,#0x14
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       pbuf_header
0000a2  b1a0              CBZ      r0,|L1.206|
;;;214        /* allocate header in new pbuf */
;;;215        q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
0000a4  2200              MOVS     r2,#0
0000a6  4611              MOV      r1,r2
0000a8  2001              MOVS     r0,#1
0000aa  f7fffffe          BL       pbuf_alloc
0000ae  4606              MOV      r6,r0
;;;216        /* new header pbuf could not be allocated? */
;;;217        if (q == NULL) {
0000b0  b92e              CBNZ     r6,|L1.190|
;;;218          LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
0000b2  bf00              NOP      
0000b4  bf00              NOP      
;;;219          return ERR_MEM;
0000b6  f04f30ff          MOV      r0,#0xffffffff
                  |L1.186|
;;;220        }
;;;221        if (p->tot_len != 0) {
;;;222          /* chain header q in front of given pbuf p */
;;;223          pbuf_chain(q, p);
;;;224        }
;;;225        /* { first pbuf q points to header pbuf } */
;;;226        LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;227      }  else {
;;;228        /* first pbuf q equals given pbuf */
;;;229        q = p;
;;;230        if(pbuf_header(q, -IP_HLEN)) {
;;;231          LWIP_ASSERT("Can't restore header we just removed!", 0);
;;;232          return ERR_MEM;
;;;233        }
;;;234      }
;;;235    
;;;236      if ((netif = ip_route(ipaddr)) == NULL) {
;;;237        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;238          ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
;;;239        /* free any temporary header pbuf allocated by pbuf_header() */
;;;240        if (q != p) {
;;;241          pbuf_free(q);
;;;242        }
;;;243        return ERR_RTE;
;;;244      }
;;;245    
;;;246    #if IP_SOF_BROADCAST
;;;247      /* broadcast filter? */
;;;248      if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(ipaddr, netif)) {
;;;249        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;250        /* free any temporary header pbuf allocated by pbuf_header() */
;;;251        if (q != p) {
;;;252          pbuf_free(q);
;;;253        }
;;;254        return ERR_VAL;
;;;255      }
;;;256    #endif /* IP_SOF_BROADCAST */
;;;257    
;;;258      if (ip_addr_isany(&pcb->local_ip)) {
;;;259        /* use outgoing network interface IP address as source address */
;;;260        src_ip = &(netif->ip_addr);
;;;261      } else {
;;;262        /* use RAW PCB local IP address as source address */
;;;263        src_ip = &(pcb->local_ip);
;;;264      }
;;;265    
;;;266      NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;267      err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
;;;268      NETIF_SET_HWADDRHINT(netif, NULL);
;;;269    
;;;270      /* did we chain a header earlier? */
;;;271      if (q != p) {
;;;272        /* free the header */
;;;273        pbuf_free(q);
;;;274      }
;;;275      return err;
;;;276    }
0000ba  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.190|
0000be  8928              LDRH     r0,[r5,#8]            ;221
0000c0  b118              CBZ      r0,|L1.202|
0000c2  4629              MOV      r1,r5                 ;223
0000c4  4630              MOV      r0,r6                 ;223
0000c6  f7fffffe          BL       pbuf_chain
                  |L1.202|
0000ca  bf00              NOP                            ;226
0000cc  e00b              B        |L1.230|
                  |L1.206|
0000ce  462e              MOV      r6,r5                 ;229
0000d0  f06f0113          MVN      r1,#0x13              ;230
0000d4  4630              MOV      r0,r6                 ;230
0000d6  f7fffffe          BL       pbuf_header
0000da  b120              CBZ      r0,|L1.230|
0000dc  bf00              NOP                            ;231
0000de  bf00              NOP                            ;231
0000e0  f04f30ff          MOV      r0,#0xffffffff        ;232
0000e4  e7e9              B        |L1.186|
                  |L1.230|
0000e6  4648              MOV      r0,r9                 ;236
0000e8  f7fffffe          BL       ip_route
0000ec  1e07              SUBS     r7,r0,#0              ;236
0000ee  d109              BNE      |L1.260|
0000f0  bf00              NOP                            ;237
0000f2  bf00              NOP                            ;237
0000f4  42ae              CMP      r6,r5                 ;240
0000f6  d002              BEQ      |L1.254|
0000f8  4630              MOV      r0,r6                 ;241
0000fa  f7fffffe          BL       pbuf_free
                  |L1.254|
0000fe  f06f0003          MVN      r0,#3                 ;243
000102  e7da              B        |L1.186|
                  |L1.260|
000104  b10c              CBZ      r4,|L1.266|
000106  6820              LDR      r0,[r4,#0]            ;258
000108  b910              CBNZ     r0,|L1.272|
                  |L1.266|
00010a  f1070804          ADD      r8,r7,#4              ;260
00010e  e000              B        |L1.274|
                  |L1.272|
000110  46a0              MOV      r8,r4                 ;263
                  |L1.274|
000112  7c20              LDRB     r0,[r4,#0x10]         ;267
000114  7a61              LDRB     r1,[r4,#9]            ;267
000116  e9cd0701          STRD     r0,r7,[sp,#4]         ;267
00011a  9100              STR      r1,[sp,#0]            ;267
00011c  7aa3              LDRB     r3,[r4,#0xa]          ;267
00011e  464a              MOV      r2,r9                 ;267
000120  4641              MOV      r1,r8                 ;267
000122  4630              MOV      r0,r6                 ;267
000124  f7fffffe          BL       ip_output_if
000128  4682              MOV      r10,r0                ;267
00012a  42ae              CMP      r6,r5                 ;271
00012c  d002              BEQ      |L1.308|
00012e  4630              MOV      r0,r6                 ;273
000130  f7fffffe          BL       pbuf_free
                  |L1.308|
000134  4650              MOV      r0,r10                ;275
000136  e7c0              B        |L1.186|
;;;277    
                          ENDP

                  raw_send PROC
;;;285    err_t
;;;286    raw_send(struct raw_pcb *pcb, struct pbuf *p)
000138  b570              PUSH     {r4-r6,lr}
;;;287    {
00013a  4604              MOV      r4,r0
00013c  460d              MOV      r5,r1
;;;288      return raw_sendto(pcb, p, &pcb->remote_ip);
00013e  1d22              ADDS     r2,r4,#4
000140  4629              MOV      r1,r5
000142  4620              MOV      r0,r4
000144  f7fffffe          BL       raw_sendto
;;;289    }
000148  bd70              POP      {r4-r6,pc}
;;;290    
                          ENDP

                  raw_remove PROC
;;;299    void
;;;300    raw_remove(struct raw_pcb *pcb)
00014a  b570              PUSH     {r4-r6,lr}
;;;301    {
00014c  4605              MOV      r5,r0
;;;302      struct raw_pcb *pcb2;
;;;303      /* pcb to be removed is first in list? */
;;;304      if (raw_pcbs == pcb) {
00014e  4819              LDR      r0,|L1.436|
000150  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000152  42a8              CMP      r0,r5
000154  d105              BNE      |L1.354|
;;;305        /* make list start at 2nd pcb */
;;;306        raw_pcbs = raw_pcbs->next;
000156  4817              LDR      r0,|L1.436|
000158  6800              LDR      r0,[r0,#0]  ; raw_pcbs
00015a  68c0              LDR      r0,[r0,#0xc]
00015c  4915              LDR      r1,|L1.436|
00015e  6008              STR      r0,[r1,#0]  ; raw_pcbs
000160  e00c              B        |L1.380|
                  |L1.354|
;;;307        /* pcb not 1st in list */
;;;308      } else {
;;;309        for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
000162  4814              LDR      r0,|L1.436|
000164  6804              LDR      r4,[r0,#0]  ; raw_pcbs
000166  e007              B        |L1.376|
                  |L1.360|
;;;310          /* find pcb in raw_pcbs list */
;;;311          if (pcb2->next != NULL && pcb2->next == pcb) {
000168  68e0              LDR      r0,[r4,#0xc]
00016a  b120              CBZ      r0,|L1.374|
00016c  68e0              LDR      r0,[r4,#0xc]
00016e  42a8              CMP      r0,r5
000170  d101              BNE      |L1.374|
;;;312            /* remove pcb from list */
;;;313            pcb2->next = pcb->next;
000172  68e8              LDR      r0,[r5,#0xc]
000174  60e0              STR      r0,[r4,#0xc]
                  |L1.374|
000176  68e4              LDR      r4,[r4,#0xc]          ;309
                  |L1.376|
000178  2c00              CMP      r4,#0                 ;309
00017a  d1f5              BNE      |L1.360|
                  |L1.380|
;;;314          }
;;;315        }
;;;316      }
;;;317      memp_free(MEMP_RAW_PCB, pcb);
00017c  4629              MOV      r1,r5
00017e  2000              MOVS     r0,#0
000180  f7fffffe          BL       memp_free
;;;318    }
000184  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP

                  raw_new PROC
;;;330    struct raw_pcb *
;;;331    raw_new(u8_t proto)
000186  b570              PUSH     {r4-r6,lr}
;;;332    {
000188  4605              MOV      r5,r0
;;;333      struct raw_pcb *pcb;
;;;334    
;;;335      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
00018a  bf00              NOP      
00018c  bf00              NOP      
;;;336    
;;;337      pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
00018e  2000              MOVS     r0,#0
000190  f7fffffe          BL       memp_malloc
000194  4604              MOV      r4,r0
;;;338      /* could allocate RAW PCB? */
;;;339      if (pcb != NULL) {
000196  b15c              CBZ      r4,|L1.432|
;;;340        /* initialize PCB to all zeroes */
;;;341        memset(pcb, 0, sizeof(struct raw_pcb));
000198  211c              MOVS     r1,#0x1c
00019a  4620              MOV      r0,r4
00019c  f7fffffe          BL       __aeabi_memclr4
;;;342        pcb->protocol = proto;
0001a0  7425              STRB     r5,[r4,#0x10]
;;;343        pcb->ttl = RAW_TTL;
0001a2  20ff              MOVS     r0,#0xff
0001a4  72a0              STRB     r0,[r4,#0xa]
;;;344        pcb->next = raw_pcbs;
0001a6  4803              LDR      r0,|L1.436|
0001a8  6800              LDR      r0,[r0,#0]  ; raw_pcbs
0001aa  60e0              STR      r0,[r4,#0xc]
;;;345        raw_pcbs = pcb;
0001ac  4801              LDR      r0,|L1.436|
0001ae  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L1.432|
;;;346      }
;;;347      return pcb;
0001b0  4620              MOV      r0,r4
;;;348    }
0001b2  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

                  |L1.436|
                          DCD      raw_pcbs
                  |L1.440|
                          DCD      current_iphdr_dest
                  |L1.444|
                          DCD      current_iphdr_src

                          AREA ||.data||, DATA, ALIGN=2

                  raw_pcbs
                          DCD      0x00000000
