; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\msg.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\msg.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\msg.crf ..\..\libraries\ptpd-2.0.0\src\dep\msg.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  msgUnpackHeader PROC
;;;5      /* Unpack header message */
;;;6      void msgUnpackHeader(const octet_t *buf, MsgHeader *header)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;7      {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;8      	int32_t msb;
;;;9      	uint32_t lsb;
;;;10     
;;;11     	header->transportSpecific = (*(nibble_t*)(buf + 0)) >> 4;
000008  7828              LDRB     r0,[r5,#0]
00000a  1100              ASRS     r0,r0,#4
00000c  7020              STRB     r0,[r4,#0]
;;;12     	header->messageType = (*(enum4bit_t*)(buf + 0)) & 0x0F;
00000e  7828              LDRB     r0,[r5,#0]
000010  f000000f          AND      r0,r0,#0xf
000014  7060              STRB     r0,[r4,#1]
;;;13     	header->versionPTP = (*(uint4bit_t*)(buf  + 1)) & 0x0F; //force reserved bit to zero if not
000016  7868              LDRB     r0,[r5,#1]
000018  f000000f          AND      r0,r0,#0xf
00001c  70a0              STRB     r0,[r4,#2]
;;;14     	header->messageLength = flip16(*(int16_t*)(buf  + 2));
00001e  8869              LDRH     r1,[r5,#2]
000020  b288              UXTH     r0,r1
000022  f7fffffe          BL       lwip_htons
000026  b200              SXTH     r0,r0
000028  80a0              STRH     r0,[r4,#4]
;;;15     	header->domainNumber = (*(uint8_t*)(buf + 4));
00002a  7928              LDRB     r0,[r5,#4]
00002c  71a0              STRB     r0,[r4,#6]
;;;16     	memcpy(header->flagField, (buf + 6), FLAG_FIELD_LENGTH);
00002e  88e8              LDRH     r0,[r5,#6]
000030  f8a40007          STRH     r0,[r4,#7]
;;;17     	memcpy(&msb, (buf + 8), 4);
000034  68ae              LDR      r6,[r5,#8]
;;;18     	memcpy(&lsb, (buf + 12), 4);
000036  68ef              LDR      r7,[r5,#0xc]
;;;19     	header->correctionfield = flip32(msb);
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       lwip_htonl
00003e  2100              MOVS     r1,#0
000040  e9c40104          STRD     r0,r1,[r4,#0x10]
;;;20     	header->correctionfield <<= 32;
000044  6920              LDR      r0,[r4,#0x10]
000046  e9c41004          STRD     r1,r0,[r4,#0x10]
;;;21     	header->correctionfield += flip32(lsb);
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       lwip_htonl
000050  e9d42304          LDRD     r2,r3,[r4,#0x10]
000054  1880              ADDS     r0,r0,r2
000056  f1430100          ADC      r1,r3,#0
00005a  e9c40104          STRD     r0,r1,[r4,#0x10]
;;;22     	memcpy(header->sourcePortIdentity.clockIdentity, (buf + 20), CLOCK_IDENTITY_LENGTH);
00005e  6968              LDR      r0,[r5,#0x14]
000060  61a0              STR      r0,[r4,#0x18]
000062  69a8              LDR      r0,[r5,#0x18]
000064  61e0              STR      r0,[r4,#0x1c]
;;;23     	header->sourcePortIdentity.portNumber = flip16(*(int16_t*)(buf  + 28));
000066  8ba9              LDRH     r1,[r5,#0x1c]
000068  b288              UXTH     r0,r1
00006a  f7fffffe          BL       lwip_htons
00006e  b201              SXTH     r1,r0
000070  8421              STRH     r1,[r4,#0x20]
;;;24     	header->sequenceId = flip16(*(int16_t*)(buf + 30));
000072  8be9              LDRH     r1,[r5,#0x1e]
000074  b288              UXTH     r0,r1
000076  f7fffffe          BL       lwip_htons
00007a  b200              SXTH     r0,r0
00007c  8460              STRH     r0,[r4,#0x22]
;;;25     	header->controlField = (*(uint8_t*)(buf + 32));
00007e  f8950020          LDRB     r0,[r5,#0x20]
000082  f8840024          STRB     r0,[r4,#0x24]
;;;26     	header->logMessageInterval = (*(int8_t*)(buf + 33));
000086  f8950021          LDRB     r0,[r5,#0x21]
00008a  f8840025          STRB     r0,[r4,#0x25]
;;;27     }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;28     
                          ENDP

                  msgPackHeader PROC
;;;29     /* Pack header message */
;;;30     void msgPackHeader(const PtpClock *ptpClock, octet_t *buf)
000092  b570              PUSH     {r4-r6,lr}
;;;31     {
000094  4605              MOV      r5,r0
000096  460c              MOV      r4,r1
;;;32     	nibble_t transport = 0x00;//0x80; //(spec annex D)//为了与linuxptp兼容将0x80--->0x00
000098  2600              MOVS     r6,#0
;;;33     	*(uint8_t*)(buf + 0) = transport;
00009a  7026              STRB     r6,[r4,#0]
;;;34     	*(uint4bit_t*)(buf  + 1) = ptpClock->portDS.versionNumber;
00009c  2071              MOVS     r0,#0x71
00009e  5d40              LDRB     r0,[r0,r5]
0000a0  7060              STRB     r0,[r4,#1]
;;;35     	*(uint8_t*)(buf + 4) = ptpClock->defaultDS.domainNumber;
0000a2  7ca8              LDRB     r0,[r5,#0x12]
0000a4  7120              STRB     r0,[r4,#4]
;;;36     	if (ptpClock->defaultDS.twoStepFlag)
0000a6  7828              LDRB     r0,[r5,#0]
0000a8  b108              CBZ      r0,|L1.174|
;;;37     	{
;;;38     			*(uint8_t*)(buf + 6) = FLAG0_TWO_STEP;
0000aa  2002              MOVS     r0,#2
0000ac  71a0              STRB     r0,[r4,#6]
                  |L1.174|
;;;39     	}
;;;40     	memset((buf + 8), 0, 8);
0000ae  2000              MOVS     r0,#0
0000b0  60a0              STR      r0,[r4,#8]
0000b2  60e0              STR      r0,[r4,#0xc]
;;;41     	memcpy((buf + 20), ptpClock->portDS.portIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
0000b4  6da8              LDR      r0,[r5,#0x58]
0000b6  6160              STR      r0,[r4,#0x14]
0000b8  6de8              LDR      r0,[r5,#0x5c]
0000ba  61a0              STR      r0,[r4,#0x18]
;;;42     	*(int16_t*)(buf + 28) = flip16(ptpClock->portDS.portIdentity.portNumber);
0000bc  2160              MOVS     r1,#0x60
0000be  5b49              LDRH     r1,[r1,r5]
0000c0  b288              UXTH     r0,r1
0000c2  f7fffffe          BL       lwip_htons
0000c6  b200              SXTH     r0,r0
0000c8  83a0              STRH     r0,[r4,#0x1c]
;;;43     	*(uint8_t*)(buf + 33) = 0x7F; //Default value (spec Table 24)
0000ca  207f              MOVS     r0,#0x7f
0000cc  f8840021          STRB     r0,[r4,#0x21]
;;;44     }
0000d0  bd70              POP      {r4-r6,pc}
;;;45     
                          ENDP

                  msgPackAnnounce PROC
;;;46     /* Pack Announce message */
;;;47     void msgPackAnnounce(const PtpClock *ptpClock, octet_t *buf)
0000d2  b570              PUSH     {r4-r6,lr}
;;;48     {
0000d4  4605              MOV      r5,r0
0000d6  460c              MOV      r4,r1
;;;49     	/* Changes in header */
;;;50     	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
0000d8  7820              LDRB     r0,[r4,#0]
0000da  f00000f0          AND      r0,r0,#0xf0
0000de  7020              STRB     r0,[r4,#0]
;;;51     	*(char*)(buf + 0) = *(char*)(buf + 0) | ANNOUNCE; //Table 19
0000e0  7820              LDRB     r0,[r4,#0]
0000e2  f040000b          ORR      r0,r0,#0xb
0000e6  7020              STRB     r0,[r4,#0]
;;;52     	*(int16_t*)(buf + 2)  = flip16(ANNOUNCE_LENGTH);
0000e8  2040              MOVS     r0,#0x40
0000ea  f7fffffe          BL       lwip_htons
0000ee  b200              SXTH     r0,r0
0000f0  8060              STRH     r0,[r4,#2]
;;;53     	*(int16_t*)(buf + 30) = flip16(ptpClock->sentAnnounceSequenceId);
0000f2  f8b51386          LDRH     r1,[r5,#0x386]
0000f6  b288              UXTH     r0,r1
0000f8  f7fffffe          BL       lwip_htons
0000fc  b200              SXTH     r0,r0
0000fe  83e0              STRH     r0,[r4,#0x1e]
;;;54     	*(uint8_t*)(buf + 32) = CTRL_OTHER; /* Table 23 - controlField */
000100  2005              MOVS     r0,#5
000102  f8840020          STRB     r0,[r4,#0x20]
;;;55     	*(int8_t*)(buf + 33) = ptpClock->portDS.logAnnounceInterval;
000106  206c              MOVS     r0,#0x6c
000108  5d40              LDRB     r0,[r0,r5]
00010a  f8840021          STRB     r0,[r4,#0x21]
00010e  3416              ADDS     r4,r4,#0x16
;;;56     
;;;57     	/* Announce message */
;;;58     	memset((buf + 34), 0, 10); /* originTimestamp */
000110  2000              MOVS     r0,#0
000112  60e0              STR      r0,[r4,#0xc]
000114  6120              STR      r0,[r4,#0x10]
000116  82a0              STRH     r0,[r4,#0x14]
;;;59     	*(int16_t*)(buf + 44) = flip16(ptpClock->timePropertiesDS.currentUtcOffset);
000118  f8b5104c          LDRH     r1,[r5,#0x4c]
00011c  b288              UXTH     r0,r1
00011e  f7fffffe          BL       lwip_htons
000122  b200              SXTH     r0,r0
000124  82e0              STRH     r0,[r4,#0x16]
;;;60     	*(uint8_t*)(buf + 47) = ptpClock->parentDS.grandmasterPriority1;
000126  f8950048          LDRB     r0,[r5,#0x48]
00012a  7660              STRB     r0,[r4,#0x19]
;;;61     	*(uint8_t*)(buf + 48) = ptpClock->defaultDS.clockQuality.clockClass;
00012c  7b28              LDRB     r0,[r5,#0xc]
00012e  76a0              STRB     r0,[r4,#0x1a]
;;;62     	*(enum8bit_t*)(buf + 49) = ptpClock->defaultDS.clockQuality.clockAccuracy;
000130  7b68              LDRB     r0,[r5,#0xd]
000132  76e0              STRB     r0,[r4,#0x1b]
;;;63     	*(int16_t*)(buf + 50) = flip16(ptpClock->defaultDS.clockQuality.offsetScaledLogVariance);
000134  89e9              LDRH     r1,[r5,#0xe]
000136  b288              UXTH     r0,r1
000138  f7fffffe          BL       lwip_htons
00013c  b200              SXTH     r0,r0
00013e  83a0              STRH     r0,[r4,#0x1c]
;;;64     	*(uint8_t*)(buf + 52) = ptpClock->parentDS.grandmasterPriority2;
000140  f8950049          LDRB     r0,[r5,#0x49]
000144  77a0              STRB     r0,[r4,#0x1e]
;;;65     	memcpy((buf + 53), ptpClock->parentDS.grandmasterIdentity, CLOCK_IDENTITY_LENGTH);
000146  6be9              LDR      r1,[r5,#0x3c]
000148  f8c4101f          STR      r1,[r4,#0x1f]
00014c  6c28              LDR      r0,[r5,#0x40]
00014e  f8440f23          STR      r0,[r4,#0x23]!
;;;66     	*(int16_t*)(buf + 61) = flip16(ptpClock->currentDS.stepsRemoved);
000152  8aa9              LDRH     r1,[r5,#0x14]
000154  b288              UXTH     r0,r1
000156  f7fffffe          BL       lwip_htons
00015a  b200              SXTH     r0,r0
00015c  80a0              STRH     r0,[r4,#4]
;;;67     	*(enum8bit_t*)(buf + 63) = ptpClock->timePropertiesDS.timeSource;
00015e  2054              MOVS     r0,#0x54
000160  5d40              LDRB     r0,[r0,r5]
000162  71a0              STRB     r0,[r4,#6]
000164  3c39              SUBS     r4,r4,#0x39
;;;68     }
000166  bd70              POP      {r4-r6,pc}
;;;69     
                          ENDP

                  msgUnpackAnnounce PROC
;;;70     /* Unpack Announce message */
;;;71     void msgUnpackAnnounce(const octet_t *buf, MsgAnnounce *announce)
000168  b570              PUSH     {r4-r6,lr}
;;;72     {
00016a  4604              MOV      r4,r0
00016c  460d              MOV      r5,r1
;;;73     	announce->originTimestamp.secondsField.msb = flip16(*(int16_t*)(buf + 34));
00016e  3424              ADDS     r4,r4,#0x24
000170  f8341c02          LDRH     r1,[r4,#-2]
000174  b288              UXTH     r0,r1
000176  f7fffffe          BL       lwip_htons
00017a  80a8              STRH     r0,[r5,#4]
;;;74     	announce->originTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
00017c  6820              LDR      r0,[r4,#0]
00017e  f7fffffe          BL       lwip_htonl
000182  6028              STR      r0,[r5,#0]
;;;75     	announce->originTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
000184  6860              LDR      r0,[r4,#4]
000186  f7fffffe          BL       lwip_htonl
00018a  60a8              STR      r0,[r5,#8]
;;;76     	announce->currentUtcOffset = flip16(*(int16_t*)(buf + 44));
00018c  8921              LDRH     r1,[r4,#8]
00018e  b288              UXTH     r0,r1
000190  f7fffffe          BL       lwip_htons
000194  b200              SXTH     r0,r0
000196  81a8              STRH     r0,[r5,#0xc]
;;;77     	announce->grandmasterPriority1 = *(uint8_t*)(buf + 47);
000198  7ae0              LDRB     r0,[r4,#0xb]
00019a  73a8              STRB     r0,[r5,#0xe]
;;;78     	announce->grandmasterClockQuality.clockClass = *(uint8_t*)(buf + 48);
00019c  7b20              LDRB     r0,[r4,#0xc]
00019e  7428              STRB     r0,[r5,#0x10]
;;;79     	announce->grandmasterClockQuality.clockAccuracy = *(enum8bit_t*)(buf + 49);
0001a0  7b61              LDRB     r1,[r4,#0xd]
0001a2  7469              STRB     r1,[r5,#0x11]
;;;80     	announce->grandmasterClockQuality.offsetScaledLogVariance = flip16(*(int16_t*)(buf  + 50));
0001a4  89e1              LDRH     r1,[r4,#0xe]
0001a6  b288              UXTH     r0,r1
0001a8  f7fffffe          BL       lwip_htons
0001ac  b201              SXTH     r1,r0
0001ae  8269              STRH     r1,[r5,#0x12]
;;;81     	announce->grandmasterPriority2 = *(uint8_t*)(buf + 52);
0001b0  7c20              LDRB     r0,[r4,#0x10]
0001b2  7528              STRB     r0,[r5,#0x14]
;;;82     	memcpy(announce->grandmasterIdentity, (buf + 53), CLOCK_IDENTITY_LENGTH);
0001b4  f8d40011          LDR      r0,[r4,#0x11]
0001b8  f8c50015          STR      r0,[r5,#0x15]
0001bc  f8d40015          LDR      r0,[r4,#0x15]
0001c0  f8c50019          STR      r0,[r5,#0x19]
;;;83     	announce->stepsRemoved = flip16(*(int16_t*)(buf + 61));
0001c4  f8b41019          LDRH     r1,[r4,#0x19]
0001c8  b288              UXTH     r0,r1
0001ca  f7fffffe          BL       lwip_htons
0001ce  b200              SXTH     r0,r0
0001d0  83e8              STRH     r0,[r5,#0x1e]
;;;84     	announce->timeSource = *(enum8bit_t*)(buf + 63);
0001d2  7ee0              LDRB     r0,[r4,#0x1b]
0001d4  3c24              SUBS     r4,r4,#0x24
0001d6  f8850020          STRB     r0,[r5,#0x20]
;;;85     }
0001da  bd70              POP      {r4-r6,pc}
;;;86     
                          ENDP

                  msgPackSync PROC
;;;87     /* Pack SYNC message */
;;;88     void msgPackSync(const PtpClock *ptpClock, octet_t *buf, const Timestamp *originTimestamp)
0001dc  b570              PUSH     {r4-r6,lr}
;;;89     {
0001de  4606              MOV      r6,r0
0001e0  460c              MOV      r4,r1
0001e2  4615              MOV      r5,r2
;;;90     	/* Changes in header */
;;;91     	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
0001e4  7820              LDRB     r0,[r4,#0]
0001e6  f00000f0          AND      r0,r0,#0xf0
0001ea  7020              STRB     r0,[r4,#0]
;;;92     	*(char*)(buf + 0) = *(char*)(buf + 0) | SYNC; //Table 19
0001ec  7820              LDRB     r0,[r4,#0]
0001ee  7020              STRB     r0,[r4,#0]
;;;93     	*(int16_t*)(buf + 2)  = flip16(SYNC_LENGTH);
0001f0  202c              MOVS     r0,#0x2c
0001f2  f7fffffe          BL       lwip_htons
0001f6  b200              SXTH     r0,r0
0001f8  8060              STRH     r0,[r4,#2]
;;;94     	*(int16_t*)(buf + 30) = flip16(ptpClock->sentSyncSequenceId);
0001fa  f8b61384          LDRH     r1,[r6,#0x384]
0001fe  b288              UXTH     r0,r1
000200  f7fffffe          BL       lwip_htons
000204  b200              SXTH     r0,r0
000206  83e0              STRH     r0,[r4,#0x1e]
;;;95     	*(uint8_t*)(buf + 32) = CTRL_SYNC; //Table 23
000208  2000              MOVS     r0,#0
00020a  f8840020          STRB     r0,[r4,#0x20]
;;;96     	*(int8_t*)(buf + 33) = ptpClock->portDS.logSyncInterval;
00020e  206e              MOVS     r0,#0x6e
000210  5d80              LDRB     r0,[r0,r6]
000212  f8840021          STRB     r0,[r4,#0x21]
;;;97     	memset((buf + 8), 0, 8); /* correction field */
000216  2000              MOVS     r0,#0
000218  60a0              STR      r0,[r4,#8]
00021a  60e0              STR      r0,[r4,#0xc]
;;;98     
;;;99     	/* Sync message */
;;;100    	*(int16_t*)(buf + 34) = flip16(originTimestamp->secondsField.msb);
00021c  88a8              LDRH     r0,[r5,#4]
00021e  f7fffffe          BL       lwip_htons
000222  b200              SXTH     r0,r0
000224  8460              STRH     r0,[r4,#0x22]
;;;101    	*(uint32_t*)(buf + 36) = flip32(originTimestamp->secondsField.lsb);
000226  6828              LDR      r0,[r5,#0]
000228  f7fffffe          BL       lwip_htonl
00022c  6260              STR      r0,[r4,#0x24]
;;;102    	*(uint32_t*)(buf + 40) = flip32(originTimestamp->nanosecondsField);
00022e  68a8              LDR      r0,[r5,#8]
000230  f7fffffe          BL       lwip_htonl
000234  62a0              STR      r0,[r4,#0x28]
;;;103    }
000236  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP

                  msgUnpackSync PROC
;;;105    /* Unpack Sync message */
;;;106    void msgUnpackSync(const octet_t *buf, MsgSync *sync)
000238  b570              PUSH     {r4-r6,lr}
;;;107    {
00023a  4604              MOV      r4,r0
00023c  460d              MOV      r5,r1
;;;108    	sync->originTimestamp.secondsField.msb = flip16(*(int16_t*)(buf + 34));
00023e  8c61              LDRH     r1,[r4,#0x22]
000240  b288              UXTH     r0,r1
000242  f7fffffe          BL       lwip_htons
000246  80a8              STRH     r0,[r5,#4]
;;;109    	sync->originTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
000248  6a60              LDR      r0,[r4,#0x24]
00024a  f7fffffe          BL       lwip_htonl
00024e  6028              STR      r0,[r5,#0]
;;;110    	sync->originTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
000250  6aa0              LDR      r0,[r4,#0x28]
000252  f7fffffe          BL       lwip_htonl
000256  60a8              STR      r0,[r5,#8]
;;;111    }
000258  bd70              POP      {r4-r6,pc}
;;;112    
                          ENDP

                  msgPackDelayReq PROC
;;;113    /* Pack delayReq message */
;;;114    void msgPackDelayReq(const PtpClock *ptpClock, octet_t *buf, const Timestamp *originTimestamp)
00025a  b570              PUSH     {r4-r6,lr}
;;;115    {
00025c  4606              MOV      r6,r0
00025e  460c              MOV      r4,r1
000260  4615              MOV      r5,r2
;;;116    	/* Changes in header */
;;;117    	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
000262  7820              LDRB     r0,[r4,#0]
000264  f00000f0          AND      r0,r0,#0xf0
000268  7020              STRB     r0,[r4,#0]
;;;118    	*(char*)(buf + 0) = *(char*)(buf + 0) | DELAY_REQ; //Table 19
00026a  7820              LDRB     r0,[r4,#0]
00026c  f0400001          ORR      r0,r0,#1
000270  7020              STRB     r0,[r4,#0]
;;;119    	*(int16_t*)(buf + 2)  = flip16(DELAY_REQ_LENGTH);
000272  202c              MOVS     r0,#0x2c
000274  f7fffffe          BL       lwip_htons
000278  b200              SXTH     r0,r0
00027a  8060              STRH     r0,[r4,#2]
;;;120    	*(int16_t*)(buf + 30) = flip16(ptpClock->sentDelayReqSequenceId);
00027c  f8b61382          LDRH     r1,[r6,#0x382]
000280  b288              UXTH     r0,r1
000282  f7fffffe          BL       lwip_htons
000286  b200              SXTH     r0,r0
000288  83e0              STRH     r0,[r4,#0x1e]
;;;121    	*(uint8_t*)(buf + 32) = CTRL_DELAY_REQ; //Table 23
00028a  2001              MOVS     r0,#1
00028c  f8840020          STRB     r0,[r4,#0x20]
;;;122    	*(int8_t*)(buf + 33) = 0x7F; //Table 24
000290  207f              MOVS     r0,#0x7f
000292  f8840021          STRB     r0,[r4,#0x21]
;;;123    	memset((buf + 8), 0, 8);
000296  2000              MOVS     r0,#0
000298  60a0              STR      r0,[r4,#8]
00029a  60e0              STR      r0,[r4,#0xc]
;;;124    
;;;125    	/* delay_req message */
;;;126    	*(int16_t*)(buf + 34) = flip16(originTimestamp->secondsField.msb);
00029c  88a8              LDRH     r0,[r5,#4]
00029e  f7fffffe          BL       lwip_htons
0002a2  b200              SXTH     r0,r0
0002a4  8460              STRH     r0,[r4,#0x22]
;;;127    	*(uint32_t*)(buf + 36) = flip32(originTimestamp->secondsField.lsb);
0002a6  6828              LDR      r0,[r5,#0]
0002a8  f7fffffe          BL       lwip_htonl
0002ac  6260              STR      r0,[r4,#0x24]
;;;128    	*(uint32_t*)(buf + 40) = flip32(originTimestamp->nanosecondsField);
0002ae  68a8              LDR      r0,[r5,#8]
0002b0  f7fffffe          BL       lwip_htonl
0002b4  62a0              STR      r0,[r4,#0x28]
;;;129    }
0002b6  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

                  msgUnpackDelayReq PROC
;;;131    /* Unpack delayReq message */
;;;132    void msgUnpackDelayReq(const octet_t *buf, MsgDelayReq *delayreq)
0002b8  b570              PUSH     {r4-r6,lr}
;;;133    {
0002ba  4604              MOV      r4,r0
0002bc  460d              MOV      r5,r1
;;;134    	delayreq->originTimestamp.secondsField.msb = flip16(*(int16_t*)(buf + 34));
0002be  8c61              LDRH     r1,[r4,#0x22]
0002c0  b288              UXTH     r0,r1
0002c2  f7fffffe          BL       lwip_htons
0002c6  80a8              STRH     r0,[r5,#4]
;;;135    	delayreq->originTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
0002c8  6a60              LDR      r0,[r4,#0x24]
0002ca  f7fffffe          BL       lwip_htonl
0002ce  6028              STR      r0,[r5,#0]
;;;136    	delayreq->originTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
0002d0  6aa0              LDR      r0,[r4,#0x28]
0002d2  f7fffffe          BL       lwip_htonl
0002d6  60a8              STR      r0,[r5,#8]
;;;137    }
0002d8  bd70              POP      {r4-r6,pc}
;;;138    
                          ENDP

                  msgPackFollowUp PROC
;;;139    /* Pack Follow_up message */
;;;140    void msgPackFollowUp(const PtpClock *ptpClock, octet_t*buf, const Timestamp *preciseOriginTimestamp)
0002da  b570              PUSH     {r4-r6,lr}
;;;141    {
0002dc  4606              MOV      r6,r0
0002de  460c              MOV      r4,r1
0002e0  4615              MOV      r5,r2
;;;142    	/* Changes in header */
;;;143    	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
0002e2  7820              LDRB     r0,[r4,#0]
0002e4  f00000f0          AND      r0,r0,#0xf0
0002e8  7020              STRB     r0,[r4,#0]
;;;144    	*(char*)(buf + 0) = *(char*)(buf + 0) | FOLLOW_UP; //Table 19
0002ea  7820              LDRB     r0,[r4,#0]
0002ec  f0400008          ORR      r0,r0,#8
0002f0  7020              STRB     r0,[r4,#0]
;;;145    	*(int16_t*)(buf + 2)  = flip16(FOLLOW_UP_LENGTH);
0002f2  202c              MOVS     r0,#0x2c
0002f4  f7fffffe          BL       lwip_htons
0002f8  b200              SXTH     r0,r0
0002fa  8060              STRH     r0,[r4,#2]
;;;146    	*(int16_t*)(buf + 30) = flip16(ptpClock->sentSyncSequenceId - 1);//sentSyncSequenceId has already been  incremented in issueSync
0002fc  f8b61384          LDRH     r1,[r6,#0x384]
000300  1e49              SUBS     r1,r1,#1
000302  b288              UXTH     r0,r1
000304  f7fffffe          BL       lwip_htons
000308  b200              SXTH     r0,r0
00030a  83e0              STRH     r0,[r4,#0x1e]
;;;147    	*(uint8_t*)(buf + 32) = CTRL_FOLLOW_UP; //Table 23
00030c  2002              MOVS     r0,#2
00030e  f8840020          STRB     r0,[r4,#0x20]
;;;148    	*(int8_t*)(buf + 33) = ptpClock->portDS.logSyncInterval;
000312  206e              MOVS     r0,#0x6e
000314  5d80              LDRB     r0,[r0,r6]
000316  f8840021          STRB     r0,[r4,#0x21]
;;;149    
;;;150    	/* Follow_up message */
;;;151    	*(int16_t*)(buf + 34) = flip16(preciseOriginTimestamp->secondsField.msb);
00031a  88a8              LDRH     r0,[r5,#4]
00031c  f7fffffe          BL       lwip_htons
000320  b200              SXTH     r0,r0
000322  8460              STRH     r0,[r4,#0x22]
;;;152    	*(uint32_t*)(buf + 36) = flip32(preciseOriginTimestamp->secondsField.lsb);
000324  6828              LDR      r0,[r5,#0]
000326  f7fffffe          BL       lwip_htonl
00032a  6260              STR      r0,[r4,#0x24]
;;;153    	*(uint32_t*)(buf + 40) = flip32(preciseOriginTimestamp->nanosecondsField);
00032c  68a8              LDR      r0,[r5,#8]
00032e  f7fffffe          BL       lwip_htonl
000332  62a0              STR      r0,[r4,#0x28]
;;;154    }
000334  bd70              POP      {r4-r6,pc}
;;;155    
                          ENDP

                  msgUnpackFollowUp PROC
;;;156    /* Unpack Follow_up message */
;;;157    void msgUnpackFollowUp(const octet_t *buf, MsgFollowUp *follow)
000336  b570              PUSH     {r4-r6,lr}
;;;158    {
000338  4604              MOV      r4,r0
00033a  460d              MOV      r5,r1
;;;159    	follow->preciseOriginTimestamp.secondsField.msb = flip16(*(int16_t*)(buf  + 34));
00033c  8c61              LDRH     r1,[r4,#0x22]
00033e  b288              UXTH     r0,r1
000340  f7fffffe          BL       lwip_htons
000344  80a8              STRH     r0,[r5,#4]
;;;160    	follow->preciseOriginTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
000346  6a60              LDR      r0,[r4,#0x24]
000348  f7fffffe          BL       lwip_htonl
00034c  6028              STR      r0,[r5,#0]
;;;161    	follow->preciseOriginTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
00034e  6aa0              LDR      r0,[r4,#0x28]
000350  f7fffffe          BL       lwip_htonl
000354  60a8              STR      r0,[r5,#8]
;;;162    }
000356  bd70              POP      {r4-r6,pc}
;;;163    
                          ENDP

                  msgPackDelayResp PROC
;;;164    /* Pack delayResp message */
;;;165    void msgPackDelayResp(const PtpClock *ptpClock, octet_t *buf, const MsgHeader *header, const Timestamp *receiveTimestamp)
000358  e92d41f0          PUSH     {r4-r8,lr}
;;;166    {
00035c  4607              MOV      r7,r0
00035e  460c              MOV      r4,r1
000360  4615              MOV      r5,r2
000362  461e              MOV      r6,r3
;;;167    	/* Changes in header */
;;;168    	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
000364  7820              LDRB     r0,[r4,#0]
000366  f00000f0          AND      r0,r0,#0xf0
00036a  7020              STRB     r0,[r4,#0]
;;;169    	*(char*)(buf + 0) = *(char*)(buf + 0) | DELAY_RESP; //Table 19
00036c  7820              LDRB     r0,[r4,#0]
00036e  f0400009          ORR      r0,r0,#9
000372  7020              STRB     r0,[r4,#0]
;;;170    	*(int16_t*)(buf + 2)  = flip16(DELAY_RESP_LENGTH);
000374  2036              MOVS     r0,#0x36
000376  f7fffffe          BL       lwip_htons
00037a  b200              SXTH     r0,r0
00037c  8060              STRH     r0,[r4,#2]
;;;171    	/* *(uint8_t*)(buf+4) = header->domainNumber; */ /* TODO: Why? */
;;;172    	memset((buf + 8), 0, 8);
00037e  2000              MOVS     r0,#0
000380  60a0              STR      r0,[r4,#8]
000382  60e0              STR      r0,[r4,#0xc]
;;;173    
;;;174    	/* Copy correctionField of  delayReqMessage */
;;;175    	*(int32_t*)(buf + 8) = flip32(header->correctionfield >> 32);
000384  6968              LDR      r0,[r5,#0x14]
000386  f7fffffe          BL       lwip_htonl
00038a  60a0              STR      r0,[r4,#8]
;;;176    	*(int32_t*)(buf + 12) = flip32((int32_t)header->correctionfield);
00038c  6928              LDR      r0,[r5,#0x10]
00038e  f7fffffe          BL       lwip_htonl
000392  60e0              STR      r0,[r4,#0xc]
;;;177    	*(int16_t*)(buf + 30) = flip16(header->sequenceId);
000394  8c69              LDRH     r1,[r5,#0x22]
000396  b288              UXTH     r0,r1
000398  f7fffffe          BL       lwip_htons
00039c  b200              SXTH     r0,r0
00039e  83e0              STRH     r0,[r4,#0x1e]
;;;178    	*(uint8_t*)(buf + 32) = CTRL_DELAY_RESP; //Table 23
0003a0  2003              MOVS     r0,#3
0003a2  f8840020          STRB     r0,[r4,#0x20]
;;;179    	*(int8_t*)(buf + 33) = ptpClock->portDS.logMinDelayReqInterval; //Table 24
0003a6  2063              MOVS     r0,#0x63
0003a8  5dc0              LDRB     r0,[r0,r7]
0003aa  f8840021          STRB     r0,[r4,#0x21]
;;;180    
;;;181    	/* delay_resp message */
;;;182    	*(int16_t*)(buf + 34) = flip16(receiveTimestamp->secondsField.msb);
0003ae  88b0              LDRH     r0,[r6,#4]
0003b0  f7fffffe          BL       lwip_htons
0003b4  b200              SXTH     r0,r0
0003b6  8460              STRH     r0,[r4,#0x22]
;;;183    	*(uint32_t*)(buf + 36) = flip32(receiveTimestamp->secondsField.lsb);
0003b8  6830              LDR      r0,[r6,#0]
0003ba  f7fffffe          BL       lwip_htonl
0003be  6260              STR      r0,[r4,#0x24]
;;;184    	*(uint32_t*)(buf + 40) = flip32(receiveTimestamp->nanosecondsField);
0003c0  68b0              LDR      r0,[r6,#8]
0003c2  f7fffffe          BL       lwip_htonl
0003c6  62a0              STR      r0,[r4,#0x28]
;;;185    	memcpy((buf + 44), header->sourcePortIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
0003c8  69a8              LDR      r0,[r5,#0x18]
0003ca  62e0              STR      r0,[r4,#0x2c]
0003cc  69e8              LDR      r0,[r5,#0x1c]
0003ce  6320              STR      r0,[r4,#0x30]
;;;186    	*(int16_t*)(buf + 52) = flip16(header->sourcePortIdentity.portNumber);
0003d0  8c29              LDRH     r1,[r5,#0x20]
0003d2  b288              UXTH     r0,r1
0003d4  f7fffffe          BL       lwip_htons
0003d8  b200              SXTH     r0,r0
0003da  86a0              STRH     r0,[r4,#0x34]
;;;187    }
0003dc  e8bd81f0          POP      {r4-r8,pc}
;;;188    
                          ENDP

                  msgUnpackDelayResp PROC
;;;189    /* Unpack delayResp message */
;;;190    void msgUnpackDelayResp(const octet_t *buf, MsgDelayResp *resp)
0003e0  b570              PUSH     {r4-r6,lr}
;;;191    {
0003e2  4604              MOV      r4,r0
0003e4  460d              MOV      r5,r1
;;;192    	resp->receiveTimestamp.secondsField.msb = flip16(*(int16_t*)(buf  + 34));
0003e6  8c61              LDRH     r1,[r4,#0x22]
0003e8  b288              UXTH     r0,r1
0003ea  f7fffffe          BL       lwip_htons
0003ee  80a8              STRH     r0,[r5,#4]
;;;193    	resp->receiveTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
0003f0  6a60              LDR      r0,[r4,#0x24]
0003f2  f7fffffe          BL       lwip_htonl
0003f6  6028              STR      r0,[r5,#0]
;;;194    	resp->receiveTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
0003f8  6aa0              LDR      r0,[r4,#0x28]
0003fa  f7fffffe          BL       lwip_htonl
0003fe  60a8              STR      r0,[r5,#8]
;;;195    	memcpy(resp->requestingPortIdentity.clockIdentity, (buf + 44), CLOCK_IDENTITY_LENGTH);
000400  6ae0              LDR      r0,[r4,#0x2c]
000402  60e8              STR      r0,[r5,#0xc]
000404  6b20              LDR      r0,[r4,#0x30]
000406  6128              STR      r0,[r5,#0x10]
;;;196    	resp->requestingPortIdentity.portNumber = flip16(*(int16_t*)(buf  + 52));
000408  8ea1              LDRH     r1,[r4,#0x34]
00040a  b288              UXTH     r0,r1
00040c  f7fffffe          BL       lwip_htons
000410  b201              SXTH     r1,r0
000412  82a9              STRH     r1,[r5,#0x14]
;;;197    }
000414  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP

                  msgPackPDelayReq PROC
;;;199    /* Pack PdelayReq message */
;;;200    void msgPackPDelayReq(const PtpClock *ptpClock, octet_t *buf, const Timestamp *originTimestamp)
000416  b570              PUSH     {r4-r6,lr}
;;;201    {
000418  4606              MOV      r6,r0
00041a  460c              MOV      r4,r1
00041c  4615              MOV      r5,r2
;;;202    	/* Changes in header */
;;;203    	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
00041e  7820              LDRB     r0,[r4,#0]
000420  f00000f0          AND      r0,r0,#0xf0
000424  7020              STRB     r0,[r4,#0]
;;;204    	*(char*)(buf + 0) = *(char*)(buf + 0) | PDELAY_REQ; //Table 19
000426  7820              LDRB     r0,[r4,#0]
000428  f0400002          ORR      r0,r0,#2
00042c  7020              STRB     r0,[r4,#0]
;;;205    	*(int16_t*)(buf + 2)  = flip16(PDELAY_REQ_LENGTH);
00042e  2036              MOVS     r0,#0x36
000430  f7fffffe          BL       lwip_htons
000434  b200              SXTH     r0,r0
000436  8060              STRH     r0,[r4,#2]
;;;206    	*(int16_t*)(buf + 30) = flip16(ptpClock->sentPDelayReqSequenceId);
000438  f8b61380          LDRH     r1,[r6,#0x380]
00043c  b288              UXTH     r0,r1
00043e  f7fffffe          BL       lwip_htons
000442  b200              SXTH     r0,r0
000444  83e0              STRH     r0,[r4,#0x1e]
;;;207    	*(uint8_t*)(buf + 32) = CTRL_OTHER; //Table 23
000446  2005              MOVS     r0,#5
000448  f8840020          STRB     r0,[r4,#0x20]
;;;208    	*(int8_t*)(buf + 33) = 0x7F; //Table 24
00044c  207f              MOVS     r0,#0x7f
00044e  f8840021          STRB     r0,[r4,#0x21]
;;;209    	memset((buf + 8), 0, 8);
000452  2000              MOVS     r0,#0
000454  60a0              STR      r0,[r4,#8]
000456  60e0              STR      r0,[r4,#0xc]
;;;210    
;;;211    	/* Pdelay_req message */
;;;212    	*(int16_t*)(buf + 34) = flip16(originTimestamp->secondsField.msb);
000458  88a8              LDRH     r0,[r5,#4]
00045a  f7fffffe          BL       lwip_htons
00045e  b200              SXTH     r0,r0
000460  8460              STRH     r0,[r4,#0x22]
;;;213    	*(uint32_t*)(buf + 36) = flip32(originTimestamp->secondsField.lsb);
000462  6828              LDR      r0,[r5,#0]
000464  f7fffffe          BL       lwip_htonl
000468  6260              STR      r0,[r4,#0x24]
;;;214    	*(uint32_t*)(buf + 40) = flip32(originTimestamp->nanosecondsField);
00046a  68a8              LDR      r0,[r5,#8]
00046c  f7fffffe          BL       lwip_htonl
000470  62a0              STR      r0,[r4,#0x28]
;;;215    
;;;216    	memset((buf + 44), 0, 10); // RAZ reserved octets
000472  2000              MOVS     r0,#0
000474  62e0              STR      r0,[r4,#0x2c]
000476  6320              STR      r0,[r4,#0x30]
000478  86a0              STRH     r0,[r4,#0x34]
;;;217    }
00047a  bd70              POP      {r4-r6,pc}
;;;218    
                          ENDP

                  msgUnpackPDelayReq PROC
;;;219    /* Unpack PdelayReq message */
;;;220    void msgUnpackPDelayReq(const octet_t *buf, MsgPDelayReq *pdelayreq)
00047c  b570              PUSH     {r4-r6,lr}
;;;221    {
00047e  4604              MOV      r4,r0
000480  460d              MOV      r5,r1
;;;222    	pdelayreq->originTimestamp.secondsField.msb = flip16(*(int16_t*)(buf  + 34));
000482  8c61              LDRH     r1,[r4,#0x22]
000484  b288              UXTH     r0,r1
000486  f7fffffe          BL       lwip_htons
00048a  80a8              STRH     r0,[r5,#4]
;;;223    	pdelayreq->originTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
00048c  6a60              LDR      r0,[r4,#0x24]
00048e  f7fffffe          BL       lwip_htonl
000492  6028              STR      r0,[r5,#0]
;;;224    	pdelayreq->originTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
000494  6aa0              LDR      r0,[r4,#0x28]
000496  f7fffffe          BL       lwip_htonl
00049a  60a8              STR      r0,[r5,#8]
;;;225    }
00049c  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP

                  msgPackPDelayResp PROC
;;;227    /* Pack PdelayResp message */
;;;228    void msgPackPDelayResp(octet_t *buf, const MsgHeader *header, const Timestamp *requestReceiptTimestamp)
00049e  b570              PUSH     {r4-r6,lr}
;;;229    {
0004a0  4604              MOV      r4,r0
0004a2  460d              MOV      r5,r1
0004a4  4616              MOV      r6,r2
;;;230    	/* Changes in header */
;;;231    	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
0004a6  7820              LDRB     r0,[r4,#0]
0004a8  f00000f0          AND      r0,r0,#0xf0
0004ac  7020              STRB     r0,[r4,#0]
;;;232    	*(char*)(buf + 0) = *(char*)(buf + 0) | PDELAY_RESP; //Table 19
0004ae  7820              LDRB     r0,[r4,#0]
0004b0  f0400003          ORR      r0,r0,#3
0004b4  7020              STRB     r0,[r4,#0]
;;;233    	*(int16_t*)(buf + 2)  = flip16(PDELAY_RESP_LENGTH);
0004b6  2036              MOVS     r0,#0x36
0004b8  f7fffffe          BL       lwip_htons
0004bc  b200              SXTH     r0,r0
0004be  8060              STRH     r0,[r4,#2]
;;;234    	/* *(uint8_t*)(buf+4) = header->domainNumber; */ /* TODO: Why? */
;;;235    	memset((buf + 8), 0, 8);
0004c0  2000              MOVS     r0,#0
0004c2  60a0              STR      r0,[r4,#8]
0004c4  60e0              STR      r0,[r4,#0xc]
;;;236    	*(int16_t*)(buf + 30) = flip16(header->sequenceId);
0004c6  8c69              LDRH     r1,[r5,#0x22]
0004c8  b288              UXTH     r0,r1
0004ca  f7fffffe          BL       lwip_htons
0004ce  b200              SXTH     r0,r0
0004d0  83e0              STRH     r0,[r4,#0x1e]
;;;237    	*(uint8_t*)(buf + 32) = CTRL_OTHER; //Table 23
0004d2  2005              MOVS     r0,#5
0004d4  f8840020          STRB     r0,[r4,#0x20]
;;;238    	*(int8_t*)(buf + 33) = 0x7F; //Table 24
0004d8  207f              MOVS     r0,#0x7f
0004da  f8840021          STRB     r0,[r4,#0x21]
;;;239    
;;;240    	/* Pdelay_resp message */
;;;241    	*(int16_t*)(buf + 34) = flip16(requestReceiptTimestamp->secondsField.msb);
0004de  88b0              LDRH     r0,[r6,#4]
0004e0  f7fffffe          BL       lwip_htons
0004e4  b200              SXTH     r0,r0
0004e6  8460              STRH     r0,[r4,#0x22]
;;;242    	*(uint32_t*)(buf + 36) = flip32(requestReceiptTimestamp->secondsField.lsb);
0004e8  6830              LDR      r0,[r6,#0]
0004ea  f7fffffe          BL       lwip_htonl
0004ee  6260              STR      r0,[r4,#0x24]
;;;243    	*(uint32_t*)(buf + 40) = flip32(requestReceiptTimestamp->nanosecondsField);
0004f0  68b0              LDR      r0,[r6,#8]
0004f2  f7fffffe          BL       lwip_htonl
0004f6  62a0              STR      r0,[r4,#0x28]
;;;244    	memcpy((buf + 44), header->sourcePortIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
0004f8  69a8              LDR      r0,[r5,#0x18]
0004fa  62e0              STR      r0,[r4,#0x2c]
0004fc  69e8              LDR      r0,[r5,#0x1c]
0004fe  6320              STR      r0,[r4,#0x30]
;;;245    	*(int16_t*)(buf + 52) = flip16(header->sourcePortIdentity.portNumber);
000500  8c29              LDRH     r1,[r5,#0x20]
000502  b288              UXTH     r0,r1
000504  f7fffffe          BL       lwip_htons
000508  b200              SXTH     r0,r0
00050a  86a0              STRH     r0,[r4,#0x34]
;;;246    
;;;247    }
00050c  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP

                  msgUnpackPDelayResp PROC
;;;249    /* Unpack PdelayResp message */
;;;250    void msgUnpackPDelayResp(const octet_t *buf, MsgPDelayResp *presp)
00050e  b570              PUSH     {r4-r6,lr}
;;;251    {
000510  4604              MOV      r4,r0
000512  460d              MOV      r5,r1
;;;252    	presp->requestReceiptTimestamp.secondsField.msb = flip16(*(int16_t*)(buf  + 34));
000514  8c61              LDRH     r1,[r4,#0x22]
000516  b288              UXTH     r0,r1
000518  f7fffffe          BL       lwip_htons
00051c  80a8              STRH     r0,[r5,#4]
;;;253    	presp->requestReceiptTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
00051e  6a60              LDR      r0,[r4,#0x24]
000520  f7fffffe          BL       lwip_htonl
000524  6028              STR      r0,[r5,#0]
;;;254    	presp->requestReceiptTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
000526  6aa0              LDR      r0,[r4,#0x28]
000528  f7fffffe          BL       lwip_htonl
00052c  60a8              STR      r0,[r5,#8]
;;;255    	memcpy(presp->requestingPortIdentity.clockIdentity, (buf + 44), CLOCK_IDENTITY_LENGTH);
00052e  6ae0              LDR      r0,[r4,#0x2c]
000530  60e8              STR      r0,[r5,#0xc]
000532  6b20              LDR      r0,[r4,#0x30]
000534  6128              STR      r0,[r5,#0x10]
;;;256    	presp->requestingPortIdentity.portNumber = flip16(*(int16_t*)(buf + 52));
000536  8ea1              LDRH     r1,[r4,#0x34]
000538  b288              UXTH     r0,r1
00053a  f7fffffe          BL       lwip_htons
00053e  b201              SXTH     r1,r0
000540  82a9              STRH     r1,[r5,#0x14]
;;;257    }
000542  bd70              POP      {r4-r6,pc}
;;;258    
                          ENDP

                  msgPackPDelayRespFollowUp PROC
;;;259    /* Pack PdelayRespfollowup message */
;;;260    void msgPackPDelayRespFollowUp(octet_t *buf, const MsgHeader *header, const Timestamp *responseOriginTimestamp)
000544  b570              PUSH     {r4-r6,lr}
;;;261    {
000546  4604              MOV      r4,r0
000548  460d              MOV      r5,r1
00054a  4616              MOV      r6,r2
;;;262    	/* Changes in header */
;;;263    	*(char*)(buf + 0) = *(char*)(buf + 0) & 0xF0; //RAZ messageType
00054c  7820              LDRB     r0,[r4,#0]
00054e  f00000f0          AND      r0,r0,#0xf0
000552  7020              STRB     r0,[r4,#0]
;;;264    	*(char*)(buf + 0) = *(char*)(buf + 0) | PDELAY_RESP_FOLLOW_UP; //Table 19
000554  7820              LDRB     r0,[r4,#0]
000556  f040000a          ORR      r0,r0,#0xa
00055a  7020              STRB     r0,[r4,#0]
;;;265    	*(int16_t*)(buf + 2)  = flip16(PDELAY_RESP_FOLLOW_UP_LENGTH);
00055c  2036              MOVS     r0,#0x36
00055e  f7fffffe          BL       lwip_htons
000562  b200              SXTH     r0,r0
000564  8060              STRH     r0,[r4,#2]
;;;266    	*(int16_t*)(buf + 30) = flip16(header->sequenceId);
000566  8c69              LDRH     r1,[r5,#0x22]
000568  b288              UXTH     r0,r1
00056a  f7fffffe          BL       lwip_htons
00056e  b200              SXTH     r0,r0
000570  83e0              STRH     r0,[r4,#0x1e]
;;;267    	*(uint8_t*)(buf + 32) = CTRL_OTHER; //Table 23
000572  2005              MOVS     r0,#5
000574  f8840020          STRB     r0,[r4,#0x20]
;;;268    	*(int8_t*)(buf + 33) = 0x7F; //Table 24
000578  207f              MOVS     r0,#0x7f
00057a  f8840021          STRB     r0,[r4,#0x21]
;;;269    
;;;270    	/* Copy correctionField of  PdelayReqMessage */
;;;271    	*(int32_t*)(buf + 8) = flip32(header->correctionfield >> 32);
00057e  6968              LDR      r0,[r5,#0x14]
000580  f7fffffe          BL       lwip_htonl
000584  60a0              STR      r0,[r4,#8]
;;;272    	*(int32_t*)(buf + 12) = flip32((int32_t)header->correctionfield);
000586  6928              LDR      r0,[r5,#0x10]
000588  f7fffffe          BL       lwip_htonl
00058c  60e0              STR      r0,[r4,#0xc]
;;;273    
;;;274    	/* Pdelay_resp_follow_up message */
;;;275    	*(int16_t*)(buf + 34) = flip16(responseOriginTimestamp->secondsField.msb);
00058e  88b0              LDRH     r0,[r6,#4]
000590  f7fffffe          BL       lwip_htons
000594  b200              SXTH     r0,r0
000596  8460              STRH     r0,[r4,#0x22]
;;;276    	*(uint32_t*)(buf + 36) = flip32(responseOriginTimestamp->secondsField.lsb);
000598  6830              LDR      r0,[r6,#0]
00059a  f7fffffe          BL       lwip_htonl
00059e  6260              STR      r0,[r4,#0x24]
;;;277    	*(uint32_t*)(buf + 40) = flip32(responseOriginTimestamp->nanosecondsField);
0005a0  68b0              LDR      r0,[r6,#8]
0005a2  f7fffffe          BL       lwip_htonl
0005a6  62a0              STR      r0,[r4,#0x28]
;;;278    	memcpy((buf + 44), header->sourcePortIdentity.clockIdentity, CLOCK_IDENTITY_LENGTH);
0005a8  69a8              LDR      r0,[r5,#0x18]
0005aa  62e0              STR      r0,[r4,#0x2c]
0005ac  69e8              LDR      r0,[r5,#0x1c]
0005ae  6320              STR      r0,[r4,#0x30]
;;;279    	*(int16_t*)(buf + 52) = flip16(header->sourcePortIdentity.portNumber);
0005b0  8c29              LDRH     r1,[r5,#0x20]
0005b2  b288              UXTH     r0,r1
0005b4  f7fffffe          BL       lwip_htons
0005b8  b200              SXTH     r0,r0
0005ba  86a0              STRH     r0,[r4,#0x34]
;;;280    }
0005bc  bd70              POP      {r4-r6,pc}
;;;281    
                          ENDP

                  msgUnpackPDelayRespFollowUp PROC
;;;282    /* Unpack PdelayResp message */
;;;283    void msgUnpackPDelayRespFollowUp(const octet_t *buf, MsgPDelayRespFollowUp *prespfollow)
0005be  b570              PUSH     {r4-r6,lr}
;;;284    {
0005c0  4604              MOV      r4,r0
0005c2  460d              MOV      r5,r1
;;;285    	prespfollow->responseOriginTimestamp.secondsField.msb = flip16(*(int16_t*)(buf  + 34));
0005c4  8c61              LDRH     r1,[r4,#0x22]
0005c6  b288              UXTH     r0,r1
0005c8  f7fffffe          BL       lwip_htons
0005cc  80a8              STRH     r0,[r5,#4]
;;;286    	prespfollow->responseOriginTimestamp.secondsField.lsb = flip32(*(uint32_t*)(buf + 36));
0005ce  6a60              LDR      r0,[r4,#0x24]
0005d0  f7fffffe          BL       lwip_htonl
0005d4  6028              STR      r0,[r5,#0]
;;;287    	prespfollow->responseOriginTimestamp.nanosecondsField = flip32(*(uint32_t*)(buf + 40));
0005d6  6aa0              LDR      r0,[r4,#0x28]
0005d8  f7fffffe          BL       lwip_htonl
0005dc  60a8              STR      r0,[r5,#8]
;;;288    	memcpy(prespfollow->requestingPortIdentity.clockIdentity, (buf + 44), CLOCK_IDENTITY_LENGTH);
0005de  6ae0              LDR      r0,[r4,#0x2c]
0005e0  60e8              STR      r0,[r5,#0xc]
0005e2  6b20              LDR      r0,[r4,#0x30]
0005e4  6128              STR      r0,[r5,#0x10]
;;;289    	prespfollow->requestingPortIdentity.portNumber = flip16(*(int16_t*)(buf + 52));
0005e6  8ea1              LDRH     r1,[r4,#0x34]
0005e8  b288              UXTH     r0,r1
0005ea  f7fffffe          BL       lwip_htons
0005ee  b201              SXTH     r1,r0
0005f0  82a9              STRH     r1,[r5,#0x14]
;;;290    }
0005f2  bd70              POP      {r4-r6,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\dep\\msg.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_msg_c_988f4dde____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_msg_c_988f4dde____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_msg_c_988f4dde____REVSH|
#line 128
|__asm___5_msg_c_988f4dde____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
