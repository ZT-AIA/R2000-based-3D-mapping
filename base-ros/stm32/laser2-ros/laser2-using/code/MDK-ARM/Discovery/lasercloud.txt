; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\lasercloud.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\lasercloud.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\lasercloud.crf ..\src\laserCloud.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1155    */
;;;1156   static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1157   {
;;;1158     if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da07              BGE      |L1.22|
;;;1159       SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
000006  070a              LSLS     r2,r1,#28
000008  0e14              LSRS     r4,r2,#24
00000a  4afb              LDR      r2,|L1.1016|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L1.30|
                  |L1.22|
;;;1160     else {
;;;1161       NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
000016  070a              LSLS     r2,r1,#28
000018  0e13              LSRS     r3,r2,#24
00001a  4af8              LDR      r2,|L1.1020|
00001c  5413              STRB     r3,[r2,r0]
                  |L1.30|
;;;1162   }
00001e  bd10              POP      {r4,pc}
;;;1163   
                          ENDP

                  QEPInit PROC
;;;45     //为了记录旋转电机的，需要初始化定时器捕获正交编码信号
;;;46     static void QEPInit(void)
000020  b500              PUSH     {lr}
;;;47     {
000022  b087              SUB      sp,sp,#0x1c
;;;48     	GPIO_InitTypeDef GPIO_InitStructure;
;;;49     	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  
;;;50     	//TIM_ICInitTypeDef TIM_ICInitStructure;
;;;51     	EXTI_InitTypeDef EXTI_InitStructure;
;;;52     
;;;53     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
000024  2101              MOVS     r1,#1
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;54     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  2008              MOVS     r0,#8
000030  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;55     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,  ENABLE);
000034  2101              MOVS     r1,#1
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;56     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,  ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;57     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,  ENABLE);
000044  2101              MOVS     r1,#1
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;58     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5,  ENABLE);
00004c  2101              MOVS     r1,#1
00004e  2008              MOVS     r0,#8
000050  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;59     	/* Enable SYSCFG clock */
;;;60     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);  
000054  2101              MOVS     r1,#1
000056  0388              LSLS     r0,r1,#14
000058  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     
;;;62     	/* Configure encoder input */
;;;63     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
00005c  2001              MOVS     r0,#1
00005e  f88d0019          STRB     r0,[sp,#0x19]
;;;64     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	//第二功能
000062  2002              MOVS     r0,#2
000064  f88d0018          STRB     r0,[sp,#0x18]
;;;65     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	//推挽方式
000068  2000              MOVS     r0,#0
00006a  f88d001a          STRB     r0,[sp,#0x1a]
;;;66     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;        //带上拉
00006e  2001              MOVS     r0,#1
000070  f88d001b          STRB     r0,[sp,#0x1b]
;;;67     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
000074  2030              MOVS     r0,#0x30
000076  9005              STR      r0,[sp,#0x14]
;;;68     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000078  a905              ADD      r1,sp,#0x14
00007a  48e1              LDR      r0,|L1.1024|
00007c  f7fffffe          BL       GPIO_Init
;;;69     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13;
000080  f44f5040          MOV      r0,#0x3000
000084  9005              STR      r0,[sp,#0x14]
;;;70     	GPIO_Init(GPIOD, &GPIO_InitStructure);
000086  a905              ADD      r1,sp,#0x14
000088  48de              LDR      r0,|L1.1028|
00008a  f7fffffe          BL       GPIO_Init
;;;71     	
;;;72     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
00008e  2000              MOVS     r0,#0
000090  f88d0018          STRB     r0,[sp,#0x18]
;;;73     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000094  f88d001b          STRB     r0,[sp,#0x1b]
;;;74     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
000098  2008              MOVS     r0,#8
00009a  9005              STR      r0,[sp,#0x14]
;;;75     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00009c  a905              ADD      r1,sp,#0x14
00009e  48d8              LDR      r0,|L1.1024|
0000a0  f7fffffe          BL       GPIO_Init
;;;76     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
0000a4  f44f4080          MOV      r0,#0x4000
0000a8  9005              STR      r0,[sp,#0x14]
;;;77     	GPIO_Init(GPIOD, &GPIO_InitStructure);
0000aa  a905              ADD      r1,sp,#0x14
0000ac  48d5              LDR      r0,|L1.1028|
0000ae  f7fffffe          BL       GPIO_Init
;;;78     	
;;;79     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_TIM3);
0000b2  2202              MOVS     r2,#2
0000b4  2104              MOVS     r1,#4
0000b6  48d2              LDR      r0,|L1.1024|
0000b8  f7fffffe          BL       GPIO_PinAFConfig
;;;80       GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_TIM3);
0000bc  2202              MOVS     r2,#2
0000be  2105              MOVS     r1,#5
0000c0  48cf              LDR      r0,|L1.1024|
0000c2  f7fffffe          BL       GPIO_PinAFConfig
;;;81     	GPIO_PinAFConfig(GPIOD,GPIO_PinSource12,GPIO_AF_TIM4);
0000c6  2202              MOVS     r2,#2
0000c8  210c              MOVS     r1,#0xc
0000ca  48ce              LDR      r0,|L1.1028|
0000cc  f7fffffe          BL       GPIO_PinAFConfig
;;;82     	GPIO_PinAFConfig(GPIOD,GPIO_PinSource13,GPIO_AF_TIM4);
0000d0  2202              MOVS     r2,#2
0000d2  210d              MOVS     r1,#0xd
0000d4  48cb              LDR      r0,|L1.1028|
0000d6  f7fffffe          BL       GPIO_PinAFConfig
;;;83     	/* Connect EXTI Line to PB3 & PD14 Pin */
;;;84     	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource3);
0000da  2103              MOVS     r1,#3
0000dc  2001              MOVS     r0,#1
0000de  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;85     	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);
0000e2  210e              MOVS     r1,#0xe
0000e4  2003              MOVS     r0,#3
0000e6  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;86     
;;;87     	/* Timer configuration in Encoder mode */ 
;;;88     	//TIM_DeInit(TIM3);
;;;89     	TIM_TimeBaseStructure.TIM_Prescaler = 0; 			// No prescaling 
0000ea  2000              MOVS     r0,#0
0000ec  f8ad0008          STRH     r0,[sp,#8]
;;;90     	TIM_TimeBaseStructure.TIM_Period 	= 0xffffu; 
0000f0  f64f70ff          MOV      r0,#0xffff
0000f4  9003              STR      r0,[sp,#0xc]
;;;91     	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
0000f6  2000              MOVS     r0,#0
0000f8  f8ad0010          STRH     r0,[sp,#0x10]
;;;92     	TIM_TimeBaseStructure.TIM_CounterMode 	= TIM_CounterMode_Up;   
0000fc  f8ad000a          STRH     r0,[sp,#0xa]
;;;93     	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
000100  f88d0012          STRB     r0,[sp,#0x12]
;;;94     	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
000104  a902              ADD      r1,sp,#8
000106  f04f4080          MOV      r0,#0x40000000
00010a  f7fffffe          BL       TIM_TimeBaseInit
;;;95     	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
00010e  a902              ADD      r1,sp,#8
000110  48bd              LDR      r0,|L1.1032|
000112  f7fffffe          BL       TIM_TimeBaseInit
;;;96     	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
000116  a902              ADD      r1,sp,#8
000118  48bc              LDR      r0,|L1.1036|
00011a  f7fffffe          BL       TIM_TimeBaseInit
;;;97     	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
00011e  a902              ADD      r1,sp,#8
000120  48bb              LDR      r0,|L1.1040|
000122  f7fffffe          BL       TIM_TimeBaseInit
;;;98     	
;;;99     	/* TIM3 & TIM4 is configured as Master */
;;;100    	TIM_SelectOutputTrigger(TIM3, TIM_TRGOSource_Update);
000126  2120              MOVS     r1,#0x20
000128  48b7              LDR      r0,|L1.1032|
00012a  f7fffffe          BL       TIM_SelectOutputTrigger
;;;101    	TIM_SelectMasterSlaveMode(TIM3, TIM_MasterSlaveMode_Enable);
00012e  2180              MOVS     r1,#0x80
000130  48b5              LDR      r0,|L1.1032|
000132  f7fffffe          BL       TIM_SelectMasterSlaveMode
;;;102    	TIM_SelectOutputTrigger(TIM4, TIM_TRGOSource_Update);
000136  2120              MOVS     r1,#0x20
000138  48b4              LDR      r0,|L1.1036|
00013a  f7fffffe          BL       TIM_SelectOutputTrigger
;;;103    	TIM_SelectMasterSlaveMode(TIM4, TIM_MasterSlaveMode_Enable);
00013e  2180              MOVS     r1,#0x80
000140  48b2              LDR      r0,|L1.1036|
000142  f7fffffe          BL       TIM_SelectMasterSlaveMode
;;;104    	/* TIM2 & TIM5 is configured as Slave */
;;;105    	TIM_SelectInputTrigger(TIM2, TIM_TS_ITR2);
000146  2120              MOVS     r1,#0x20
000148  0648              LSLS     r0,r1,#25
00014a  f7fffffe          BL       TIM_SelectInputTrigger
;;;106    	TIM_SelectSlaveMode(TIM2, TIM_SlaveMode_External1);
00014e  2107              MOVS     r1,#7
000150  f04f4080          MOV      r0,#0x40000000
000154  f7fffffe          BL       TIM_SelectSlaveMode
;;;107    	TIM_ITRxExternalClockConfig(TIM2, TIM_TS_ITR2);
000158  2120              MOVS     r1,#0x20
00015a  0648              LSLS     r0,r1,#25
00015c  f7fffffe          BL       TIM_ITRxExternalClockConfig
;;;108    	TIM_SelectInputTrigger(TIM5, TIM_TS_ITR2);
000160  2120              MOVS     r1,#0x20
000162  48ab              LDR      r0,|L1.1040|
000164  f7fffffe          BL       TIM_SelectInputTrigger
;;;109    	TIM_SelectSlaveMode(TIM5, TIM_SlaveMode_External1);
000168  2107              MOVS     r1,#7
00016a  48a9              LDR      r0,|L1.1040|
00016c  f7fffffe          BL       TIM_SelectSlaveMode
;;;110    	TIM_ITRxExternalClockConfig(TIM5, TIM_TS_ITR2);
000170  2120              MOVS     r1,#0x20
000172  48a7              LDR      r0,|L1.1040|
000174  f7fffffe          BL       TIM_ITRxExternalClockConfig
;;;111    	
;;;112    	/* TIM3 & TIM4 is configured as QEP I/F */
;;;113    	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
000178  2300              MOVS     r3,#0
00017a  461a              MOV      r2,r3
00017c  2103              MOVS     r1,#3
00017e  48a2              LDR      r0,|L1.1032|
000180  f7fffffe          BL       TIM_EncoderInterfaceConfig
;;;114    	TIM_EncoderInterfaceConfig(TIM4, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
000184  2300              MOVS     r3,#0
000186  461a              MOV      r2,r3
000188  2103              MOVS     r1,#3
00018a  48a0              LDR      r0,|L1.1036|
00018c  f7fffffe          BL       TIM_EncoderInterfaceConfig
;;;115    	
;;;116    	TIM3->CCMR1 |= (TIM_CCMR1_IC1F & (1uL << 4 ));
000190  489d              LDR      r0,|L1.1032|
000192  3018              ADDS     r0,r0,#0x18
000194  8800              LDRH     r0,[r0,#0]
000196  f0400010          ORR      r0,r0,#0x10
00019a  499b              LDR      r1,|L1.1032|
00019c  3118              ADDS     r1,r1,#0x18
00019e  8008              STRH     r0,[r1,#0]
;;;117    	TIM3->CCMR1 |= (TIM_CCMR1_IC2F & (1uL << 12));
0001a0  4608              MOV      r0,r1
0001a2  8800              LDRH     r0,[r0,#0]
0001a4  f4405080          ORR      r0,r0,#0x1000
0001a8  8008              STRH     r0,[r1,#0]
;;;118    	TIM4->CCMR1 |= (TIM_CCMR1_IC1F & (3uL << 4 ));
0001aa  4898              LDR      r0,|L1.1036|
0001ac  3018              ADDS     r0,r0,#0x18
0001ae  8800              LDRH     r0,[r0,#0]
0001b0  f0400030          ORR      r0,r0,#0x30
0001b4  4995              LDR      r1,|L1.1036|
0001b6  3118              ADDS     r1,r1,#0x18
0001b8  8008              STRH     r0,[r1,#0]
;;;119    	TIM4->CCMR1 |= (TIM_CCMR1_IC2F & (3uL << 12));
0001ba  4608              MOV      r0,r1
0001bc  8800              LDRH     r0,[r0,#0]
0001be  f4405040          ORR      r0,r0,#0x3000
0001c2  8008              STRH     r0,[r1,#0]
;;;120    	
;;;121    	/* EXTI ENABLE*/
;;;122    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
0001c4  2000              MOVS     r0,#0
0001c6  f88d0004          STRB     r0,[sp,#4]
;;;123    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
0001ca  2008              MOVS     r0,#8
0001cc  f88d0005          STRB     r0,[sp,#5]
;;;124    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0001d0  2001              MOVS     r0,#1
0001d2  f88d0006          STRB     r0,[sp,#6]
;;;125    	EXTI_InitStructure.EXTI_Line = EXTI_Line3;
0001d6  2008              MOVS     r0,#8
0001d8  9000              STR      r0,[sp,#0]
;;;126    	EXTI_Init(&EXTI_InitStructure);
0001da  4668              MOV      r0,sp
0001dc  f7fffffe          BL       EXTI_Init
;;;127    	EXTI_InitStructure.EXTI_Line = EXTI_Line14;
0001e0  f44f4080          MOV      r0,#0x4000
0001e4  9000              STR      r0,[sp,#0]
;;;128    	EXTI_Init(&EXTI_InitStructure);
0001e6  4668              MOV      r0,sp
0001e8  f7fffffe          BL       EXTI_Init
;;;129    	EXTI_ClearFlag(EXTI_Line3);
0001ec  2008              MOVS     r0,#8
0001ee  f7fffffe          BL       EXTI_ClearFlag
;;;130    	EXTI_ClearFlag(EXTI_Line14);
0001f2  f44f4080          MOV      r0,#0x4000
0001f6  f7fffffe          BL       EXTI_ClearFlag
;;;131    	NVIC_SetPriority(EXTI3_IRQn, ZPM1_RPIO);
0001fa  2102              MOVS     r1,#2
0001fc  2009              MOVS     r0,#9
0001fe  f7fffffe          BL       NVIC_SetPriority
;;;132    	NVIC_SetPriority(EXTI15_10_IRQn, ZPM2_PRIO);
000202  2103              MOVS     r1,#3
000204  2028              MOVS     r0,#0x28
000206  f7fffffe          BL       NVIC_SetPriority
;;;133    	NVIC_EnableIRQ(EXTI3_IRQn);
00020a  2009              MOVS     r0,#9
00020c  f7fffffe          BL       NVIC_EnableIRQ
;;;134    	NVIC_EnableIRQ(EXTI15_10_IRQn);
000210  2028              MOVS     r0,#0x28
000212  f7fffffe          BL       NVIC_EnableIRQ
;;;135    	
;;;136    	TIM_Cmd(TIM2, ENABLE);
000216  2101              MOVS     r1,#1
000218  0788              LSLS     r0,r1,#30
00021a  f7fffffe          BL       TIM_Cmd
;;;137    	TIM_Cmd(TIM3, ENABLE);
00021e  2101              MOVS     r1,#1
000220  4879              LDR      r0,|L1.1032|
000222  f7fffffe          BL       TIM_Cmd
;;;138    	TIM_Cmd(TIM4, ENABLE);
000226  2101              MOVS     r1,#1
000228  4878              LDR      r0,|L1.1036|
00022a  f7fffffe          BL       TIM_Cmd
;;;139    	TIM_Cmd(TIM5, ENABLE);
00022e  2101              MOVS     r1,#1
000230  4877              LDR      r0,|L1.1040|
000232  f7fffffe          BL       TIM_Cmd
;;;140    	TIM2->CNT = 0;
000236  2000              MOVS     r0,#0
000238  f04f4180          MOV      r1,#0x40000000
00023c  6248              STR      r0,[r1,#0x24]
;;;141    	TIM3->CNT = 0;
00023e  4972              LDR      r1,|L1.1032|
000240  3124              ADDS     r1,r1,#0x24
000242  6008              STR      r0,[r1,#0]
;;;142    	TIM4->CNT = 0;
000244  4971              LDR      r1,|L1.1036|
000246  3124              ADDS     r1,r1,#0x24
000248  6008              STR      r0,[r1,#0]
;;;143    	TIM5->CNT = 0;
00024a  4971              LDR      r1,|L1.1040|
00024c  3124              ADDS     r1,r1,#0x24
00024e  6008              STR      r0,[r1,#0]
;;;144    }
000250  b007              ADD      sp,sp,#0x1c
000252  bd00              POP      {pc}
;;;145    
                          ENDP

                  laser_rec_trypost PROC
;;;146    void laser_rec_trypost(void)
000254  b510              PUSH     {r4,lr}
;;;147    {
;;;148    	sys_mbox_trypost(&laserReceiveQue,NULL);//释放一个消息
000256  2100              MOVS     r1,#0
000258  486e              LDR      r0,|L1.1044|
00025a  f7fffffe          BL       sys_mbox_trypost
;;;149    }
00025e  bd10              POP      {r4,pc}
;;;150    
                          ENDP

                  laser_rec_fetch PROC
;;;151    void laser_rec_fetch(void)
000260  b510              PUSH     {r4,lr}
;;;152    {
;;;153    	sys_arch_mbox_fetch(&laserReceiveQue,NULL,10);//等待消息邮箱
000262  220a              MOVS     r2,#0xa
000264  2100              MOVS     r1,#0
000266  486b              LDR      r0,|L1.1044|
000268  f7fffffe          BL       sys_arch_mbox_fetch
;;;154    }
00026c  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  getCurTime PROC
;;;156    //获取系统的当前的时间ptp的时间寄存器中得到相应的时间信息
;;;157    void getCurTime(struct ptptime_t *time)
00026e  b510              PUSH     {r4,lr}
;;;158    {
000270  4604              MOV      r4,r0
;;;159    	ETH_PTPTime_GetTime(time);//获取当前模块的时间
000272  4620              MOV      r0,r4
000274  f7fffffe          BL       ETH_PTPTime_GetTime
;;;160    }
000278  bd10              POP      {r4,pc}
;;;161    
                          ENDP

                  getInputTime PROC
;;;162    //直接从接受的pbuf中的时间戳拷贝到时间戳的标记中
;;;163    void getInputTime(struct pbuf *p,struct ptptime_t *time)
00027a  6902              LDR      r2,[r0,#0x10]
;;;164    {
;;;165    	time->tv_sec= p->time_sec;
00027c  600a              STR      r2,[r1,#0]
;;;166    	time->tv_nsec = p->time_nsec;
00027e  6942              LDR      r2,[r0,#0x14]
000280  604a              STR      r2,[r1,#4]
;;;167    }
000282  4770              BX       lr
;;;168    
                          ENDP

                  udplaser_callback PROC
;;;183    ***************************************************************************/
;;;184    void udplaser_callback(void *arg,struct udp_pcb *pcb,struct pbuf *p,
000284  e92d47f0          PUSH     {r4-r10,lr}
;;;185    	ip_addr_t *addr,u16_t port)
;;;186    {
000288  4605              MOV      r5,r0
00028a  4689              MOV      r9,r1
00028c  4616              MOV      r6,r2
00028e  461f              MOV      r7,r3
000290  f8dd8020          LDR      r8,[sp,#0x20]
;;;187    	struct net_path *netpath = (struct net_path *)arg;
000294  462c              MOV      r4,r5
;;;188    	//printf("udplaser_callback function is called!\n");
;;;189    	if(((netpath->tail+1)&(laserbufsize-1))!=netpath->front)
000296  7920              LDRB     r0,[r4,#4]
000298  1c40              ADDS     r0,r0,#1
00029a  f0000007          AND      r0,r0,#7
00029e  6821              LDR      r1,[r4,#0]
0002a0  4288              CMP      r0,r1
0002a2  d017              BEQ      |L1.724|
;;;190    	{
;;;191    		if(p->tot_len<=30)
0002a4  8930              LDRH     r0,[r6,#8]
0002a6  281e              CMP      r0,#0x1e
0002a8  dc03              BGT      |L1.690|
;;;192    		{//获取电脑主机的ip地址
;;;193    			netpath->remoteport = port;
0002aa  f8a4802e          STRH     r8,[r4,#0x2e]
;;;194    			netpath->remoteip_addr = *addr;
0002ae  6838              LDR      r0,[r7,#0]
0002b0  6360              STR      r0,[r4,#0x34]
                  |L1.690|
;;;195    		}
;;;196    		netpath->pbufque[netpath->tail] = p;
0002b2  f1040008          ADD      r0,r4,#8
0002b6  6861              LDR      r1,[r4,#4]
0002b8  f8406021          STR      r6,[r0,r1,LSL #2]
;;;197    		sys_mutex_lock(&(netpath->bufmutex));
0002bc  3030              ADDS     r0,r0,#0x30
0002be  f7fffffe          BL       sys_mutex_lock
;;;198    		netpath->tail = (netpath->tail+1)&(laserbufsize-1);
0002c2  7920              LDRB     r0,[r4,#4]
0002c4  1c40              ADDS     r0,r0,#1
0002c6  f0000007          AND      r0,r0,#7
0002ca  6060              STR      r0,[r4,#4]
;;;199    		sys_mutex_unlock(&(netpath->bufmutex));
0002cc  f1040038          ADD      r0,r4,#0x38
0002d0  f7fffffe          BL       sys_mutex_unlock
                  |L1.724|
;;;200    	}
;;;201    	laser_rec_trypost();//sys_mbox_trypost(&laserReceiveQue,NULL);//释放一个消息
0002d4  f7fffffe          BL       laser_rec_trypost
;;;202    }
0002d8  e8bd87f0          POP      {r4-r10,pc}
;;;203    
                          ENDP

                  headProcess PROC
;;;239    *****************************************************************/
;;;240    void headProcess(struct pbuf *p,struct net_path *netpath)
0002dc  b530              PUSH     {r4,r5,lr}
;;;241    {
0002de  4602              MOV      r2,r0
0002e0  460b              MOV      r3,r1
;;;242    	static int16_t time4_cnt = 0;
;;;243    	int16_t curcnt;
;;;244    	if(p->tot_len>60)
0002e2  8910              LDRH     r0,[r2,#8]
0002e4  283c              CMP      r0,#0x3c
0002e6  dd30              BLE      |L1.842|
;;;245    	{
;;;246    		//时间戳信息
;;;247    		char *pdata = p->payload;
0002e8  6850              LDR      r0,[r2,#4]
;;;248    		pdata+=22;
0002ea  3016              ADDS     r0,r0,#0x16
;;;249    		*(int *)pdata = p->time_sec;
0002ec  6914              LDR      r4,[r2,#0x10]
0002ee  6004              STR      r4,[r0,#0]
;;;250    		pdata+=4;
0002f0  1d00              ADDS     r0,r0,#4
;;;251    		*(int *)pdata = p->time_nsec;
0002f2  6954              LDR      r4,[r2,#0x14]
0002f4  6004              STR      r4,[r0,#0]
;;;252    		
;;;253    		curcnt=(int16_t)TIM4->CNT-time4_cnt;
0002f6  4c45              LDR      r4,|L1.1036|
0002f8  3424              ADDS     r4,r4,#0x24
0002fa  6824              LDR      r4,[r4,#0]
0002fc  4d46              LDR      r5,|L1.1048|
0002fe  882d              LDRH     r5,[r5,#0]  ; time4_cnt
000300  1b64              SUBS     r4,r4,r5
000302  b221              SXTH     r1,r4
;;;254    		curPluseCnt+=curcnt;
000304  4c45              LDR      r4,|L1.1052|
000306  6824              LDR      r4,[r4,#0]  ; curPluseCnt
000308  440c              ADD      r4,r4,r1
00030a  4d44              LDR      r5,|L1.1052|
00030c  602c              STR      r4,[r5,#0]  ; curPluseCnt
;;;255    		time4_cnt = (int16_t)TIM4->CNT;
00030e  4c3f              LDR      r4,|L1.1036|
000310  3424              ADDS     r4,r4,#0x24
000312  6824              LDR      r4,[r4,#0]
000314  b224              SXTH     r4,r4
000316  4d40              LDR      r5,|L1.1048|
000318  802c              STRH     r4,[r5,#0]
;;;256    		//旋转平台转动的脉冲数
;;;257    		if(!initSystem)
00031a  4c41              LDR      r4,|L1.1056|
00031c  7824              LDRB     r4,[r4,#0]  ; initSystem
00031e  b934              CBNZ     r4,|L1.814|
;;;258    		{
;;;259    			initSystem = true;
000320  2401              MOVS     r4,#1
000322  4d3f              LDR      r5,|L1.1056|
000324  702c              STRB     r4,[r5,#0]
;;;260    			lastPluseCnt = curPluseCnt;
000326  4c3d              LDR      r4,|L1.1052|
000328  6824              LDR      r4,[r4,#0]  ; curPluseCnt
00032a  4d3e              LDR      r5,|L1.1060|
00032c  602c              STR      r4,[r5,#0]  ; lastPluseCnt
                  |L1.814|
;;;261    		}
;;;262    		
;;;263    		pdata = p->payload;
00032e  6850              LDR      r0,[r2,#4]
;;;264    		pdata+=52;
000330  3034              ADDS     r0,r0,#0x34
;;;265    		*(int *)pdata = lastPluseCnt;
000332  4c3c              LDR      r4,|L1.1060|
000334  6824              LDR      r4,[r4,#0]  ; lastPluseCnt
000336  6004              STR      r4,[r0,#0]
;;;266    		pdata+=4;
000338  1d00              ADDS     r0,r0,#4
;;;267    		*(int *)pdata = curPluseCnt;
00033a  4c38              LDR      r4,|L1.1052|
00033c  6824              LDR      r4,[r4,#0]  ; curPluseCnt
00033e  6004              STR      r4,[r0,#0]
;;;268    		lastPluseCnt = curPluseCnt;
000340  4c36              LDR      r4,|L1.1052|
000342  6824              LDR      r4,[r4,#0]  ; curPluseCnt
000344  4d37              LDR      r5,|L1.1060|
000346  602c              STR      r4,[r5,#0]  ; lastPluseCnt
;;;269    	}
000348  bf00              NOP      
                  |L1.842|
;;;270    }
00034a  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

                  cmdackpacket PROC
;;;272    //处理应答从的报文
;;;273    void cmdackpacket(struct pbuf *p,struct net_path *netpath)
00034c  b5f8              PUSH     {r3-r7,lr}
;;;274    {
00034e  4606              MOV      r6,r0
000350  460c              MOV      r4,r1
;;;275    	struct msg_head recv_msg;
;;;276    	uint8_t recv_msg_type;
;;;277    	/* Get the udp datagram head */
;;;278    	pbuf_copy_partial(p, &recv_msg, sizeof(recv_msg),0);
000352  2300              MOVS     r3,#0
000354  2204              MOVS     r2,#4
000356  4669              MOV      r1,sp
000358  4630              MOV      r0,r6
00035a  f7fffffe          BL       pbuf_copy_partial
;;;279    	recv_msg_type = recv_msg.msg_type;
00035e  f89d5002          LDRB     r5,[sp,#2]
;;;280    	if(recv_msg_type<MAX_MSG_HANDLER)
000362  2d08              CMP      r5,#8
000364  da03              BGE      |L1.878|
;;;281    		recv_msg.type_dscr = MSG_ACK;
000366  20ff              MOVS     r0,#0xff
000368  f88d0003          STRB     r0,[sp,#3]
00036c  e018              B        |L1.928|
                  |L1.878|
;;;282    	else
;;;283    	{
;;;284    		if(recv_msg_type==HAND_SHAKE)
00036e  2d3f              CMP      r5,#0x3f
000370  d106              BNE      |L1.896|
;;;285    		{
;;;286    			recv_msg.type_dscr = MSG_ACK;
000372  20ff              MOVS     r0,#0xff
000374  f88d0003          STRB     r0,[sp,#3]
;;;287    			sys_sta.hostready=TRUE;
000378  2001              MOVS     r0,#1
00037a  492b              LDR      r1,|L1.1064|
00037c  7008              STRB     r0,[r1,#0]
00037e  e00b              B        |L1.920|
                  |L1.896|
;;;288    		}
;;;289    		else if(recv_msg_type==END_TRANS)
000380  2d1f              CMP      r5,#0x1f
000382  d106              BNE      |L1.914|
;;;290    		{
;;;291    			recv_msg.type_dscr = MSG_ACK;
000384  20ff              MOVS     r0,#0xff
000386  f88d0003          STRB     r0,[sp,#3]
;;;292    			sys_sta.hostready = FALSE;
00038a  2000              MOVS     r0,#0
00038c  4926              LDR      r1,|L1.1064|
00038e  7008              STRB     r0,[r1,#0]
000390  e002              B        |L1.920|
                  |L1.914|
;;;293    		}
;;;294    		else
;;;295    			recv_msg.type_dscr = MSG_ERR;
000392  206a              MOVS     r0,#0x6a
000394  f88d0003          STRB     r0,[sp,#3]
                  |L1.920|
;;;296    		recv_msg_type = MAX_MSG_HANDLER-1;
000398  2507              MOVS     r5,#7
;;;297    		initSystem = false;
00039a  2000              MOVS     r0,#0
00039c  4920              LDR      r1,|L1.1056|
00039e  7008              STRB     r0,[r1,#0]
                  |L1.928|
;;;298    	}
;;;299    	pbuf_take(p,&recv_msg,sizeof(recv_msg));
0003a0  2204              MOVS     r2,#4
0003a2  4669              MOV      r1,sp
0003a4  4630              MOV      r0,r6
0003a6  f7fffffe          BL       pbuf_take
;;;300    	/* Reply */
;;;301    	udp_sendto(netpath->udppcb,p,&(netpath->remoteip_addr),netpath->remoteport);
0003aa  8de3              LDRH     r3,[r4,#0x2e]
0003ac  f1040234          ADD      r2,r4,#0x34
0003b0  4631              MOV      r1,r6
0003b2  6aa0              LDR      r0,[r4,#0x28]
0003b4  f7fffffe          BL       udp_sendto
;;;302    }
0003b8  bdf8              POP      {r3-r7,pc}
;;;303    
                          ENDP

                  laserPointCloudForward_thread PROC
;;;304    //定义一个点云数据的转发的线程
;;;305    void laserPointCloudForward_thread(void *msg)
0003ba  b570              PUSH     {r4-r6,lr}
;;;306    {
0003bc  b094              SUB      sp,sp,#0x50
0003be  4606              MOV      r6,r0
;;;307    	struct net_path netpath;
;;;308    	err_t error;
;;;309    	struct pbuf *p;
;;;310    	
;;;311    	QEPInit();
0003c0  f7fffffe          BL       QEPInit
;;;312    	
;;;313    	netpath.udppcb = udp_new();
0003c4  f7fffffe          BL       udp_new
0003c8  900a              STR      r0,[sp,#0x28]
;;;314    	netpath.front = netpath.tail = 0;
0003ca  2000              MOVS     r0,#0
0003cc  9001              STR      r0,[sp,#4]
0003ce  9000              STR      r0,[sp,#0]
;;;315    	netpath.remoteport =  hostport;
0003d0  f641704a          MOV      r0,#0x1f4a
0003d4  f8ad002e          STRH     r0,[sp,#0x2e]
;;;316    	netpath.localport = laserlocalport;
0003d8  f8ad002c          STRH     r0,[sp,#0x2c]
;;;317    	//IP4_ADDR(&netpath.remoteip_addr,hostip_addr0,hostip_addr1,hostip_addr2,hostip_addr3);
;;;318    	IP4_ADDR(&netpath.remoteip_addr,192,168,1,101);
0003dc  4813              LDR      r0,|L1.1068|
0003de  900d              STR      r0,[sp,#0x34]
;;;319    	IP4_ADDR(&netpath.localip_addr,192,168,1,10);
0003e0  4813              LDR      r0,|L1.1072|
0003e2  900c              STR      r0,[sp,#0x30]
;;;320    	
;;;321    	error = sys_mutex_new(&(netpath.bufmutex));
0003e4  a80e              ADD      r0,sp,#0x38
0003e6  f7fffffe          BL       sys_mutex_new
0003ea  4605              MOV      r5,r0
;;;322    	if(error!=ERR_OK)
0003ec  b395              CBZ      r5,|L1.1108|
;;;323    	{
;;;324    		printf("create netpath.bufmutex fail!");
0003ee  a011              ADR      r0,|L1.1076|
0003f0  f7fffffe          BL       __2printf
;;;325    		return;
;;;326    	}
;;;327    	
;;;328    	if(netpath.udppcb==NULL)
;;;329    	{
;;;330    		printf("create udp_pcb fail!");
;;;331    		return;
;;;332    	}
;;;333    	//回调函数的注册
;;;334    	udp_recv(netpath.udppcb,udplaser_callback,&netpath);
;;;335    	//端口号的绑定
;;;336    	udp_bind(netpath.udppcb,IP_ADDR_ANY,laserlocalport);
;;;337    	for(;;)
;;;338    	{
;;;339    		while(netpath.front!=netpath.tail)
;;;340    		{
;;;341    			p = netpath.pbufque[netpath.front];
;;;342    			if(p->tot_len<30)
;;;343    			{//来自上位机的应答的程序
;;;344    				cmdackpacket(p,&netpath);
;;;345    			}
;;;346    			else if(p->tot_len>30&&sys_sta.hostready==TRUE)
;;;347    			{//激光点云的数据
;;;348    				headProcess(p,&netpath);
;;;349    				udp_sendto(netpath.udppcb,p,&(netpath.remoteip_addr),netpath.remoteport);
;;;350    			}
;;;351    			pbuf_free(p);
;;;352    			sys_mutex_lock(&(netpath.bufmutex));
;;;353    			netpath.front = (netpath.front+1)&(laserbufsize-1);
;;;354    			sys_mutex_unlock(&(netpath.bufmutex));
;;;355    		}
;;;356    		laser_rec_fetch();
;;;357    	}
;;;358    }
0003f4  b014              ADD      sp,sp,#0x50
0003f6  bd70              POP      {r4-r6,pc}
                  |L1.1016|
                          DCD      0xe000ed18
                  |L1.1020|
                          DCD      0xe000e400
                  |L1.1024|
                          DCD      0x40020400
                  |L1.1028|
                          DCD      0x40020c00
                  |L1.1032|
                          DCD      0x40000400
                  |L1.1036|
                          DCD      0x40000800
                  |L1.1040|
                          DCD      0x40000c00
                  |L1.1044|
                          DCD      laserReceiveQue
                  |L1.1048|
                          DCD      time4_cnt
                  |L1.1052|
                          DCD      curPluseCnt
                  |L1.1056|
                          DCD      initSystem
                  |L1.1060|
                          DCD      lastPluseCnt
                  |L1.1064|
                          DCD      sys_sta
                  |L1.1068|
                          DCD      0x6501a8c0
                  |L1.1072|
                          DCD      0x0a01a8c0
                  |L1.1076|
000434  63726561          DCB      "create netpath.bufmutex fail!",0
000438  7465206e
00043c  65747061
000440  74682e62
000444  75666d75
000448  74657820
00044c  6661696c
000450  2100    
000452  00                DCB      0
000453  00                DCB      0
                  |L1.1108|
000454  e7ff              B        |L1.1110|
                  |L1.1110|
000456  980a              LDR      r0,[sp,#0x28]         ;328
000458  b920              CBNZ     r0,|L1.1124|
00045a  a033              ADR      r0,|L1.1320|
00045c  f7fffffe          BL       __2printf
000460  b014              ADD      sp,sp,#0x50
000462  bd70              POP      {r4-r6,pc}
                  |L1.1124|
000464  466a              MOV      r2,sp                 ;334
000466  f2af11e3          ADR      r1,udplaser_callback + 1
00046a  980a              LDR      r0,[sp,#0x28]         ;334
00046c  f7fffffe          BL       udp_recv
000470  f641724a          MOV      r2,#0x1f4a            ;336
000474  4932              LDR      r1,|L1.1344|
000476  980a              LDR      r0,[sp,#0x28]         ;336
000478  f7fffffe          BL       udp_bind
00047c  bf00              NOP                            ;337
                  |L1.1150|
00047e  e02b              B        |L1.1240|
                  |L1.1152|
000480  a802              ADD      r0,sp,#8              ;341
000482  9900              LDR      r1,[sp,#0]            ;341
000484  f8504021          LDR      r4,[r0,r1,LSL #2]     ;341
000488  8920              LDRH     r0,[r4,#8]            ;342
00048a  281e              CMP      r0,#0x1e              ;342
00048c  da04              BGE      |L1.1176|
00048e  4669              MOV      r1,sp                 ;344
000490  4620              MOV      r0,r4                 ;344
000492  f7fffffe          BL       cmdackpacket
000496  e011              B        |L1.1212|
                  |L1.1176|
000498  8920              LDRH     r0,[r4,#8]            ;346
00049a  281e              CMP      r0,#0x1e              ;346
00049c  dd0e              BLE      |L1.1212|
00049e  4829              LDR      r0,|L1.1348|
0004a0  7800              LDRB     r0,[r0,#0]            ;346  ; sys_sta
0004a2  2801              CMP      r0,#1                 ;346
0004a4  d10a              BNE      |L1.1212|
0004a6  4669              MOV      r1,sp                 ;348
0004a8  4620              MOV      r0,r4                 ;348
0004aa  f7fffffe          BL       headProcess
0004ae  f8bd302e          LDRH     r3,[sp,#0x2e]         ;349
0004b2  aa0d              ADD      r2,sp,#0x34           ;349
0004b4  4621              MOV      r1,r4                 ;349
0004b6  980a              LDR      r0,[sp,#0x28]         ;349
0004b8  f7fffffe          BL       udp_sendto
                  |L1.1212|
0004bc  4620              MOV      r0,r4                 ;351
0004be  f7fffffe          BL       pbuf_free
0004c2  a80e              ADD      r0,sp,#0x38           ;352
0004c4  f7fffffe          BL       sys_mutex_lock
0004c8  9800              LDR      r0,[sp,#0]            ;353
0004ca  1c40              ADDS     r0,r0,#1              ;353
0004cc  f0000007          AND      r0,r0,#7              ;353
0004d0  9000              STR      r0,[sp,#0]            ;353
0004d2  a80e              ADD      r0,sp,#0x38           ;354
0004d4  f7fffffe          BL       sys_mutex_unlock
                  |L1.1240|
0004d8  e9dd0100          LDRD     r0,r1,[sp,#0]         ;339
0004dc  4288              CMP      r0,r1                 ;339
0004de  d1cf              BNE      |L1.1152|
0004e0  f7fffffe          BL       laser_rec_fetch
0004e4  e7cb              B        |L1.1150|
;;;359    
                          ENDP

                  laserCloud_Init PROC
;;;360    void laserCloud_Init(void)
0004e6  b508              PUSH     {r3,lr}
;;;361    {
;;;362    	//创建消息的接收的邮箱，用于接收消息的传递
;;;363    	if(sys_mbox_new(&laserReceiveQue,10)!=ERR_OK)
0004e8  210a              MOVS     r1,#0xa
0004ea  4817              LDR      r0,|L1.1352|
0004ec  f7fffffe          BL       sys_mbox_new
0004f0  b118              CBZ      r0,|L1.1274|
;;;364    	{
;;;365    		printf("create laserReceiveQue is fail!!!\n");
0004f2  a016              ADR      r0,|L1.1356|
0004f4  f7fffffe          BL       __2printf
                  |L1.1272|
;;;366    		return;
;;;367    	}
;;;368    	sys_thread_new("laserPointCloudForward_thread",laserPointCloudForward_thread,NULL,DEFAULT_THREAD_STACKSIZE*2,osPriorityAboveNormal);//创建线程
;;;369    }
0004f8  bd08              POP      {r3,pc}
                  |L1.1274|
0004fa  2001              MOVS     r0,#1                 ;368
0004fc  02c3              LSLS     r3,r0,#11             ;368
0004fe  2200              MOVS     r2,#0                 ;368
000500  f2af1149          ADR      r1,laserPointCloudForward_thread + 1
000504  9000              STR      r0,[sp,#0]            ;368
000506  a01a              ADR      r0,|L1.1392|
000508  f7fffffe          BL       sys_thread_new
00050c  bf00              NOP      
00050e  e7f3              B        |L1.1272|
                          ENDP

                  NVIC_EnableIRQ PROC
;;;1070    */
;;;1071   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000510  f000021f          AND      r2,r0,#0x1f
;;;1072   {
;;;1073   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1074     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000514  2101              MOVS     r1,#1
000516  4091              LSLS     r1,r1,r2
000518  0942              LSRS     r2,r0,#5
00051a  0092              LSLS     r2,r2,#2
00051c  f10222e0          ADD      r2,r2,#0xe000e000
000520  f8c21100          STR      r1,[r2,#0x100]
;;;1075   }
000524  4770              BX       lr
;;;1076   
                          ENDP

000526  0000              DCW      0x0000
                  |L1.1320|
000528  63726561          DCB      "create udp_pcb fail!",0
00052c  74652075
000530  64705f70
000534  63622066
000538  61696c21
00053c  00      
00053d  00                DCB      0
00053e  00                DCB      0
00053f  00                DCB      0
                  |L1.1344|
                          DCD      ip_addr_any
                  |L1.1348|
                          DCD      sys_sta
                  |L1.1352|
                          DCD      laserReceiveQue
                  |L1.1356|
00054c  63726561          DCB      "create laserReceiveQue is fail!!!\n",0
000550  7465206c
000554  61736572
000558  52656365
00055c  69766551
000560  75652069
000564  73206661
000568  696c2121
00056c  210a00  
00056f  00                DCB      0
                  |L1.1392|
000570  6c617365          DCB      "laserPointCloudForward_thread",0
000574  72506f69
000578  6e74436c
00057c  6f756446
000580  6f727761
000584  72645f74
000588  68726561
00058c  6400    
00058e  00                DCB      0
00058f  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  laserReceiveQue
                          %        92

                          AREA ||.data||, DATA, ALIGN=2

                  sys_sta
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  lastPluseCnt
                          DCD      0x00000000
                  curPluseCnt
                          DCD      0x00000000
                  initSystem
00000c  0000              DCB      0x00,0x00
                  time4_cnt
00000e  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\src\\laserCloud.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_laserCloud_c_597916c2____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_laserCloud_c_597916c2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___12_laserCloud_c_597916c2____REVSH|
#line 128
|__asm___12_laserCloud_c_597916c2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
