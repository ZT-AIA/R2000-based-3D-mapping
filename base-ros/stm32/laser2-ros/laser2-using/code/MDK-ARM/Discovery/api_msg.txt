; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\api_msg.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\api_msg.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\api_msg.crf ..\..\libraries\lwip-1.4.1\src\api\api_msg.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  recv_raw PROC
;;;77     static u8_t
;;;78     recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;79         ip_addr_t *addr)
;;;80     {
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
;;;81       struct pbuf *q;
;;;82       struct netbuf *buf;
;;;83       struct netconn *conn;
;;;84     
;;;85       LWIP_UNUSED_ARG(addr);
;;;86       conn = (struct netconn *)arg;
00000c  463e              MOV      r6,r7
;;;87     
;;;88       if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
00000e  2e00              CMP      r6,#0
000010  d042              BEQ      |L1.152|
000012  69f0              LDR      r0,[r6,#0x1c]
000014  b108              CBZ      r0,|L1.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L1.28|
                  |L1.26|
00001a  2000              MOVS     r0,#0
                  |L1.28|
00001c  2800              CMP      r0,#0
00001e  d03b              BEQ      |L1.152|
;;;89     #if LWIP_SO_RCVBUF
;;;90         int recv_avail;
;;;91         SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;92         if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
;;;93           return 0;
;;;94         }
;;;95     #endif /* LWIP_SO_RCVBUF */
;;;96         /* copy the whole packet into new pbufs */
;;;97         q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
000020  f8b81008          LDRH     r1,[r8,#8]
000024  2200              MOVS     r2,#0
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       pbuf_alloc
00002c  4605              MOV      r5,r0
;;;98         if(q != NULL) {
00002e  b145              CBZ      r5,|L1.66|
;;;99           if (pbuf_copy(q, p) != ERR_OK) {
000030  4641              MOV      r1,r8
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       pbuf_copy
000038  b118              CBZ      r0,|L1.66|
;;;100            pbuf_free(q);
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       pbuf_free
;;;101            q = NULL;
000040  2500              MOVS     r5,#0
                  |L1.66|
;;;102          }
;;;103        }
;;;104    
;;;105        if (q != NULL) {
000042  b34d              CBZ      r5,|L1.152|
;;;106          u16_t len;
;;;107          buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
000044  2005              MOVS     r0,#5
000046  f7fffffe          BL       memp_malloc
00004a  4604              MOV      r4,r0
;;;108          if (buf == NULL) {
00004c  b92c              CBNZ     r4,|L1.90|
;;;109            pbuf_free(q);
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       pbuf_free
;;;110            return 0;
000054  2000              MOVS     r0,#0
                  |L1.86|
;;;111          }
;;;112    
;;;113          buf->p = q;
;;;114          buf->ptr = q;
;;;115          ip_addr_copy(buf->addr, *ip_current_src_addr());
;;;116          buf->port = pcb->protocol;
;;;117    
;;;118          len = q->tot_len;
;;;119          if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;120            netbuf_delete(buf);
;;;121            return 0;
;;;122          } else {
;;;123    #if LWIP_SO_RCVBUF
;;;124            SYS_ARCH_INC(conn->recv_avail, len);
;;;125    #endif /* LWIP_SO_RCVBUF */
;;;126            /* Register event with callback */
;;;127            API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;128          }
;;;129        }
;;;130      }
;;;131    
;;;132      return 0; /* do not eat the packet */
;;;133    }
000056  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.90|
00005a  6025              STR      r5,[r4,#0]            ;113
00005c  6065              STR      r5,[r4,#4]            ;114
00005e  48fe              LDR      r0,|L1.1112|
000060  6800              LDR      r0,[r0,#0]            ;115  ; current_iphdr_src
000062  60a0              STR      r0,[r4,#8]            ;115
000064  f8990010          LDRB     r0,[r9,#0x10]         ;116
000068  81a0              STRH     r0,[r4,#0xc]          ;116
00006a  f8b5a008          LDRH     r10,[r5,#8]           ;118
00006e  4621              MOV      r1,r4                 ;119
000070  f106001c          ADD      r0,r6,#0x1c           ;119
000074  f7fffffe          BL       sys_mbox_trypost
000078  b120              CBZ      r0,|L1.132|
00007a  4620              MOV      r0,r4                 ;120
00007c  f7fffffe          BL       netbuf_delete
000080  2000              MOVS     r0,#0                 ;121
000082  e7e8              B        |L1.86|
                  |L1.132|
000084  f8d600e4          LDR      r0,[r6,#0xe4]         ;127
000088  b128              CBZ      r0,|L1.150|
00008a  4652              MOV      r2,r10                ;127
00008c  2100              MOVS     r1,#0                 ;127
00008e  4630              MOV      r0,r6                 ;127
000090  f8d630e4          LDR      r3,[r6,#0xe4]         ;127
000094  4798              BLX      r3                    ;127
                  |L1.150|
000096  bf00              NOP                            ;129
                  |L1.152|
000098  2000              MOVS     r0,#0                 ;132
00009a  e7dc              B        |L1.86|
;;;134    #endif /* LWIP_RAW*/
                          ENDP

                  recv_udp PROC
;;;143    static void
;;;144    recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
00009c  e92d5ff0          PUSH     {r4-r12,lr}
;;;145       ip_addr_t *addr, u16_t port)
;;;146    {
0000a0  4680              MOV      r8,r0
0000a2  468b              MOV      r11,r1
0000a4  4616              MOV      r6,r2
0000a6  461f              MOV      r7,r3
0000a8  f8dda028          LDR      r10,[sp,#0x28]
;;;147      struct netbuf *buf;
;;;148      struct netconn *conn;
;;;149      u16_t len;
;;;150    #if LWIP_SO_RCVBUF
;;;151      int recv_avail;
;;;152    #endif /* LWIP_SO_RCVBUF */
;;;153    
;;;154      LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
;;;155      LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
0000ac  bf00              NOP      
0000ae  bf00              NOP      
;;;156      LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
0000b0  bf00              NOP      
0000b2  bf00              NOP      
;;;157      conn = (struct netconn *)arg;
0000b4  4645              MOV      r5,r8
;;;158      LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
0000b6  bf00              NOP      
0000b8  bf00              NOP      
;;;159    
;;;160    #if LWIP_SO_RCVBUF
;;;161      SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;162      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
;;;163          ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
;;;164    #else  /* LWIP_SO_RCVBUF */
;;;165      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
0000ba  b12d              CBZ      r5,|L1.200|
0000bc  69e8              LDR      r0,[r5,#0x1c]
0000be  b108              CBZ      r0,|L1.196|
0000c0  2001              MOVS     r0,#1
0000c2  e000              B        |L1.198|
                  |L1.196|
0000c4  2000              MOVS     r0,#0
                  |L1.198|
0000c6  b920              CBNZ     r0,|L1.210|
                  |L1.200|
;;;166    #endif /* LWIP_SO_RCVBUF */
;;;167        pbuf_free(p);
0000c8  4630              MOV      r0,r6
0000ca  f7fffffe          BL       pbuf_free
                  |L1.206|
;;;168        return;
;;;169      }
;;;170    
;;;171      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
;;;172      if (buf == NULL) {
;;;173        pbuf_free(p);
;;;174        return;
;;;175      } else {
;;;176        buf->p = p;
;;;177        buf->ptr = p;
;;;178        ip_addr_set(&buf->addr, addr);
;;;179        buf->port = port;
;;;180    #if LWIP_NETBUF_RECVINFO
;;;181        {
;;;182          const struct ip_hdr* iphdr = ip_current_header();
;;;183          /* get the UDP header - always in the first pbuf, ensured by udp_input */
;;;184          const struct udp_hdr* udphdr = (void*)(((char*)iphdr) + IPH_LEN(iphdr));
;;;185    #if LWIP_CHECKSUM_ON_COPY
;;;186          buf->flags = NETBUF_FLAG_DESTADDR;
;;;187    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;188          ip_addr_set(&buf->toaddr, ip_current_dest_addr());
;;;189          buf->toport_chksum = udphdr->dest;
;;;190        }
;;;191    #endif /* LWIP_NETBUF_RECVINFO */
;;;192      }
;;;193    
;;;194      len = p->tot_len;
;;;195      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;196        netbuf_delete(buf);
;;;197        return;
;;;198      } else {
;;;199    #if LWIP_SO_RCVBUF
;;;200        SYS_ARCH_INC(conn->recv_avail, len);
;;;201    #endif /* LWIP_SO_RCVBUF */
;;;202        /* Register event with callback */
;;;203        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;204      }
;;;205    }
0000ce  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.210|
0000d2  2005              MOVS     r0,#5                 ;171
0000d4  f7fffffe          BL       memp_malloc
0000d8  4604              MOV      r4,r0                 ;171
0000da  b91c              CBNZ     r4,|L1.228|
0000dc  4630              MOV      r0,r6                 ;173
0000de  f7fffffe          BL       pbuf_free
0000e2  e7f4              B        |L1.206|
                  |L1.228|
0000e4  6026              STR      r6,[r4,#0]            ;176
0000e6  6066              STR      r6,[r4,#4]            ;177
0000e8  b90f              CBNZ     r7,|L1.238|
0000ea  2000              MOVS     r0,#0                 ;178
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  6838              LDR      r0,[r7,#0]            ;178
                  |L1.240|
0000f0  60a0              STR      r0,[r4,#8]            ;178
0000f2  f8a4a00c          STRH     r10,[r4,#0xc]         ;179
0000f6  f8b69008          LDRH     r9,[r6,#8]            ;194
0000fa  4621              MOV      r1,r4                 ;195
0000fc  f105001c          ADD      r0,r5,#0x1c           ;195
000100  f7fffffe          BL       sys_mbox_trypost
000104  b118              CBZ      r0,|L1.270|
000106  4620              MOV      r0,r4                 ;196
000108  f7fffffe          BL       netbuf_delete
00010c  e7df              B        |L1.206|
                  |L1.270|
00010e  f8d500e4          LDR      r0,[r5,#0xe4]         ;203
000112  b128              CBZ      r0,|L1.288|
000114  464a              MOV      r2,r9                 ;203
000116  2100              MOVS     r1,#0                 ;203
000118  4628              MOV      r0,r5                 ;203
00011a  f8d530e4          LDR      r3,[r5,#0xe4]         ;203
00011e  4798              BLX      r3                    ;203
                  |L1.288|
000120  bf00              NOP      
000122  e7d4              B        |L1.206|
;;;206    #endif /* LWIP_UDP */
                          ENDP

                  recv_tcp PROC
;;;215    static err_t
;;;216    recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000124  e92d47f0          PUSH     {r4-r10,lr}
;;;217    {
000128  4607              MOV      r7,r0
00012a  4688              MOV      r8,r1
00012c  4615              MOV      r5,r2
00012e  4699              MOV      r9,r3
;;;218      struct netconn *conn;
;;;219      u16_t len;
;;;220    
;;;221      LWIP_UNUSED_ARG(pcb);
;;;222      LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
000130  bf00              NOP      
000132  bf00              NOP      
;;;223      LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
000134  bf00              NOP      
000136  bf00              NOP      
;;;224      conn = (struct netconn *)arg;
000138  463c              MOV      r4,r7
;;;225      LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
00013a  bf00              NOP      
00013c  bf00              NOP      
;;;226    
;;;227      if (conn == NULL) {
00013e  b91c              CBNZ     r4,|L1.328|
;;;228        return ERR_VAL;
000140  f06f0005          MVN      r0,#5
                  |L1.324|
;;;229      }
;;;230      if (!sys_mbox_valid(&conn->recvmbox)) {
;;;231        /* recvmbox already deleted */
;;;232        if (p != NULL) {
;;;233          tcp_recved(pcb, p->tot_len);
;;;234          pbuf_free(p);
;;;235        }
;;;236        return ERR_OK;
;;;237      }
;;;238      /* Unlike for UDP or RAW pcbs, don't check for available space
;;;239         using recv_avail since that could break the connection
;;;240         (data is already ACKed) */
;;;241    
;;;242      /* don't overwrite fatal errors! */
;;;243      NETCONN_SET_SAFE_ERR(conn, err);
;;;244    
;;;245      if (p != NULL) {
;;;246        len = p->tot_len;
;;;247      } else {
;;;248        len = 0;
;;;249      }
;;;250    
;;;251      if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
;;;252        /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
;;;253        return ERR_MEM;
;;;254      } else {
;;;255    #if LWIP_SO_RCVBUF
;;;256        SYS_ARCH_INC(conn->recv_avail, len);
;;;257    #endif /* LWIP_SO_RCVBUF */
;;;258        /* Register event with callback */
;;;259        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;260      }
;;;261    
;;;262      return ERR_OK;
;;;263    }
000144  e8bd87f0          POP      {r4-r10,pc}
                  |L1.328|
000148  69e0              LDR      r0,[r4,#0x1c]         ;230
00014a  b108              CBZ      r0,|L1.336|
00014c  2001              MOVS     r0,#1                 ;230
00014e  e000              B        |L1.338|
                  |L1.336|
000150  2000              MOVS     r0,#0                 ;230
                  |L1.338|
000152  b948              CBNZ     r0,|L1.360|
000154  b135              CBZ      r5,|L1.356|
000156  8929              LDRH     r1,[r5,#8]            ;233
000158  4640              MOV      r0,r8                 ;233
00015a  f7fffffe          BL       tcp_recved
00015e  4628              MOV      r0,r5                 ;234
000160  f7fffffe          BL       pbuf_free
                  |L1.356|
000164  2000              MOVS     r0,#0                 ;236
000166  e7ed              B        |L1.324|
                  |L1.360|
000168  bf00              NOP                            ;243
00016a  f7fffffe          BL       sys_arch_protect
00016e  4682              MOV      r10,r0                ;243
000170  f9940008          LDRSB    r0,[r4,#8]            ;243
000174  f1100f09          CMN      r0,#9                 ;243
000178  db01              BLT      |L1.382|
00017a  f8849008          STRB     r9,[r4,#8]            ;243
                  |L1.382|
00017e  4650              MOV      r0,r10                ;243
000180  f7fffffe          BL       sys_arch_unprotect
000184  bf00              NOP                            ;243
000186  b10d              CBZ      r5,|L1.396|
000188  892e              LDRH     r6,[r5,#8]            ;246
00018a  e000              B        |L1.398|
                  |L1.396|
00018c  2600              MOVS     r6,#0                 ;248
                  |L1.398|
00018e  4629              MOV      r1,r5                 ;251
000190  f104001c          ADD      r0,r4,#0x1c           ;251
000194  f7fffffe          BL       sys_mbox_trypost
000198  b110              CBZ      r0,|L1.416|
00019a  f04f30ff          MOV      r0,#0xffffffff        ;253
00019e  e7d1              B        |L1.324|
                  |L1.416|
0001a0  f8d400e4          LDR      r0,[r4,#0xe4]         ;259
0001a4  b128              CBZ      r0,|L1.434|
0001a6  4632              MOV      r2,r6                 ;259
0001a8  2100              MOVS     r1,#0                 ;259
0001aa  4620              MOV      r0,r4                 ;259
0001ac  f8d430e4          LDR      r3,[r4,#0xe4]         ;259
0001b0  4798              BLX      r3                    ;259
                  |L1.434|
0001b2  2000              MOVS     r0,#0                 ;262
0001b4  e7c6              B        |L1.324|
;;;264    
                          ENDP

                  err_tcp PROC
;;;346    static void
;;;347    err_tcp(void *arg, err_t err)
0001b6  e92d47f0          PUSH     {r4-r10,lr}
;;;348    {
0001ba  4607              MOV      r7,r0
0001bc  460e              MOV      r6,r1
;;;349      struct netconn *conn;
;;;350      enum netconn_state old_state;
;;;351      SYS_ARCH_DECL_PROTECT(lev);
;;;352    
;;;353      conn = (struct netconn *)arg;
0001be  463c              MOV      r4,r7
;;;354      LWIP_ASSERT("conn != NULL", (conn != NULL));
0001c0  bf00              NOP      
0001c2  bf00              NOP      
;;;355    
;;;356      conn->pcb.tcp = NULL;
0001c4  2000              MOVS     r0,#0
0001c6  6060              STR      r0,[r4,#4]
;;;357    
;;;358      /* no check since this is always fatal! */
;;;359      SYS_ARCH_PROTECT(lev);
0001c8  f7fffffe          BL       sys_arch_protect
0001cc  4681              MOV      r9,r0
;;;360      conn->last_err = err;
0001ce  7226              STRB     r6,[r4,#8]
;;;361      SYS_ARCH_UNPROTECT(lev);
0001d0  4648              MOV      r0,r9
0001d2  f7fffffe          BL       sys_arch_unprotect
;;;362    
;;;363      /* reset conn->state now before waking up other threads */
;;;364      old_state = conn->state;
0001d6  7865              LDRB     r5,[r4,#1]
;;;365      conn->state = NETCONN_NONE;
0001d8  2000              MOVS     r0,#0
0001da  7060              STRB     r0,[r4,#1]
;;;366    
;;;367      /* Notify the user layer about a connection error. Used to signal
;;;368         select. */
;;;369      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
0001dc  f8d400e4          LDR      r0,[r4,#0xe4]
0001e0  b128              CBZ      r0,|L1.494|
0001e2  2200              MOVS     r2,#0
0001e4  2104              MOVS     r1,#4
0001e6  4620              MOV      r0,r4
0001e8  f8d430e4          LDR      r3,[r4,#0xe4]
0001ec  4798              BLX      r3
                  |L1.494|
;;;370      /* Try to release selects pending on 'read' or 'write', too.
;;;371         They will get an error if they actually try to read or write. */
;;;372      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
0001ee  f8d400e4          LDR      r0,[r4,#0xe4]
0001f2  b128              CBZ      r0,|L1.512|
0001f4  2200              MOVS     r2,#0
0001f6  4611              MOV      r1,r2
0001f8  4620              MOV      r0,r4
0001fa  f8d430e4          LDR      r3,[r4,#0xe4]
0001fe  4798              BLX      r3
                  |L1.512|
;;;373      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
000200  f8d400e4          LDR      r0,[r4,#0xe4]
000204  b128              CBZ      r0,|L1.530|
000206  2200              MOVS     r2,#0
000208  2102              MOVS     r1,#2
00020a  4620              MOV      r0,r4
00020c  f8d430e4          LDR      r3,[r4,#0xe4]
000210  4798              BLX      r3
                  |L1.530|
;;;374    
;;;375      /* pass NULL-message to recvmbox to wake up pending recv */
;;;376      if (sys_mbox_valid(&conn->recvmbox)) {
000212  69e0              LDR      r0,[r4,#0x1c]
000214  b108              CBZ      r0,|L1.538|
000216  2001              MOVS     r0,#1
000218  e000              B        |L1.540|
                  |L1.538|
00021a  2000              MOVS     r0,#0
                  |L1.540|
00021c  b120              CBZ      r0,|L1.552|
;;;377        /* use trypost to prevent deadlock */
;;;378        sys_mbox_trypost(&conn->recvmbox, NULL);
00021e  2100              MOVS     r1,#0
000220  f104001c          ADD      r0,r4,#0x1c
000224  f7fffffe          BL       sys_mbox_trypost
                  |L1.552|
;;;379      }
;;;380      /* pass NULL-message to acceptmbox to wake up pending accept */
;;;381      if (sys_mbox_valid(&conn->acceptmbox)) {
000228  6fa0              LDR      r0,[r4,#0x78]
00022a  b108              CBZ      r0,|L1.560|
00022c  2001              MOVS     r0,#1
00022e  e000              B        |L1.562|
                  |L1.560|
000230  2000              MOVS     r0,#0
                  |L1.562|
000232  b120              CBZ      r0,|L1.574|
;;;382        /* use trypost to preven deadlock */
;;;383        sys_mbox_trypost(&conn->acceptmbox, NULL);
000234  2100              MOVS     r1,#0
000236  f1040078          ADD      r0,r4,#0x78
00023a  f7fffffe          BL       sys_mbox_trypost
                  |L1.574|
;;;384      }
;;;385    
;;;386      if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
00023e  2d01              CMP      r5,#1
000240  d003              BEQ      |L1.586|
000242  2d04              CMP      r5,#4
000244  d001              BEQ      |L1.586|
;;;387          (old_state == NETCONN_CONNECT)) {
000246  2d03              CMP      r5,#3
000248  d11b              BNE      |L1.642|
                  |L1.586|
;;;388        /* calling do_writemore/do_close_internal is not necessary
;;;389           since the pcb has already been deleted! */
;;;390        int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
00024a  f89400d8          LDRB     r0,[r4,#0xd8]
00024e  f3c00880          UBFX     r8,r0,#2,#1
;;;391        SET_NONBLOCKING_CONNECT(conn, 0);
000252  bf00              NOP      
000254  f89400d8          LDRB     r0,[r4,#0xd8]
000258  f0200004          BIC      r0,r0,#4
00025c  f88400d8          STRB     r0,[r4,#0xd8]
000260  bf00              NOP      
;;;392    
;;;393        if (!was_nonblocking_connect) {
000262  f1b80f00          CMP      r8,#0
000266  d10b              BNE      |L1.640|
;;;394          /* set error return code */
;;;395          LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
000268  bf00              NOP      
00026a  bf00              NOP      
;;;396          conn->current_msg->err = err;
00026c  f8d400e0          LDR      r0,[r4,#0xe0]
000270  7106              STRB     r6,[r0,#4]
;;;397          conn->current_msg = NULL;
000272  2000              MOVS     r0,#0
000274  f8c400e0          STR      r0,[r4,#0xe0]
;;;398          /* wake up the waiting task */
;;;399          sys_sem_signal(&conn->op_completed);
000278  f104000c          ADD      r0,r4,#0xc
00027c  f7fffffe          BL       sys_sem_signal
                  |L1.640|
;;;400        }
;;;401      } else {
000280  e001              B        |L1.646|
                  |L1.642|
;;;402        LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
000282  bf00              NOP      
000284  bf00              NOP      
                  |L1.646|
;;;403      }
;;;404    }
000286  e8bd87f0          POP      {r4-r10,pc}
;;;405    
                          ENDP

                  do_writemore PROC
;;;1207   static err_t
;;;1208   do_writemore(struct netconn *conn)
00028a  e92d4ff8          PUSH     {r3-r11,lr}
;;;1209   {
00028e  4604              MOV      r4,r0
;;;1210     err_t err;
;;;1211     void *dataptr;
;;;1212     u16_t len, available;
;;;1213     u8_t write_finished = 0;
000290  2000              MOVS     r0,#0
000292  9000              STR      r0,[sp,#0]
;;;1214     size_t diff;
;;;1215     u8_t dontblock = netconn_is_nonblocking(conn) ||
000294  f89400d8          LDRB     r0,[r4,#0xd8]
000298  f0000002          AND      r0,r0,#2
00029c  b928              CBNZ     r0,|L1.682|
;;;1216          (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
00029e  f8d400e0          LDR      r0,[r4,#0xe0]
0002a2  7c00              LDRB     r0,[r0,#0x10]
0002a4  f0000004          AND      r0,r0,#4
0002a8  b108              CBZ      r0,|L1.686|
                  |L1.682|
0002aa  2001              MOVS     r0,#1
0002ac  e000              B        |L1.688|
                  |L1.686|
0002ae  2000              MOVS     r0,#0
                  |L1.688|
0002b0  4607              MOV      r7,r0
;;;1217     u8_t apiflags = conn->current_msg->msg.w.apiflags;
0002b2  f8d400e0          LDR      r0,[r4,#0xe0]
0002b6  f8908010          LDRB     r8,[r0,#0x10]
;;;1218   
;;;1219     LWIP_ASSERT("conn != NULL", conn != NULL);
0002ba  bf00              NOP      
0002bc  bf00              NOP      
;;;1220     LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
0002be  bf00              NOP      
0002c0  bf00              NOP      
;;;1221     LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
0002c2  bf00              NOP      
0002c4  bf00              NOP      
;;;1222     LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
0002c6  bf00              NOP      
0002c8  bf00              NOP      
;;;1223     LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
0002ca  bf00              NOP      
0002cc  bf00              NOP      
;;;1224       conn->write_offset < conn->current_msg->msg.w.len);
;;;1225   
;;;1226   #if LWIP_SO_SNDTIMEO
;;;1227     if ((conn->send_timeout != 0) &&
;;;1228         ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
;;;1229       write_finished = 1;
;;;1230       if (conn->write_offset == 0) {
;;;1231         /* nothing has been written */
;;;1232         err = ERR_WOULDBLOCK;
;;;1233         conn->current_msg->msg.w.len = 0;
;;;1234       } else {
;;;1235         /* partial write */
;;;1236         err = ERR_OK;
;;;1237         conn->current_msg->msg.w.len = conn->write_offset;
;;;1238       }
;;;1239     } else
;;;1240   #endif /* LWIP_SO_SNDTIMEO */
;;;1241     {
;;;1242       dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
0002ce  34dc              ADDS     r4,r4,#0xdc
0002d0  6860              LDR      r0,[r4,#4]
0002d2  6880              LDR      r0,[r0,#8]
0002d4  6821              LDR      r1,[r4,#0]
0002d6  eb000b01          ADD      r11,r0,r1
;;;1243       diff = conn->current_msg->msg.w.len - conn->write_offset;
0002da  6860              LDR      r0,[r4,#4]
0002dc  68c0              LDR      r0,[r0,#0xc]
0002de  f85419dc          LDR      r1,[r4],#-0xdc
0002e2  eba00a01          SUB      r10,r0,r1
;;;1244       if (diff > 0xffffUL) { /* max_u16_t */
0002e6  f5ba3f80          CMP      r10,#0x10000
0002ea  d304              BCC      |L1.758|
;;;1245         len = 0xffff;
0002ec  f64f76ff          MOV      r6,#0xffff
;;;1246   #if LWIP_TCPIP_CORE_LOCKING
;;;1247         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1248   #endif
;;;1249         apiflags |= TCP_WRITE_FLAG_MORE;
0002f0  f0480802          ORR      r8,r8,#2
0002f4  e001              B        |L1.762|
                  |L1.758|
;;;1250       } else {
;;;1251         len = (u16_t)diff;
0002f6  fa1ff68a          UXTH     r6,r10
                  |L1.762|
;;;1252       }
;;;1253       available = tcp_sndbuf(conn->pcb.tcp);
0002fa  6860              LDR      r0,[r4,#4]
0002fc  f8b09066          LDRH     r9,[r0,#0x66]
;;;1254       if (available < len) {
000300  45b1              CMP      r9,r6
000302  da07              BGE      |L1.788|
;;;1255         /* don't try to write more than sendbuf */
;;;1256         len = available;
000304  464e              MOV      r6,r9
;;;1257         if (dontblock){ 
000306  b11f              CBZ      r7,|L1.784|
;;;1258           if (!len) {
000308  b926              CBNZ     r6,|L1.788|
;;;1259             err = ERR_WOULDBLOCK;
00030a  f06f0506          MVN      r5,#6
;;;1260             goto err_mem;
00030e  e00e              B        |L1.814|
                  |L1.784|
;;;1261           }
;;;1262         } else {
;;;1263   #if LWIP_TCPIP_CORE_LOCKING
;;;1264           conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1265   #endif
;;;1266           apiflags |= TCP_WRITE_FLAG_MORE;
000310  f0480802          ORR      r8,r8,#2
                  |L1.788|
;;;1267         }
;;;1268       }
;;;1269       LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
000314  bf00              NOP      
000316  bf00              NOP      
;;;1270       err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
000318  4643              MOV      r3,r8
00031a  4632              MOV      r2,r6
00031c  4659              MOV      r1,r11
00031e  6860              LDR      r0,[r4,#4]
000320  f7fffffe          BL       tcp_write
000324  4605              MOV      r5,r0
;;;1271       /* if OK or memory error, check available space */
;;;1272       if ((err == ERR_OK) || (err == ERR_MEM)) {
000326  b10d              CBZ      r5,|L1.812|
000328  1c68              ADDS     r0,r5,#1
00032a  bb58              CBNZ     r0,|L1.900|
                  |L1.812|
;;;1273   err_mem:
00032c  bf00              NOP      
                  |L1.814|
;;;1274         if (dontblock && (len < conn->current_msg->msg.w.len)) {
00032e  b1a7              CBZ      r7,|L1.858|
000330  f8d400e0          LDR      r0,[r4,#0xe0]
000334  68c0              LDR      r0,[r0,#0xc]
000336  42b0              CMP      r0,r6
000338  d90f              BLS      |L1.858|
;;;1275           /* non-blocking write did not write everything: mark the pcb non-writable
;;;1276              and let poll_tcp check writable space to mark the pcb writable again */
;;;1277           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
00033a  f8d400e4          LDR      r0,[r4,#0xe4]
00033e  b128              CBZ      r0,|L1.844|
000340  4632              MOV      r2,r6
000342  2103              MOVS     r1,#3
000344  4620              MOV      r0,r4
000346  f8d430e4          LDR      r3,[r4,#0xe4]
00034a  4798              BLX      r3
                  |L1.844|
;;;1278           conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
00034c  f89400d8          LDRB     r0,[r4,#0xd8]
000350  f0400010          ORR      r0,r0,#0x10
000354  f88400d8          STRB     r0,[r4,#0xd8]
000358  e014              B        |L1.900|
                  |L1.858|
;;;1279         } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
00035a  6860              LDR      r0,[r4,#4]
00035c  f8b00066          LDRH     r0,[r0,#0x66]
000360  f6403169          MOV      r1,#0xb69
000364  4288              CMP      r0,r1
000366  dd04              BLE      |L1.882|
;;;1280                    (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
000368  6860              LDR      r0,[r4,#4]
00036a  f8b00068          LDRH     r0,[r0,#0x68]
00036e  2805              CMP      r0,#5
000370  db08              BLT      |L1.900|
                  |L1.882|
;;;1281           /* The queued byte- or pbuf-count exceeds the configured low-water limit,
;;;1282              let select mark this pcb as non-writable. */
;;;1283           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
000372  f8d400e4          LDR      r0,[r4,#0xe4]
000376  b128              CBZ      r0,|L1.900|
000378  4632              MOV      r2,r6
00037a  2103              MOVS     r1,#3
00037c  4620              MOV      r0,r4
00037e  f8d430e4          LDR      r3,[r4,#0xe4]
000382  4798              BLX      r3
                  |L1.900|
;;;1284         }
;;;1285       }
;;;1286   
;;;1287       if (err == ERR_OK) {
000384  b9bd              CBNZ     r5,|L1.950|
;;;1288         conn->write_offset += len;
000386  f8540fdc          LDR      r0,[r4,#0xdc]!
00038a  4430              ADD      r0,r0,r6
00038c  6020              STR      r0,[r4,#0]
;;;1289         if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
00038e  e9d41000          LDRD     r1,r0,[r4,#0]
000392  3cdc              SUBS     r4,r4,#0xdc
000394  68c0              LDR      r0,[r0,#0xc]
000396  4281              CMP      r1,r0
000398  d000              BEQ      |L1.924|
00039a  b147              CBZ      r7,|L1.942|
                  |L1.924|
;;;1290           /* return sent length */
;;;1291           conn->current_msg->msg.w.len = conn->write_offset;
00039c  f8541fdc          LDR      r1,[r4,#0xdc]!
0003a0  6860              LDR      r0,[r4,#4]
0003a2  60c1              STR      r1,[r0,#0xc]
;;;1292           /* everything was written */
;;;1293           write_finished = 1;
0003a4  2001              MOVS     r0,#1
0003a6  9000              STR      r0,[sp,#0]
;;;1294           conn->write_offset = 0;
0003a8  2000              MOVS     r0,#0
0003aa  f84409dc          STR      r0,[r4],#-0xdc
                  |L1.942|
;;;1295         }
;;;1296         tcp_output(conn->pcb.tcp);
0003ae  6860              LDR      r0,[r4,#4]
0003b0  f7fffffe          BL       tcp_output
0003b4  e00c              B        |L1.976|
                  |L1.950|
;;;1297       } else if ((err == ERR_MEM) && !dontblock) {
0003b6  1c68              ADDS     r0,r5,#1
0003b8  b920              CBNZ     r0,|L1.964|
0003ba  b91f              CBNZ     r7,|L1.964|
;;;1298         /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
;;;1299            we do NOT return to the application thread, since ERR_MEM is
;;;1300            only a temporary error! */
;;;1301   
;;;1302         /* tcp_write returned ERR_MEM, try tcp_output anyway */
;;;1303         tcp_output(conn->pcb.tcp);
0003bc  6860              LDR      r0,[r4,#4]
0003be  f7fffffe          BL       tcp_output
0003c2  e005              B        |L1.976|
                  |L1.964|
;;;1304   
;;;1305   #if LWIP_TCPIP_CORE_LOCKING
;;;1306         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1307   #endif
;;;1308       } else {
;;;1309         /* On errors != ERR_MEM, we don't try writing any more but return
;;;1310            the error to the application thread. */
;;;1311         write_finished = 1;
0003c4  2001              MOVS     r0,#1
0003c6  9000              STR      r0,[sp,#0]
;;;1312         conn->current_msg->msg.w.len = 0;
0003c8  2100              MOVS     r1,#0
0003ca  f8d400e0          LDR      r0,[r4,#0xe0]
0003ce  60c1              STR      r1,[r0,#0xc]
                  |L1.976|
;;;1313       }
;;;1314     }
;;;1315     if (write_finished) {
0003d0  9800              LDR      r0,[sp,#0]
0003d2  b150              CBZ      r0,|L1.1002|
;;;1316       /* everything was written: set back connection state
;;;1317          and back to application task */
;;;1318       conn->current_msg->err = err;
0003d4  f8d400e0          LDR      r0,[r4,#0xe0]
0003d8  7105              STRB     r5,[r0,#4]
;;;1319       conn->current_msg = NULL;
0003da  2000              MOVS     r0,#0
0003dc  f8c400e0          STR      r0,[r4,#0xe0]
;;;1320       conn->state = NETCONN_NONE;
0003e0  7060              STRB     r0,[r4,#1]
;;;1321   #if LWIP_TCPIP_CORE_LOCKING
;;;1322       if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
;;;1323   #endif
;;;1324       {
;;;1325         sys_sem_signal(&conn->op_completed);
0003e2  f104000c          ADD      r0,r4,#0xc
0003e6  f7fffffe          BL       sys_sem_signal
                  |L1.1002|
;;;1326       }
;;;1327     }
;;;1328   #if LWIP_TCPIP_CORE_LOCKING
;;;1329     else
;;;1330       return ERR_MEM;
;;;1331   #endif
;;;1332     return ERR_OK;
0003ea  2000              MOVS     r0,#0
;;;1333   }
0003ec  e8bd8ff8          POP      {r3-r11,pc}
;;;1334   #endif /* LWIP_TCP */
                          ENDP

                  sent_tcp PROC
;;;312    static err_t
;;;313    sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
0003f0  e92d41f0          PUSH     {r4-r8,lr}
;;;314    {
0003f4  4605              MOV      r5,r0
0003f6  460f              MOV      r7,r1
0003f8  4616              MOV      r6,r2
;;;315      struct netconn *conn = (struct netconn *)arg;
0003fa  462c              MOV      r4,r5
;;;316    
;;;317      LWIP_UNUSED_ARG(pcb);
;;;318      LWIP_ASSERT("conn != NULL", (conn != NULL));
0003fc  bf00              NOP      
0003fe  bf00              NOP      
;;;319    
;;;320      if (conn->state == NETCONN_WRITE) {
000400  7860              LDRB     r0,[r4,#1]
000402  2801              CMP      r0,#1
000404  d103              BNE      |L1.1038|
;;;321        do_writemore(conn);
000406  4620              MOV      r0,r4
000408  f7fffffe          BL       do_writemore
00040c  e005              B        |L1.1050|
                  |L1.1038|
;;;322      } else if (conn->state == NETCONN_CLOSE) {
00040e  7860              LDRB     r0,[r4,#1]
000410  2804              CMP      r0,#4
000412  d102              BNE      |L1.1050|
;;;323        do_close_internal(conn);
000414  4620              MOV      r0,r4
000416  f7fffffe          BL       do_close_internal
                  |L1.1050|
;;;324      }
;;;325    
;;;326      if (conn) {
00041a  b1dc              CBZ      r4,|L1.1108|
;;;327        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;328           let select mark this pcb as writable again. */
;;;329        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
00041c  6860              LDR      r0,[r4,#4]
00041e  b1c8              CBZ      r0,|L1.1108|
000420  6860              LDR      r0,[r4,#4]
000422  f8b00066          LDRH     r0,[r0,#0x66]
000426  f6403169          MOV      r1,#0xb69
00042a  4288              CMP      r0,r1
00042c  dd12              BLE      |L1.1108|
;;;330          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
00042e  6860              LDR      r0,[r4,#4]
000430  f8b00068          LDRH     r0,[r0,#0x68]
000434  2805              CMP      r0,#5
000436  da0d              BGE      |L1.1108|
;;;331          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
000438  f8140fd8          LDRB     r0,[r4,#0xd8]!
00043c  f0200010          BIC      r0,r0,#0x10
000440  7020              STRB     r0,[r4,#0]
;;;332          API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
000442  68e0              LDR      r0,[r4,#0xc]
000444  3cd8              SUBS     r4,r4,#0xd8
000446  b128              CBZ      r0,|L1.1108|
000448  4632              MOV      r2,r6
00044a  2102              MOVS     r1,#2
00044c  4620              MOV      r0,r4
00044e  f8d430e4          LDR      r3,[r4,#0xe4]
000452  4798              BLX      r3
                  |L1.1108|
;;;333        }
;;;334      }
;;;335      
;;;336      return ERR_OK;
000454  2000              MOVS     r0,#0
;;;337    }
000456  e001              B        |L1.1116|
                  |L1.1112|
                          DCD      current_iphdr_src
                  |L1.1116|
00045c  e8bd81f0          POP      {r4-r8,pc}
;;;338    
                          ENDP

                  do_close_internal PROC
;;;746    static void
;;;747    do_close_internal(struct netconn *conn)
000460  e92d47f0          PUSH     {r4-r10,lr}
;;;748    {
000464  4604              MOV      r4,r0
;;;749      err_t err;
;;;750      u8_t shut, shut_rx, shut_tx, close;
;;;751    
;;;752      LWIP_ASSERT("invalid conn", (conn != NULL));
000466  bf00              NOP      
000468  bf00              NOP      
;;;753      LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
00046a  bf00              NOP      
00046c  bf00              NOP      
;;;754      LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
00046e  bf00              NOP      
000470  bf00              NOP      
;;;755      LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
000472  bf00              NOP      
000474  bf00              NOP      
;;;756      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
000476  bf00              NOP      
000478  bf00              NOP      
;;;757    
;;;758      shut = conn->current_msg->msg.sd.shut;
00047a  f8d400e0          LDR      r0,[r4,#0xe0]
00047e  7a06              LDRB     r6,[r0,#8]
;;;759      shut_rx = shut & NETCONN_SHUT_RD;
000480  f0060701          AND      r7,r6,#1
;;;760      shut_tx = shut & NETCONN_SHUT_WR;
000484  f0060802          AND      r8,r6,#2
;;;761      /* shutting down both ends is the same as closing */
;;;762      close = shut == NETCONN_SHUT_RDWR;
000488  2e03              CMP      r6,#3
00048a  d101              BNE      |L1.1168|
00048c  2001              MOVS     r0,#1
00048e  e000              B        |L1.1170|
                  |L1.1168|
000490  2000              MOVS     r0,#0
                  |L1.1170|
000492  4681              MOV      r9,r0
;;;763    
;;;764      /* Set back some callback pointers */
;;;765      if (close) {
000494  f1b90f00          CMP      r9,#0
000498  d003              BEQ      |L1.1186|
;;;766        tcp_arg(conn->pcb.tcp, NULL);
00049a  2100              MOVS     r1,#0
00049c  6860              LDR      r0,[r4,#4]
00049e  f7fffffe          BL       tcp_arg
                  |L1.1186|
;;;767      }
;;;768      if (conn->pcb.tcp->state == LISTEN) {
0004a2  6860              LDR      r0,[r4,#4]
0004a4  7e00              LDRB     r0,[r0,#0x18]
0004a6  2801              CMP      r0,#1
0004a8  d104              BNE      |L1.1204|
;;;769        tcp_accept(conn->pcb.tcp, NULL);
0004aa  2100              MOVS     r1,#0
0004ac  6860              LDR      r0,[r4,#4]
0004ae  f7fffffe          BL       tcp_accept
0004b2  e01b              B        |L1.1260|
                  |L1.1204|
;;;770      } else {
;;;771        /* some callbacks have to be reset if tcp_close is not successful */
;;;772        if (shut_rx) {
0004b4  b13f              CBZ      r7,|L1.1222|
;;;773          tcp_recv(conn->pcb.tcp, NULL);
0004b6  2100              MOVS     r1,#0
0004b8  6860              LDR      r0,[r4,#4]
0004ba  f7fffffe          BL       tcp_recv
;;;774          tcp_accept(conn->pcb.tcp, NULL);
0004be  2100              MOVS     r1,#0
0004c0  6860              LDR      r0,[r4,#4]
0004c2  f7fffffe          BL       tcp_accept
                  |L1.1222|
;;;775        }
;;;776        if (shut_tx) {
0004c6  f1b80f00          CMP      r8,#0
0004ca  d003              BEQ      |L1.1236|
;;;777          tcp_sent(conn->pcb.tcp, NULL);
0004cc  2100              MOVS     r1,#0
0004ce  6860              LDR      r0,[r4,#4]
0004d0  f7fffffe          BL       tcp_sent
                  |L1.1236|
;;;778        }
;;;779        if (close) {
0004d4  f1b90f00          CMP      r9,#0
0004d8  d008              BEQ      |L1.1260|
;;;780          tcp_poll(conn->pcb.tcp, NULL, 4);
0004da  2204              MOVS     r2,#4
0004dc  2100              MOVS     r1,#0
0004de  6860              LDR      r0,[r4,#4]
0004e0  f7fffffe          BL       tcp_poll
;;;781          tcp_err(conn->pcb.tcp, NULL);
0004e4  2100              MOVS     r1,#0
0004e6  6860              LDR      r0,[r4,#4]
0004e8  f7fffffe          BL       tcp_err
                  |L1.1260|
;;;782        }
;;;783      }
;;;784      /* Try to close the connection */
;;;785      if (close) {
0004ec  f1b90f00          CMP      r9,#0
0004f0  d004              BEQ      |L1.1276|
;;;786        err = tcp_close(conn->pcb.tcp);
0004f2  6860              LDR      r0,[r4,#4]
0004f4  f7fffffe          BL       tcp_close
0004f8  4605              MOV      r5,r0
0004fa  e005              B        |L1.1288|
                  |L1.1276|
;;;787      } else {
;;;788        err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
0004fc  4642              MOV      r2,r8
0004fe  4639              MOV      r1,r7
000500  6860              LDR      r0,[r4,#4]
000502  f7fffffe          BL       tcp_shutdown
000506  4605              MOV      r5,r0
                  |L1.1288|
;;;789      }
;;;790      if (err == ERR_OK) {
000508  bb75              CBNZ     r5,|L1.1384|
;;;791        /* Closing succeeded */
;;;792        conn->current_msg->err = ERR_OK;
00050a  2000              MOVS     r0,#0
00050c  f8d410e0          LDR      r1,[r4,#0xe0]
000510  7108              STRB     r0,[r1,#4]
;;;793        conn->current_msg = NULL;
000512  f8c400e0          STR      r0,[r4,#0xe0]
;;;794        conn->state = NETCONN_NONE;
000516  7060              STRB     r0,[r4,#1]
;;;795        if (close) {
000518  f1b90f00          CMP      r9,#0
00051c  d009              BEQ      |L1.1330|
;;;796          /* Set back some callback pointers as conn is going away */
;;;797          conn->pcb.tcp = NULL;
00051e  6060              STR      r0,[r4,#4]
;;;798          /* Trigger select() in socket layer. Make sure everybody notices activity
;;;799           on the connection, error first! */
;;;800          API_EVENT(conn, NETCONN_EVT_ERROR, 0);
000520  f8d400e4          LDR      r0,[r4,#0xe4]
000524  b128              CBZ      r0,|L1.1330|
000526  2200              MOVS     r2,#0
000528  2104              MOVS     r1,#4
00052a  4620              MOV      r0,r4
00052c  f8d430e4          LDR      r3,[r4,#0xe4]
000530  4798              BLX      r3
                  |L1.1330|
;;;801        }
;;;802        if (shut_rx) {
000532  b147              CBZ      r7,|L1.1350|
;;;803          API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
000534  f8d400e4          LDR      r0,[r4,#0xe4]
000538  b128              CBZ      r0,|L1.1350|
00053a  2200              MOVS     r2,#0
00053c  4611              MOV      r1,r2
00053e  4620              MOV      r0,r4
000540  f8d430e4          LDR      r3,[r4,#0xe4]
000544  4798              BLX      r3
                  |L1.1350|
;;;804        }
;;;805        if (shut_tx) {
000546  f1b80f00          CMP      r8,#0
00054a  d008              BEQ      |L1.1374|
;;;806          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
00054c  f8d400e4          LDR      r0,[r4,#0xe4]
000550  b128              CBZ      r0,|L1.1374|
000552  2200              MOVS     r2,#0
000554  2102              MOVS     r1,#2
000556  4620              MOV      r0,r4
000558  f8d430e4          LDR      r3,[r4,#0xe4]
00055c  4798              BLX      r3
                  |L1.1374|
;;;807        }
;;;808        /* wake up the application task */
;;;809        sys_sem_signal(&conn->op_completed);
00055e  f104000c          ADD      r0,r4,#0xc
000562  f7fffffe          BL       sys_sem_signal
000566  e012              B        |L1.1422|
                  |L1.1384|
;;;810      } else {
;;;811        /* Closing failed, restore some of the callbacks */
;;;812        /* Closing of listen pcb will never fail! */
;;;813        LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
000568  bf00              NOP      
00056a  bf00              NOP      
;;;814        tcp_sent(conn->pcb.tcp, sent_tcp);
00056c  49fd              LDR      r1,|L1.2404|
00056e  6860              LDR      r0,[r4,#4]
000570  f7fffffe          BL       tcp_sent
;;;815        tcp_poll(conn->pcb.tcp, poll_tcp, 4);
000574  2204              MOVS     r2,#4
000576  49fc              LDR      r1,|L1.2408|
000578  6860              LDR      r0,[r4,#4]
00057a  f7fffffe          BL       tcp_poll
;;;816        tcp_err(conn->pcb.tcp, err_tcp);
00057e  49fb              LDR      r1,|L1.2412|
000580  6860              LDR      r0,[r4,#4]
000582  f7fffffe          BL       tcp_err
;;;817        tcp_arg(conn->pcb.tcp, conn);
000586  4621              MOV      r1,r4
000588  6860              LDR      r0,[r4,#4]
00058a  f7fffffe          BL       tcp_arg
                  |L1.1422|
;;;818        /* don't restore recv callback: we don't want to receive any more data */
;;;819      }
;;;820      /* If closing didn't succeed, we get called again either
;;;821         from poll_tcp or from sent_tcp */
;;;822    }
00058e  e8bd87f0          POP      {r4-r10,pc}
;;;823    #endif /* LWIP_TCP */
                          ENDP

                  poll_tcp PROC
;;;276    static err_t
;;;277    poll_tcp(void *arg, struct tcp_pcb *pcb)
000592  b570              PUSH     {r4-r6,lr}
;;;278    {
000594  4605              MOV      r5,r0
000596  460e              MOV      r6,r1
;;;279      struct netconn *conn = (struct netconn *)arg;
000598  462c              MOV      r4,r5
;;;280    
;;;281      LWIP_UNUSED_ARG(pcb);
;;;282      LWIP_ASSERT("conn != NULL", (conn != NULL));
00059a  bf00              NOP      
00059c  bf00              NOP      
;;;283    
;;;284      if (conn->state == NETCONN_WRITE) {
00059e  7860              LDRB     r0,[r4,#1]
0005a0  2801              CMP      r0,#1
0005a2  d103              BNE      |L1.1452|
;;;285        do_writemore(conn);
0005a4  4620              MOV      r0,r4
0005a6  f7fffffe          BL       do_writemore
0005aa  e005              B        |L1.1464|
                  |L1.1452|
;;;286      } else if (conn->state == NETCONN_CLOSE) {
0005ac  7860              LDRB     r0,[r4,#1]
0005ae  2804              CMP      r0,#4
0005b0  d102              BNE      |L1.1464|
;;;287        do_close_internal(conn);
0005b2  4620              MOV      r0,r4
0005b4  f7fffffe          BL       do_close_internal
                  |L1.1464|
;;;288      }
;;;289      /* @todo: implement connect timeout here? */
;;;290    
;;;291      /* Did a nonblocking write fail before? Then check available write-space. */
;;;292      if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
0005b8  f89400d8          LDRB     r0,[r4,#0xd8]
0005bc  f0000010          AND      r0,r0,#0x10
0005c0  b1d8              CBZ      r0,|L1.1530|
;;;293        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;294           let select mark this pcb as writable again. */
;;;295        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
0005c2  6860              LDR      r0,[r4,#4]
0005c4  b1c8              CBZ      r0,|L1.1530|
0005c6  6860              LDR      r0,[r4,#4]
0005c8  f8b00066          LDRH     r0,[r0,#0x66]
0005cc  f6403169          MOV      r1,#0xb69
0005d0  4288              CMP      r0,r1
0005d2  dd12              BLE      |L1.1530|
;;;296          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
0005d4  6860              LDR      r0,[r4,#4]
0005d6  f8b00068          LDRH     r0,[r0,#0x68]
0005da  2805              CMP      r0,#5
0005dc  da0d              BGE      |L1.1530|
;;;297          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
0005de  f8140fd8          LDRB     r0,[r4,#0xd8]!
0005e2  f0200010          BIC      r0,r0,#0x10
0005e6  7020              STRB     r0,[r4,#0]
;;;298          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
0005e8  68e0              LDR      r0,[r4,#0xc]
0005ea  3cd8              SUBS     r4,r4,#0xd8
0005ec  b128              CBZ      r0,|L1.1530|
0005ee  2200              MOVS     r2,#0
0005f0  2102              MOVS     r1,#2
0005f2  4620              MOV      r0,r4
0005f4  f8d430e4          LDR      r3,[r4,#0xe4]
0005f8  4798              BLX      r3
                  |L1.1530|
;;;299        }
;;;300      }
;;;301    
;;;302      return ERR_OK;
0005fa  2000              MOVS     r0,#0
;;;303    }
0005fc  bd70              POP      {r4-r6,pc}
;;;304    
                          ENDP

                  setup_tcp PROC
;;;412    static void
;;;413    setup_tcp(struct netconn *conn)
0005fe  b570              PUSH     {r4-r6,lr}
;;;414    {
000600  4604              MOV      r4,r0
;;;415      struct tcp_pcb *pcb;
;;;416    
;;;417      pcb = conn->pcb.tcp;
000602  6865              LDR      r5,[r4,#4]
;;;418      tcp_arg(pcb, conn);
000604  4621              MOV      r1,r4
000606  4628              MOV      r0,r5
000608  f7fffffe          BL       tcp_arg
;;;419      tcp_recv(pcb, recv_tcp);
00060c  49d8              LDR      r1,|L1.2416|
00060e  4628              MOV      r0,r5
000610  f7fffffe          BL       tcp_recv
;;;420      tcp_sent(pcb, sent_tcp);
000614  49d3              LDR      r1,|L1.2404|
000616  4628              MOV      r0,r5
000618  f7fffffe          BL       tcp_sent
;;;421      tcp_poll(pcb, poll_tcp, 4);
00061c  2204              MOVS     r2,#4
00061e  49d2              LDR      r1,|L1.2408|
000620  4628              MOV      r0,r5
000622  f7fffffe          BL       tcp_poll
;;;422      tcp_err(pcb, err_tcp);
000626  49d1              LDR      r1,|L1.2412|
000628  4628              MOV      r0,r5
00062a  f7fffffe          BL       tcp_err
;;;423    }
00062e  bd70              POP      {r4-r6,pc}
;;;424    
                          ENDP

                  netconn_free PROC
;;;656    void
;;;657    netconn_free(struct netconn *conn)
000630  b510              PUSH     {r4,lr}
;;;658    {
000632  4604              MOV      r4,r0
;;;659      LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
000634  bf00              NOP      
000636  bf00              NOP      
;;;660      LWIP_ASSERT("recvmbox must be deallocated before calling this function",
000638  bf00              NOP      
00063a  bf00              NOP      
;;;661        !sys_mbox_valid(&conn->recvmbox));
;;;662    #if LWIP_TCP
;;;663      LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
00063c  bf00              NOP      
00063e  bf00              NOP      
;;;664        !sys_mbox_valid(&conn->acceptmbox));
;;;665    #endif /* LWIP_TCP */
;;;666    
;;;667      sys_sem_free(&conn->op_completed);
000640  f104000c          ADD      r0,r4,#0xc
000644  f7fffffe          BL       sys_sem_free
;;;668      sys_sem_set_invalid(&conn->op_completed);
000648  2000              MOVS     r0,#0
00064a  60e0              STR      r0,[r4,#0xc]
;;;669    
;;;670      memp_free(MEMP_NETCONN, conn);
00064c  4621              MOV      r1,r4
00064e  2006              MOVS     r0,#6
000650  f7fffffe          BL       memp_free
;;;671    }
000654  bd10              POP      {r4,pc}
;;;672    
                          ENDP

                  netconn_alloc PROC
;;;571    struct netconn*
;;;572    netconn_alloc(enum netconn_type t, netconn_callback callback)
000656  e92d41f0          PUSH     {r4-r8,lr}
;;;573    {
00065a  4605              MOV      r5,r0
00065c  460e              MOV      r6,r1
;;;574      struct netconn *conn;
;;;575      int size;
;;;576    
;;;577      conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
00065e  2006              MOVS     r0,#6
000660  f7fffffe          BL       memp_malloc
000664  4604              MOV      r4,r0
;;;578      if (conn == NULL) {
000666  b914              CBNZ     r4,|L1.1646|
;;;579        return NULL;
000668  2000              MOVS     r0,#0
                  |L1.1642|
;;;580      }
;;;581    
;;;582      conn->last_err = ERR_OK;
;;;583      conn->type = t;
;;;584      conn->pcb.tcp = NULL;
;;;585    
;;;586    #if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
;;;587        (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
;;;588      size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;589    #else
;;;590      switch(NETCONNTYPE_GROUP(t)) {
;;;591    #if LWIP_RAW
;;;592      case NETCONN_RAW:
;;;593        size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;594        break;
;;;595    #endif /* LWIP_RAW */
;;;596    #if LWIP_UDP
;;;597      case NETCONN_UDP:
;;;598        size = DEFAULT_UDP_RECVMBOX_SIZE;
;;;599        break;
;;;600    #endif /* LWIP_UDP */
;;;601    #if LWIP_TCP
;;;602      case NETCONN_TCP:
;;;603        size = DEFAULT_TCP_RECVMBOX_SIZE;
;;;604        break;
;;;605    #endif /* LWIP_TCP */
;;;606      default:
;;;607        LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
;;;608        goto free_and_return;
;;;609      }
;;;610    #endif
;;;611    
;;;612      if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
;;;613        goto free_and_return;
;;;614      }
;;;615      if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
;;;616        sys_sem_free(&conn->op_completed);
;;;617        goto free_and_return;
;;;618      }
;;;619    
;;;620    #if LWIP_TCP
;;;621      sys_mbox_set_invalid(&conn->acceptmbox);
;;;622    #endif
;;;623      conn->state        = NETCONN_NONE;
;;;624    #if LWIP_SOCKET
;;;625      /* initialize socket to -1 since 0 is a valid socket */
;;;626      conn->socket       = -1;
;;;627    #endif /* LWIP_SOCKET */
;;;628      conn->callback     = callback;
;;;629    #if LWIP_TCP
;;;630      conn->current_msg  = NULL;
;;;631      conn->write_offset = 0;
;;;632    #endif /* LWIP_TCP */
;;;633    #if LWIP_SO_SNDTIMEO
;;;634      conn->send_timeout = 0;
;;;635    #endif /* LWIP_SO_SNDTIMEO */
;;;636    #if LWIP_SO_RCVTIMEO
;;;637      conn->recv_timeout = 0;
;;;638    #endif /* LWIP_SO_RCVTIMEO */
;;;639    #if LWIP_SO_RCVBUF
;;;640      conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
;;;641      conn->recv_avail   = 0;
;;;642    #endif /* LWIP_SO_RCVBUF */
;;;643      conn->flags = 0;
;;;644      return conn;
;;;645    free_and_return:
;;;646      memp_free(MEMP_NETCONN, conn);
;;;647      return NULL;
;;;648    }
00066a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1646|
00066e  2000              MOVS     r0,#0                 ;582
000670  7220              STRB     r0,[r4,#8]            ;582
000672  7025              STRB     r5,[r4,#0]            ;583
000674  6060              STR      r0,[r4,#4]            ;584
000676  2710              MOVS     r7,#0x10              ;588
000678  2100              MOVS     r1,#0                 ;612
00067a  f104000c          ADD      r0,r4,#0xc            ;612
00067e  f7fffffe          BL       sys_sem_new
000682  b100              CBZ      r0,|L1.1670|
000684  e01a              B        |L1.1724|
                  |L1.1670|
000686  4639              MOV      r1,r7                 ;615
000688  f104001c          ADD      r0,r4,#0x1c           ;615
00068c  f7fffffe          BL       sys_mbox_new
000690  b120              CBZ      r0,|L1.1692|
000692  f104000c          ADD      r0,r4,#0xc            ;616
000696  f7fffffe          BL       sys_sem_free
00069a  e00f              B        |L1.1724|
                  |L1.1692|
00069c  2000              MOVS     r0,#0                 ;621
00069e  f8440f78          STR      r0,[r4,#0x78]!        ;621
0006a2  f8040c77          STRB     r0,[r4,#-0x77]        ;623
0006a6  1e40              SUBS     r0,r0,#1              ;626
0006a8  65e0              STR      r0,[r4,#0x5c]         ;626
0006aa  66e6              STR      r6,[r4,#0x6c]         ;628
0006ac  2000              MOVS     r0,#0                 ;630
0006ae  66a0              STR      r0,[r4,#0x68]         ;630
0006b0  6660              STR      r0,[r4,#0x64]         ;631
0006b2  f8840060          STRB     r0,[r4,#0x60]         ;643
0006b6  3c78              SUBS     r4,r4,#0x78           ;643
0006b8  4620              MOV      r0,r4                 ;644
0006ba  e7d6              B        |L1.1642|
                  |L1.1724|
0006bc  4621              MOV      r1,r4                 ;646
0006be  2006              MOVS     r0,#6                 ;646
0006c0  f7fffffe          BL       memp_free
0006c4  2000              MOVS     r0,#0                 ;647
0006c6  e7d0              B        |L1.1642|
;;;649    
                          ENDP

                  accept_function PROC
;;;431    static err_t
;;;432    accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
0006c8  e92d47f0          PUSH     {r4-r10,lr}
;;;433    {
0006cc  4606              MOV      r6,r0
0006ce  460f              MOV      r7,r1
0006d0  4690              MOV      r8,r2
;;;434      struct netconn *newconn;
;;;435      struct netconn *conn = (struct netconn *)arg;
0006d2  4635              MOV      r5,r6
;;;436    
;;;437      LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));
0006d4  bf00              NOP      
0006d6  bf00              NOP      
;;;438    
;;;439      if (!sys_mbox_valid(&conn->acceptmbox)) {
0006d8  6fa8              LDR      r0,[r5,#0x78]
0006da  b108              CBZ      r0,|L1.1760|
0006dc  2001              MOVS     r0,#1
0006de  e000              B        |L1.1762|
                  |L1.1760|
0006e0  2000              MOVS     r0,#0
                  |L1.1762|
0006e2  b928              CBNZ     r0,|L1.1776|
;;;440        LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
0006e4  bf00              NOP      
0006e6  bf00              NOP      
;;;441        return ERR_VAL;
0006e8  f06f0005          MVN      r0,#5
                  |L1.1772|
;;;442      }
;;;443    
;;;444      /* We have to set the callback here even though
;;;445       * the new socket is unknown. conn->socket is marked as -1. */
;;;446      newconn = netconn_alloc(conn->type, conn->callback);
;;;447      if (newconn == NULL) {
;;;448        return ERR_MEM;
;;;449      }
;;;450      newconn->pcb.tcp = newpcb;
;;;451      setup_tcp(newconn);
;;;452      /* no protection: when creating the pcb, the netconn is not yet known
;;;453         to the application thread */
;;;454      newconn->last_err = err;
;;;455    
;;;456      if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
;;;457        /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
;;;458           so do nothing here! */
;;;459        /* remove all references to this netconn from the pcb */
;;;460        struct tcp_pcb* pcb = newconn->pcb.tcp;
;;;461        tcp_arg(pcb, NULL);
;;;462        tcp_recv(pcb, NULL);
;;;463        tcp_sent(pcb, NULL);
;;;464        tcp_poll(pcb, NULL, 4);
;;;465        tcp_err(pcb, NULL);
;;;466        /* remove reference from to the pcb from this netconn */
;;;467        newconn->pcb.tcp = NULL;
;;;468        /* no need to drain since we know the recvmbox is empty. */
;;;469        sys_mbox_free(&newconn->recvmbox);
;;;470        sys_mbox_set_invalid(&newconn->recvmbox);
;;;471        netconn_free(newconn);
;;;472        return ERR_MEM;
;;;473      } else {
;;;474        /* Register event with callback */
;;;475        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
;;;476      }
;;;477    
;;;478      return ERR_OK;
;;;479    }
0006ec  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1776|
0006f0  7828              LDRB     r0,[r5,#0]            ;446
0006f2  f8d510e4          LDR      r1,[r5,#0xe4]         ;446
0006f6  f7fffffe          BL       netconn_alloc
0006fa  4604              MOV      r4,r0                 ;446
0006fc  b914              CBNZ     r4,|L1.1796|
0006fe  f04f30ff          MOV      r0,#0xffffffff        ;448
000702  e7f3              B        |L1.1772|
                  |L1.1796|
000704  6067              STR      r7,[r4,#4]            ;450
000706  4620              MOV      r0,r4                 ;451
000708  f7fffffe          BL       setup_tcp
00070c  f8848008          STRB     r8,[r4,#8]            ;454
000710  4621              MOV      r1,r4                 ;456
000712  f1050078          ADD      r0,r5,#0x78           ;456
000716  f7fffffe          BL       sys_mbox_trypost
00071a  b320              CBZ      r0,|L1.1894|
00071c  f8d49004          LDR      r9,[r4,#4]            ;460
000720  2100              MOVS     r1,#0                 ;461
000722  4648              MOV      r0,r9                 ;461
000724  f7fffffe          BL       tcp_arg
000728  2100              MOVS     r1,#0                 ;462
00072a  4648              MOV      r0,r9                 ;462
00072c  f7fffffe          BL       tcp_recv
000730  2100              MOVS     r1,#0                 ;463
000732  4648              MOV      r0,r9                 ;463
000734  f7fffffe          BL       tcp_sent
000738  2204              MOVS     r2,#4                 ;464
00073a  2100              MOVS     r1,#0                 ;464
00073c  4648              MOV      r0,r9                 ;464
00073e  f7fffffe          BL       tcp_poll
000742  2100              MOVS     r1,#0                 ;465
000744  4648              MOV      r0,r9                 ;465
000746  f7fffffe          BL       tcp_err
00074a  2000              MOVS     r0,#0                 ;467
00074c  6060              STR      r0,[r4,#4]            ;467
00074e  f104001c          ADD      r0,r4,#0x1c           ;469
000752  f7fffffe          BL       sys_mbox_free
000756  2000              MOVS     r0,#0                 ;470
000758  61e0              STR      r0,[r4,#0x1c]         ;470
00075a  4620              MOV      r0,r4                 ;471
00075c  f7fffffe          BL       netconn_free
000760  f04f30ff          MOV      r0,#0xffffffff        ;472
000764  e7c2              B        |L1.1772|
                  |L1.1894|
000766  f8d500e4          LDR      r0,[r5,#0xe4]         ;475
00076a  b128              CBZ      r0,|L1.1912|
00076c  2200              MOVS     r2,#0                 ;475
00076e  4611              MOV      r1,r2                 ;475
000770  4628              MOV      r0,r5                 ;475
000772  f8d530e4          LDR      r3,[r5,#0xe4]         ;475
000776  4798              BLX      r3                    ;475
                  |L1.1912|
000778  2000              MOVS     r0,#0                 ;478
00077a  e7b7              B        |L1.1772|
;;;480    #endif /* LWIP_TCP */
                          ENDP

                  pcb_new PROC
;;;489    static void
;;;490    pcb_new(struct api_msg_msg *msg)
00077c  b510              PUSH     {r4,lr}
;;;491    {
00077e  4604              MOV      r4,r0
;;;492      LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
000780  bf00              NOP      
000782  bf00              NOP      
;;;493    
;;;494      /* Allocate a PCB for this connection */
;;;495      switch(NETCONNTYPE_GROUP(msg->conn->type)) {
000784  6820              LDR      r0,[r4,#0]
000786  7800              LDRB     r0,[r0,#0]
000788  f00000f0          AND      r0,r0,#0xf0
00078c  2810              CMP      r0,#0x10
00078e  d02c              BEQ      |L1.2026|
000790  2820              CMP      r0,#0x20
000792  d012              BEQ      |L1.1978|
000794  2840              CMP      r0,#0x40
000796  d136              BNE      |L1.2054|
;;;496    #if LWIP_RAW
;;;497      case NETCONN_RAW:
;;;498        msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
000798  7a20              LDRB     r0,[r4,#8]
00079a  f7fffffe          BL       raw_new
00079e  6821              LDR      r1,[r4,#0]
0007a0  6048              STR      r0,[r1,#4]
;;;499        if(msg->conn->pcb.raw == NULL) {
0007a2  6820              LDR      r0,[r4,#0]
0007a4  6840              LDR      r0,[r0,#4]
0007a6  b910              CBNZ     r0,|L1.1966|
;;;500          msg->err = ERR_MEM;
0007a8  20ff              MOVS     r0,#0xff
0007aa  7120              STRB     r0,[r4,#4]
;;;501          break;
0007ac  e02e              B        |L1.2060|
                  |L1.1966|
;;;502        }
;;;503        raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
0007ae  6822              LDR      r2,[r4,#0]
0007b0  4970              LDR      r1,|L1.2420|
0007b2  6850              LDR      r0,[r2,#4]
0007b4  f7fffffe          BL       raw_recv
;;;504        break;
0007b8  e028              B        |L1.2060|
                  |L1.1978|
;;;505    #endif /* LWIP_RAW */
;;;506    #if LWIP_UDP
;;;507      case NETCONN_UDP:
;;;508        msg->conn->pcb.udp = udp_new();
0007ba  f7fffffe          BL       udp_new
0007be  6821              LDR      r1,[r4,#0]
0007c0  6048              STR      r0,[r1,#4]
;;;509        if(msg->conn->pcb.udp == NULL) {
0007c2  6820              LDR      r0,[r4,#0]
0007c4  6840              LDR      r0,[r0,#4]
0007c6  b910              CBNZ     r0,|L1.1998|
;;;510          msg->err = ERR_MEM;
0007c8  20ff              MOVS     r0,#0xff
0007ca  7120              STRB     r0,[r4,#4]
;;;511          break;
0007cc  e01e              B        |L1.2060|
                  |L1.1998|
;;;512        }
;;;513    #if LWIP_UDPLITE
;;;514        if (msg->conn->type==NETCONN_UDPLITE) {
;;;515          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
;;;516        }
;;;517    #endif /* LWIP_UDPLITE */
;;;518        if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
0007ce  6820              LDR      r0,[r4,#0]
0007d0  7800              LDRB     r0,[r0,#0]
0007d2  2822              CMP      r0,#0x22
0007d4  d103              BNE      |L1.2014|
;;;519          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
0007d6  2001              MOVS     r0,#1
0007d8  6821              LDR      r1,[r4,#0]
0007da  6849              LDR      r1,[r1,#4]
0007dc  7408              STRB     r0,[r1,#0x10]
                  |L1.2014|
;;;520        }
;;;521        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
0007de  6822              LDR      r2,[r4,#0]
0007e0  4965              LDR      r1,|L1.2424|
0007e2  6850              LDR      r0,[r2,#4]
0007e4  f7fffffe          BL       udp_recv
;;;522        break;
0007e8  e010              B        |L1.2060|
                  |L1.2026|
;;;523    #endif /* LWIP_UDP */
;;;524    #if LWIP_TCP
;;;525      case NETCONN_TCP:
;;;526        msg->conn->pcb.tcp = tcp_new();
0007ea  f7fffffe          BL       tcp_new
0007ee  6821              LDR      r1,[r4,#0]
0007f0  6048              STR      r0,[r1,#4]
;;;527        if(msg->conn->pcb.tcp == NULL) {
0007f2  6820              LDR      r0,[r4,#0]
0007f4  6840              LDR      r0,[r0,#4]
0007f6  b910              CBNZ     r0,|L1.2046|
;;;528          msg->err = ERR_MEM;
0007f8  20ff              MOVS     r0,#0xff
0007fa  7120              STRB     r0,[r4,#4]
;;;529          break;
0007fc  e006              B        |L1.2060|
                  |L1.2046|
;;;530        }
;;;531        setup_tcp(msg->conn);
0007fe  6820              LDR      r0,[r4,#0]
000800  f7fffffe          BL       setup_tcp
;;;532        break;
000804  e002              B        |L1.2060|
                  |L1.2054|
;;;533    #endif /* LWIP_TCP */
;;;534      default:
;;;535        /* Unsupported netconn type, e.g. protocol disabled */
;;;536        msg->err = ERR_VAL;
000806  20fa              MOVS     r0,#0xfa
000808  7120              STRB     r0,[r4,#4]
;;;537        break;
00080a  bf00              NOP      
                  |L1.2060|
00080c  bf00              NOP                            ;501
;;;538      }
;;;539    }
00080e  bd10              POP      {r4,pc}
;;;540    
                          ENDP

                  do_newconn PROC
;;;547    void
;;;548    do_newconn(struct api_msg_msg *msg)
000810  b510              PUSH     {r4,lr}
;;;549    {
000812  4604              MOV      r4,r0
;;;550      msg->err = ERR_OK;
000814  2000              MOVS     r0,#0
000816  7120              STRB     r0,[r4,#4]
;;;551      if(msg->conn->pcb.tcp == NULL) {
000818  6820              LDR      r0,[r4,#0]
00081a  6840              LDR      r0,[r0,#4]
00081c  b910              CBNZ     r0,|L1.2084|
;;;552        pcb_new(msg);
00081e  4620              MOV      r0,r4
000820  f7fffffe          BL       pcb_new
                  |L1.2084|
;;;553      }
;;;554      /* Else? This "new" connection already has a PCB allocated. */
;;;555      /* Is this an error condition? Should it be deleted? */
;;;556      /* We currently just are happy and return. */
;;;557    
;;;558      TCPIP_APIMSG_ACK(msg);
000824  6821              LDR      r1,[r4,#0]
000826  f101000c          ADD      r0,r1,#0xc
00082a  f7fffffe          BL       sys_sem_signal
;;;559    }
00082e  bd10              POP      {r4,pc}
;;;560    
                          ENDP

                  netconn_drain PROC
;;;681    static void
;;;682    netconn_drain(struct netconn *conn)
000830  b5f8              PUSH     {r3-r7,lr}
;;;683    {
000832  4604              MOV      r4,r0
;;;684      void *mem;
;;;685    #if LWIP_TCP
;;;686      struct pbuf *p;
;;;687    #endif /* LWIP_TCP */
;;;688    
;;;689      /* This runs in tcpip_thread, so we don't need to lock against rx packets */
;;;690    
;;;691      /* Delete and drain the recvmbox. */
;;;692      if (sys_mbox_valid(&conn->recvmbox)) {
000834  69e0              LDR      r0,[r4,#0x1c]
000836  b108              CBZ      r0,|L1.2108|
000838  2001              MOVS     r0,#1
00083a  e000              B        |L1.2110|
                  |L1.2108|
00083c  2000              MOVS     r0,#0
                  |L1.2110|
00083e  b308              CBZ      r0,|L1.2180|
;;;693        while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
000840  e012              B        |L1.2152|
                  |L1.2114|
;;;694    #if LWIP_TCP
;;;695          if (conn->type == NETCONN_TCP) {
000842  7820              LDRB     r0,[r4,#0]
000844  2810              CMP      r0,#0x10
000846  d10c              BNE      |L1.2146|
;;;696            if(mem != NULL) {
000848  9800              LDR      r0,[sp,#0]
00084a  b168              CBZ      r0,|L1.2152|
;;;697              p = (struct pbuf*)mem;
00084c  9e00              LDR      r6,[sp,#0]
;;;698              /* pcb might be set to NULL already by err_tcp() */
;;;699              if (conn->pcb.tcp != NULL) {
00084e  6860              LDR      r0,[r4,#4]
000850  b118              CBZ      r0,|L1.2138|
;;;700                tcp_recved(conn->pcb.tcp, p->tot_len);
000852  8931              LDRH     r1,[r6,#8]
000854  6860              LDR      r0,[r4,#4]
000856  f7fffffe          BL       tcp_recved
                  |L1.2138|
;;;701              }
;;;702              pbuf_free(p);
00085a  4630              MOV      r0,r6
00085c  f7fffffe          BL       pbuf_free
000860  e002              B        |L1.2152|
                  |L1.2146|
;;;703            }
;;;704          } else
;;;705    #endif /* LWIP_TCP */
;;;706          {
;;;707            netbuf_delete((struct netbuf *)mem);
000862  9800              LDR      r0,[sp,#0]
000864  f7fffffe          BL       netbuf_delete
                  |L1.2152|
000868  4669              MOV      r1,sp                 ;693
00086a  f104001c          ADD      r0,r4,#0x1c           ;693
00086e  f7fffffe          BL       sys_arch_mbox_tryfetch
000872  1c40              ADDS     r0,r0,#1              ;693
000874  2800              CMP      r0,#0                 ;693
000876  d1e4              BNE      |L1.2114|
;;;708          }
;;;709        }
;;;710        sys_mbox_free(&conn->recvmbox);
000878  f104001c          ADD      r0,r4,#0x1c
00087c  f7fffffe          BL       sys_mbox_free
;;;711        sys_mbox_set_invalid(&conn->recvmbox);
000880  2000              MOVS     r0,#0
000882  61e0              STR      r0,[r4,#0x1c]
                  |L1.2180|
;;;712      }
;;;713    
;;;714      /* Delete and drain the acceptmbox. */
;;;715    #if LWIP_TCP
;;;716      if (sys_mbox_valid(&conn->acceptmbox)) {
000884  6fa0              LDR      r0,[r4,#0x78]
000886  b108              CBZ      r0,|L1.2188|
000888  2001              MOVS     r0,#1
00088a  e000              B        |L1.2190|
                  |L1.2188|
00088c  2000              MOVS     r0,#0
                  |L1.2190|
00088e  b340              CBZ      r0,|L1.2274|
;;;717        while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
000890  e019              B        |L1.2246|
                  |L1.2194|
;;;718          struct netconn *newconn = (struct netconn *)mem;
000892  9d00              LDR      r5,[sp,#0]
;;;719          /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
;;;720          /* pcb might be set to NULL already by err_tcp() */
;;;721          if (conn->pcb.tcp != NULL) {
000894  6860              LDR      r0,[r4,#4]
000896  b140              CBZ      r0,|L1.2218|
;;;722            tcp_accepted(conn->pcb.tcp);
000898  bf00              NOP      
00089a  bf00              NOP      
00089c  bf00              NOP      
00089e  6860              LDR      r0,[r4,#4]
0008a0  7f40              LDRB     r0,[r0,#0x1d]
0008a2  1e40              SUBS     r0,r0,#1
0008a4  6861              LDR      r1,[r4,#4]
0008a6  7748              STRB     r0,[r1,#0x1d]
0008a8  bf00              NOP      
                  |L1.2218|
;;;723          }
;;;724          /* drain recvmbox */
;;;725          netconn_drain(newconn);
0008aa  4628              MOV      r0,r5
0008ac  f7fffffe          BL       netconn_drain
;;;726          if (newconn->pcb.tcp != NULL) {
0008b0  6868              LDR      r0,[r5,#4]
0008b2  b120              CBZ      r0,|L1.2238|
;;;727            tcp_abort(newconn->pcb.tcp);
0008b4  6868              LDR      r0,[r5,#4]
0008b6  f7fffffe          BL       tcp_abort
;;;728            newconn->pcb.tcp = NULL;
0008ba  2000              MOVS     r0,#0
0008bc  6068              STR      r0,[r5,#4]
                  |L1.2238|
;;;729          }
;;;730          netconn_free(newconn);
0008be  4628              MOV      r0,r5
0008c0  f7fffffe          BL       netconn_free
;;;731        }
0008c4  bf00              NOP      
                  |L1.2246|
0008c6  4669              MOV      r1,sp                 ;717
0008c8  f1040078          ADD      r0,r4,#0x78           ;717
0008cc  f7fffffe          BL       sys_arch_mbox_tryfetch
0008d0  1c40              ADDS     r0,r0,#1              ;717
0008d2  2800              CMP      r0,#0                 ;717
0008d4  d1dd              BNE      |L1.2194|
;;;732        sys_mbox_free(&conn->acceptmbox);
0008d6  f1040078          ADD      r0,r4,#0x78
0008da  f7fffffe          BL       sys_mbox_free
;;;733        sys_mbox_set_invalid(&conn->acceptmbox);
0008de  2000              MOVS     r0,#0
0008e0  67a0              STR      r0,[r4,#0x78]
                  |L1.2274|
;;;734      }
;;;735    #endif /* LWIP_TCP */
;;;736    }
0008e2  bdf8              POP      {r3-r7,pc}
;;;737    
                          ENDP

                  do_delconn PROC
;;;831    void
;;;832    do_delconn(struct api_msg_msg *msg)
0008e4  b510              PUSH     {r4,lr}
;;;833    {
0008e6  4604              MOV      r4,r0
;;;834      /* @todo TCP: abort running write/connect? */
;;;835     if ((msg->conn->state != NETCONN_NONE) &&
0008e8  6820              LDR      r0,[r4,#0]
0008ea  7840              LDRB     r0,[r0,#1]
0008ec  b160              CBZ      r0,|L1.2312|
;;;836         (msg->conn->state != NETCONN_LISTEN) &&
0008ee  6820              LDR      r0,[r4,#0]
0008f0  7840              LDRB     r0,[r0,#1]
0008f2  2802              CMP      r0,#2
0008f4  d008              BEQ      |L1.2312|
;;;837         (msg->conn->state != NETCONN_CONNECT)) {
0008f6  6820              LDR      r0,[r4,#0]
0008f8  7840              LDRB     r0,[r0,#1]
0008fa  2803              CMP      r0,#3
0008fc  d004              BEQ      |L1.2312|
;;;838        /* this only happens for TCP netconns */
;;;839        LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
0008fe  bf00              NOP      
000900  bf00              NOP      
;;;840        msg->err = ERR_INPROGRESS;
000902  20fb              MOVS     r0,#0xfb
000904  7120              STRB     r0,[r4,#4]
000906  e053              B        |L1.2480|
                  |L1.2312|
;;;841      } else {
;;;842        LWIP_ASSERT("blocking connect in progress",
000908  bf00              NOP      
00090a  bf00              NOP      
;;;843          (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
;;;844        /* Drain and delete mboxes */
;;;845        netconn_drain(msg->conn);
00090c  6820              LDR      r0,[r4,#0]
00090e  f7fffffe          BL       netconn_drain
;;;846    
;;;847        if (msg->conn->pcb.tcp != NULL) {
000912  6820              LDR      r0,[r4,#0]
000914  6840              LDR      r0,[r0,#4]
000916  b388              CBZ      r0,|L1.2428|
;;;848    
;;;849          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000918  6820              LDR      r0,[r4,#0]
00091a  7800              LDRB     r0,[r0,#0]
00091c  f00000f0          AND      r0,r0,#0xf0
000920  2810              CMP      r0,#0x10
000922  d011              BEQ      |L1.2376|
000924  2820              CMP      r0,#0x20
000926  d006              BEQ      |L1.2358|
000928  2840              CMP      r0,#0x40
00092a  d128              BNE      |L1.2430|
;;;850    #if LWIP_RAW
;;;851          case NETCONN_RAW:
;;;852            raw_remove(msg->conn->pcb.raw);
00092c  6821              LDR      r1,[r4,#0]
00092e  6848              LDR      r0,[r1,#4]
000930  f7fffffe          BL       raw_remove
;;;853            break;
000934  e024              B        |L1.2432|
                  |L1.2358|
;;;854    #endif /* LWIP_RAW */
;;;855    #if LWIP_UDP
;;;856          case NETCONN_UDP:
;;;857            msg->conn->pcb.udp->recv_arg = NULL;
000936  2000              MOVS     r0,#0
000938  6821              LDR      r1,[r4,#0]
00093a  6849              LDR      r1,[r1,#4]
00093c  6208              STR      r0,[r1,#0x20]
;;;858            udp_remove(msg->conn->pcb.udp);
00093e  6821              LDR      r1,[r4,#0]
000940  6848              LDR      r0,[r1,#4]
000942  f7fffffe          BL       udp_remove
;;;859            break;
000946  e01b              B        |L1.2432|
                  |L1.2376|
;;;860    #endif /* LWIP_UDP */
;;;861    #if LWIP_TCP
;;;862          case NETCONN_TCP:
;;;863            LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
000948  bf00              NOP      
00094a  bf00              NOP      
;;;864              msg->conn->write_offset == 0);
;;;865            msg->conn->state = NETCONN_CLOSE;
00094c  2004              MOVS     r0,#4
00094e  6821              LDR      r1,[r4,#0]
000950  7048              STRB     r0,[r1,#1]
;;;866            msg->msg.sd.shut = NETCONN_SHUT_RDWR;
000952  2003              MOVS     r0,#3
000954  7220              STRB     r0,[r4,#8]
;;;867            msg->conn->current_msg = msg;
000956  6820              LDR      r0,[r4,#0]
000958  f8c040e0          STR      r4,[r0,#0xe0]
;;;868            do_close_internal(msg->conn);
00095c  6820              LDR      r0,[r4,#0]
00095e  f7fffffe          BL       do_close_internal
                  |L1.2402|
;;;869            /* API_EVENT is called inside do_close_internal, before releasing
;;;870               the application thread, so we can return at this point! */
;;;871            return;
;;;872    #endif /* LWIP_TCP */
;;;873          default:
;;;874            break;
;;;875          }
;;;876          msg->conn->pcb.tcp = NULL;
;;;877        }
;;;878        /* tcp netconns don't come here! */
;;;879    
;;;880        /* @todo: this lets select make the socket readable and writable,
;;;881           which is wrong! errfd instead? */
;;;882        API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
;;;883        API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
;;;884      }
;;;885      if (sys_sem_valid(&msg->conn->op_completed)) {
;;;886        sys_sem_signal(&msg->conn->op_completed);
;;;887      }
;;;888    }
000962  bd10              POP      {r4,pc}
                  |L1.2404|
                          DCD      sent_tcp
                  |L1.2408|
                          DCD      poll_tcp
                  |L1.2412|
                          DCD      err_tcp
                  |L1.2416|
                          DCD      recv_tcp
                  |L1.2420|
                          DCD      recv_raw
                  |L1.2424|
                          DCD      recv_udp
                  |L1.2428|
00097c  e004              B        |L1.2440|
                  |L1.2430|
00097e  bf00              NOP                            ;874
                  |L1.2432|
000980  bf00              NOP                            ;853
000982  2000              MOVS     r0,#0                 ;876
000984  6821              LDR      r1,[r4,#0]            ;876
000986  6048              STR      r0,[r1,#4]            ;876
                  |L1.2440|
000988  6820              LDR      r0,[r4,#0]            ;882
00098a  f8d000e4          LDR      r0,[r0,#0xe4]         ;882
00098e  b128              CBZ      r0,|L1.2460|
000990  6820              LDR      r0,[r4,#0]            ;882
000992  2200              MOVS     r2,#0                 ;882
000994  4611              MOV      r1,r2                 ;882
000996  f8d030e4          LDR      r3,[r0,#0xe4]         ;882
00099a  4798              BLX      r3                    ;882
                  |L1.2460|
00099c  6820              LDR      r0,[r4,#0]            ;883
00099e  f8d000e4          LDR      r0,[r0,#0xe4]         ;883
0009a2  b128              CBZ      r0,|L1.2480|
0009a4  6820              LDR      r0,[r4,#0]            ;883
0009a6  2200              MOVS     r2,#0                 ;883
0009a8  2102              MOVS     r1,#2                 ;883
0009aa  f8d030e4          LDR      r3,[r0,#0xe4]         ;883
0009ae  4798              BLX      r3                    ;883
                  |L1.2480|
0009b0  6820              LDR      r0,[r4,#0]            ;885
0009b2  68c0              LDR      r0,[r0,#0xc]          ;885
0009b4  b108              CBZ      r0,|L1.2490|
0009b6  2001              MOVS     r0,#1                 ;885
0009b8  e000              B        |L1.2492|
                  |L1.2490|
0009ba  2000              MOVS     r0,#0                 ;885
                  |L1.2492|
0009bc  b120              CBZ      r0,|L1.2504|
0009be  6821              LDR      r1,[r4,#0]            ;886
0009c0  f101000c          ADD      r0,r1,#0xc            ;886
0009c4  f7fffffe          BL       sys_sem_signal
                  |L1.2504|
0009c8  bf00              NOP      
0009ca  e7ca              B        |L1.2402|
;;;889    
                          ENDP

                  do_bind PROC
;;;897    void
;;;898    do_bind(struct api_msg_msg *msg)
0009cc  b510              PUSH     {r4,lr}
;;;899    {
0009ce  4604              MOV      r4,r0
;;;900      if (ERR_IS_FATAL(msg->conn->last_err)) {
0009d0  6820              LDR      r0,[r4,#0]
0009d2  f9900008          LDRSB    r0,[r0,#8]
0009d6  f1100f09          CMN      r0,#9
0009da  da03              BGE      |L1.2532|
;;;901        msg->err = msg->conn->last_err;
0009dc  6820              LDR      r0,[r4,#0]
0009de  7a00              LDRB     r0,[r0,#8]
0009e0  7120              STRB     r0,[r4,#4]
0009e2  e027              B        |L1.2612|
                  |L1.2532|
;;;902      } else {
;;;903        msg->err = ERR_VAL;
0009e4  20fa              MOVS     r0,#0xfa
0009e6  7120              STRB     r0,[r4,#4]
;;;904        if (msg->conn->pcb.tcp != NULL) {
0009e8  6820              LDR      r0,[r4,#0]
0009ea  6840              LDR      r0,[r0,#4]
0009ec  b310              CBZ      r0,|L1.2612|
;;;905          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
0009ee  6820              LDR      r0,[r4,#0]
0009f0  7800              LDRB     r0,[r0,#0]
0009f2  f00000f0          AND      r0,r0,#0xf0
0009f6  2810              CMP      r0,#0x10
0009f8  d012              BEQ      |L1.2592|
0009fa  2820              CMP      r0,#0x20
0009fc  d008              BEQ      |L1.2576|
0009fe  2840              CMP      r0,#0x40
000a00  d116              BNE      |L1.2608|
;;;906    #if LWIP_RAW
;;;907          case NETCONN_RAW:
;;;908            msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
000a02  6822              LDR      r2,[r4,#0]
000a04  68a1              LDR      r1,[r4,#8]
000a06  6850              LDR      r0,[r2,#4]
000a08  f7fffffe          BL       raw_bind
000a0c  7120              STRB     r0,[r4,#4]
;;;909            break;
000a0e  e010              B        |L1.2610|
                  |L1.2576|
;;;910    #endif /* LWIP_RAW */
;;;911    #if LWIP_UDP
;;;912          case NETCONN_UDP:
;;;913            msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000a10  89a2              LDRH     r2,[r4,#0xc]
000a12  6823              LDR      r3,[r4,#0]
000a14  68a1              LDR      r1,[r4,#8]
000a16  6858              LDR      r0,[r3,#4]
000a18  f7fffffe          BL       udp_bind
000a1c  7120              STRB     r0,[r4,#4]
;;;914            break;
000a1e  e008              B        |L1.2610|
                  |L1.2592|
;;;915    #endif /* LWIP_UDP */
;;;916    #if LWIP_TCP
;;;917          case NETCONN_TCP:
;;;918            msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000a20  89a2              LDRH     r2,[r4,#0xc]
000a22  6823              LDR      r3,[r4,#0]
000a24  68a1              LDR      r1,[r4,#8]
000a26  6858              LDR      r0,[r3,#4]
000a28  f7fffffe          BL       tcp_bind
000a2c  7120              STRB     r0,[r4,#4]
;;;919            break;
000a2e  e000              B        |L1.2610|
                  |L1.2608|
;;;920    #endif /* LWIP_TCP */
;;;921          default:
;;;922            break;
000a30  bf00              NOP      
                  |L1.2610|
000a32  bf00              NOP                            ;909
                  |L1.2612|
;;;923          }
;;;924        }
;;;925      }
;;;926      TCPIP_APIMSG_ACK(msg);
000a34  6821              LDR      r1,[r4,#0]
000a36  f101000c          ADD      r0,r1,#0xc
000a3a  f7fffffe          BL       sys_sem_signal
;;;927    }
000a3e  bd10              POP      {r4,pc}
;;;928    
                          ENDP

                  do_connected PROC
;;;936    static err_t
;;;937    do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
000a40  e92d47f0          PUSH     {r4-r10,lr}
;;;938    {
000a44  4605              MOV      r5,r0
000a46  4689              MOV      r9,r1
000a48  4616              MOV      r6,r2
;;;939      struct netconn *conn;
;;;940      int was_blocking;
;;;941    
;;;942      LWIP_UNUSED_ARG(pcb);
;;;943    
;;;944      conn = (struct netconn *)arg;
000a4a  462c              MOV      r4,r5
;;;945    
;;;946      if (conn == NULL) {
000a4c  b91c              CBNZ     r4,|L1.2646|
;;;947        return ERR_VAL;
000a4e  f06f0005          MVN      r0,#5
                  |L1.2642|
;;;948      }
;;;949    
;;;950      LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
;;;951      LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
;;;952        (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));
;;;953    
;;;954      if (conn->current_msg != NULL) {
;;;955        conn->current_msg->err = err;
;;;956      }
;;;957      if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
;;;958        setup_tcp(conn);
;;;959      }
;;;960      was_blocking = !IN_NONBLOCKING_CONNECT(conn);
;;;961      SET_NONBLOCKING_CONNECT(conn, 0);
;;;962      conn->current_msg = NULL;
;;;963      conn->state = NETCONN_NONE;
;;;964      if (!was_blocking) {
;;;965        NETCONN_SET_SAFE_ERR(conn, ERR_OK);
;;;966      }
;;;967      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
;;;968    
;;;969      if (was_blocking) {
;;;970        sys_sem_signal(&conn->op_completed);
;;;971      }
;;;972      return ERR_OK;
;;;973    }
000a52  e8bd87f0          POP      {r4-r10,pc}
                  |L1.2646|
000a56  bf00              NOP                            ;950
000a58  bf00              NOP                            ;950
000a5a  bf00              NOP                            ;951
000a5c  bf00              NOP                            ;951
000a5e  f8d400e0          LDR      r0,[r4,#0xe0]         ;954
000a62  b110              CBZ      r0,|L1.2666|
000a64  f8d400e0          LDR      r0,[r4,#0xe0]         ;955
000a68  7106              STRB     r6,[r0,#4]            ;955
                  |L1.2666|
000a6a  7820              LDRB     r0,[r4,#0]            ;957
000a6c  2810              CMP      r0,#0x10              ;957
000a6e  d103              BNE      |L1.2680|
000a70  b916              CBNZ     r6,|L1.2680|
000a72  4620              MOV      r0,r4                 ;958
000a74  f7fffffe          BL       setup_tcp
                  |L1.2680|
000a78  f89400d8          LDRB     r0,[r4,#0xd8]         ;960
000a7c  2101              MOVS     r1,#1                 ;960
000a7e  ea210790          BIC      r7,r1,r0,LSR #2       ;960
000a82  bf00              NOP                            ;961
000a84  f89400d8          LDRB     r0,[r4,#0xd8]         ;961
000a88  f0200004          BIC      r0,r0,#4              ;961
000a8c  f88400d8          STRB     r0,[r4,#0xd8]         ;961
000a90  bf00              NOP                            ;961
000a92  2000              MOVS     r0,#0                 ;962
000a94  f8c400e0          STR      r0,[r4,#0xe0]         ;962
000a98  7060              STRB     r0,[r4,#1]            ;963
000a9a  b977              CBNZ     r7,|L1.2746|
000a9c  bf00              NOP                            ;965
000a9e  f7fffffe          BL       sys_arch_protect
000aa2  4680              MOV      r8,r0                 ;965
000aa4  f9940008          LDRSB    r0,[r4,#8]            ;965
000aa8  f1100f09          CMN      r0,#9                 ;965
000aac  db01              BLT      |L1.2738|
000aae  2000              MOVS     r0,#0                 ;965
000ab0  7220              STRB     r0,[r4,#8]            ;965
                  |L1.2738|
000ab2  4640              MOV      r0,r8                 ;965
000ab4  f7fffffe          BL       sys_arch_unprotect
000ab8  bf00              NOP                            ;965
                  |L1.2746|
000aba  f8d400e4          LDR      r0,[r4,#0xe4]         ;967
000abe  b128              CBZ      r0,|L1.2764|
000ac0  2200              MOVS     r2,#0                 ;967
000ac2  2102              MOVS     r1,#2                 ;967
000ac4  4620              MOV      r0,r4                 ;967
000ac6  f8d430e4          LDR      r3,[r4,#0xe4]         ;967
000aca  4798              BLX      r3                    ;967
                  |L1.2764|
000acc  b11f              CBZ      r7,|L1.2774|
000ace  f104000c          ADD      r0,r4,#0xc            ;970
000ad2  f7fffffe          BL       sys_sem_signal
                  |L1.2774|
000ad6  2000              MOVS     r0,#0                 ;972
000ad8  e7bb              B        |L1.2642|
;;;974    #endif /* LWIP_TCP */
                          ENDP

                  do_connect PROC
;;;983    void
;;;984    do_connect(struct api_msg_msg *msg)
000ada  b510              PUSH     {r4,lr}
;;;985    {
000adc  4604              MOV      r4,r0
;;;986      if (msg->conn->pcb.tcp == NULL) {
000ade  6820              LDR      r0,[r4,#0]
000ae0  6840              LDR      r0,[r0,#4]
000ae2  b910              CBNZ     r0,|L1.2794|
;;;987        /* This may happen when calling netconn_connect() a second time */
;;;988        msg->err = ERR_CLSD;
000ae4  20f4              MOVS     r0,#0xf4
000ae6  7120              STRB     r0,[r4,#4]
000ae8  e059              B        |L1.2974|
                  |L1.2794|
;;;989      } else {
;;;990        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000aea  6820              LDR      r0,[r4,#0]
000aec  7800              LDRB     r0,[r0,#0]
000aee  f00000f0          AND      r0,r0,#0xf0
000af2  2810              CMP      r0,#0x10
000af4  d012              BEQ      |L1.2844|
000af6  2820              CMP      r0,#0x20
000af8  d008              BEQ      |L1.2828|
000afa  2840              CMP      r0,#0x40
000afc  d147              BNE      |L1.2958|
;;;991    #if LWIP_RAW
;;;992      case NETCONN_RAW:
;;;993        msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
000afe  6822              LDR      r2,[r4,#0]
000b00  68a1              LDR      r1,[r4,#8]
000b02  6850              LDR      r0,[r2,#4]
000b04  f7fffffe          BL       raw_connect
000b08  7120              STRB     r0,[r4,#4]
;;;994        break;
000b0a  e047              B        |L1.2972|
                  |L1.2828|
;;;995    #endif /* LWIP_RAW */
;;;996    #if LWIP_UDP
;;;997      case NETCONN_UDP:
;;;998        msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000b0c  89a2              LDRH     r2,[r4,#0xc]
000b0e  6823              LDR      r3,[r4,#0]
000b10  68a1              LDR      r1,[r4,#8]
000b12  6858              LDR      r0,[r3,#4]
000b14  f7fffffe          BL       udp_connect
000b18  7120              STRB     r0,[r4,#4]
;;;999        break;
000b1a  e03f              B        |L1.2972|
                  |L1.2844|
;;;1000   #endif /* LWIP_UDP */
;;;1001   #if LWIP_TCP
;;;1002     case NETCONN_TCP:
;;;1003       /* Prevent connect while doing any other action. */
;;;1004       if (msg->conn->state != NETCONN_NONE) {
000b1c  6820              LDR      r0,[r4,#0]
000b1e  7840              LDRB     r0,[r0,#1]
000b20  b110              CBZ      r0,|L1.2856|
;;;1005         msg->err = ERR_ISCONN;
000b22  20f7              MOVS     r0,#0xf7
000b24  7120              STRB     r0,[r4,#4]
000b26  e031              B        |L1.2956|
                  |L1.2856|
;;;1006       } else {
;;;1007         setup_tcp(msg->conn);
000b28  6820              LDR      r0,[r4,#0]
000b2a  f7fffffe          BL       setup_tcp
;;;1008         msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
000b2e  89a2              LDRH     r2,[r4,#0xc]
000b30  6823              LDR      r3,[r4,#0]
000b32  68a1              LDR      r1,[r4,#8]
000b34  6858              LDR      r0,[r3,#4]
000b36  4bfe              LDR      r3,|L1.3888|
000b38  f7fffffe          BL       tcp_connect
000b3c  7120              STRB     r0,[r4,#4]
;;;1009           msg->msg.bc.port, do_connected);
;;;1010         if (msg->err == ERR_OK) {
000b3e  7920              LDRB     r0,[r4,#4]
000b40  bb20              CBNZ     r0,|L1.2956|
;;;1011           u8_t non_blocking = netconn_is_nonblocking(msg->conn);
000b42  6821              LDR      r1,[r4,#0]
000b44  f89110d8          LDRB     r1,[r1,#0xd8]
000b48  f3c10040          UBFX     r0,r1,#1,#1
;;;1012           msg->conn->state = NETCONN_CONNECT;
000b4c  2103              MOVS     r1,#3
000b4e  6822              LDR      r2,[r4,#0]
000b50  7051              STRB     r1,[r2,#1]
;;;1013           SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
000b52  bf00              NOP      
000b54  b140              CBZ      r0,|L1.2920|
000b56  6821              LDR      r1,[r4,#0]
000b58  f89110d8          LDRB     r1,[r1,#0xd8]
000b5c  f0410104          ORR      r1,r1,#4
000b60  6822              LDR      r2,[r4,#0]
000b62  f88210d8          STRB     r1,[r2,#0xd8]
000b66  e007              B        |L1.2936|
                  |L1.2920|
000b68  6821              LDR      r1,[r4,#0]
000b6a  f89110d8          LDRB     r1,[r1,#0xd8]
000b6e  f0210104          BIC      r1,r1,#4
000b72  6822              LDR      r2,[r4,#0]
000b74  f88210d8          STRB     r1,[r2,#0xd8]
                  |L1.2936|
000b78  bf00              NOP      
;;;1014           if (non_blocking) {
000b7a  b110              CBZ      r0,|L1.2946|
;;;1015             msg->err = ERR_INPROGRESS;
000b7c  21fb              MOVS     r1,#0xfb
000b7e  7121              STRB     r1,[r4,#4]
000b80  e003              B        |L1.2954|
                  |L1.2946|
;;;1016           } else {
;;;1017             msg->conn->current_msg = msg;
000b82  6821              LDR      r1,[r4,#0]
000b84  f8c140e0          STR      r4,[r1,#0xe0]
                  |L1.2952|
;;;1018             /* sys_sem_signal() is called from do_connected (or err_tcp()),
;;;1019             * when the connection is established! */
;;;1020             return;
;;;1021           }
;;;1022         }
;;;1023       }
;;;1024       break;
;;;1025   #endif /* LWIP_TCP */
;;;1026     default:
;;;1027       LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
;;;1028       break;
;;;1029       }
;;;1030     }
;;;1031     sys_sem_signal(&msg->conn->op_completed);
;;;1032   }
000b88  bd10              POP      {r4,pc}
                  |L1.2954|
000b8a  bf00              NOP                            ;1022
                  |L1.2956|
000b8c  e006              B        |L1.2972|
                  |L1.2958|
000b8e  bf00              NOP                            ;1027
000b90  bf00              NOP                            ;1027
000b92  20fa              MOVS     r0,#0xfa              ;1027
000b94  7120              STRB     r0,[r4,#4]            ;1027
000b96  bf00              NOP                            ;1027
000b98  bf00              NOP                            ;1027
000b9a  bf00              NOP                            ;1028
                  |L1.2972|
000b9c  bf00              NOP                            ;994
                  |L1.2974|
000b9e  6821              LDR      r1,[r4,#0]            ;1031
000ba0  f101000c          ADD      r0,r1,#0xc            ;1031
000ba4  f7fffffe          BL       sys_sem_signal
000ba8  bf00              NOP      
000baa  e7ed              B        |L1.2952|
;;;1033   
                          ENDP

                  do_disconnect PROC
;;;1041   void
;;;1042   do_disconnect(struct api_msg_msg *msg)
000bac  b510              PUSH     {r4,lr}
;;;1043   {
000bae  4604              MOV      r4,r0
;;;1044   #if LWIP_UDP
;;;1045     if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
000bb0  6820              LDR      r0,[r4,#0]
000bb2  7800              LDRB     r0,[r0,#0]
000bb4  f00000f0          AND      r0,r0,#0xf0
000bb8  2820              CMP      r0,#0x20
000bba  d106              BNE      |L1.3018|
;;;1046       udp_disconnect(msg->conn->pcb.udp);
000bbc  6821              LDR      r1,[r4,#0]
000bbe  6848              LDR      r0,[r1,#4]
000bc0  f7fffffe          BL       udp_disconnect
;;;1047       msg->err = ERR_OK;
000bc4  2000              MOVS     r0,#0
000bc6  7120              STRB     r0,[r4,#4]
000bc8  e001              B        |L1.3022|
                  |L1.3018|
;;;1048     } else
;;;1049   #endif /* LWIP_UDP */
;;;1050     {
;;;1051       msg->err = ERR_VAL;
000bca  20fa              MOVS     r0,#0xfa
000bcc  7120              STRB     r0,[r4,#4]
                  |L1.3022|
;;;1052     }
;;;1053     TCPIP_APIMSG_ACK(msg);
000bce  6821              LDR      r1,[r4,#0]
000bd0  f101000c          ADD      r0,r1,#0xc
000bd4  f7fffffe          BL       sys_sem_signal
;;;1054   }
000bd8  bd10              POP      {r4,pc}
;;;1055   
                          ENDP

                  do_listen PROC
;;;1063   void
;;;1064   do_listen(struct api_msg_msg *msg)
000bda  b570              PUSH     {r4-r6,lr}
;;;1065   {
000bdc  4604              MOV      r4,r0
;;;1066     if (ERR_IS_FATAL(msg->conn->last_err)) {
000bde  6820              LDR      r0,[r4,#0]
000be0  f9900008          LDRSB    r0,[r0,#8]
000be4  f1100f09          CMN      r0,#9
000be8  da03              BGE      |L1.3058|
;;;1067       msg->err = msg->conn->last_err;
000bea  6820              LDR      r0,[r4,#0]
000bec  7a00              LDRB     r0,[r0,#8]
000bee  7120              STRB     r0,[r4,#4]
000bf0  e050              B        |L1.3220|
                  |L1.3058|
;;;1068     } else {
;;;1069       msg->err = ERR_CONN;
000bf2  20f3              MOVS     r0,#0xf3
000bf4  7120              STRB     r0,[r4,#4]
;;;1070       if (msg->conn->pcb.tcp != NULL) {
000bf6  6820              LDR      r0,[r4,#0]
000bf8  6840              LDR      r0,[r0,#4]
000bfa  2800              CMP      r0,#0
000bfc  d04a              BEQ      |L1.3220|
;;;1071         if (msg->conn->type == NETCONN_TCP) {
000bfe  6820              LDR      r0,[r4,#0]
000c00  7800              LDRB     r0,[r0,#0]
000c02  2810              CMP      r0,#0x10
000c04  d144              BNE      |L1.3216|
;;;1072           if (msg->conn->state == NETCONN_NONE) {
000c06  6820              LDR      r0,[r4,#0]
000c08  7840              LDRB     r0,[r0,#1]
000c0a  2800              CMP      r0,#0
000c0c  d142              BNE      |L1.3220|
;;;1073   #if TCP_LISTEN_BACKLOG
;;;1074             struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
000c0e  7a21              LDRB     r1,[r4,#8]
000c10  6822              LDR      r2,[r4,#0]
000c12  6850              LDR      r0,[r2,#4]
000c14  f7fffffe          BL       tcp_listen_with_backlog
000c18  4605              MOV      r5,r0
;;;1075   #else  /* TCP_LISTEN_BACKLOG */
;;;1076             struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
;;;1077   #endif /* TCP_LISTEN_BACKLOG */
;;;1078             if (lpcb == NULL) {
000c1a  b915              CBNZ     r5,|L1.3106|
;;;1079               /* in this case, the old pcb is still allocated */
;;;1080               msg->err = ERR_MEM;
000c1c  20ff              MOVS     r0,#0xff
000c1e  7120              STRB     r0,[r4,#4]
000c20  e035              B        |L1.3214|
                  |L1.3106|
;;;1081             } else {
;;;1082               /* delete the recvmbox and allocate the acceptmbox */
;;;1083               if (sys_mbox_valid(&msg->conn->recvmbox)) {
000c22  6820              LDR      r0,[r4,#0]
000c24  69c0              LDR      r0,[r0,#0x1c]
000c26  b108              CBZ      r0,|L1.3116|
000c28  2001              MOVS     r0,#1
000c2a  e000              B        |L1.3118|
                  |L1.3116|
000c2c  2000              MOVS     r0,#0
                  |L1.3118|
000c2e  b138              CBZ      r0,|L1.3136|
;;;1084                 /** @todo: should we drain the recvmbox here? */
;;;1085                 sys_mbox_free(&msg->conn->recvmbox);
000c30  6821              LDR      r1,[r4,#0]
000c32  f101001c          ADD      r0,r1,#0x1c
000c36  f7fffffe          BL       sys_mbox_free
;;;1086                 sys_mbox_set_invalid(&msg->conn->recvmbox);
000c3a  2000              MOVS     r0,#0
000c3c  6821              LDR      r1,[r4,#0]
000c3e  61c8              STR      r0,[r1,#0x1c]
                  |L1.3136|
;;;1087               }
;;;1088               msg->err = ERR_OK;
000c40  2000              MOVS     r0,#0
000c42  7120              STRB     r0,[r4,#4]
;;;1089               if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
000c44  6820              LDR      r0,[r4,#0]
000c46  6f80              LDR      r0,[r0,#0x78]
000c48  b108              CBZ      r0,|L1.3150|
000c4a  2001              MOVS     r0,#1
000c4c  e000              B        |L1.3152|
                  |L1.3150|
000c4e  2000              MOVS     r0,#0
                  |L1.3152|
000c50  b930              CBNZ     r0,|L1.3168|
;;;1090                 msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
000c52  6821              LDR      r1,[r4,#0]
000c54  f1010078          ADD      r0,r1,#0x78
000c58  2110              MOVS     r1,#0x10
000c5a  f7fffffe          BL       sys_mbox_new
000c5e  7120              STRB     r0,[r4,#4]
                  |L1.3168|
;;;1091               }
;;;1092               if (msg->err == ERR_OK) {
000c60  7920              LDRB     r0,[r4,#4]
000c62  b970              CBNZ     r0,|L1.3202|
;;;1093                 msg->conn->state = NETCONN_LISTEN;
000c64  2002              MOVS     r0,#2
000c66  6821              LDR      r1,[r4,#0]
000c68  7048              STRB     r0,[r1,#1]
;;;1094                 msg->conn->pcb.tcp = lpcb;
000c6a  6820              LDR      r0,[r4,#0]
000c6c  6045              STR      r5,[r0,#4]
;;;1095                 tcp_arg(msg->conn->pcb.tcp, msg->conn);
000c6e  6821              LDR      r1,[r4,#0]
000c70  6848              LDR      r0,[r1,#4]
000c72  f7fffffe          BL       tcp_arg
;;;1096                 tcp_accept(msg->conn->pcb.tcp, accept_function);
000c76  6821              LDR      r1,[r4,#0]
000c78  6848              LDR      r0,[r1,#4]
000c7a  49ae              LDR      r1,|L1.3892|
000c7c  f7fffffe          BL       tcp_accept
000c80  e005              B        |L1.3214|
                  |L1.3202|
;;;1097               } else {
;;;1098                 /* since the old pcb is already deallocated, free lpcb now */
;;;1099                 tcp_close(lpcb);
000c82  4628              MOV      r0,r5
000c84  f7fffffe          BL       tcp_close
;;;1100                 msg->conn->pcb.tcp = NULL;
000c88  2000              MOVS     r0,#0
000c8a  6821              LDR      r1,[r4,#0]
000c8c  6048              STR      r0,[r1,#4]
                  |L1.3214|
;;;1101               }
;;;1102             }
;;;1103           }
000c8e  e001              B        |L1.3220|
                  |L1.3216|
;;;1104         } else {
;;;1105           msg->err = ERR_ARG;
000c90  20f2              MOVS     r0,#0xf2
000c92  7120              STRB     r0,[r4,#4]
                  |L1.3220|
;;;1106         }
;;;1107       }
;;;1108     }
;;;1109     TCPIP_APIMSG_ACK(msg);
000c94  6821              LDR      r1,[r4,#0]
000c96  f101000c          ADD      r0,r1,#0xc
000c9a  f7fffffe          BL       sys_sem_signal
;;;1110   }
000c9e  bd70              POP      {r4-r6,pc}
;;;1111   #endif /* LWIP_TCP */
                          ENDP

                  do_send PROC
;;;1119   void
;;;1120   do_send(struct api_msg_msg *msg)
000ca0  b570              PUSH     {r4-r6,lr}
;;;1121   {
000ca2  4604              MOV      r4,r0
;;;1122     if (ERR_IS_FATAL(msg->conn->last_err)) {
000ca4  6820              LDR      r0,[r4,#0]
000ca6  f9900008          LDRSB    r0,[r0,#8]
000caa  f1100f09          CMN      r0,#9
000cae  da03              BGE      |L1.3256|
;;;1123       msg->err = msg->conn->last_err;
000cb0  6820              LDR      r0,[r4,#0]
000cb2  7a00              LDRB     r0,[r0,#8]
000cb4  7120              STRB     r0,[r4,#4]
000cb6  e040              B        |L1.3386|
                  |L1.3256|
;;;1124     } else {
;;;1125       msg->err = ERR_CONN;
000cb8  20f3              MOVS     r0,#0xf3
000cba  7120              STRB     r0,[r4,#4]
;;;1126       if (msg->conn->pcb.tcp != NULL) {
000cbc  6820              LDR      r0,[r4,#0]
000cbe  6840              LDR      r0,[r0,#4]
000cc0  2800              CMP      r0,#0
000cc2  d03a              BEQ      |L1.3386|
;;;1127         switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000cc4  6820              LDR      r0,[r4,#0]
000cc6  7800              LDRB     r0,[r0,#0]
000cc8  f00000f0          AND      r0,r0,#0xf0
000ccc  2820              CMP      r0,#0x20
000cce  d019              BEQ      |L1.3332|
000cd0  2840              CMP      r0,#0x40
000cd2  d130              BNE      |L1.3382|
;;;1128   #if LWIP_RAW
;;;1129         case NETCONN_RAW:
;;;1130           if (ip_addr_isany(&msg->msg.b->addr)) {
000cd4  68a0              LDR      r0,[r4,#8]
000cd6  3008              ADDS     r0,r0,#8
000cd8  b110              CBZ      r0,|L1.3296|
000cda  68a0              LDR      r0,[r4,#8]
000cdc  6880              LDR      r0,[r0,#8]
000cde  b938              CBNZ     r0,|L1.3312|
                  |L1.3296|
;;;1131             msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
000ce0  68a2              LDR      r2,[r4,#8]
000ce2  6811              LDR      r1,[r2,#0]
000ce4  6822              LDR      r2,[r4,#0]
000ce6  6850              LDR      r0,[r2,#4]
000ce8  f7fffffe          BL       raw_send
000cec  7120              STRB     r0,[r4,#4]
000cee  e008              B        |L1.3330|
                  |L1.3312|
;;;1132           } else {
;;;1133             msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
000cf0  68a3              LDR      r3,[r4,#8]
000cf2  f1030208          ADD      r2,r3,#8
000cf6  6819              LDR      r1,[r3,#0]
000cf8  6823              LDR      r3,[r4,#0]
000cfa  6858              LDR      r0,[r3,#4]
000cfc  f7fffffe          BL       raw_sendto
000d00  7120              STRB     r0,[r4,#4]
                  |L1.3330|
;;;1134           }
;;;1135           break;
000d02  e019              B        |L1.3384|
                  |L1.3332|
;;;1136   #endif
;;;1137   #if LWIP_UDP
;;;1138         case NETCONN_UDP:
;;;1139   #if LWIP_CHECKSUM_ON_COPY
;;;1140           if (ip_addr_isany(&msg->msg.b->addr)) {
;;;1141             msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1142               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1143           } else {
;;;1144             msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1145               &msg->msg.b->addr, msg->msg.b->port,
;;;1146               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1147           }
;;;1148   #else /* LWIP_CHECKSUM_ON_COPY */
;;;1149           if (ip_addr_isany(&msg->msg.b->addr)) {
000d04  68a0              LDR      r0,[r4,#8]
000d06  3008              ADDS     r0,r0,#8
000d08  b110              CBZ      r0,|L1.3344|
000d0a  68a0              LDR      r0,[r4,#8]
000d0c  6880              LDR      r0,[r0,#8]
000d0e  b938              CBNZ     r0,|L1.3360|
                  |L1.3344|
;;;1150             msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
000d10  68a2              LDR      r2,[r4,#8]
000d12  6811              LDR      r1,[r2,#0]
000d14  6822              LDR      r2,[r4,#0]
000d16  6850              LDR      r0,[r2,#4]
000d18  f7fffffe          BL       udp_send
000d1c  7120              STRB     r0,[r4,#4]
000d1e  e009              B        |L1.3380|
                  |L1.3360|
;;;1151           } else {
;;;1152             msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
000d20  68a5              LDR      r5,[r4,#8]
000d22  89ab              LDRH     r3,[r5,#0xc]
000d24  f1050208          ADD      r2,r5,#8
000d28  6829              LDR      r1,[r5,#0]
000d2a  6825              LDR      r5,[r4,#0]
000d2c  6868              LDR      r0,[r5,#4]
000d2e  f7fffffe          BL       udp_sendto
000d32  7120              STRB     r0,[r4,#4]
                  |L1.3380|
;;;1153           }
;;;1154   #endif /* LWIP_CHECKSUM_ON_COPY */
;;;1155           break;
000d34  e000              B        |L1.3384|
                  |L1.3382|
;;;1156   #endif /* LWIP_UDP */
;;;1157         default:
;;;1158           break;
000d36  bf00              NOP      
                  |L1.3384|
000d38  bf00              NOP                            ;1135
                  |L1.3386|
;;;1159         }
;;;1160       }
;;;1161     }
;;;1162     TCPIP_APIMSG_ACK(msg);
000d3a  6821              LDR      r1,[r4,#0]
000d3c  f101000c          ADD      r0,r1,#0xc
000d40  f7fffffe          BL       sys_sem_signal
;;;1163   }
000d44  bd70              POP      {r4-r6,pc}
;;;1164   
                          ENDP

                  do_recv PROC
;;;1172   void
;;;1173   do_recv(struct api_msg_msg *msg)
000d46  b570              PUSH     {r4-r6,lr}
;;;1174   {
000d48  4604              MOV      r4,r0
;;;1175     msg->err = ERR_OK;
000d4a  2000              MOVS     r0,#0
000d4c  7120              STRB     r0,[r4,#4]
;;;1176     if (msg->conn->pcb.tcp != NULL) {
000d4e  6820              LDR      r0,[r4,#0]
000d50  6840              LDR      r0,[r0,#4]
000d52  b330              CBZ      r0,|L1.3490|
;;;1177       if (msg->conn->type == NETCONN_TCP) {
000d54  6820              LDR      r0,[r4,#0]
000d56  7800              LDRB     r0,[r0,#0]
000d58  2810              CMP      r0,#0x10
000d5a  d122              BNE      |L1.3490|
;;;1178   #if TCP_LISTEN_BACKLOG
;;;1179         if (msg->conn->pcb.tcp->state == LISTEN) {
000d5c  6820              LDR      r0,[r4,#0]
000d5e  6840              LDR      r0,[r0,#4]
000d60  7e00              LDRB     r0,[r0,#0x18]
000d62  2801              CMP      r0,#1
000d64  d10a              BNE      |L1.3452|
;;;1180           tcp_accepted(msg->conn->pcb.tcp);
000d66  bf00              NOP      
000d68  bf00              NOP      
000d6a  bf00              NOP      
000d6c  6820              LDR      r0,[r4,#0]
000d6e  6840              LDR      r0,[r0,#4]
000d70  7f40              LDRB     r0,[r0,#0x1d]
000d72  1e40              SUBS     r0,r0,#1
000d74  6821              LDR      r1,[r4,#0]
000d76  6849              LDR      r1,[r1,#4]
000d78  7748              STRB     r0,[r1,#0x1d]
000d7a  e012              B        |L1.3490|
                  |L1.3452|
;;;1181         } else
;;;1182   #endif /* TCP_LISTEN_BACKLOG */
;;;1183         {
;;;1184           u32_t remaining = msg->msg.r.len;
000d7c  68a5              LDR      r5,[r4,#8]
;;;1185           do {
000d7e  bf00              NOP      
                  |L1.3456|
;;;1186             u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
000d80  f5b53f80          CMP      r5,#0x10000
000d84  d302              BCC      |L1.3468|
000d86  f64f70ff          MOV      r0,#0xffff
000d8a  e000              B        |L1.3470|
                  |L1.3468|
000d8c  b2a8              UXTH     r0,r5
                  |L1.3470|
000d8e  4606              MOV      r6,r0
;;;1187             tcp_recved(msg->conn->pcb.tcp, recved);
000d90  6821              LDR      r1,[r4,#0]
000d92  6848              LDR      r0,[r1,#4]
000d94  4631              MOV      r1,r6
000d96  f7fffffe          BL       tcp_recved
;;;1188             remaining -= recved;
000d9a  1bad              SUBS     r5,r5,r6
;;;1189           }while(remaining != 0);
000d9c  2d00              CMP      r5,#0
000d9e  d1ef              BNE      |L1.3456|
;;;1190         }
000da0  bf00              NOP      
                  |L1.3490|
;;;1191       }
;;;1192     }
;;;1193     TCPIP_APIMSG_ACK(msg);
000da2  6821              LDR      r1,[r4,#0]
000da4  f101000c          ADD      r0,r1,#0xc
000da8  f7fffffe          BL       sys_sem_signal
;;;1194   }
000dac  bd70              POP      {r4-r6,pc}
;;;1195   
                          ENDP

                  do_write PROC
;;;1342   void
;;;1343   do_write(struct api_msg_msg *msg)
000dae  b510              PUSH     {r4,lr}
;;;1344   {
000db0  4604              MOV      r4,r0
;;;1345     if (ERR_IS_FATAL(msg->conn->last_err)) {
000db2  6820              LDR      r0,[r4,#0]
000db4  f9900008          LDRSB    r0,[r0,#8]
000db8  f1100f09          CMN      r0,#9
000dbc  da03              BGE      |L1.3526|
;;;1346       msg->err = msg->conn->last_err;
000dbe  6820              LDR      r0,[r4,#0]
000dc0  7a00              LDRB     r0,[r0,#8]
000dc2  7120              STRB     r0,[r4,#4]
000dc4  e023              B        |L1.3598|
                  |L1.3526|
;;;1347     } else {
;;;1348       if (msg->conn->type == NETCONN_TCP) {
000dc6  6820              LDR      r0,[r4,#0]
000dc8  7800              LDRB     r0,[r0,#0]
000dca  2810              CMP      r0,#0x10
000dcc  d11d              BNE      |L1.3594|
;;;1349   #if LWIP_TCP
;;;1350         if (msg->conn->state != NETCONN_NONE) {
000dce  6820              LDR      r0,[r4,#0]
000dd0  7840              LDRB     r0,[r0,#1]
000dd2  b110              CBZ      r0,|L1.3546|
;;;1351           /* netconn is connecting, closing or in blocking write */
;;;1352           msg->err = ERR_INPROGRESS;
000dd4  20fb              MOVS     r0,#0xfb
000dd6  7120              STRB     r0,[r4,#4]
000dd8  e019              B        |L1.3598|
                  |L1.3546|
;;;1353         } else if (msg->conn->pcb.tcp != NULL) {
000dda  6820              LDR      r0,[r4,#0]
000ddc  6840              LDR      r0,[r0,#4]
000dde  b188              CBZ      r0,|L1.3588|
;;;1354           msg->conn->state = NETCONN_WRITE;
000de0  2001              MOVS     r0,#1
000de2  6821              LDR      r1,[r4,#0]
000de4  7048              STRB     r0,[r1,#1]
;;;1355           /* set all the variables used by do_writemore */
;;;1356           LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
000de6  bf00              NOP      
000de8  bf00              NOP      
;;;1357             msg->conn->write_offset == 0);
;;;1358           LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
000dea  bf00              NOP      
000dec  bf00              NOP      
;;;1359           msg->conn->current_msg = msg;
000dee  6820              LDR      r0,[r4,#0]
000df0  f8c040e0          STR      r4,[r0,#0xe0]
;;;1360           msg->conn->write_offset = 0;
000df4  2000              MOVS     r0,#0
000df6  6821              LDR      r1,[r4,#0]
000df8  f8c100dc          STR      r0,[r1,#0xdc]
;;;1361   #if LWIP_TCPIP_CORE_LOCKING
;;;1362           msg->conn->flags &= ~NETCONN_FLAG_WRITE_DELAYED;
;;;1363           if (do_writemore(msg->conn) != ERR_OK) {
;;;1364             LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
;;;1365             UNLOCK_TCPIP_CORE();
;;;1366             sys_arch_sem_wait(&msg->conn->op_completed, 0);
;;;1367             LOCK_TCPIP_CORE();
;;;1368             LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
;;;1369           }
;;;1370   #else /* LWIP_TCPIP_CORE_LOCKING */
;;;1371           do_writemore(msg->conn);
000dfc  6820              LDR      r0,[r4,#0]
000dfe  f7fffffe          BL       do_writemore
                  |L1.3586|
;;;1372   #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;1373           /* for both cases: if do_writemore was called, don't ACK the APIMSG
;;;1374              since do_writemore ACKs it! */
;;;1375           return;
;;;1376         } else {
;;;1377           msg->err = ERR_CONN;
;;;1378         }
;;;1379   #else /* LWIP_TCP */
;;;1380         msg->err = ERR_VAL;
;;;1381   #endif /* LWIP_TCP */
;;;1382   #if (LWIP_UDP || LWIP_RAW)
;;;1383       } else {
;;;1384         msg->err = ERR_VAL;
;;;1385   #endif /* (LWIP_UDP || LWIP_RAW) */
;;;1386       }
;;;1387     }
;;;1388     TCPIP_APIMSG_ACK(msg);
;;;1389   }
000e02  bd10              POP      {r4,pc}
                  |L1.3588|
000e04  20f3              MOVS     r0,#0xf3              ;1377
000e06  7120              STRB     r0,[r4,#4]            ;1377
000e08  e001              B        |L1.3598|
                  |L1.3594|
000e0a  20fa              MOVS     r0,#0xfa              ;1384
000e0c  7120              STRB     r0,[r4,#4]            ;1384
                  |L1.3598|
000e0e  6821              LDR      r1,[r4,#0]            ;1388
000e10  f101000c          ADD      r0,r1,#0xc            ;1388
000e14  f7fffffe          BL       sys_sem_signal
000e18  bf00              NOP      
000e1a  e7f2              B        |L1.3586|
;;;1390   
                          ENDP

                  do_getaddr PROC
;;;1397   void
;;;1398   do_getaddr(struct api_msg_msg *msg)
000e1c  b510              PUSH     {r4,lr}
;;;1399   {
000e1e  4604              MOV      r4,r0
;;;1400     if (msg->conn->pcb.ip != NULL) {
000e20  6820              LDR      r0,[r4,#0]
000e22  6840              LDR      r0,[r0,#4]
000e24  2800              CMP      r0,#0
000e26  d04a              BEQ      |L1.3774|
;;;1401       *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
000e28  7c20              LDRB     r0,[r4,#0x10]
000e2a  b128              CBZ      r0,|L1.3640|
000e2c  6821              LDR      r1,[r4,#0]
000e2e  68a0              LDR      r0,[r4,#8]
000e30  6849              LDR      r1,[r1,#4]
000e32  6809              LDR      r1,[r1,#0]
000e34  6001              STR      r1,[r0,#0]
000e36  e004              B        |L1.3650|
                  |L1.3640|
000e38  6821              LDR      r1,[r4,#0]
000e3a  68a0              LDR      r0,[r4,#8]
000e3c  6849              LDR      r1,[r1,#4]
000e3e  6849              LDR      r1,[r1,#4]
000e40  6001              STR      r1,[r0,#0]
                  |L1.3650|
;;;1402                                msg->conn->pcb.ip->remote_ip);
;;;1403   
;;;1404       msg->err = ERR_OK;
000e42  2000              MOVS     r0,#0
000e44  7120              STRB     r0,[r4,#4]
;;;1405       switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000e46  6820              LDR      r0,[r4,#0]
000e48  7800              LDRB     r0,[r0,#0]
000e4a  f00000f0          AND      r0,r0,#0xf0
000e4e  2810              CMP      r0,#0x10
000e50  d025              BEQ      |L1.3742|
000e52  2820              CMP      r0,#0x20
000e54  d00c              BEQ      |L1.3696|
000e56  2840              CMP      r0,#0x40
000e58  d12d              BNE      |L1.3766|
;;;1406   #if LWIP_RAW
;;;1407       case NETCONN_RAW:
;;;1408         if (msg->msg.ad.local) {
000e5a  7c20              LDRB     r0,[r4,#0x10]
000e5c  b128              CBZ      r0,|L1.3690|
;;;1409           *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
000e5e  6820              LDR      r0,[r4,#0]
000e60  6840              LDR      r0,[r0,#4]
000e62  7c01              LDRB     r1,[r0,#0x10]
000e64  68e0              LDR      r0,[r4,#0xc]
000e66  8001              STRH     r1,[r0,#0]
000e68  e001              B        |L1.3694|
                  |L1.3690|
;;;1410         } else {
;;;1411           /* return an error as connecting is only a helper for upper layers */
;;;1412           msg->err = ERR_CONN;
000e6a  20f3              MOVS     r0,#0xf3
000e6c  7120              STRB     r0,[r4,#4]
                  |L1.3694|
;;;1413         }
;;;1414         break;
000e6e  e025              B        |L1.3772|
                  |L1.3696|
;;;1415   #endif /* LWIP_RAW */
;;;1416   #if LWIP_UDP
;;;1417       case NETCONN_UDP:
;;;1418         if (msg->msg.ad.local) {
000e70  7c20              LDRB     r0,[r4,#0x10]
000e72  b128              CBZ      r0,|L1.3712|
;;;1419           *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
000e74  6820              LDR      r0,[r4,#0]
000e76  6840              LDR      r0,[r0,#4]
000e78  8a41              LDRH     r1,[r0,#0x12]
000e7a  68e0              LDR      r0,[r4,#0xc]
000e7c  8001              STRH     r1,[r0,#0]
000e7e  e00d              B        |L1.3740|
                  |L1.3712|
;;;1420         } else {
;;;1421           if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
000e80  6820              LDR      r0,[r4,#0]
000e82  6840              LDR      r0,[r0,#4]
000e84  7c00              LDRB     r0,[r0,#0x10]
000e86  f0000004          AND      r0,r0,#4
000e8a  b910              CBNZ     r0,|L1.3730|
;;;1422             msg->err = ERR_CONN;
000e8c  20f3              MOVS     r0,#0xf3
000e8e  7120              STRB     r0,[r4,#4]
000e90  e004              B        |L1.3740|
                  |L1.3730|
;;;1423           } else {
;;;1424             *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
000e92  6820              LDR      r0,[r4,#0]
000e94  6840              LDR      r0,[r0,#4]
000e96  8a81              LDRH     r1,[r0,#0x14]
000e98  68e0              LDR      r0,[r4,#0xc]
000e9a  8001              STRH     r1,[r0,#0]
                  |L1.3740|
;;;1425           }
;;;1426         }
;;;1427         break;
000e9c  e00e              B        |L1.3772|
                  |L1.3742|
;;;1428   #endif /* LWIP_UDP */
;;;1429   #if LWIP_TCP
;;;1430       case NETCONN_TCP:
;;;1431         *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
000e9e  7c20              LDRB     r0,[r4,#0x10]
000ea0  b118              CBZ      r0,|L1.3754|
000ea2  6820              LDR      r0,[r4,#0]
000ea4  6840              LDR      r0,[r0,#4]
000ea6  8b40              LDRH     r0,[r0,#0x1a]
000ea8  e002              B        |L1.3760|
                  |L1.3754|
000eaa  6820              LDR      r0,[r4,#0]
000eac  6840              LDR      r0,[r0,#4]
000eae  8b80              LDRH     r0,[r0,#0x1c]
                  |L1.3760|
000eb0  68e1              LDR      r1,[r4,#0xc]
000eb2  8008              STRH     r0,[r1,#0]
;;;1432         break;
000eb4  e002              B        |L1.3772|
                  |L1.3766|
;;;1433   #endif /* LWIP_TCP */
;;;1434       default:
;;;1435         LWIP_ASSERT("invalid netconn_type", 0);
000eb6  bf00              NOP      
000eb8  bf00              NOP      
;;;1436         break;
000eba  bf00              NOP      
                  |L1.3772|
000ebc  e001              B        |L1.3778|
                  |L1.3774|
;;;1437       }
;;;1438     } else {
;;;1439       msg->err = ERR_CONN;
000ebe  20f3              MOVS     r0,#0xf3
000ec0  7120              STRB     r0,[r4,#4]
                  |L1.3778|
;;;1440     }
;;;1441     TCPIP_APIMSG_ACK(msg);
000ec2  6821              LDR      r1,[r4,#0]
000ec4  f101000c          ADD      r0,r1,#0xc
000ec8  f7fffffe          BL       sys_sem_signal
;;;1442   }
000ecc  bd10              POP      {r4,pc}
;;;1443   
                          ENDP

                  do_close PROC
;;;1450   void
;;;1451   do_close(struct api_msg_msg *msg)
000ece  b510              PUSH     {r4,lr}
;;;1452   {
000ed0  4604              MOV      r4,r0
;;;1453   #if LWIP_TCP
;;;1454     /* @todo: abort running write/connect? */
;;;1455     if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
000ed2  6820              LDR      r0,[r4,#0]
000ed4  7840              LDRB     r0,[r0,#1]
000ed6  b140              CBZ      r0,|L1.3818|
000ed8  6820              LDR      r0,[r4,#0]
000eda  7840              LDRB     r0,[r0,#1]
000edc  2802              CMP      r0,#2
000ede  d004              BEQ      |L1.3818|
;;;1456       /* this only happens for TCP netconns */
;;;1457       LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
000ee0  bf00              NOP      
000ee2  bf00              NOP      
;;;1458       msg->err = ERR_INPROGRESS;
000ee4  20fb              MOVS     r0,#0xfb
000ee6  7120              STRB     r0,[r4,#4]
000ee8  e02b              B        |L1.3906|
                  |L1.3818|
;;;1459     } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
000eea  6820              LDR      r0,[r4,#0]
000eec  6840              LDR      r0,[r0,#4]
000eee  b1f0              CBZ      r0,|L1.3886|
000ef0  6820              LDR      r0,[r4,#0]
000ef2  7800              LDRB     r0,[r0,#0]
000ef4  2810              CMP      r0,#0x10
000ef6  d122              BNE      |L1.3902|
;;;1460       if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
000ef8  7a20              LDRB     r0,[r4,#8]
000efa  2803              CMP      r0,#3
000efc  d006              BEQ      |L1.3852|
000efe  6820              LDR      r0,[r4,#0]
000f00  7840              LDRB     r0,[r0,#1]
000f02  2802              CMP      r0,#2
000f04  d102              BNE      |L1.3852|
;;;1461         /* LISTEN doesn't support half shutdown */
;;;1462         msg->err = ERR_CONN;
000f06  20f3              MOVS     r0,#0xf3
000f08  7120              STRB     r0,[r4,#4]
000f0a  e01a              B        |L1.3906|
                  |L1.3852|
;;;1463       } else {
;;;1464         if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
000f0c  7a20              LDRB     r0,[r4,#8]
000f0e  f0000001          AND      r0,r0,#1
000f12  b110              CBZ      r0,|L1.3866|
;;;1465           /* Drain and delete mboxes */
;;;1466           netconn_drain(msg->conn);
000f14  6820              LDR      r0,[r4,#0]
000f16  f7fffffe          BL       netconn_drain
                  |L1.3866|
;;;1467         }
;;;1468         LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
000f1a  bf00              NOP      
000f1c  bf00              NOP      
;;;1469           msg->conn->write_offset == 0);
;;;1470         msg->conn->state = NETCONN_CLOSE;
000f1e  2004              MOVS     r0,#4
000f20  6821              LDR      r1,[r4,#0]
000f22  7048              STRB     r0,[r1,#1]
;;;1471         msg->conn->current_msg = msg;
000f24  6820              LDR      r0,[r4,#0]
000f26  f8c040e0          STR      r4,[r0,#0xe0]
;;;1472         do_close_internal(msg->conn);
000f2a  6820              LDR      r0,[r4,#0]
000f2c  e004              B        |L1.3896|
                  |L1.3886|
000f2e  e006              B        |L1.3902|
                  |L1.3888|
                          DCD      do_connected
                  |L1.3892|
                          DCD      accept_function
                  |L1.3896|
000f38  f7fffffe          BL       do_close_internal
                  |L1.3900|
;;;1473         /* for tcp netconns, do_close_internal ACKs the message */
;;;1474         return;
;;;1475       }
;;;1476     } else
;;;1477   #endif /* LWIP_TCP */
;;;1478     {
;;;1479       msg->err = ERR_VAL;
;;;1480     }
;;;1481     sys_sem_signal(&msg->conn->op_completed);
;;;1482   }
000f3c  bd10              POP      {r4,pc}
                  |L1.3902|
000f3e  20fa              MOVS     r0,#0xfa              ;1479
000f40  7120              STRB     r0,[r4,#4]            ;1479
                  |L1.3906|
000f42  6821              LDR      r1,[r4,#0]            ;1481
000f44  f101000c          ADD      r0,r1,#0xc            ;1481
000f48  f7fffffe          BL       sys_sem_signal
000f4c  bf00              NOP      
000f4e  e7f5              B        |L1.3900|
;;;1483   
                          ENDP

                  do_join_leave_group PROC
;;;1491   void
;;;1492   do_join_leave_group(struct api_msg_msg *msg)
000f50  b510              PUSH     {r4,lr}
;;;1493   { 
000f52  4604              MOV      r4,r0
;;;1494     if (ERR_IS_FATAL(msg->conn->last_err)) {
000f54  6820              LDR      r0,[r4,#0]
000f56  f9900008          LDRSB    r0,[r0,#8]
000f5a  f1100f09          CMN      r0,#9
000f5e  da03              BGE      |L1.3944|
;;;1495       msg->err = msg->conn->last_err;
000f60  6820              LDR      r0,[r4,#0]
000f62  7a00              LDRB     r0,[r0,#8]
000f64  7120              STRB     r0,[r4,#4]
000f66  e01b              B        |L1.4000|
                  |L1.3944|
;;;1496     } else {
;;;1497       if (msg->conn->pcb.tcp != NULL) {
000f68  6820              LDR      r0,[r4,#0]
000f6a  6840              LDR      r0,[r0,#4]
000f6c  b1b0              CBZ      r0,|L1.3996|
;;;1498         if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
000f6e  6820              LDR      r0,[r4,#0]
000f70  7800              LDRB     r0,[r0,#0]
000f72  f00000f0          AND      r0,r0,#0xf0
000f76  2820              CMP      r0,#0x20
000f78  d10d              BNE      |L1.3990|
;;;1499   #if LWIP_UDP
;;;1500           if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
000f7a  7c20              LDRB     r0,[r4,#0x10]
000f7c  b928              CBNZ     r0,|L1.3978|
;;;1501             msg->err = igmp_joingroup(msg->msg.jl.netif_addr, msg->msg.jl.multiaddr);
000f7e  e9d41002          LDRD     r1,r0,[r4,#8]
000f82  f7fffffe          BL       igmp_joingroup
000f86  7120              STRB     r0,[r4,#4]
000f88  e00a              B        |L1.4000|
                  |L1.3978|
;;;1502           } else {
;;;1503             msg->err = igmp_leavegroup(msg->msg.jl.netif_addr, msg->msg.jl.multiaddr);
000f8a  e9d41002          LDRD     r1,r0,[r4,#8]
000f8e  f7fffffe          BL       igmp_leavegroup
000f92  7120              STRB     r0,[r4,#4]
000f94  e004              B        |L1.4000|
                  |L1.3990|
;;;1504           }
;;;1505   #endif /* LWIP_UDP */
;;;1506   #if (LWIP_TCP || LWIP_RAW)
;;;1507         } else {
;;;1508           msg->err = ERR_VAL;
000f96  20fa              MOVS     r0,#0xfa
000f98  7120              STRB     r0,[r4,#4]
000f9a  e001              B        |L1.4000|
                  |L1.3996|
;;;1509   #endif /* (LWIP_TCP || LWIP_RAW) */
;;;1510         }
;;;1511       } else {
;;;1512         msg->err = ERR_CONN;
000f9c  20f3              MOVS     r0,#0xf3
000f9e  7120              STRB     r0,[r4,#4]
                  |L1.4000|
;;;1513       }
;;;1514     }
;;;1515     TCPIP_APIMSG_ACK(msg);
000fa0  6821              LDR      r1,[r4,#0]
000fa2  f101000c          ADD      r0,r1,#0xc
000fa6  f7fffffe          BL       sys_sem_signal
;;;1516   }
000faa  bd10              POP      {r4,pc}
;;;1517   #endif /* LWIP_IGMP */
                          ENDP

