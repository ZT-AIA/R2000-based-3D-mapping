; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\icmp.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\icmp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\icmp.crf ..\..\libraries\lwip-1.4.1\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
000008  6865              LDR      r5,[r4,#4]
;;;92       hlen = IPH_HL(iphdr) * 4;
00000a  7828              LDRB     r0,[r5,#0]
00000c  0700              LSLS     r0,r0,#28
00000e  ea4f6890          LSR      r8,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
000012  f1c80100          RSB      r1,r8,#0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pbuf_header
00001c  b910              CBNZ     r0,|L1.36|
00001e  8920              LDRH     r0,[r4,#8]
000020  2804              CMP      r0,#4
000022  d202              BCS      |L1.42|
                  |L1.36|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
000024  bf00              NOP      
000026  bf00              NOP      
;;;95         goto lenerr;
000028  e09f              B        |L1.362|
                  |L1.42|
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
00002a  6860              LDR      r0,[r4,#4]
00002c  f890a000          LDRB     r10,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
000030  6860              LDR      r0,[r4,#4]
000032  f890b001          LDRB     r11,[r0,#1]
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000036  f1ba0f00          CMP      r10,#0
00003a  d003              BEQ      |L1.68|
00003c  f1ba0f08          CMP      r10,#8
000040  d179              BNE      |L1.310|
000042  e000              B        |L1.70|
                  |L1.68|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
000044  e08c              B        |L1.352|
                  |L1.70|
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
000046  2601              MOVS     r6,#1
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
000048  4873              LDR      r0,|L1.536|
00004a  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
00004c  f00000f0          AND      r0,r0,#0xf0
000050  28e0              CMP      r0,#0xe0
000052  d100              BNE      |L1.86|
;;;114            accepted = 0;
000054  2600              MOVS     r6,#0
                  |L1.86|
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
000056  4970              LDR      r1,|L1.536|
000058  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
00005a  4649              MOV      r1,r9
00005c  f7fffffe          BL       ip4_addr_isbroadcast
000060  b100              CBZ      r0,|L1.100|
;;;120            accepted = 0;
000062  2600              MOVS     r6,#0
                  |L1.100|
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
000064  b936              CBNZ     r6,|L1.116|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
000066  bf00              NOP      
000068  bf00              NOP      
;;;126            ICMP_STATS_INC(icmp.err);
;;;127            pbuf_free(p);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       pbuf_free
                  |L1.112|
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;157          if (r == NULL) {
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203    
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;206        IPH_CHKSUM_SET(iphdr, 0);
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
;;;233        ICMP_STATS_INC(icmp.drop);
;;;234      }
;;;235      pbuf_free(p);
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
;;;239      ICMP_STATS_INC(icmp.lenerr);
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
;;;245      ICMP_STATS_INC(icmp.err);
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
000070  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.116|
000074  bf00              NOP                            ;132
000076  bf00              NOP                            ;132
000078  8920              LDRH     r0,[r4,#8]            ;133
00007a  2808              CMP      r0,#8                 ;133
00007c  d202              BCS      |L1.132|
00007e  bf00              NOP                            ;134
000080  bf00              NOP                            ;134
000082  e072              B        |L1.362|
                  |L1.132|
000084  4620              MOV      r0,r4                 ;137
000086  f7fffffe          BL       inet_chksum_pbuf
00008a  b128              CBZ      r0,|L1.152|
00008c  bf00              NOP                            ;138
00008e  bf00              NOP                            ;138
000090  4620              MOV      r0,r4                 ;139
000092  f7fffffe          BL       pbuf_free
000096  e7eb              B        |L1.112|
                  |L1.152|
000098  2122              MOVS     r1,#0x22              ;145
00009a  4620              MOV      r0,r4                 ;145
00009c  f7fffffe          BL       pbuf_header
0000a0  b358              CBZ      r0,|L1.250|
0000a2  4641              MOV      r1,r8                 ;151
0000a4  4620              MOV      r0,r4                 ;151
0000a6  f7fffffe          BL       pbuf_header
0000aa  b110              CBZ      r0,|L1.178|
0000ac  bf00              NOP                            ;152
0000ae  bf00              NOP                            ;152
0000b0  e05f              B        |L1.370|
                  |L1.178|
0000b2  8921              LDRH     r1,[r4,#8]            ;156
0000b4  2200              MOVS     r2,#0                 ;156
0000b6  2002              MOVS     r0,#2                 ;156
0000b8  f7fffffe          BL       pbuf_alloc
0000bc  4606              MOV      r6,r0                 ;156
0000be  b916              CBNZ     r6,|L1.198|
0000c0  bf00              NOP                            ;158
0000c2  bf00              NOP                            ;158
0000c4  e055              B        |L1.370|
                  |L1.198|
0000c6  bf00              NOP                            ;161
0000c8  bf00              NOP                            ;161
0000ca  4621              MOV      r1,r4                 ;164
0000cc  4630              MOV      r0,r6                 ;164
0000ce  f7fffffe          BL       pbuf_copy
0000d2  b110              CBZ      r0,|L1.218|
0000d4  bf00              NOP                            ;165
0000d6  bf00              NOP                            ;165
0000d8  e04b              B        |L1.370|
                  |L1.218|
0000da  6875              LDR      r5,[r6,#4]            ;168
0000dc  f1c80000          RSB      r0,r8,#0              ;170
0000e0  b201              SXTH     r1,r0                 ;170
0000e2  4630              MOV      r0,r6                 ;170
0000e4  f7fffffe          BL       pbuf_header
0000e8  b110              CBZ      r0,|L1.240|
0000ea  bf00              NOP                            ;171
0000ec  bf00              NOP                            ;171
0000ee  e040              B        |L1.370|
                  |L1.240|
0000f0  4620              MOV      r0,r4                 ;175
0000f2  f7fffffe          BL       pbuf_free
0000f6  4634              MOV      r4,r6                 ;177
0000f8  e008              B        |L1.268|
                  |L1.250|
0000fa  f06f0121          MVN      r1,#0x21              ;180
0000fe  4620              MOV      r0,r4                 ;180
000100  f7fffffe          BL       pbuf_header
000104  b110              CBZ      r0,|L1.268|
000106  bf00              NOP                            ;181
000108  bf00              NOP                            ;181
00010a  e032              B        |L1.370|
                  |L1.268|
00010c  6867              LDR      r7,[r4,#4]            ;189
00010e  4842              LDR      r0,|L1.536|
000110  6800              LDR      r0,[r0,#0]            ;190  ; current_iphdr_dest
000112  60e8              STR      r0,[r5,#0xc]          ;190
000114  4841              LDR      r0,|L1.540|
000116  6800              LDR      r0,[r0,#0]            ;191  ; current_iphdr_src
000118  6128              STR      r0,[r5,#0x10]         ;191
00011a  2000              MOVS     r0,#0                 ;192
00011c  7038              STRB     r0,[r7,#0]            ;192
00011e  8078              STRH     r0,[r7,#2]            ;201
000120  20ff              MOVS     r0,#0xff              ;205
000122  7228              STRB     r0,[r5,#8]            ;205
000124  2000              MOVS     r0,#0                 ;206
000126  8168              STRH     r0,[r5,#0xa]          ;206
000128  4641              MOV      r1,r8                 ;217
00012a  4620              MOV      r0,r4                 ;217
00012c  f7fffffe          BL       pbuf_header
000130  b110              CBZ      r0,|L1.312|
000132  bf00              NOP                            ;218
000134  e010              B        |L1.344|
                  |L1.310|
000136  e010              B        |L1.346|
                  |L1.312|
000138  2001              MOVS     r0,#1                 ;222
00013a  2100              MOVS     r1,#0                 ;222
00013c  23ff              MOVS     r3,#0xff              ;222
00013e  460a              MOV      r2,r1                 ;222
000140  e9cd0901          STRD     r0,r9,[sp,#4]         ;222
000144  9100              STR      r1,[sp,#0]            ;222
000146  4934              LDR      r1,|L1.536|
000148  4620              MOV      r0,r4                 ;222
00014a  f7fffffe          BL       ip_output_if
00014e  4606              MOV      r6,r0                 ;222
000150  b10e              CBZ      r6,|L1.342|
000152  bf00              NOP                            ;225
000154  bf00              NOP                            ;225
                  |L1.342|
000156  bf00              NOP                            ;227
                  |L1.344|
000158  e002              B        |L1.352|
                  |L1.346|
00015a  bf00              NOP                            ;230
00015c  bf00              NOP                            ;230
00015e  bf00              NOP                            ;102
                  |L1.352|
000160  bf00              NOP                            ;106
000162  4620              MOV      r0,r4                 ;235
000164  f7fffffe          BL       pbuf_free
000168  e782              B        |L1.112|
                  |L1.362|
00016a  4620              MOV      r0,r4                 ;238
00016c  f7fffffe          BL       pbuf_free
000170  e77e              B        |L1.112|
                  |L1.370|
000172  4620              MOV      r0,r4                 ;244
000174  f7fffffe          BL       pbuf_free
000178  bf00              NOP                            ;247
00017a  e779              B        |L1.112|
;;;250    
                          ENDP

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
00017c  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
000180  4606              MOV      r6,r0
000182  460f              MOV      r7,r1
000184  4690              MOV      r8,r2
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
000186  2200              MOVS     r2,#0
000188  2124              MOVS     r1,#0x24
00018a  2001              MOVS     r0,#1
00018c  f7fffffe          BL       pbuf_alloc
000190  4605              MOV      r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
000192  b91d              CBNZ     r5,|L1.412|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
000194  bf00              NOP      
000196  bf00              NOP      
                  |L1.408|
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;317      icmphdr->type = type;
;;;318      icmphdr->code = code;
;;;319      icmphdr->id = 0;
;;;320      icmphdr->seqno = 0;
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;329      ICMP_STATS_INC(icmp.xmit);
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
;;;336      pbuf_free(q);
;;;337    }
000198  e8bd83fe          POP      {r1-r9,pc}
                  |L1.412|
00019c  bf00              NOP                            ;306
00019e  bf00              NOP                            ;306
0001a0  f8d69004          LDR      r9,[r6,#4]            ;309
0001a4  bf00              NOP                            ;310
0001a6  bf00              NOP                            ;310
0001a8  bf00              NOP                            ;311
0001aa  bf00              NOP                            ;311
0001ac  bf00              NOP                            ;312
0001ae  bf00              NOP                            ;312
0001b0  bf00              NOP                            ;313
0001b2  bf00              NOP                            ;313
0001b4  bf00              NOP                            ;314
0001b6  bf00              NOP                            ;314
0001b8  686c              LDR      r4,[r5,#4]            ;316
0001ba  7027              STRB     r7,[r4,#0]            ;317
0001bc  f8848001          STRB     r8,[r4,#1]            ;318
0001c0  2000              MOVS     r0,#0                 ;319
0001c2  80a0              STRH     r0,[r4,#4]            ;319
0001c4  80e0              STRH     r0,[r4,#6]            ;320
0001c6  6871              LDR      r1,[r6,#4]            ;323
0001c8  686a              LDR      r2,[r5,#4]            ;323
0001ca  f1020008          ADD      r0,r2,#8              ;323
0001ce  221c              MOVS     r2,#0x1c              ;323
0001d0  f7fffffe          BL       __aeabi_memcpy
0001d4  2000              MOVS     r0,#0                 ;327
0001d6  8060              STRH     r0,[r4,#2]            ;327
0001d8  8969              LDRH     r1,[r5,#0xa]          ;328
0001da  4620              MOV      r0,r4                 ;328
0001dc  f7fffffe          BL       inet_chksum
0001e0  8060              STRH     r0,[r4,#2]            ;328
0001e2  f8d9000c          LDR      r0,[r9,#0xc]          ;334
0001e6  9002              STR      r0,[sp,#8]            ;334
0001e8  2001              MOVS     r0,#1                 ;335
0001ea  2100              MOVS     r1,#0                 ;335
0001ec  23ff              MOVS     r3,#0xff              ;335
0001ee  aa02              ADD      r2,sp,#8              ;335
0001f0  e9cd1000          STRD     r1,r0,[sp,#0]         ;335
0001f4  4628              MOV      r0,r5                 ;335
0001f6  f7fffffe          BL       ip_output
0001fa  4628              MOV      r0,r5                 ;336
0001fc  f7fffffe          BL       pbuf_free
000200  bf00              NOP      
000202  e7c9              B        |L1.408|
;;;338    
                          ENDP

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000204  b570              PUSH     {r4-r6,lr}
;;;262    {
000206  4605              MOV      r5,r0
000208  460c              MOV      r4,r1
;;;263      icmp_send_response(p, ICMP_DUR, t);
00020a  4622              MOV      r2,r4
00020c  2103              MOVS     r1,#3
00020e  4628              MOV      r0,r5
000210  f7fffffe          BL       icmp_send_response
;;;264    }
000214  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

000216  0000              DCW      0x0000
                  |L1.536|
                          DCD      current_iphdr_dest
                  |L1.540|
                          DCD      current_iphdr_src
