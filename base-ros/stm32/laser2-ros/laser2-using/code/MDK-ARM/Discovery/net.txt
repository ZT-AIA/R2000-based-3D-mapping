; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\net.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\net.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\net.crf ..\..\libraries\ptpd-2.0.0\src\dep\net.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  netQInit PROC
;;;5      /* Initialize network queue. */
;;;6      static void netQInit(BufQueue *queue)
000000  b510              PUSH     {r4,lr}
;;;7      {
000002  4604              MOV      r4,r0
;;;8      	queue->head = 0;
000004  2000              MOVS     r0,#0
000006  8220              STRH     r0,[r4,#0x10]
;;;9      	queue->tail = 0;
000008  8260              STRH     r0,[r4,#0x12]
;;;10     	sys_mutex_new(&queue->mutex);
00000a  f1040014          ADD      r0,r4,#0x14
00000e  f7fffffe          BL       sys_mutex_new
;;;11     }
000012  bd10              POP      {r4,pc}
;;;12     
                          ENDP

                  netQPut PROC
;;;13     /* Put data to the network queue. */
;;;14     static bool netQPut(BufQueue *queue, void *pbuf)
000014  b570              PUSH     {r4-r6,lr}
;;;15     {
000016  4604              MOV      r4,r0
000018  460d              MOV      r5,r1
;;;16     	bool retval = FALSE;
00001a  2600              MOVS     r6,#0
;;;17     
;;;18     	sys_mutex_lock(&queue->mutex);
00001c  f1040014          ADD      r0,r4,#0x14
000020  f7fffffe          BL       sys_mutex_lock
;;;19     
;;;20     	// Is there room on the queue for the buffer?
;;;21     	if (((queue->head + 1) & PBUF_QUEUE_MASK) != queue->tail)
000024  7c20              LDRB     r0,[r4,#0x10]
000026  1c40              ADDS     r0,r0,#1
000028  f0000003          AND      r0,r0,#3
00002c  f9b41012          LDRSH    r1,[r4,#0x12]
000030  4288              CMP      r0,r1
000032  d009              BEQ      |L1.72|
;;;22     	{
;;;23     		// Place the buffer in the queue.
;;;24     		queue->head = (queue->head + 1) & PBUF_QUEUE_MASK;
000034  7c20              LDRB     r0,[r4,#0x10]
000036  1c40              ADDS     r0,r0,#1
000038  f0000003          AND      r0,r0,#3
00003c  8220              STRH     r0,[r4,#0x10]
;;;25     		queue->pbuf[queue->head] = pbuf;
00003e  f9b40010          LDRSH    r0,[r4,#0x10]
000042  f8445020          STR      r5,[r4,r0,LSL #2]
;;;26     		retval = TRUE;
000046  2601              MOVS     r6,#1
                  |L1.72|
;;;27     	}
;;;28     
;;;29     	sys_mutex_unlock(&queue->mutex);
000048  f1040014          ADD      r0,r4,#0x14
00004c  f7fffffe          BL       sys_mutex_unlock
;;;30     
;;;31     	return retval;
000050  4630              MOV      r0,r6
;;;32     }
000052  bd70              POP      {r4-r6,pc}
;;;33     
                          ENDP

                  netQGet PROC
;;;34     /* Get data from the network queue. */
;;;35     static void *netQGet(BufQueue *queue)
000054  b570              PUSH     {r4-r6,lr}
;;;36     {
000056  4604              MOV      r4,r0
;;;37     	void *pbuf = NULL;
000058  2500              MOVS     r5,#0
;;;38     
;;;39     	sys_mutex_lock(&queue->mutex);
00005a  f1040014          ADD      r0,r4,#0x14
00005e  f7fffffe          BL       sys_mutex_lock
;;;40     
;;;41     	// Is there a buffer on the queue?
;;;42     	if (queue->tail != queue->head)
000062  f9b40012          LDRSH    r0,[r4,#0x12]
000066  f9b41010          LDRSH    r1,[r4,#0x10]
00006a  4288              CMP      r0,r1
00006c  d008              BEQ      |L1.128|
;;;43     	{
;;;44     		// Get the buffer from the queue.
;;;45     		queue->tail = (queue->tail + 1) & PBUF_QUEUE_MASK;
00006e  7ca0              LDRB     r0,[r4,#0x12]
000070  1c40              ADDS     r0,r0,#1
000072  f0000003          AND      r0,r0,#3
000076  8260              STRH     r0,[r4,#0x12]
;;;46     		pbuf = queue->pbuf[queue->tail];
000078  f9b40012          LDRSH    r0,[r4,#0x12]
00007c  f8545020          LDR      r5,[r4,r0,LSL #2]
                  |L1.128|
;;;47     	}
;;;48     
;;;49     	sys_mutex_unlock(&queue->mutex);
000080  f1040014          ADD      r0,r4,#0x14
000084  f7fffffe          BL       sys_mutex_unlock
;;;50     
;;;51     	return pbuf;
000088  4628              MOV      r0,r5
;;;52     }
00008a  bd70              POP      {r4-r6,pc}
;;;53     
                          ENDP

                  netQEmpty PROC
;;;54     /* Free any remaining pbufs in the queue. */
;;;55     static void netQEmpty(BufQueue *queue)
00008c  b510              PUSH     {r4,lr}
;;;56     {
00008e  4604              MOV      r4,r0
;;;57     	sys_mutex_lock(&queue->mutex);
000090  f1040014          ADD      r0,r4,#0x14
000094  f7fffffe          BL       sys_mutex_lock
;;;58     
;;;59     	// Free each remaining buffer in the queue.
;;;60     	while (queue->tail != queue->head)
000098  e00a              B        |L1.176|
                  |L1.154|
;;;61     	{
;;;62     		// Get the buffer from the queue.
;;;63     		queue->tail = (queue->tail + 1) & PBUF_QUEUE_MASK;
00009a  7ca0              LDRB     r0,[r4,#0x12]
00009c  1c40              ADDS     r0,r0,#1
00009e  f0000003          AND      r0,r0,#3
0000a2  8260              STRH     r0,[r4,#0x12]
;;;64     		pbuf_free(queue->pbuf[queue->tail]);
0000a4  f9b41012          LDRSH    r1,[r4,#0x12]
0000a8  f8540021          LDR      r0,[r4,r1,LSL #2]
0000ac  f7fffffe          BL       pbuf_free
                  |L1.176|
0000b0  f9b40012          LDRSH    r0,[r4,#0x12]         ;60
0000b4  f9b41010          LDRSH    r1,[r4,#0x10]         ;60
0000b8  4288              CMP      r0,r1                 ;60
0000ba  d1ee              BNE      |L1.154|
;;;65     	}
;;;66     	
;;;67     	sys_mutex_unlock(&queue->mutex);
0000bc  f1040014          ADD      r0,r4,#0x14
0000c0  f7fffffe          BL       sys_mutex_unlock
;;;68     }
0000c4  bd10              POP      {r4,pc}
;;;69     
                          ENDP

                  netQCheck PROC
;;;70     /* Check if something is in the queue */
;;;71     static bool netQCheck(BufQueue  *queue)
0000c6  b570              PUSH     {r4-r6,lr}
;;;72     {
0000c8  4604              MOV      r4,r0
;;;73     	bool  retval = FALSE;
0000ca  2500              MOVS     r5,#0
;;;74     
;;;75     	sys_mutex_lock(&queue->mutex);
0000cc  f1040014          ADD      r0,r4,#0x14
0000d0  f7fffffe          BL       sys_mutex_lock
;;;76     
;;;77     	if (queue->tail != queue->head) retval = TRUE;
0000d4  f9b40012          LDRSH    r0,[r4,#0x12]
0000d8  f9b41010          LDRSH    r1,[r4,#0x10]
0000dc  4288              CMP      r0,r1
0000de  d000              BEQ      |L1.226|
0000e0  2501              MOVS     r5,#1
                  |L1.226|
;;;78     
;;;79     	sys_mutex_unlock(&queue->mutex);
0000e2  f1040014          ADD      r0,r4,#0x14
0000e6  f7fffffe          BL       sys_mutex_unlock
;;;80     
;;;81     	return retval;
0000ea  4628              MOV      r0,r5
;;;82     }
0000ec  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  netShutdown PROC
;;;84     /* Shut down  the UDP and network stuff */
;;;85     bool netShutdown(NetPath *netPath)
0000ee  b538              PUSH     {r3-r5,lr}
;;;86     {
0000f0  4604              MOV      r4,r0
;;;87     	struct ip_addr multicastAaddr;
;;;88     
;;;89     	DBG("netShutdown\n");
;;;90     
;;;91     	/* leave multicast group */
;;;92     	multicastAaddr.addr = netPath->multicastAddr;
0000f2  6820              LDR      r0,[r4,#0]
0000f4  9000              STR      r0,[sp,#0]
;;;93     	igmp_leavegroup(IP_ADDR_ANY, &multicastAaddr);
0000f6  4669              MOV      r1,sp
0000f8  48cf              LDR      r0,|L1.1080|
0000fa  f7fffffe          BL       igmp_leavegroup
;;;94     
;;;95     	/* Disconnect and close the Event UDP interface */
;;;96     	if (netPath->eventPcb)
0000fe  68e0              LDR      r0,[r4,#0xc]
000100  b138              CBZ      r0,|L1.274|
;;;97     	{
;;;98     		udp_disconnect(netPath->eventPcb);
000102  68e0              LDR      r0,[r4,#0xc]
000104  f7fffffe          BL       udp_disconnect
;;;99     		udp_remove(netPath->eventPcb);
000108  68e0              LDR      r0,[r4,#0xc]
00010a  f7fffffe          BL       udp_remove
;;;100    		netPath->eventPcb = NULL;
00010e  2000              MOVS     r0,#0
000110  60e0              STR      r0,[r4,#0xc]
                  |L1.274|
;;;101    	}
;;;102    
;;;103    	/* Disconnect and close the General UDP interface */
;;;104    	if (netPath->generalPcb)
000112  6920              LDR      r0,[r4,#0x10]
000114  b138              CBZ      r0,|L1.294|
;;;105    	{
;;;106    		udp_disconnect(netPath->generalPcb);
000116  6920              LDR      r0,[r4,#0x10]
000118  f7fffffe          BL       udp_disconnect
;;;107    		udp_remove(netPath->generalPcb);
00011c  6920              LDR      r0,[r4,#0x10]
00011e  f7fffffe          BL       udp_remove
;;;108    		netPath->generalPcb = NULL;
000122  2000              MOVS     r0,#0
000124  6120              STR      r0,[r4,#0x10]
                  |L1.294|
;;;109    	}
;;;110    
;;;111    	/* Clear the network addresses. */
;;;112    	netPath->multicastAddr = 0;
000126  2000              MOVS     r0,#0
000128  6020              STR      r0,[r4,#0]
;;;113    	netPath->unicastAddr = 0;
00012a  60a0              STR      r0,[r4,#8]
;;;114    
;;;115    	/* Return a success code. */
;;;116    	return TRUE;
00012c  2001              MOVS     r0,#1
;;;117    }
00012e  bd38              POP      {r3-r5,pc}
;;;118    
                          ENDP

                  findIface PROC
;;;120    	 Will return the IPv4 address of  the interface. */
;;;121    static int32_t findIface(const octet_t *ifaceName, octet_t *uuid, NetPath *netPath)
000130  e92d41f0          PUSH     {r4-r8,lr}
;;;122    {
000134  4606              MOV      r6,r0
000136  460d              MOV      r5,r1
000138  4617              MOV      r7,r2
;;;123    	struct netif *iface;
;;;124    
;;;125    	iface = netif_default;
00013a  48c0              LDR      r0,|L1.1084|
00013c  6804              LDR      r4,[r0,#0]  ; netif_default
;;;126    	memcpy(uuid, iface->hwaddr, iface->hwaddr_len);
00013e  f8942026          LDRB     r2,[r4,#0x26]
000142  f1040127          ADD      r1,r4,#0x27
000146  4628              MOV      r0,r5
000148  f7fffffe          BL       __aeabi_memcpy
;;;127    
;;;128    	return iface->ip_addr.addr;
00014c  6860              LDR      r0,[r4,#4]
;;;129    }
00014e  e8bd81f0          POP      {r4-r8,pc}
;;;130    
                          ENDP

                  netRecvEventCallback PROC
;;;131    /* Process an incoming message on the Event port. */
;;;132    static void netRecvEventCallback(void *arg, struct udp_pcb *pcb, struct pbuf *p,
000152  e92d47f0          PUSH     {r4-r10,lr}
;;;133    																 struct ip_addr *addr, u16_t port)
;;;134    {
000156  4604              MOV      r4,r0
000158  4688              MOV      r8,r1
00015a  4615              MOV      r5,r2
00015c  4699              MOV      r9,r3
00015e  9f08              LDR      r7,[sp,#0x20]
;;;135    	NetPath *netPath = (NetPath *) arg;
000160  4626              MOV      r6,r4
;;;136    
;;;137    	/* Place the incoming message on the Event Port QUEUE. */
;;;138    	if (!netQPut(&netPath->eventQ, p))
000162  4629              MOV      r1,r5
000164  f1060014          ADD      r0,r6,#0x14
000168  f7fffffe          BL       netQPut
00016c  b920              CBNZ     r0,|L1.376|
;;;139    	{
;;;140    		pbuf_free(p);
00016e  4628              MOV      r0,r5
000170  f7fffffe          BL       pbuf_free
                  |L1.372|
;;;141    		ERROR("netRecvEventCallback: queue full\n");
;;;142    		return;
;;;143    	}
;;;144    
;;;145    	/* Alert the PTP thread there is now something to do. */
;;;146    	ptpd_alert();
;;;147    }
000174  e8bd87f0          POP      {r4-r10,pc}
                  |L1.376|
000178  f7fffffe          BL       ptpd_alert
00017c  bf00              NOP      
00017e  e7f9              B        |L1.372|
;;;148    
                          ENDP

                  netRecvGeneralCallback PROC
;;;149    /* Process an incoming message on the General port. */
;;;150    static void netRecvGeneralCallback(void *arg, struct udp_pcb *pcb, struct pbuf *p,
000180  e92d47f0          PUSH     {r4-r10,lr}
;;;151    																	 struct ip_addr *addr, u16_t port)
;;;152    {
000184  4604              MOV      r4,r0
000186  4688              MOV      r8,r1
000188  4615              MOV      r5,r2
00018a  4699              MOV      r9,r3
00018c  9f08              LDR      r7,[sp,#0x20]
;;;153    	NetPath *netPath = (NetPath *) arg;
00018e  4626              MOV      r6,r4
;;;154    
;;;155    	/* Place the incoming message on the Event Port QUEUE. */
;;;156    	if (!netQPut(&netPath->generalQ, p))
000190  4629              MOV      r1,r5
000192  f1060040          ADD      r0,r6,#0x40
000196  f7fffffe          BL       netQPut
00019a  b920              CBNZ     r0,|L1.422|
;;;157    	{
;;;158    		pbuf_free(p);
00019c  4628              MOV      r0,r5
00019e  f7fffffe          BL       pbuf_free
                  |L1.418|
;;;159    		ERROR("netRecvGeneralCallback: queue full\n");
;;;160    		return;
;;;161    	}
;;;162    
;;;163    	/* Alert the PTP thread there is now something to do. */
;;;164    	ptpd_alert();
;;;165    }
0001a2  e8bd87f0          POP      {r4-r10,pc}
                  |L1.422|
0001a6  f7fffffe          BL       ptpd_alert
0001aa  bf00              NOP      
0001ac  e7f9              B        |L1.418|
;;;166    
                          ENDP

                  netInit PROC
;;;167    /* Start  all of the UDP stuff */
;;;168    bool netInit(NetPath *netPath, PtpClock *ptpClock)
0001ae  b530              PUSH     {r4,r5,lr}
;;;169    {
0001b0  b087              SUB      sp,sp,#0x1c
0001b2  4604              MOV      r4,r0
0001b4  460d              MOV      r5,r1
;;;170    	struct in_addr netAddr;
;;;171    	struct ip_addr interfaceAddr;
;;;172    	char addrStr[NET_ADDRESS_LENGTH];
;;;173    
;;;174    	DBG("netInit\n");
;;;175    
;;;176    	/* Initialize the buffer queues. */
;;;177    	netQInit(&netPath->eventQ);
0001b6  f1040014          ADD      r0,r4,#0x14
0001ba  f7fffffe          BL       netQInit
;;;178    	netQInit(&netPath->generalQ);
0001be  f1040040          ADD      r0,r4,#0x40
0001c2  f7fffffe          BL       netQInit
;;;179    
;;;180    	/* Find a network interface */
;;;181    	interfaceAddr.addr = findIface(ptpClock->rtOpts->ifaceName, ptpClock->portUuidField, netPath);
0001c6  f8d51464          LDR      r1,[r5,#0x464]
0001ca  f101000c          ADD      r0,r1,#0xc
0001ce  4622              MOV      r2,r4
0001d0  f2054139          ADD      r1,r5,#0x439
0001d4  f7fffffe          BL       findIface
0001d8  9005              STR      r0,[sp,#0x14]
;;;182    	if (!(interfaceAddr.addr))
0001da  9805              LDR      r0,[sp,#0x14]
0001dc  b900              CBNZ     r0,|L1.480|
;;;183    	{
;;;184    			ERROR("netInit: Failed to find interface address\n");
;;;185    			goto fail01;
0001de  e059              B        |L1.660|
                  |L1.480|
;;;186    	}
;;;187    
;;;188    	/* Open lwIP raw udp interfaces for the event port. */
;;;189    	netPath->eventPcb = udp_new();
0001e0  f7fffffe          BL       udp_new
0001e4  60e0              STR      r0,[r4,#0xc]
;;;190    	if (NULL == netPath->eventPcb)
0001e6  68e0              LDR      r0,[r4,#0xc]
0001e8  b900              CBNZ     r0,|L1.492|
;;;191    	{
;;;192    			ERROR("netInit: Failed to open Event UDP PCB\n");
;;;193    			goto fail02;
0001ea  e052              B        |L1.658|
                  |L1.492|
;;;194    	}
;;;195    
;;;196    	/* Open lwIP raw udp interfaces for the general port. */
;;;197    	netPath->generalPcb = udp_new();
0001ec  f7fffffe          BL       udp_new
0001f0  6120              STR      r0,[r4,#0x10]
;;;198    	if (NULL == netPath->generalPcb)
0001f2  6920              LDR      r0,[r4,#0x10]
0001f4  b900              CBNZ     r0,|L1.504|
;;;199    	{
;;;200    			ERROR("netInit: Failed to open General UDP PCB\n");
;;;201    			goto fail03;
0001f6  e048              B        |L1.650|
                  |L1.504|
;;;202    	}
;;;203    
;;;204    	/* Configure network (broadcast/unicast) addresses. */
;;;205    	netPath->unicastAddr = 0; /* disable unicast */
0001f8  2000              MOVS     r0,#0
0001fa  60a0              STR      r0,[r4,#8]
;;;206    
;;;207    	/* Init General multicast IP address */
;;;208    	memcpy(addrStr, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
0001fc  a390              ADR      r3,|L1.1088|
0001fe  cb0f              LDM      r3,{r0-r3}
000200  e9cd2303          STRD     r2,r3,[sp,#0xc]
000204  e9cd0101          STRD     r0,r1,[sp,#4]
;;;209    	if (!inet_aton(addrStr, &netAddr))
000208  a906              ADD      r1,sp,#0x18
00020a  a801              ADD      r0,sp,#4
00020c  f7fffffe          BL       ipaddr_aton
000210  b900              CBNZ     r0,|L1.532|
;;;210    	{
;;;211    			ERROR("netInit: failed to encode multi-cast address: %s\n", addrStr);
;;;212    			goto fail04;
000212  e036              B        |L1.642|
                  |L1.532|
;;;213    	}
;;;214    	netPath->multicastAddr = netAddr.s_addr;
000214  9806              LDR      r0,[sp,#0x18]
000216  6020              STR      r0,[r4,#0]
;;;215    
;;;216    	/* Join multicast group (for receiving) on specified interface */
;;;217    	igmp_joingroup(&interfaceAddr, (struct ip_addr *)&netAddr);
000218  a906              ADD      r1,sp,#0x18
00021a  a805              ADD      r0,sp,#0x14
00021c  f7fffffe          BL       igmp_joingroup
;;;218    
;;;219    	/* Init Peer multicast IP address */
;;;220    	memcpy(addrStr, PEER_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
000220  a38a              ADR      r3,|L1.1100|
000222  cb0f              LDM      r3,{r0-r3}
000224  e9cd2303          STRD     r2,r3,[sp,#0xc]
000228  e9cd0101          STRD     r0,r1,[sp,#4]
;;;221    	if (!inet_aton(addrStr, &netAddr))
00022c  a906              ADD      r1,sp,#0x18
00022e  a801              ADD      r0,sp,#4
000230  f7fffffe          BL       ipaddr_aton
000234  b900              CBNZ     r0,|L1.568|
;;;222    	{
;;;223    			ERROR("netInit: failed to encode peer multi-cast address: %s\n", addrStr);
;;;224    			goto fail04;
000236  e024              B        |L1.642|
                  |L1.568|
;;;225    	}
;;;226    	netPath->peerMulticastAddr = netAddr.s_addr;
000238  9806              LDR      r0,[sp,#0x18]
00023a  6060              STR      r0,[r4,#4]
;;;227    
;;;228    	/* Join peer multicast group (for receiving) on specified interface */
;;;229    	igmp_joingroup(&interfaceAddr, (struct ip_addr *) &netAddr);
00023c  a906              ADD      r1,sp,#0x18
00023e  a805              ADD      r0,sp,#0x14
000240  f7fffffe          BL       igmp_joingroup
;;;230    
;;;231    	/* Multicast send only on specified interface. */
;;;232    	netPath->eventPcb->multicast_ip.addr = netPath->multicastAddr;
000244  68e1              LDR      r1,[r4,#0xc]
000246  6820              LDR      r0,[r4,#0]
000248  6188              STR      r0,[r1,#0x18]
;;;233    	netPath->generalPcb->multicast_ip.addr = netPath->multicastAddr;
00024a  6921              LDR      r1,[r4,#0x10]
00024c  6820              LDR      r0,[r4,#0]
00024e  6188              STR      r0,[r1,#0x18]
;;;234    
;;;235    	/* Establish the appropriate UDP bindings/connections for events. */
;;;236    	udp_recv(netPath->eventPcb, netRecvEventCallback, netPath);
000250  4622              MOV      r2,r4
000252  4981              LDR      r1,|L1.1112|
000254  68e0              LDR      r0,[r4,#0xc]
000256  f7fffffe          BL       udp_recv
;;;237    	udp_bind(netPath->eventPcb, IP_ADDR_ANY, PTP_EVENT_PORT);
00025a  f240123f          MOV      r2,#0x13f
00025e  4976              LDR      r1,|L1.1080|
000260  68e0              LDR      r0,[r4,#0xc]
000262  f7fffffe          BL       udp_bind
;;;238    	/*  udp_connect(netPath->eventPcb, &netAddr, PTP_EVENT_PORT); */
;;;239    
;;;240    	/* Establish the appropriate UDP bindings/connections for general. */
;;;241    	udp_recv(netPath->generalPcb, netRecvGeneralCallback, netPath);
000266  4622              MOV      r2,r4
000268  497c              LDR      r1,|L1.1116|
00026a  6920              LDR      r0,[r4,#0x10]
00026c  f7fffffe          BL       udp_recv
;;;242    	udp_bind(netPath->generalPcb, IP_ADDR_ANY, PTP_GENERAL_PORT);
000270  f44f72a0          MOV      r2,#0x140
000274  4970              LDR      r1,|L1.1080|
000276  6920              LDR      r0,[r4,#0x10]
000278  f7fffffe          BL       udp_bind
;;;243    	/*  udp_connect(netPath->generalPcb, &netAddr, PTP_GENERAL_PORT); */
;;;244    
;;;245    	/* Return a success code. */
;;;246    	return TRUE;
00027c  2001              MOVS     r0,#1
                  |L1.638|
;;;247    
;;;248    fail04:
;;;249    	udp_remove(netPath->generalPcb);
;;;250    fail03:
;;;251    	udp_remove(netPath->eventPcb);
;;;252    fail02:
;;;253    fail01:
;;;254    	return FALSE;
;;;255    }
00027e  b007              ADD      sp,sp,#0x1c
000280  bd30              POP      {r4,r5,pc}
                  |L1.642|
000282  6920              LDR      r0,[r4,#0x10]         ;249
000284  f7fffffe          BL       udp_remove
000288  bf00              NOP                            ;250
                  |L1.650|
00028a  68e0              LDR      r0,[r4,#0xc]          ;251
00028c  f7fffffe          BL       udp_remove
000290  bf00              NOP                            ;252
                  |L1.658|
000292  bf00              NOP                            ;253
                  |L1.660|
000294  2000              MOVS     r0,#0                 ;254
000296  e7f2              B        |L1.638|
;;;256    
                          ENDP

                  netSelect PROC
;;;259     *  otherwise return 0. */
;;;260    int32_t netSelect(NetPath *netPath, const TimeInternal *timeout)
000298  b570              PUSH     {r4-r6,lr}
;;;261    {
00029a  4604              MOV      r4,r0
00029c  460d              MOV      r5,r1
;;;262    	/* Check the packet queues.  If there is data, return TRUE. */
;;;263    	if (netQCheck(&netPath->eventQ) || netQCheck(&netPath->generalQ)) return 1;
00029e  f1040014          ADD      r0,r4,#0x14
0002a2  f7fffffe          BL       netQCheck
0002a6  b920              CBNZ     r0,|L1.690|
0002a8  f1040040          ADD      r0,r4,#0x40
0002ac  f7fffffe          BL       netQCheck
0002b0  b108              CBZ      r0,|L1.694|
                  |L1.690|
0002b2  2001              MOVS     r0,#1
                  |L1.692|
;;;264    
;;;265    	return 0;
;;;266    }
0002b4  bd70              POP      {r4-r6,pc}
                  |L1.694|
0002b6  2000              MOVS     r0,#0                 ;265
0002b8  e7fc              B        |L1.692|
;;;267    
                          ENDP

                  netEmptyEventQ PROC
;;;268    /* Delete all waiting packets in event queue. */
;;;269    void netEmptyEventQ(NetPath *netPath)
0002ba  b510              PUSH     {r4,lr}
;;;270    {
0002bc  4604              MOV      r4,r0
;;;271    	netQEmpty(&netPath->eventQ);
0002be  f1040014          ADD      r0,r4,#0x14
0002c2  f7fffffe          BL       netQEmpty
;;;272    }
0002c6  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  netRecv PROC
;;;274    static ssize_t netRecv(octet_t *buf, TimeInternal *time, BufQueue *msgQueue)
0002c8  e92d5ff0          PUSH     {r4-r12,lr}
;;;275    {
0002cc  4682              MOV      r10,r0
0002ce  460e              MOV      r6,r1
0002d0  4693              MOV      r11,r2
;;;276    	int i;
;;;277    	int j;
;;;278    	u16_t length;
;;;279    	struct pbuf *p;
;;;280    	struct pbuf *pcopy;
;;;281    
;;;282    	/* Get the next buffer from the queue. */
;;;283    	if ((p = (struct pbuf*) netQGet(msgQueue)) == NULL)
0002d2  4658              MOV      r0,r11
0002d4  f7fffffe          BL       netQGet
0002d8  1e04              SUBS     r4,r0,#0
0002da  d101              BNE      |L1.736|
                  |L1.732|
;;;284    	{
;;;285    		return 0;
;;;286    	}
;;;287    
;;;288    	/* Verify that we have enough space to store the contents. */
;;;289    	if (p->tot_len > PACKET_SIZE)
;;;290    	{
;;;291    		ERROR("netRecv: received truncated message\n");
;;;292    		pbuf_free(p);
;;;293    		return 0;
;;;294    	}
;;;295    
;;;296    	/* Verify there is contents to copy. */
;;;297    	if (p->tot_len == 0)
;;;298    	{
;;;299    		ERROR("netRecv: received empty packet\n");
;;;300    		pbuf_free(p);
;;;301    		return 0;
;;;302    	}
;;;303    
;;;304    	if (time != NULL)
;;;305    	{
;;;306    #if LWIP_PTP
;;;307    		time->seconds = p->time_sec;
;;;308    		time->nanoseconds = p->time_nsec;
;;;309    #else
;;;310    		getTime(time);
;;;311    #endif
;;;312    	}
;;;313    
;;;314    	/* Get the length of the buffer to copy. */
;;;315    	length = p->tot_len;
;;;316    
;;;317    	/* Copy the pbuf payload into the buffer. */
;;;318    	pcopy = p;
;;;319    	j = 0;
;;;320    	for (i = 0; i < length; i++)
;;;321    	{
;;;322    		// Copy the next byte in the payload.
;;;323    		buf[i] = ((u8_t *)pcopy->payload)[j++];
;;;324    
;;;325    		// Skip to the next buffer in the payload?
;;;326    		if (j == pcopy->len)
;;;327    		{
;;;328    			// Move to the next buffer.
;;;329    			pcopy = pcopy->next;
;;;330    			j = 0;
;;;331    		}
;;;332    	}
;;;333    
;;;334    	/* Free up the pbuf (chain). */
;;;335    	pbuf_free(p);
;;;336    
;;;337    	return length;
;;;338    }
0002dc  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.736|
0002e0  8920              LDRH     r0,[r4,#8]            ;289
0002e2  f5b07f96          CMP      r0,#0x12c             ;289
0002e6  dd04              BLE      |L1.754|
0002e8  4620              MOV      r0,r4                 ;292
0002ea  f7fffffe          BL       pbuf_free
0002ee  2000              MOVS     r0,#0                 ;293
0002f0  e7f4              B        |L1.732|
                  |L1.754|
0002f2  8920              LDRH     r0,[r4,#8]            ;297
0002f4  b920              CBNZ     r0,|L1.768|
0002f6  4620              MOV      r0,r4                 ;300
0002f8  f7fffffe          BL       pbuf_free
0002fc  2000              MOVS     r0,#0                 ;301
0002fe  e7ed              B        |L1.732|
                  |L1.768|
000300  b11e              CBZ      r6,|L1.778|
000302  6920              LDR      r0,[r4,#0x10]         ;307
000304  6030              STR      r0,[r6,#0]            ;307
000306  6960              LDR      r0,[r4,#0x14]         ;308
000308  6070              STR      r0,[r6,#4]            ;308
                  |L1.778|
00030a  f8b49008          LDRH     r9,[r4,#8]            ;315
00030e  4625              MOV      r5,r4                 ;318
000310  f04f0800          MOV      r8,#0                 ;319
000314  2700              MOVS     r7,#0                 ;320
000316  e00d              B        |L1.820|
                  |L1.792|
000318  4640              MOV      r0,r8                 ;323
00031a  f1080801          ADD      r8,r8,#1              ;323
00031e  686a              LDR      r2,[r5,#4]            ;323
000320  5c10              LDRB     r0,[r2,r0]            ;323
000322  f80a0007          STRB     r0,[r10,r7]           ;323
000326  8968              LDRH     r0,[r5,#0xa]          ;326
000328  4540              CMP      r0,r8                 ;326
00032a  d102              BNE      |L1.818|
00032c  682d              LDR      r5,[r5,#0]            ;329
00032e  f04f0800          MOV      r8,#0                 ;330
                  |L1.818|
000332  1c7f              ADDS     r7,r7,#1              ;320
                  |L1.820|
000334  454f              CMP      r7,r9                 ;320
000336  dbef              BLT      |L1.792|
000338  4620              MOV      r0,r4                 ;335
00033a  f7fffffe          BL       pbuf_free
00033e  4648              MOV      r0,r9                 ;337
000340  e7cc              B        |L1.732|
;;;339    
                          ENDP

                  netRecvEvent PROC
;;;340    ssize_t netRecvEvent(NetPath *netPath, octet_t *buf, TimeInternal *time)
000342  b570              PUSH     {r4-r6,lr}
;;;341    {
000344  4606              MOV      r6,r0
000346  460c              MOV      r4,r1
000348  4615              MOV      r5,r2
;;;342    	return netRecv(buf, time, &netPath->eventQ);
00034a  f1060214          ADD      r2,r6,#0x14
00034e  4629              MOV      r1,r5
000350  4620              MOV      r0,r4
000352  f7fffffe          BL       netRecv
;;;343    }
000356  bd70              POP      {r4-r6,pc}
;;;344    
                          ENDP

                  netRecvGeneral PROC
;;;345    ssize_t netRecvGeneral(NetPath *netPath, octet_t *buf, TimeInternal *time)
000358  b570              PUSH     {r4-r6,lr}
;;;346    {
00035a  4606              MOV      r6,r0
00035c  460c              MOV      r4,r1
00035e  4615              MOV      r5,r2
;;;347    	return netRecv(buf, time, &netPath->generalQ);
000360  f1060240          ADD      r2,r6,#0x40
000364  4629              MOV      r1,r5
000366  4620              MOV      r0,r4
000368  f7fffffe          BL       netRecv
;;;348    }
00036c  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

                  netSend PROC
;;;350    static ssize_t netSend(const octet_t *buf, int16_t  length, TimeInternal *time, const int32_t * addr, struct udp_pcb * pcb)
00036e  e92d47f0          PUSH     {r4-r10,lr}
;;;351    {
000372  4680              MOV      r8,r0
000374  460d              MOV      r5,r1
000376  4616              MOV      r6,r2
000378  4699              MOV      r9,r3
00037a  f8dda020          LDR      r10,[sp,#0x20]
;;;352    	err_t result;
;;;353    	struct pbuf * p;
;;;354    
;;;355    	/* Allocate the tx pbuf based on the current size. */
;;;356    	p = pbuf_alloc(PBUF_TRANSPORT, length, PBUF_RAM);
00037e  b2a9              UXTH     r1,r5
000380  2200              MOVS     r2,#0
000382  4610              MOV      r0,r2
000384  f7fffffe          BL       pbuf_alloc
000388  4604              MOV      r4,r0
;;;357    	if (NULL == p)
00038a  b904              CBNZ     r4,|L1.910|
;;;358    	{
;;;359    		ERROR("netSend: Failed to allocate Tx Buffer\n");
;;;360    		goto fail01;
00038c  e01b              B        |L1.966|
                  |L1.910|
;;;361    	}
;;;362    
;;;363    	/* Copy the incoming data into the pbuf payload. */
;;;364    	result = pbuf_take(p, buf, length);
00038e  b2aa              UXTH     r2,r5
000390  4641              MOV      r1,r8
000392  4620              MOV      r0,r4
000394  f7fffffe          BL       pbuf_take
000398  4607              MOV      r7,r0
;;;365    	if (ERR_OK != result)
00039a  b107              CBZ      r7,|L1.926|
;;;366    	{
;;;367    		ERROR("netSend: Failed to copy data to Pbuf (%d)\n", result);
;;;368    		goto fail02;
00039c  e00f              B        |L1.958|
                  |L1.926|
;;;369    	}
;;;370    
;;;371    	/* send the buffer. */
;;;372    	result = udp_sendto(pcb, p, (void *)addr, pcb->local_port);
00039e  f8ba3012          LDRH     r3,[r10,#0x12]
0003a2  464a              MOV      r2,r9
0003a4  4621              MOV      r1,r4
0003a6  4650              MOV      r0,r10
0003a8  f7fffffe          BL       udp_sendto
0003ac  4607              MOV      r7,r0
;;;373    	if (ERR_OK != result)
0003ae  b107              CBZ      r7,|L1.946|
;;;374    	{
;;;375    		ERROR("netSend: Failed to send data (%d)\n", result);
;;;376    		goto fail02;
0003b0  e005              B        |L1.958|
                  |L1.946|
;;;377    	}
;;;378    
;;;379    	if (time != NULL)
0003b2  b11e              CBZ      r6,|L1.956|
;;;380    	{
;;;381    #if LWIP_PTP
;;;382    		time->seconds = p->time_sec;
0003b4  6920              LDR      r0,[r4,#0x10]
0003b6  6030              STR      r0,[r6,#0]
;;;383    		time->nanoseconds = p->time_nsec;
0003b8  6960              LDR      r0,[r4,#0x14]
0003ba  6070              STR      r0,[r6,#4]
                  |L1.956|
;;;384    #else
;;;385    		/* TODO: use of loopback mode */
;;;386    		/*
;;;387    		time->seconds = 0;
;;;388    		time->nanoseconds = 0;
;;;389    		*/
;;;390    		getTime(time);
;;;391    #endif
;;;392    		DBGV("netSend: %d sec %d nsec\n", time->seconds, time->nanoseconds);
;;;393    	} else {
;;;394    		DBGV("netSend\n");
;;;395    	}
;;;396    
;;;397    
;;;398    fail02:
0003bc  bf00              NOP      
                  |L1.958|
;;;399    	pbuf_free(p);
0003be  4620              MOV      r0,r4
0003c0  f7fffffe          BL       pbuf_free
;;;400    
;;;401    fail01:
0003c4  bf00              NOP      
                  |L1.966|
;;;402    	return length;
0003c6  4628              MOV      r0,r5
;;;403    
;;;404    	/*  return (0 == result) ? length : 0; */
;;;405    }
0003c8  e8bd87f0          POP      {r4-r10,pc}
;;;406    
                          ENDP

                  netSendEvent PROC
;;;407    ssize_t netSendEvent(NetPath *netPath, const octet_t *buf, int16_t  length, TimeInternal *time)
0003cc  b5f8              PUSH     {r3-r7,lr}
;;;408    {
0003ce  4604              MOV      r4,r0
0003d0  460d              MOV      r5,r1
0003d2  4616              MOV      r6,r2
0003d4  461f              MOV      r7,r3
;;;409    	return netSend(buf, length, time, &netPath->multicastAddr, netPath->eventPcb);
0003d6  68e0              LDR      r0,[r4,#0xc]
0003d8  4623              MOV      r3,r4
0003da  463a              MOV      r2,r7
0003dc  4631              MOV      r1,r6
0003de  9000              STR      r0,[sp,#0]
0003e0  4628              MOV      r0,r5
0003e2  f7fffffe          BL       netSend
;;;410    }
0003e6  bdf8              POP      {r3-r7,pc}
;;;411    
                          ENDP

                  netSendGeneral PROC
;;;412    ssize_t netSendGeneral(NetPath *netPath, const octet_t *buf, int16_t  length)
0003e8  b5f8              PUSH     {r3-r7,lr}
;;;413    {
0003ea  4604              MOV      r4,r0
0003ec  460d              MOV      r5,r1
0003ee  4616              MOV      r6,r2
;;;414    	return netSend(buf, length, NULL, &netPath->multicastAddr, netPath->generalPcb);
0003f0  6920              LDR      r0,[r4,#0x10]
0003f2  4623              MOV      r3,r4
0003f4  2200              MOVS     r2,#0
0003f6  4631              MOV      r1,r6
0003f8  9000              STR      r0,[sp,#0]
0003fa  4628              MOV      r0,r5
0003fc  f7fffffe          BL       netSend
;;;415    }
000400  bdf8              POP      {r3-r7,pc}
;;;416    
                          ENDP

                  netSendPeerGeneral PROC
;;;417    ssize_t netSendPeerGeneral(NetPath *netPath, const octet_t *buf, int16_t  length)
000402  b5f8              PUSH     {r3-r7,lr}
;;;418    {
000404  4604              MOV      r4,r0
000406  460d              MOV      r5,r1
000408  4616              MOV      r6,r2
;;;419    	return netSend(buf, length, NULL, &netPath->peerMulticastAddr, netPath->generalPcb);
00040a  6920              LDR      r0,[r4,#0x10]
00040c  1d23              ADDS     r3,r4,#4
00040e  2200              MOVS     r2,#0
000410  4631              MOV      r1,r6
000412  9000              STR      r0,[sp,#0]
000414  4628              MOV      r0,r5
000416  f7fffffe          BL       netSend
;;;420    }
00041a  bdf8              POP      {r3-r7,pc}
;;;421    
                          ENDP

                  netSendPeerEvent PROC
;;;422    ssize_t netSendPeerEvent(NetPath *netPath, const octet_t *buf, int16_t  length, TimeInternal* time)
00041c  b5f8              PUSH     {r3-r7,lr}
;;;423    {
00041e  4604              MOV      r4,r0
000420  460d              MOV      r5,r1
000422  4616              MOV      r6,r2
000424  461f              MOV      r7,r3
;;;424    	return netSend(buf, length, time, &netPath->peerMulticastAddr, netPath->eventPcb);
000426  68e0              LDR      r0,[r4,#0xc]
000428  1d23              ADDS     r3,r4,#4
00042a  463a              MOV      r2,r7
00042c  4631              MOV      r1,r6
00042e  9000              STR      r0,[sp,#0]
000430  4628              MOV      r0,r5
000432  f7fffffe          BL       netSend
;;;425    }
000436  bdf8              POP      {r3-r7,pc}
                          ENDP

                  |L1.1080|
                          DCD      ip_addr_any
                  |L1.1084|
                          DCD      netif_default
                  |L1.1088|
000440  3232342e          DCB      "224.0.1.129",0
000444  302e312e
000448  31323900
                  |L1.1100|
00044c  3232342e          DCB      "224.0.0.107",0
000450  302e302e
000454  31303700
                  |L1.1112|
                          DCD      netRecvEventCallback
                  |L1.1116|
                          DCD      netRecvGeneralCallback

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\dep\\net.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_net_c_fa5232c2____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_net_c_fa5232c2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_net_c_fa5232c2____REVSH|
#line 128
|__asm___5_net_c_fa5232c2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
