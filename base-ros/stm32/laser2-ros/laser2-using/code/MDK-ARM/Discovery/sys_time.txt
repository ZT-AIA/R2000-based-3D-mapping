; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\sys_time.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\sys_time.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\sys_time.crf ..\..\libraries\ptpd-2.0.0\src\dep\sys_time.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  displayStats PROC
;;;4      
;;;5      void displayStats(const PtpClock *ptpClock)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6      {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
;;;7      	const char *s;
;;;8      	unsigned char *uuid;
;;;9      	char sign;
;;;10     
;;;11     	uuid = (unsigned char*) ptpClock->parentDS.parentPortIdentity.clockIdentity;
000008  f1040628          ADD      r6,r4,#0x28
;;;12     
;;;13     	/* Master clock UUID */
;;;14     	printf("%02X%02X:%02X%02X:%02X%02X:%02X%02X\n",
00000c  79f0              LDRB     r0,[r6,#7]
00000e  79b2              LDRB     r2,[r6,#6]
000010  7971              LDRB     r1,[r6,#5]
000012  7933              LDRB     r3,[r6,#4]
000014  e9cd3101          STRD     r3,r1,[sp,#4]
000018  e9cd2003          STRD     r2,r0,[sp,#0xc]
00001c  78f0              LDRB     r0,[r6,#3]
00001e  9000              STR      r0,[sp,#0]
000020  78b3              LDRB     r3,[r6,#2]
000022  7872              LDRB     r2,[r6,#1]
000024  7831              LDRB     r1,[r6,#0]
000026  a057              ADR      r0,|L1.388|
000028  f7fffffe          BL       __2printf
;;;15     					uuid[0], uuid[1],
;;;16     					uuid[2], uuid[3],
;;;17     					uuid[4], uuid[5],
;;;18     					uuid[6], uuid[7]);
;;;19     
;;;20     	switch (ptpClock->portDS.portState)
00002c  2062              MOVS     r0,#0x62
00002e  5d00              LDRB     r0,[r0,r4]
000030  2809              CMP      r0,#9
000032  d218              BCS      |L1.102|
000034  e8dff000          TBB      [pc,r0]
000038  05071509          DCB      0x05,0x07,0x15,0x09
00003c  11130b0d          DCB      0x11,0x13,0x0b,0x0d
000040  0f00              DCB      0x0f,0x00
;;;21     	{
;;;22     		case PTP_INITIALIZING:  s = "init";  break;
000042  a55a              ADR      r5,|L1.428|
000044  e011              B        |L1.106|
;;;23     		case PTP_FAULTY:        s = "faulty";   break;
000046  a55b              ADR      r5,|L1.436|
000048  e00f              B        |L1.106|
;;;24     		case PTP_LISTENING:     s = "listening";  break;
00004a  a55c              ADR      r5,|L1.444|
00004c  e00d              B        |L1.106|
;;;25     		case PTP_PASSIVE:       s = "passive";  break;
00004e  a55e              ADR      r5,|L1.456|
000050  e00b              B        |L1.106|
;;;26     		case PTP_UNCALIBRATED:  s = "uncalibrated";  break;
000052  a55f              ADR      r5,|L1.464|
000054  e009              B        |L1.106|
;;;27     		case PTP_SLAVE:         s = "slave";   break;
000056  a562              ADR      r5,|L1.480|
000058  e007              B        |L1.106|
;;;28     		case PTP_PRE_MASTER:    s = "pre master";  break;
00005a  a563              ADR      r5,|L1.488|
00005c  e005              B        |L1.106|
;;;29     		case PTP_MASTER:        s = "master";   break;
00005e  a563              ADR      r5,|L1.492|
000060  e003              B        |L1.106|
;;;30     		case PTP_DISABLED:      s = "disabled";  break;
000062  a564              ADR      r5,|L1.500|
000064  e001              B        |L1.106|
                  |L1.102|
;;;31     		default:                s = "?";     break;
000066  a566              ADR      r5,|L1.512|
000068  bf00              NOP      
                  |L1.106|
00006a  bf00              NOP                            ;22
;;;32     	}
;;;33     
;;;34     	/* State of the PTP */
;;;35     	printf("state: %s\n", s);
00006c  4629              MOV      r1,r5
00006e  a065              ADR      r0,|L1.516|
000070  f7fffffe          BL       __2printf
;;;36     
;;;37     	/* One way delay */
;;;38     	switch (ptpClock->portDS.delayMechanism)
000074  206f              MOVS     r0,#0x6f
000076  5d00              LDRB     r0,[r0,r4]
000078  2801              CMP      r0,#1
00007a  d002              BEQ      |L1.130|
00007c  2802              CMP      r0,#2
00007e  d10a              BNE      |L1.150|
000080  e004              B        |L1.140|
                  |L1.130|
;;;39     	{
;;;40     		case E2E:
;;;41     			printf("path delay: %d nsec\n", ptpClock->currentDS.meanPathDelay.nanoseconds);
000082  a063              ADR      r0,|L1.528|
000084  6a61              LDR      r1,[r4,#0x24]
000086  f7fffffe          BL       __2printf
;;;42     			break;
00008a  e008              B        |L1.158|
                  |L1.140|
;;;43     		case P2P:
;;;44     			printf("path delay: %d nsec\n", ptpClock->portDS.peerMeanPathDelay.nanoseconds);
00008c  a060              ADR      r0,|L1.528|
00008e  6ea1              LDR      r1,[r4,#0x68]
000090  f7fffffe          BL       __2printf
;;;45     			break;
000094  e003              B        |L1.158|
                  |L1.150|
;;;46     		default:
;;;47     			printf("path delay: unknown\n");
000096  a064              ADR      r0,|L1.552|
000098  f7fffffe          BL       __2printf
;;;48     			/* none */
;;;49     			break;
00009c  bf00              NOP      
                  |L1.158|
00009e  bf00              NOP                            ;42
;;;50     	}
;;;51     
;;;52     	/* Offset from master */
;;;53     	if (ptpClock->currentDS.offsetFromMaster.seconds)
0000a0  69a0              LDR      r0,[r4,#0x18]
0000a2  b120              CBZ      r0,|L1.174|
;;;54     	{
;;;55     		printf("offset: %d sec\n", ptpClock->currentDS.offsetFromMaster.seconds);
0000a4  a066              ADR      r0,|L1.576|
0000a6  69a1              LDR      r1,[r4,#0x18]
0000a8  f7fffffe          BL       __2printf
0000ac  e003              B        |L1.182|
                  |L1.174|
;;;56     	}
;;;57     	else
;;;58     	{
;;;59     		printf("offset: %d nsec\n", ptpClock->currentDS.offsetFromMaster.nanoseconds);
0000ae  a068              ADR      r0,|L1.592|
0000b0  69e1              LDR      r1,[r4,#0x1c]
0000b2  f7fffffe          BL       __2printf
                  |L1.182|
;;;60     	}
;;;61     
;;;62     	/* Observed drift from master */
;;;63     	sign = ' ';
0000b6  2720              MOVS     r7,#0x20
;;;64     	if (ptpClock->observedDrift > 0) sign = '+';
0000b8  f8d403c4          LDR      r0,[r4,#0x3c4]
0000bc  2800              CMP      r0,#0
0000be  dd00              BLE      |L1.194|
0000c0  272b              MOVS     r7,#0x2b
                  |L1.194|
;;;65     	if (ptpClock->observedDrift < 0) sign = '-';
0000c2  f8d403c4          LDR      r0,[r4,#0x3c4]
0000c6  2800              CMP      r0,#0
0000c8  da00              BGE      |L1.204|
0000ca  272d              MOVS     r7,#0x2d
                  |L1.204|
;;;66     
;;;67     	printf("drift: %c%d.%03d ppm\n", sign, abs(ptpClock->observedDrift / 1000), abs(ptpClock->observedDrift % 1000));
0000cc  f44f717a          MOV      r1,#0x3e8
0000d0  f8d403c4          LDR      r0,[r4,#0x3c4]
0000d4  fb90f2f1          SDIV     r2,r0,r1
0000d8  fb010812          MLS      r8,r1,r2,r0
0000dc  fb90f9f1          SDIV     r9,r0,r1
0000e0  f1b80f00          CMP      r8,#0
0000e4  db01              BLT      |L1.234|
0000e6  4640              MOV      r0,r8
0000e8  e001              B        |L1.238|
                  |L1.234|
0000ea  f1c80000          RSB      r0,r8,#0
                  |L1.238|
0000ee  4603              MOV      r3,r0
0000f0  f1b90f00          CMP      r9,#0
0000f4  db01              BLT      |L1.250|
0000f6  4648              MOV      r0,r9
0000f8  e001              B        |L1.254|
                  |L1.250|
0000fa  f1c90000          RSB      r0,r9,#0
                  |L1.254|
0000fe  4602              MOV      r2,r0
000100  4639              MOV      r1,r7
000102  a058              ADR      r0,|L1.612|
000104  f7fffffe          BL       __2printf
;;;68     }
000108  b005              ADD      sp,sp,#0x14
00010a  e8bd83f0          POP      {r4-r9,pc}
;;;69     
                          ENDP

                  getTime PROC
;;;70     void getTime(TimeInternal *time)
00010e  b51c              PUSH     {r2-r4,lr}
;;;71     {
000110  4604              MOV      r4,r0
;;;72     	struct ptptime_t timestamp;
;;;73     	ETH_PTPTime_GetTime(&timestamp);
000112  4668              MOV      r0,sp
000114  f7fffffe          BL       ETH_PTPTime_GetTime
;;;74     	time->seconds = timestamp.tv_sec;
000118  9800              LDR      r0,[sp,#0]
00011a  6020              STR      r0,[r4,#0]
;;;75     	time->nanoseconds = timestamp.tv_nsec;
00011c  9801              LDR      r0,[sp,#4]
00011e  6060              STR      r0,[r4,#4]
;;;76     }
000120  bd1c              POP      {r2-r4,pc}
;;;77     
                          ENDP

                  setTime PROC
;;;78     void setTime(const TimeInternal *time)
000122  b51c              PUSH     {r2-r4,lr}
;;;79     {
000124  4604              MOV      r4,r0
;;;80     	struct ptptime_t ts;
;;;81     
;;;82     	ts.tv_sec = time->seconds;
000126  6820              LDR      r0,[r4,#0]
000128  9000              STR      r0,[sp,#0]
;;;83     	ts.tv_nsec = time->nanoseconds;
00012a  6860              LDR      r0,[r4,#4]
00012c  9001              STR      r0,[sp,#4]
;;;84     	ETH_PTPTime_SetTime(&ts);
00012e  4668              MOV      r0,sp
000130  f7fffffe          BL       ETH_PTPTime_SetTime
;;;85     	DBG("resetting system clock to %d sec %d nsec\n", time->seconds, time->nanoseconds);
;;;86     }
000134  bd1c              POP      {r2-r4,pc}
;;;87     
                          ENDP

                  updateTime PROC
;;;88     void updateTime(const TimeInternal *time)
000136  b51c              PUSH     {r2-r4,lr}
;;;89     {
000138  4604              MOV      r4,r0
;;;90     	struct ptptime_t timeoffset;
;;;91     
;;;92     	DBGV("updateTime: %d sec %d nsec\n", time->seconds, time->nanoseconds);
;;;93     
;;;94     	timeoffset.tv_sec = -time->seconds;
00013a  6820              LDR      r0,[r4,#0]
00013c  4240              RSBS     r0,r0,#0
00013e  9000              STR      r0,[sp,#0]
;;;95     	timeoffset.tv_nsec = -time->nanoseconds;
000140  6860              LDR      r0,[r4,#4]
000142  4240              RSBS     r0,r0,#0
000144  9001              STR      r0,[sp,#4]
;;;96     
;;;97     	/* Coarse update method */
;;;98     	ETH_PTPTime_UpdateOffset(&timeoffset);
000146  4668              MOV      r0,sp
000148  f7fffffe          BL       ETH_PTPTime_UpdateOffset
;;;99     	DBGV("updateTime: updated\n");
;;;100    }
00014c  bd1c              POP      {r2-r4,pc}
;;;101    
                          ENDP

                  getRand PROC
;;;102    uint32_t getRand(uint32_t randMax)
00014e  b510              PUSH     {r4,lr}
;;;103    {
000150  4604              MOV      r4,r0
;;;104    	return rand() % randMax;
000152  f7fffffe          BL       rand
000156  fbb0f1f4          UDIV     r1,r0,r4
00015a  fb040011          MLS      r0,r4,r1,r0
;;;105    }
00015e  bd10              POP      {r4,pc}
;;;106    
                          ENDP

                  adjFreq PROC
;;;107    bool  adjFreq(int32_t adj)
000160  b510              PUSH     {r4,lr}
;;;108    {
000162  4604              MOV      r4,r0
;;;109    	DBGV("adjFreq %d\n", adj);
;;;110    
;;;111    	if (adj > ADJ_FREQ_MAX)
000164  f5b42ffa          CMP      r4,#0x7d000
000168  dd02              BLE      |L1.368|
;;;112    		adj = ADJ_FREQ_MAX;
00016a  f44f24fa          MOV      r4,#0x7d000
00016e  e003              B        |L1.376|
                  |L1.368|
;;;113    	else if (adj < -ADJ_FREQ_MAX)
000170  f5142ffa          CMN      r4,#0x7d000
000174  da00              BGE      |L1.376|
;;;114    		adj = -ADJ_FREQ_MAX;
000176  4c41              LDR      r4,|L1.636|
                  |L1.376|
;;;115    
;;;116    	/* Fine update method */
;;;117    	ETH_PTPTime_AdjFreq(adj);
000178  4620              MOV      r0,r4
00017a  f7fffffe          BL       ETH_PTPTime_AdjFreq
;;;118    
;;;119    	return TRUE;
00017e  2001              MOVS     r0,#1
;;;120    }
000180  bd10              POP      {r4,pc}
                          ENDP

000182  0000              DCW      0x0000
                  |L1.388|
000184  25303258          DCB      "%02X%02X:%02X%02X:%02X%02X:%02X%02X\n",0
000188  25303258
00018c  3a253032
000190  58253032
000194  583a2530
000198  32582530
00019c  32583a25
0001a0  30325825
0001a4  3032580a
0001a8  00      
0001a9  00                DCB      0
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L1.428|
0001ac  696e6974          DCB      "init",0
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L1.436|
0001b4  6661756c          DCB      "faulty",0
0001b8  747900  
0001bb  00                DCB      0
                  |L1.444|
0001bc  6c697374          DCB      "listening",0
0001c0  656e696e
0001c4  6700    
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L1.456|
0001c8  70617373          DCB      "passive",0
0001cc  69766500
                  |L1.464|
0001d0  756e6361          DCB      "uncalibrated",0
0001d4  6c696272
0001d8  61746564
0001dc  00      
0001dd  00                DCB      0
0001de  00                DCB      0
0001df  00                DCB      0
                  |L1.480|
0001e0  736c6176          DCB      "slave",0
0001e4  6500    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L1.488|
0001e8  70726520          DCB      "pre "
                  |L1.492|
0001ec  6d617374          DCB      "master",0
0001f0  657200  
0001f3  00                DCB      0
                  |L1.500|
0001f4  64697361          DCB      "disabled",0
0001f8  626c6564
0001fc  00      
0001fd  00                DCB      0
0001fe  00                DCB      0
0001ff  00                DCB      0
                  |L1.512|
000200  3f00              DCB      "?",0
000202  00                DCB      0
000203  00                DCB      0
                  |L1.516|
000204  73746174          DCB      "state: %s\n",0
000208  653a2025
00020c  730a00  
00020f  00                DCB      0
                  |L1.528|
000210  70617468          DCB      "path delay: %d nsec\n",0
000214  2064656c
000218  61793a20
00021c  2564206e
000220  7365630a
000224  00      
000225  00                DCB      0
000226  00                DCB      0
000227  00                DCB      0
                  |L1.552|
000228  70617468          DCB      "path delay: unknown\n",0
00022c  2064656c
000230  61793a20
000234  756e6b6e
000238  6f776e0a
00023c  00      
00023d  00                DCB      0
00023e  00                DCB      0
00023f  00                DCB      0
                  |L1.576|
000240  6f666673          DCB      "offset: %d sec\n",0
000244  65743a20
000248  25642073
00024c  65630a00
                  |L1.592|
000250  6f666673          DCB      "offset: %d nsec\n",0
000254  65743a20
000258  2564206e
00025c  7365630a
000260  00      
000261  00                DCB      0
000262  00                DCB      0
000263  00                DCB      0
                  |L1.612|
000264  64726966          DCB      "drift: %c%d.%03d ppm\n",0
000268  743a2025
00026c  6325642e
000270  25303364
000274  2070706d
000278  0a00    
00027a  00                DCB      0
00027b  00                DCB      0
                  |L1.636|
                          DCD      0xfff83000

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\ptpd-2.0.0\\src\\dep\\sys_time.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_sys_time_c_40c9d5f4____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_sys_time_c_40c9d5f4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_sys_time_c_40c9d5f4____REVSH|
#line 128
|__asm___10_sys_time_c_40c9d5f4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
