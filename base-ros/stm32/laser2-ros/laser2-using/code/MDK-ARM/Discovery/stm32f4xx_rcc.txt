; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4xx_rcc.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4xx_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4xx_rcc.crf ..\..\libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;201      */
;;;202    void RCC_DeInit(void)
000000  48fa              LDR      r0,|L1.1004|
;;;203    {
;;;204      /* Set HSION bit */
;;;205      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  49f8              LDR      r1,|L1.1004|
00000a  6008              STR      r0,[r1,#0]
;;;206    
;;;207      /* Reset CFGR register */
;;;208      RCC->CFGR = 0x00000000;
00000c  2000              MOVS     r0,#0
00000e  49f7              LDR      r1,|L1.1004|
000010  3108              ADDS     r1,r1,#8
000012  6008              STR      r0,[r1,#0]
;;;209    
;;;210      /* Reset HSEON, CSSON and PLLON bits */
;;;211      RCC->CR &= (uint32_t)0xFEF6FFFF;
000014  48f5              LDR      r0,|L1.1004|
000016  6800              LDR      r0,[r0,#0]
000018  49f5              LDR      r1,|L1.1008|
00001a  4008              ANDS     r0,r0,r1
00001c  49f3              LDR      r1,|L1.1004|
00001e  6008              STR      r0,[r1,#0]
;;;212    
;;;213      /* Reset PLLCFGR register */
;;;214      RCC->PLLCFGR = 0x24003010;
000020  48f4              LDR      r0,|L1.1012|
000022  1d09              ADDS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;215    
;;;216      /* Reset HSEBYP bit */
;;;217      RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  1f08              SUBS     r0,r1,#4
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  1f09              SUBS     r1,r1,#4
000030  6008              STR      r0,[r1,#0]
;;;218    
;;;219      /* Disable all interrupts */
;;;220      RCC->CIR = 0x00000000;
000032  2000              MOVS     r0,#0
000034  49ed              LDR      r1,|L1.1004|
000036  310c              ADDS     r1,r1,#0xc
000038  6008              STR      r0,[r1,#0]
;;;221    }
00003a  4770              BX       lr
;;;222    
                          ENDP

                  RCC_HSEConfig PROC
;;;242      */
;;;243    void RCC_HSEConfig(uint8_t RCC_HSE)
00003c  2100              MOVS     r1,#0
;;;244    {
;;;245      /* Check the parameters */
;;;246      assert_param(IS_RCC_HSE(RCC_HSE));
;;;247    
;;;248      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;249      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
00003e  4aeb              LDR      r2,|L1.1004|
000040  1c92              ADDS     r2,r2,#2
000042  7011              STRB     r1,[r2,#0]
;;;250    
;;;251      /* Set the new HSE configuration -------------------------------------------*/
;;;252      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000044  4611              MOV      r1,r2
000046  7008              STRB     r0,[r1,#0]
;;;253    }
000048  4770              BX       lr
;;;254    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1690     */
;;;1691   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
00004a  b510              PUSH     {r4,lr}
;;;1692   {
00004c  4601              MOV      r1,r0
;;;1693     uint32_t tmp = 0;
00004e  2200              MOVS     r2,#0
;;;1694     uint32_t statusreg = 0;
000050  2300              MOVS     r3,#0
;;;1695     FlagStatus bitstatus = RESET;
000052  2000              MOVS     r0,#0
;;;1696   
;;;1697     /* Check the parameters */
;;;1698     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1699   
;;;1700     /* Get the RCC register index */
;;;1701     tmp = RCC_FLAG >> 5;
000054  114a              ASRS     r2,r1,#5
;;;1702     if (tmp == 1)               /* The flag to check is in CR register */
000056  2a01              CMP      r2,#1
000058  d102              BNE      |L1.96|
;;;1703     {
;;;1704       statusreg = RCC->CR;
00005a  4ce4              LDR      r4,|L1.1004|
00005c  6823              LDR      r3,[r4,#0]
00005e  e008              B        |L1.114|
                  |L1.96|
;;;1705     }
;;;1706     else if (tmp == 2)          /* The flag to check is in BDCR register */
000060  2a02              CMP      r2,#2
000062  d103              BNE      |L1.108|
;;;1707     {
;;;1708       statusreg = RCC->BDCR;
000064  4ce1              LDR      r4,|L1.1004|
000066  3470              ADDS     r4,r4,#0x70
000068  6823              LDR      r3,[r4,#0]
00006a  e002              B        |L1.114|
                  |L1.108|
;;;1709     }
;;;1710     else                       /* The flag to check is in CSR register */
;;;1711     {
;;;1712       statusreg = RCC->CSR;
00006c  4cdf              LDR      r4,|L1.1004|
00006e  3474              ADDS     r4,r4,#0x74
000070  6823              LDR      r3,[r4,#0]
                  |L1.114|
;;;1713     }
;;;1714   
;;;1715     /* Get the flag position */
;;;1716     tmp = RCC_FLAG & FLAG_MASK;
000072  f001021f          AND      r2,r1,#0x1f
;;;1717     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000076  2401              MOVS     r4,#1
000078  4094              LSLS     r4,r4,r2
00007a  401c              ANDS     r4,r4,r3
00007c  b10c              CBZ      r4,|L1.130|
;;;1718     {
;;;1719       bitstatus = SET;
00007e  2001              MOVS     r0,#1
000080  e000              B        |L1.132|
                  |L1.130|
;;;1720     }
;;;1721     else
;;;1722     {
;;;1723       bitstatus = RESET;
000082  2000              MOVS     r0,#0
                  |L1.132|
;;;1724     }
;;;1725     /* Return the flag status */
;;;1726     return bitstatus;
;;;1727   }
000084  bd10              POP      {r4,pc}
;;;1728   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;266      */
;;;267    ErrorStatus RCC_WaitForHSEStartUp(void)
000086  b538              PUSH     {r3-r5,lr}
;;;268    {
;;;269      __IO uint32_t startupcounter = 0;
000088  2000              MOVS     r0,#0
00008a  9000              STR      r0,[sp,#0]
;;;270      ErrorStatus status = ERROR;
00008c  2400              MOVS     r4,#0
;;;271      FlagStatus hsestatus = RESET;
00008e  2500              MOVS     r5,#0
;;;272      /* Wait till HSE is ready and if Time out is reached exit */
;;;273      do
000090  bf00              NOP      
                  |L1.146|
;;;274      {
;;;275        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
000092  2031              MOVS     r0,#0x31
000094  f7fffffe          BL       RCC_GetFlagStatus
000098  4605              MOV      r5,r0
;;;276        startupcounter++;
00009a  9800              LDR      r0,[sp,#0]
00009c  1c40              ADDS     r0,r0,#1
00009e  9000              STR      r0,[sp,#0]
;;;277      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
0000a0  9800              LDR      r0,[sp,#0]
0000a2  f5b06fa0          CMP      r0,#0x500
0000a6  d001              BEQ      |L1.172|
0000a8  2d00              CMP      r5,#0
0000aa  d0f2              BEQ      |L1.146|
                  |L1.172|
;;;278    
;;;279      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000ac  2031              MOVS     r0,#0x31
0000ae  f7fffffe          BL       RCC_GetFlagStatus
0000b2  b108              CBZ      r0,|L1.184|
;;;280      {
;;;281        status = SUCCESS;
0000b4  2401              MOVS     r4,#1
0000b6  e000              B        |L1.186|
                  |L1.184|
;;;282      }
;;;283      else
;;;284      {
;;;285        status = ERROR;
0000b8  2400              MOVS     r4,#0
                  |L1.186|
;;;286      }
;;;287      return (status);
0000ba  4620              MOV      r0,r4
;;;288    }
0000bc  bd38              POP      {r3-r5,pc}
;;;289    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;297      */
;;;298    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
0000be  4601              MOV      r1,r0
;;;299    {
;;;300      uint32_t tmpreg = 0;
0000c0  2000              MOVS     r0,#0
;;;301      /* Check the parameters */
;;;302      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;303    
;;;304      tmpreg = RCC->CR;
0000c2  4aca              LDR      r2,|L1.1004|
0000c4  6810              LDR      r0,[r2,#0]
;;;305    
;;;306      /* Clear HSITRIM[4:0] bits */
;;;307      tmpreg &= ~RCC_CR_HSITRIM;
0000c6  f02000f8          BIC      r0,r0,#0xf8
;;;308    
;;;309      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;310      tmpreg |= (uint32_t)HSICalibrationValue << 3;
0000ca  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;311    
;;;312      /* Store the new value */
;;;313      RCC->CR = tmpreg;
0000ce  6010              STR      r0,[r2,#0]
;;;314    }
0000d0  4770              BX       lr
;;;315    
                          ENDP

                  RCC_HSICmd PROC
;;;333      */
;;;334    void RCC_HSICmd(FunctionalState NewState)
0000d2  49c9              LDR      r1,|L1.1016|
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;338    
;;;339      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
0000d4  6008              STR      r0,[r1,#0]
;;;340    }
0000d6  4770              BX       lr
;;;341    
                          ENDP

                  RCC_LSEConfig PROC
;;;358      */
;;;359    void RCC_LSEConfig(uint8_t RCC_LSE)
0000d8  2100              MOVS     r1,#0
;;;360    {
;;;361      /* Check the parameters */
;;;362      assert_param(IS_RCC_LSE(RCC_LSE));
;;;363    
;;;364      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;365      /* Reset LSEON bit */
;;;366      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0000da  4ac4              LDR      r2,|L1.1004|
0000dc  3270              ADDS     r2,r2,#0x70
0000de  7011              STRB     r1,[r2,#0]
;;;367    
;;;368      /* Reset LSEBYP bit */
;;;369      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0000e0  7011              STRB     r1,[r2,#0]
;;;370    
;;;371      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;372      switch (RCC_LSE)
0000e2  2801              CMP      r0,#1
0000e4  d002              BEQ      |L1.236|
0000e6  2804              CMP      r0,#4
0000e8  d10a              BNE      |L1.256|
0000ea  e004              B        |L1.246|
                  |L1.236|
;;;373      {
;;;374        case RCC_LSE_ON:
;;;375          /* Set LSEON bit */
;;;376          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
0000ec  2101              MOVS     r1,#1
0000ee  4abf              LDR      r2,|L1.1004|
0000f0  3270              ADDS     r2,r2,#0x70
0000f2  7011              STRB     r1,[r2,#0]
;;;377          break;
0000f4  e005              B        |L1.258|
                  |L1.246|
;;;378        case RCC_LSE_Bypass:
;;;379          /* Set LSEBYP and LSEON bits */
;;;380          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
0000f6  2105              MOVS     r1,#5
0000f8  4abc              LDR      r2,|L1.1004|
0000fa  3270              ADDS     r2,r2,#0x70
0000fc  7011              STRB     r1,[r2,#0]
;;;381          break;
0000fe  e000              B        |L1.258|
                  |L1.256|
;;;382        default:
;;;383          break;
000100  bf00              NOP      
                  |L1.258|
000102  bf00              NOP                            ;377
;;;384      }
;;;385    }
000104  4770              BX       lr
;;;386    
                          ENDP

                  RCC_LSICmd PROC
;;;398      */
;;;399    void RCC_LSICmd(FunctionalState NewState)
000106  49bd              LDR      r1,|L1.1020|
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403    
;;;404      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000108  6008              STR      r0,[r1,#0]
;;;405    }
00010a  4770              BX       lr
;;;406    
                          ENDP

                  RCC_PLLConfig PROC
;;;441      */
;;;442    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
00010c  b570              PUSH     {r4-r6,lr}
;;;443    {
00010e  9c04              LDR      r4,[sp,#0x10]
;;;444      /* Check the parameters */
;;;445      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;446      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;447      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;448      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;449      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;450    
;;;451      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000110  ea411582          ORR      r5,r1,r2,LSL #6
000114  2601              MOVS     r6,#1
000116  ebc60653          RSB      r6,r6,r3,LSR #1
00011a  ea454506          ORR      r5,r5,r6,LSL #16
00011e  4305              ORRS     r5,r5,r0
000120  ea456504          ORR      r5,r5,r4,LSL #24
000124  4eb1              LDR      r6,|L1.1004|
000126  1d36              ADDS     r6,r6,#4
000128  6035              STR      r5,[r6,#0]
;;;452                     (PLLQ << 24);
;;;453    }
00012a  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP

                  RCC_PLLCmd PROC
;;;464      */
;;;465    void RCC_PLLCmd(FunctionalState NewState)
00012c  49b2              LDR      r1,|L1.1016|
;;;466    {
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;469      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
00012e  6608              STR      r0,[r1,#0x60]
;;;470    }
000130  4770              BX       lr
;;;471    
                          ENDP

                  RCC_PLLI2SConfig PROC
;;;490      */
;;;491    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000132  0182              LSLS     r2,r0,#6
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;495      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;496    
;;;497      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000134  ea427201          ORR      r2,r2,r1,LSL #28
000138  4bac              LDR      r3,|L1.1004|
00013a  3384              ADDS     r3,r3,#0x84
00013c  601a              STR      r2,[r3,#0]
;;;498    }
00013e  4770              BX       lr
;;;499    
                          ENDP

                  RCC_PLLI2SCmd PROC
;;;505      */
;;;506    void RCC_PLLI2SCmd(FunctionalState NewState)
000140  49ad              LDR      r1,|L1.1016|
;;;507    {
;;;508      /* Check the parameters */
;;;509      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;510      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000142  6688              STR      r0,[r1,#0x68]
;;;511    }
000144  4770              BX       lr
;;;512    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;523      */
;;;524    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000146  49ac              LDR      r1,|L1.1016|
;;;525    {
;;;526      /* Check the parameters */
;;;527      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;528      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000148  64c8              STR      r0,[r1,#0x4c]
;;;529    }
00014a  4770              BX       lr
;;;530    
                          ENDP

                  RCC_MCO1Config PROC
;;;548      */
;;;549    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
00014c  4602              MOV      r2,r0
;;;550    {
;;;551      uint32_t tmpreg = 0;
00014e  2000              MOVS     r0,#0
;;;552      
;;;553      /* Check the parameters */
;;;554      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;555      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;556    
;;;557      tmpreg = RCC->CFGR;
000150  4ba6              LDR      r3,|L1.1004|
000152  3308              ADDS     r3,r3,#8
000154  6818              LDR      r0,[r3,#0]
;;;558    
;;;559      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;560      tmpreg &= CFGR_MCO1_RESET_MASK;
000156  f02060ec          BIC      r0,r0,#0x7600000
;;;561    
;;;562      /* Select MCO1 clock source and prescaler */
;;;563      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
00015a  ea420301          ORR      r3,r2,r1
00015e  4318              ORRS     r0,r0,r3
;;;564    
;;;565      /* Store the new value */
;;;566      RCC->CFGR = tmpreg;  
000160  4ba2              LDR      r3,|L1.1004|
000162  3308              ADDS     r3,r3,#8
000164  6018              STR      r0,[r3,#0]
;;;567    }
000166  4770              BX       lr
;;;568    
                          ENDP

                  RCC_MCO2Config PROC
;;;586      */
;;;587    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000168  4602              MOV      r2,r0
;;;588    {
;;;589      uint32_t tmpreg = 0;
00016a  2000              MOVS     r0,#0
;;;590      
;;;591      /* Check the parameters */
;;;592      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;593      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;594      
;;;595      tmpreg = RCC->CFGR;
00016c  4b9f              LDR      r3,|L1.1004|
00016e  3308              ADDS     r3,r3,#8
000170  6818              LDR      r0,[r3,#0]
;;;596      
;;;597      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;598      tmpreg &= CFGR_MCO2_RESET_MASK;
000172  f0204078          BIC      r0,r0,#0xf8000000
;;;599    
;;;600      /* Select MCO2 clock source and prescaler */
;;;601      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000176  ea420301          ORR      r3,r2,r1
00017a  4318              ORRS     r0,r0,r3
;;;602    
;;;603      /* Store the new value */
;;;604      RCC->CFGR = tmpreg;  
00017c  4b9b              LDR      r3,|L1.1004|
00017e  3308              ADDS     r3,r3,#8
000180  6018              STR      r0,[r3,#0]
;;;605    }
000182  4770              BX       lr
;;;606    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;692      */
;;;693    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000184  4601              MOV      r1,r0
;;;694    {
;;;695      uint32_t tmpreg = 0;
000186  2000              MOVS     r0,#0
;;;696    
;;;697      /* Check the parameters */
;;;698      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;699    
;;;700      tmpreg = RCC->CFGR;
000188  4a98              LDR      r2,|L1.1004|
00018a  3208              ADDS     r2,r2,#8
00018c  6810              LDR      r0,[r2,#0]
;;;701    
;;;702      /* Clear SW[1:0] bits */
;;;703      tmpreg &= ~RCC_CFGR_SW;
00018e  f0200003          BIC      r0,r0,#3
;;;704    
;;;705      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;706      tmpreg |= RCC_SYSCLKSource;
000192  4308              ORRS     r0,r0,r1
;;;707    
;;;708      /* Store the new value */
;;;709      RCC->CFGR = tmpreg;
000194  6010              STR      r0,[r2,#0]
;;;710    }
000196  4770              BX       lr
;;;711    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;720      */
;;;721    uint8_t RCC_GetSYSCLKSource(void)
000198  4894              LDR      r0,|L1.1004|
;;;722    {
;;;723      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
00019a  3008              ADDS     r0,r0,#8
00019c  6800              LDR      r0,[r0,#0]
00019e  f000000c          AND      r0,r0,#0xc
;;;724    }
0001a2  4770              BX       lr
;;;725    
                          ENDP

                  RCC_HCLKConfig PROC
;;;745      */
;;;746    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
0001a4  4601              MOV      r1,r0
;;;747    {
;;;748      uint32_t tmpreg = 0;
0001a6  2000              MOVS     r0,#0
;;;749      
;;;750      /* Check the parameters */
;;;751      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;752    
;;;753      tmpreg = RCC->CFGR;
0001a8  4a90              LDR      r2,|L1.1004|
0001aa  3208              ADDS     r2,r2,#8
0001ac  6810              LDR      r0,[r2,#0]
;;;754    
;;;755      /* Clear HPRE[3:0] bits */
;;;756      tmpreg &= ~RCC_CFGR_HPRE;
0001ae  f02000f0          BIC      r0,r0,#0xf0
;;;757    
;;;758      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;759      tmpreg |= RCC_SYSCLK;
0001b2  4308              ORRS     r0,r0,r1
;;;760    
;;;761      /* Store the new value */
;;;762      RCC->CFGR = tmpreg;
0001b4  6010              STR      r0,[r2,#0]
;;;763    }
0001b6  4770              BX       lr
;;;764    
                          ENDP

                  RCC_PCLK1Config PROC
;;;777      */
;;;778    void RCC_PCLK1Config(uint32_t RCC_HCLK)
0001b8  4601              MOV      r1,r0
;;;779    {
;;;780      uint32_t tmpreg = 0;
0001ba  2000              MOVS     r0,#0
;;;781    
;;;782      /* Check the parameters */
;;;783      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;784    
;;;785      tmpreg = RCC->CFGR;
0001bc  4a8b              LDR      r2,|L1.1004|
0001be  3208              ADDS     r2,r2,#8
0001c0  6810              LDR      r0,[r2,#0]
;;;786    
;;;787      /* Clear PPRE1[2:0] bits */
;;;788      tmpreg &= ~RCC_CFGR_PPRE1;
0001c2  f42050e0          BIC      r0,r0,#0x1c00
;;;789    
;;;790      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;791      tmpreg |= RCC_HCLK;
0001c6  4308              ORRS     r0,r0,r1
;;;792    
;;;793      /* Store the new value */
;;;794      RCC->CFGR = tmpreg;
0001c8  6010              STR      r0,[r2,#0]
;;;795    }
0001ca  4770              BX       lr
;;;796    
                          ENDP

                  RCC_PCLK2Config PROC
;;;808      */
;;;809    void RCC_PCLK2Config(uint32_t RCC_HCLK)
0001cc  4601              MOV      r1,r0
;;;810    {
;;;811      uint32_t tmpreg = 0;
0001ce  2000              MOVS     r0,#0
;;;812    
;;;813      /* Check the parameters */
;;;814      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;815    
;;;816      tmpreg = RCC->CFGR;
0001d0  4a86              LDR      r2,|L1.1004|
0001d2  3208              ADDS     r2,r2,#8
0001d4  6810              LDR      r0,[r2,#0]
;;;817    
;;;818      /* Clear PPRE2[2:0] bits */
;;;819      tmpreg &= ~RCC_CFGR_PPRE2;
0001d6  f4204060          BIC      r0,r0,#0xe000
;;;820    
;;;821      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;822      tmpreg |= RCC_HCLK << 3;
0001da  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;823    
;;;824      /* Store the new value */
;;;825      RCC->CFGR = tmpreg;
0001de  6010              STR      r0,[r2,#0]
;;;826    }
0001e0  4770              BX       lr
;;;827    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;860      */
;;;861    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
0001e2  b5f0              PUSH     {r4-r7,lr}
;;;862    {
;;;863      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
0001e4  2100              MOVS     r1,#0
0001e6  2200              MOVS     r2,#0
0001e8  2400              MOVS     r4,#0
0001ea  2502              MOVS     r5,#2
0001ec  2600              MOVS     r6,#0
0001ee  2302              MOVS     r3,#2
;;;864    
;;;865      /* Get SYSCLK source -------------------------------------------------------*/
;;;866      tmp = RCC->CFGR & RCC_CFGR_SWS;
0001f0  4f7e              LDR      r7,|L1.1004|
0001f2  3708              ADDS     r7,r7,#8
0001f4  683f              LDR      r7,[r7,#0]
0001f6  f007010c          AND      r1,r7,#0xc
;;;867    
;;;868      switch (tmp)
0001fa  b121              CBZ      r1,|L1.518|
0001fc  2904              CMP      r1,#4
0001fe  d005              BEQ      |L1.524|
000200  2908              CMP      r1,#8
000202  d137              BNE      |L1.628|
000204  e005              B        |L1.530|
                  |L1.518|
;;;869      {
;;;870        case 0x00:  /* HSI used as system clock source */
;;;871          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000206  4f7e              LDR      r7,|L1.1024|
000208  6007              STR      r7,[r0,#0]
;;;872          break;
00020a  e036              B        |L1.634|
                  |L1.524|
;;;873        case 0x04:  /* HSE used as system clock  source */
;;;874          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00020c  4f7d              LDR      r7,|L1.1028|
00020e  6007              STR      r7,[r0,#0]
;;;875          break;
000210  e033              B        |L1.634|
                  |L1.530|
;;;876        case 0x08:  /* PLL used as system clock  source */
;;;877    
;;;878          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;879             SYSCLK = PLL_VCO / PLLP
;;;880             */    
;;;881          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
000212  4f76              LDR      r7,|L1.1004|
000214  1d3f              ADDS     r7,r7,#4
000216  683f              LDR      r7,[r7,#0]
000218  f3c75680          UBFX     r6,r7,#22,#1
;;;882          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
00021c  4f73              LDR      r7,|L1.1004|
00021e  1d3f              ADDS     r7,r7,#4
000220  683f              LDR      r7,[r7,#0]
000222  f007033f          AND      r3,r7,#0x3f
;;;883          
;;;884          if (pllsource != 0)
000226  b16e              CBZ      r6,|L1.580|
;;;885          {
;;;886            /* HSE used as PLL clock source */
;;;887            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000228  4f76              LDR      r7,|L1.1028|
00022a  fbb7f7f3          UDIV     r7,r7,r3
00022e  f8dfc1bc          LDR      r12,|L1.1004|
000232  f10c0c04          ADD      r12,r12,#4
000236  f8dcc000          LDR      r12,[r12,#0]
00023a  f3cc1c88          UBFX     r12,r12,#6,#9
00023e  fb07f40c          MUL      r4,r7,r12
000242  e00c              B        |L1.606|
                  |L1.580|
;;;888          }
;;;889          else
;;;890          {
;;;891            /* HSI used as PLL clock source */
;;;892            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000244  4f6e              LDR      r7,|L1.1024|
000246  fbb7f7f3          UDIV     r7,r7,r3
00024a  f8dfc1a0          LDR      r12,|L1.1004|
00024e  f10c0c04          ADD      r12,r12,#4
000252  f8dcc000          LDR      r12,[r12,#0]
000256  f3cc1c88          UBFX     r12,r12,#6,#9
00025a  fb07f40c          MUL      r4,r7,r12
                  |L1.606|
;;;893          }
;;;894    
;;;895          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00025e  4f63              LDR      r7,|L1.1004|
000260  1d3f              ADDS     r7,r7,#4
000262  683f              LDR      r7,[r7,#0]
000264  f3c74701          UBFX     r7,r7,#16,#2
000268  1c7f              ADDS     r7,r7,#1
00026a  007d              LSLS     r5,r7,#1
;;;896          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
00026c  fbb4f7f5          UDIV     r7,r4,r5
000270  6007              STR      r7,[r0,#0]
;;;897          break;
000272  e002              B        |L1.634|
                  |L1.628|
;;;898        default:
;;;899          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000274  4f62              LDR      r7,|L1.1024|
000276  6007              STR      r7,[r0,#0]
;;;900          break;
000278  bf00              NOP      
                  |L1.634|
00027a  bf00              NOP                            ;872
;;;901      }
;;;902      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;903    
;;;904      /* Get HCLK prescaler */
;;;905      tmp = RCC->CFGR & RCC_CFGR_HPRE;
00027c  4f5b              LDR      r7,|L1.1004|
00027e  3708              ADDS     r7,r7,#8
000280  683f              LDR      r7,[r7,#0]
000282  f00701f0          AND      r1,r7,#0xf0
;;;906      tmp = tmp >> 4;
000286  0909              LSRS     r1,r1,#4
;;;907      presc = APBAHBPrescTable[tmp];
000288  4f5f              LDR      r7,|L1.1032|
00028a  5c7a              LDRB     r2,[r7,r1]
;;;908      /* HCLK clock frequency */
;;;909      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00028c  6807              LDR      r7,[r0,#0]
00028e  40d7              LSRS     r7,r7,r2
000290  6047              STR      r7,[r0,#4]
;;;910    
;;;911      /* Get PCLK1 prescaler */
;;;912      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
000292  4f56              LDR      r7,|L1.1004|
000294  3708              ADDS     r7,r7,#8
000296  683f              LDR      r7,[r7,#0]
000298  f40751e0          AND      r1,r7,#0x1c00
;;;913      tmp = tmp >> 10;
00029c  0a89              LSRS     r1,r1,#10
;;;914      presc = APBAHBPrescTable[tmp];
00029e  4f5a              LDR      r7,|L1.1032|
0002a0  5c7a              LDRB     r2,[r7,r1]
;;;915      /* PCLK1 clock frequency */
;;;916      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002a2  6847              LDR      r7,[r0,#4]
0002a4  40d7              LSRS     r7,r7,r2
0002a6  6087              STR      r7,[r0,#8]
;;;917    
;;;918      /* Get PCLK2 prescaler */
;;;919      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
0002a8  4f50              LDR      r7,|L1.1004|
0002aa  3708              ADDS     r7,r7,#8
0002ac  683f              LDR      r7,[r7,#0]
0002ae  f4074160          AND      r1,r7,#0xe000
;;;920      tmp = tmp >> 13;
0002b2  0b49              LSRS     r1,r1,#13
;;;921      presc = APBAHBPrescTable[tmp];
0002b4  4f54              LDR      r7,|L1.1032|
0002b6  5c7a              LDRB     r2,[r7,r1]
;;;922      /* PCLK2 clock frequency */
;;;923      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002b8  6847              LDR      r7,[r0,#4]
0002ba  40d7              LSRS     r7,r7,r2
0002bc  60c7              STR      r7,[r0,#0xc]
;;;924    }
0002be  bdf0              POP      {r4-r7,pc}
;;;925    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;985      */
;;;986    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
0002c0  2100              MOVS     r1,#0
;;;987    {
;;;988      uint32_t tmpreg = 0;
;;;989    
;;;990      /* Check the parameters */
;;;991      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;992    
;;;993      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
0002c2  f4007240          AND      r2,r0,#0x300
0002c6  f5b27f40          CMP      r2,#0x300
0002ca  d10a              BNE      |L1.738|
;;;994      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;995        tmpreg = RCC->CFGR;
0002cc  4a47              LDR      r2,|L1.1004|
0002ce  3208              ADDS     r2,r2,#8
0002d0  6811              LDR      r1,[r2,#0]
;;;996    
;;;997        /* Clear RTCPRE[4:0] bits */
;;;998        tmpreg &= ~RCC_CFGR_RTCPRE;
0002d2  f42111f8          BIC      r1,r1,#0x1f0000
;;;999    
;;;1000       /* Configure HSE division factor for RTC clock */
;;;1001       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
0002d6  4a4d              LDR      r2,|L1.1036|
0002d8  4002              ANDS     r2,r2,r0
0002da  4311              ORRS     r1,r1,r2
;;;1002   
;;;1003       /* Store the new value */
;;;1004       RCC->CFGR = tmpreg;
0002dc  4a43              LDR      r2,|L1.1004|
0002de  3208              ADDS     r2,r2,#8
0002e0  6011              STR      r1,[r2,#0]
                  |L1.738|
;;;1005     }
;;;1006       
;;;1007     /* Select the RTC clock source */
;;;1008     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
0002e2  4a42              LDR      r2,|L1.1004|
0002e4  3270              ADDS     r2,r2,#0x70
0002e6  6812              LDR      r2,[r2,#0]
0002e8  f3c0030b          UBFX     r3,r0,#0,#12
0002ec  431a              ORRS     r2,r2,r3
0002ee  4b3f              LDR      r3,|L1.1004|
0002f0  3370              ADDS     r3,r3,#0x70
0002f2  601a              STR      r2,[r3,#0]
;;;1009   }
0002f4  4770              BX       lr
;;;1010   
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;1017     */
;;;1018   void RCC_RTCCLKCmd(FunctionalState NewState)
0002f6  4941              LDR      r1,|L1.1020|
;;;1019   {
;;;1020     /* Check the parameters */
;;;1021     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1022   
;;;1023     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
0002f8  3944              SUBS     r1,r1,#0x44
0002fa  6008              STR      r0,[r1,#0]
;;;1024   }
0002fc  4770              BX       lr
;;;1025   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1034     */
;;;1035   void RCC_BackupResetCmd(FunctionalState NewState)
0002fe  493f              LDR      r1,|L1.1020|
;;;1036   {
;;;1037     /* Check the parameters */
;;;1038     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1039     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000300  3940              SUBS     r1,r1,#0x40
000302  6008              STR      r0,[r1,#0]
;;;1040   }
000304  4770              BX       lr
;;;1041   
                          ENDP

                  RCC_I2SCLKConfig PROC
;;;1051     */
;;;1052   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000306  4942              LDR      r1,|L1.1040|
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1056   
;;;1057     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000308  6008              STR      r0,[r1,#0]
;;;1058   }
00030a  4770              BX       lr
;;;1059   
                          ENDP

                  RCC_AHB1PeriphClockCmd PROC
;;;1090     */
;;;1091   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
00030c  b139              CBZ      r1,|L1.798|
;;;1092   {
;;;1093     /* Check the parameters */
;;;1094     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1095   
;;;1096     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1097     if (NewState != DISABLE)
;;;1098     {
;;;1099       RCC->AHB1ENR |= RCC_AHB1Periph;
00030e  4a37              LDR      r2,|L1.1004|
000310  3230              ADDS     r2,r2,#0x30
000312  6812              LDR      r2,[r2,#0]
000314  4302              ORRS     r2,r2,r0
000316  4b35              LDR      r3,|L1.1004|
000318  3330              ADDS     r3,r3,#0x30
00031a  601a              STR      r2,[r3,#0]
00031c  e006              B        |L1.812|
                  |L1.798|
;;;1100     }
;;;1101     else
;;;1102     {
;;;1103       RCC->AHB1ENR &= ~RCC_AHB1Periph;
00031e  4a33              LDR      r2,|L1.1004|
000320  3230              ADDS     r2,r2,#0x30
000322  6812              LDR      r2,[r2,#0]
000324  4382              BICS     r2,r2,r0
000326  4b31              LDR      r3,|L1.1004|
000328  3330              ADDS     r3,r3,#0x30
00032a  601a              STR      r2,[r3,#0]
                  |L1.812|
;;;1104     }
;;;1105   }
00032c  4770              BX       lr
;;;1106   
                          ENDP

                  RCC_AHB2PeriphClockCmd PROC
;;;1122     */
;;;1123   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
00032e  b139              CBZ      r1,|L1.832|
;;;1124   {
;;;1125     /* Check the parameters */
;;;1126     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1127     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1128   
;;;1129     if (NewState != DISABLE)
;;;1130     {
;;;1131       RCC->AHB2ENR |= RCC_AHB2Periph;
000330  4a2e              LDR      r2,|L1.1004|
000332  3234              ADDS     r2,r2,#0x34
000334  6812              LDR      r2,[r2,#0]
000336  4302              ORRS     r2,r2,r0
000338  4b2c              LDR      r3,|L1.1004|
00033a  3334              ADDS     r3,r3,#0x34
00033c  601a              STR      r2,[r3,#0]
00033e  e006              B        |L1.846|
                  |L1.832|
;;;1132     }
;;;1133     else
;;;1134     {
;;;1135       RCC->AHB2ENR &= ~RCC_AHB2Periph;
000340  4a2a              LDR      r2,|L1.1004|
000342  3234              ADDS     r2,r2,#0x34
000344  6812              LDR      r2,[r2,#0]
000346  4382              BICS     r2,r2,r0
000348  4b28              LDR      r3,|L1.1004|
00034a  3334              ADDS     r3,r3,#0x34
00034c  601a              STR      r2,[r3,#0]
                  |L1.846|
;;;1136     }
;;;1137   }
00034e  4770              BX       lr
;;;1138   
                          ENDP

                  RCC_AHB3PeriphClockCmd PROC
;;;1149     */
;;;1150   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000350  b139              CBZ      r1,|L1.866|
;;;1151   {
;;;1152     /* Check the parameters */
;;;1153     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1154     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1155   
;;;1156     if (NewState != DISABLE)
;;;1157     {
;;;1158       RCC->AHB3ENR |= RCC_AHB3Periph;
000352  4a26              LDR      r2,|L1.1004|
000354  3238              ADDS     r2,r2,#0x38
000356  6812              LDR      r2,[r2,#0]
000358  4302              ORRS     r2,r2,r0
00035a  4b24              LDR      r3,|L1.1004|
00035c  3338              ADDS     r3,r3,#0x38
00035e  601a              STR      r2,[r3,#0]
000360  e006              B        |L1.880|
                  |L1.866|
;;;1159     }
;;;1160     else
;;;1161     {
;;;1162       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000362  4a22              LDR      r2,|L1.1004|
000364  3238              ADDS     r2,r2,#0x38
000366  6812              LDR      r2,[r2,#0]
000368  4382              BICS     r2,r2,r0
00036a  4b20              LDR      r3,|L1.1004|
00036c  3338              ADDS     r3,r3,#0x38
00036e  601a              STR      r2,[r3,#0]
                  |L1.880|
;;;1163     }
;;;1164   }
000370  4770              BX       lr
;;;1165   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1199     */
;;;1200   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000372  b139              CBZ      r1,|L1.900|
;;;1201   {
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1204     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1205   
;;;1206     if (NewState != DISABLE)
;;;1207     {
;;;1208       RCC->APB1ENR |= RCC_APB1Periph;
000374  4a1d              LDR      r2,|L1.1004|
000376  3240              ADDS     r2,r2,#0x40
000378  6812              LDR      r2,[r2,#0]
00037a  4302              ORRS     r2,r2,r0
00037c  4b1b              LDR      r3,|L1.1004|
00037e  3340              ADDS     r3,r3,#0x40
000380  601a              STR      r2,[r3,#0]
000382  e006              B        |L1.914|
                  |L1.900|
;;;1209     }
;;;1210     else
;;;1211     {
;;;1212       RCC->APB1ENR &= ~RCC_APB1Periph;
000384  4a19              LDR      r2,|L1.1004|
000386  3240              ADDS     r2,r2,#0x40
000388  6812              LDR      r2,[r2,#0]
00038a  4382              BICS     r2,r2,r0
00038c  4b17              LDR      r3,|L1.1004|
00038e  3340              ADDS     r3,r3,#0x40
000390  601a              STR      r2,[r3,#0]
                  |L1.914|
;;;1213     }
;;;1214   }
000392  4770              BX       lr
;;;1215   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1239     */
;;;1240   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000394  b139              CBZ      r1,|L1.934|
;;;1241   {
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1244     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1245   
;;;1246     if (NewState != DISABLE)
;;;1247     {
;;;1248       RCC->APB2ENR |= RCC_APB2Periph;
000396  4a15              LDR      r2,|L1.1004|
000398  3244              ADDS     r2,r2,#0x44
00039a  6812              LDR      r2,[r2,#0]
00039c  4302              ORRS     r2,r2,r0
00039e  4b13              LDR      r3,|L1.1004|
0003a0  3344              ADDS     r3,r3,#0x44
0003a2  601a              STR      r2,[r3,#0]
0003a4  e006              B        |L1.948|
                  |L1.934|
;;;1249     }
;;;1250     else
;;;1251     {
;;;1252       RCC->APB2ENR &= ~RCC_APB2Periph;
0003a6  4a11              LDR      r2,|L1.1004|
0003a8  3244              ADDS     r2,r2,#0x44
0003aa  6812              LDR      r2,[r2,#0]
0003ac  4382              BICS     r2,r2,r0
0003ae  4b0f              LDR      r3,|L1.1004|
0003b0  3344              ADDS     r3,r3,#0x44
0003b2  601a              STR      r2,[r3,#0]
                  |L1.948|
;;;1253     }
;;;1254   }
0003b4  4770              BX       lr
;;;1255   
                          ENDP

                  RCC_AHB1PeriphResetCmd PROC
;;;1278     */
;;;1279   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
0003b6  b139              CBZ      r1,|L1.968|
;;;1280   {
;;;1281     /* Check the parameters */
;;;1282     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1283     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1284   
;;;1285     if (NewState != DISABLE)
;;;1286     {
;;;1287       RCC->AHB1RSTR |= RCC_AHB1Periph;
0003b8  4a0c              LDR      r2,|L1.1004|
0003ba  3210              ADDS     r2,r2,#0x10
0003bc  6812              LDR      r2,[r2,#0]
0003be  4302              ORRS     r2,r2,r0
0003c0  4b0a              LDR      r3,|L1.1004|
0003c2  3310              ADDS     r3,r3,#0x10
0003c4  601a              STR      r2,[r3,#0]
0003c6  e006              B        |L1.982|
                  |L1.968|
;;;1288     }
;;;1289     else
;;;1290     {
;;;1291       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
0003c8  4a08              LDR      r2,|L1.1004|
0003ca  3210              ADDS     r2,r2,#0x10
0003cc  6812              LDR      r2,[r2,#0]
0003ce  4382              BICS     r2,r2,r0
0003d0  4b06              LDR      r3,|L1.1004|
0003d2  3310              ADDS     r3,r3,#0x10
0003d4  601a              STR      r2,[r3,#0]
                  |L1.982|
;;;1292     }
;;;1293   }
0003d6  4770              BX       lr
;;;1294   
                          ENDP

                  RCC_AHB2PeriphResetCmd PROC
;;;1307     */
;;;1308   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
0003d8  b1e1              CBZ      r1,|L1.1044|
;;;1309   {
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1312     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1313   
;;;1314     if (NewState != DISABLE)
;;;1315     {
;;;1316       RCC->AHB2RSTR |= RCC_AHB2Periph;
0003da  4a04              LDR      r2,|L1.1004|
0003dc  3214              ADDS     r2,r2,#0x14
0003de  6812              LDR      r2,[r2,#0]
0003e0  4302              ORRS     r2,r2,r0
0003e2  4b02              LDR      r3,|L1.1004|
0003e4  3314              ADDS     r3,r3,#0x14
0003e6  601a              STR      r2,[r3,#0]
0003e8  e019              B        |L1.1054|
0003ea  0000              DCW      0x0000
                  |L1.1004|
                          DCD      0x40023800
                  |L1.1008|
                          DCD      0xfef6ffff
                  |L1.1012|
                          DCD      0x24003010
                  |L1.1016|
                          DCD      0x42470000
                  |L1.1020|
                          DCD      0x42470e80
                  |L1.1024|
                          DCD      0x00f42400
                  |L1.1028|
                          DCD      0x007a1200
                  |L1.1032|
                          DCD      APBAHBPrescTable
                  |L1.1036|
                          DCD      0x0ffffcff
                  |L1.1040|
                          DCD      0x4247015c
                  |L1.1044|
;;;1317     }
;;;1318     else
;;;1319     {
;;;1320       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
000414  4a5b              LDR      r2,|L1.1412|
000416  6812              LDR      r2,[r2,#0]
000418  4382              BICS     r2,r2,r0
00041a  4b5a              LDR      r3,|L1.1412|
00041c  601a              STR      r2,[r3,#0]
                  |L1.1054|
;;;1321     }
;;;1322   }
00041e  4770              BX       lr
;;;1323   
                          ENDP

                  RCC_AHB3PeriphResetCmd PROC
;;;1331     */
;;;1332   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000420  b139              CBZ      r1,|L1.1074|
;;;1333   {
;;;1334     /* Check the parameters */
;;;1335     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1336     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1337   
;;;1338     if (NewState != DISABLE)
;;;1339     {
;;;1340       RCC->AHB3RSTR |= RCC_AHB3Periph;
000422  4a58              LDR      r2,|L1.1412|
000424  1d12              ADDS     r2,r2,#4
000426  6812              LDR      r2,[r2,#0]
000428  4302              ORRS     r2,r2,r0
00042a  4b56              LDR      r3,|L1.1412|
00042c  1d1b              ADDS     r3,r3,#4
00042e  601a              STR      r2,[r3,#0]
000430  e006              B        |L1.1088|
                  |L1.1074|
;;;1341     }
;;;1342     else
;;;1343     {
;;;1344       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
000432  4a54              LDR      r2,|L1.1412|
000434  1d12              ADDS     r2,r2,#4
000436  6812              LDR      r2,[r2,#0]
000438  4382              BICS     r2,r2,r0
00043a  4b52              LDR      r3,|L1.1412|
00043c  1d1b              ADDS     r3,r3,#4
00043e  601a              STR      r2,[r3,#0]
                  |L1.1088|
;;;1345     }
;;;1346   }
000440  4770              BX       lr
;;;1347   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1378     */
;;;1379   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000442  b139              CBZ      r1,|L1.1108|
;;;1380   {
;;;1381     /* Check the parameters */
;;;1382     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1383     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1384     if (NewState != DISABLE)
;;;1385     {
;;;1386       RCC->APB1RSTR |= RCC_APB1Periph;
000444  4a4f              LDR      r2,|L1.1412|
000446  320c              ADDS     r2,r2,#0xc
000448  6812              LDR      r2,[r2,#0]
00044a  4302              ORRS     r2,r2,r0
00044c  4b4d              LDR      r3,|L1.1412|
00044e  330c              ADDS     r3,r3,#0xc
000450  601a              STR      r2,[r3,#0]
000452  e006              B        |L1.1122|
                  |L1.1108|
;;;1387     }
;;;1388     else
;;;1389     {
;;;1390       RCC->APB1RSTR &= ~RCC_APB1Periph;
000454  4a4b              LDR      r2,|L1.1412|
000456  320c              ADDS     r2,r2,#0xc
000458  6812              LDR      r2,[r2,#0]
00045a  4382              BICS     r2,r2,r0
00045c  4b49              LDR      r3,|L1.1412|
00045e  330c              ADDS     r3,r3,#0xc
000460  601a              STR      r2,[r3,#0]
                  |L1.1122|
;;;1391     }
;;;1392   }
000462  4770              BX       lr
;;;1393   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1414     */
;;;1415   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000464  b139              CBZ      r1,|L1.1142|
;;;1416   {
;;;1417     /* Check the parameters */
;;;1418     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1419     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1420     if (NewState != DISABLE)
;;;1421     {
;;;1422       RCC->APB2RSTR |= RCC_APB2Periph;
000466  4a47              LDR      r2,|L1.1412|
000468  3210              ADDS     r2,r2,#0x10
00046a  6812              LDR      r2,[r2,#0]
00046c  4302              ORRS     r2,r2,r0
00046e  4b45              LDR      r3,|L1.1412|
000470  3310              ADDS     r3,r3,#0x10
000472  601a              STR      r2,[r3,#0]
000474  e006              B        |L1.1156|
                  |L1.1142|
;;;1423     }
;;;1424     else
;;;1425     {
;;;1426       RCC->APB2RSTR &= ~RCC_APB2Periph;
000476  4a43              LDR      r2,|L1.1412|
000478  3210              ADDS     r2,r2,#0x10
00047a  6812              LDR      r2,[r2,#0]
00047c  4382              BICS     r2,r2,r0
00047e  4b41              LDR      r3,|L1.1412|
000480  3310              ADDS     r3,r3,#0x10
000482  601a              STR      r2,[r3,#0]
                  |L1.1156|
;;;1427     }
;;;1428   }
000484  4770              BX       lr
;;;1429   
                          ENDP

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1460     */
;;;1461   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000486  b139              CBZ      r1,|L1.1176|
;;;1462   {
;;;1463     /* Check the parameters */
;;;1464     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1465     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1466     if (NewState != DISABLE)
;;;1467     {
;;;1468       RCC->AHB1LPENR |= RCC_AHB1Periph;
000488  4a3e              LDR      r2,|L1.1412|
00048a  323c              ADDS     r2,r2,#0x3c
00048c  6812              LDR      r2,[r2,#0]
00048e  4302              ORRS     r2,r2,r0
000490  4b3c              LDR      r3,|L1.1412|
000492  333c              ADDS     r3,r3,#0x3c
000494  601a              STR      r2,[r3,#0]
000496  e006              B        |L1.1190|
                  |L1.1176|
;;;1469     }
;;;1470     else
;;;1471     {
;;;1472       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000498  4a3a              LDR      r2,|L1.1412|
00049a  323c              ADDS     r2,r2,#0x3c
00049c  6812              LDR      r2,[r2,#0]
00049e  4382              BICS     r2,r2,r0
0004a0  4b38              LDR      r3,|L1.1412|
0004a2  333c              ADDS     r3,r3,#0x3c
0004a4  601a              STR      r2,[r3,#0]
                  |L1.1190|
;;;1473     }
;;;1474   }
0004a6  4770              BX       lr
;;;1475   
                          ENDP

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1492     */
;;;1493   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
0004a8  b139              CBZ      r1,|L1.1210|
;;;1494   {
;;;1495     /* Check the parameters */
;;;1496     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1497     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1498     if (NewState != DISABLE)
;;;1499     {
;;;1500       RCC->AHB2LPENR |= RCC_AHB2Periph;
0004aa  4a36              LDR      r2,|L1.1412|
0004ac  3240              ADDS     r2,r2,#0x40
0004ae  6812              LDR      r2,[r2,#0]
0004b0  4302              ORRS     r2,r2,r0
0004b2  4b34              LDR      r3,|L1.1412|
0004b4  3340              ADDS     r3,r3,#0x40
0004b6  601a              STR      r2,[r3,#0]
0004b8  e006              B        |L1.1224|
                  |L1.1210|
;;;1501     }
;;;1502     else
;;;1503     {
;;;1504       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
0004ba  4a32              LDR      r2,|L1.1412|
0004bc  3240              ADDS     r2,r2,#0x40
0004be  6812              LDR      r2,[r2,#0]
0004c0  4382              BICS     r2,r2,r0
0004c2  4b30              LDR      r3,|L1.1412|
0004c4  3340              ADDS     r3,r3,#0x40
0004c6  601a              STR      r2,[r3,#0]
                  |L1.1224|
;;;1505     }
;;;1506   }
0004c8  4770              BX       lr
;;;1507   
                          ENDP

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1519     */
;;;1520   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
0004ca  b139              CBZ      r1,|L1.1244|
;;;1521   {
;;;1522     /* Check the parameters */
;;;1523     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1524     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1525     if (NewState != DISABLE)
;;;1526     {
;;;1527       RCC->AHB3LPENR |= RCC_AHB3Periph;
0004cc  4a2d              LDR      r2,|L1.1412|
0004ce  3244              ADDS     r2,r2,#0x44
0004d0  6812              LDR      r2,[r2,#0]
0004d2  4302              ORRS     r2,r2,r0
0004d4  4b2b              LDR      r3,|L1.1412|
0004d6  3344              ADDS     r3,r3,#0x44
0004d8  601a              STR      r2,[r3,#0]
0004da  e006              B        |L1.1258|
                  |L1.1244|
;;;1528     }
;;;1529     else
;;;1530     {
;;;1531       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
0004dc  4a29              LDR      r2,|L1.1412|
0004de  3244              ADDS     r2,r2,#0x44
0004e0  6812              LDR      r2,[r2,#0]
0004e2  4382              BICS     r2,r2,r0
0004e4  4b27              LDR      r3,|L1.1412|
0004e6  3344              ADDS     r3,r3,#0x44
0004e8  601a              STR      r2,[r3,#0]
                  |L1.1258|
;;;1532     }
;;;1533   }
0004ea  4770              BX       lr
;;;1534   
                          ENDP

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1569     */
;;;1570   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
0004ec  b139              CBZ      r1,|L1.1278|
;;;1571   {
;;;1572     /* Check the parameters */
;;;1573     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1574     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1575     if (NewState != DISABLE)
;;;1576     {
;;;1577       RCC->APB1LPENR |= RCC_APB1Periph;
0004ee  4a25              LDR      r2,|L1.1412|
0004f0  324c              ADDS     r2,r2,#0x4c
0004f2  6812              LDR      r2,[r2,#0]
0004f4  4302              ORRS     r2,r2,r0
0004f6  4b23              LDR      r3,|L1.1412|
0004f8  334c              ADDS     r3,r3,#0x4c
0004fa  601a              STR      r2,[r3,#0]
0004fc  e006              B        |L1.1292|
                  |L1.1278|
;;;1578     }
;;;1579     else
;;;1580     {
;;;1581       RCC->APB1LPENR &= ~RCC_APB1Periph;
0004fe  4a21              LDR      r2,|L1.1412|
000500  324c              ADDS     r2,r2,#0x4c
000502  6812              LDR      r2,[r2,#0]
000504  4382              BICS     r2,r2,r0
000506  4b1f              LDR      r3,|L1.1412|
000508  334c              ADDS     r3,r3,#0x4c
00050a  601a              STR      r2,[r3,#0]
                  |L1.1292|
;;;1582     }
;;;1583   }
00050c  4770              BX       lr
;;;1584   
                          ENDP

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1609     */
;;;1610   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
00050e  b139              CBZ      r1,|L1.1312|
;;;1611   {
;;;1612     /* Check the parameters */
;;;1613     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1614     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1615     if (NewState != DISABLE)
;;;1616     {
;;;1617       RCC->APB2LPENR |= RCC_APB2Periph;
000510  4a1c              LDR      r2,|L1.1412|
000512  3250              ADDS     r2,r2,#0x50
000514  6812              LDR      r2,[r2,#0]
000516  4302              ORRS     r2,r2,r0
000518  4b1a              LDR      r3,|L1.1412|
00051a  3350              ADDS     r3,r3,#0x50
00051c  601a              STR      r2,[r3,#0]
00051e  e006              B        |L1.1326|
                  |L1.1312|
;;;1618     }
;;;1619     else
;;;1620     {
;;;1621       RCC->APB2LPENR &= ~RCC_APB2Periph;
000520  4a18              LDR      r2,|L1.1412|
000522  3250              ADDS     r2,r2,#0x50
000524  6812              LDR      r2,[r2,#0]
000526  4382              BICS     r2,r2,r0
000528  4b16              LDR      r3,|L1.1412|
00052a  3350              ADDS     r3,r3,#0x50
00052c  601a              STR      r2,[r3,#0]
                  |L1.1326|
;;;1622     }
;;;1623   }
00052e  4770              BX       lr
;;;1624   
                          ENDP

                  RCC_ITConfig PROC
;;;1654     */
;;;1655   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000530  b139              CBZ      r1,|L1.1346|
;;;1656   {
;;;1657     /* Check the parameters */
;;;1658     assert_param(IS_RCC_IT(RCC_IT));
;;;1659     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1660     if (NewState != DISABLE)
;;;1661     {
;;;1662       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1663       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000532  4a14              LDR      r2,|L1.1412|
000534  1fd2              SUBS     r2,r2,#7
000536  7812              LDRB     r2,[r2,#0]
000538  4302              ORRS     r2,r2,r0
00053a  4b12              LDR      r3,|L1.1412|
00053c  1fdb              SUBS     r3,r3,#7
00053e  701a              STRB     r2,[r3,#0]
000540  e006              B        |L1.1360|
                  |L1.1346|
;;;1664     }
;;;1665     else
;;;1666     {
;;;1667       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1668       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000542  4a10              LDR      r2,|L1.1412|
000544  1fd2              SUBS     r2,r2,#7
000546  7812              LDRB     r2,[r2,#0]
000548  4382              BICS     r2,r2,r0
00054a  4b0e              LDR      r3,|L1.1412|
00054c  1fdb              SUBS     r3,r3,#7
00054e  701a              STRB     r2,[r3,#0]
                  |L1.1360|
;;;1669     }
;;;1670   }
000550  4770              BX       lr
;;;1671   
                          ENDP

                  RCC_ClearFlag PROC
;;;1735     */
;;;1736   void RCC_ClearFlag(void)
000552  480c              LDR      r0,|L1.1412|
;;;1737   {
;;;1738     /* Set RMVF bit to clear the reset flags */
;;;1739     RCC->CSR |= RCC_CSR_RMVF;
000554  3060              ADDS     r0,r0,#0x60
000556  6800              LDR      r0,[r0,#0]
000558  f0407080          ORR      r0,r0,#0x1000000
00055c  4909              LDR      r1,|L1.1412|
00055e  3160              ADDS     r1,r1,#0x60
000560  6008              STR      r0,[r1,#0]
;;;1740   }
000562  4770              BX       lr
;;;1741   
                          ENDP

                  RCC_GetITStatus PROC
;;;1754     */
;;;1755   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000564  4601              MOV      r1,r0
;;;1756   {
;;;1757     ITStatus bitstatus = RESET;
000566  2000              MOVS     r0,#0
;;;1758   
;;;1759     /* Check the parameters */
;;;1760     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1761   
;;;1762     /* Check the status of the specified RCC interrupt */
;;;1763     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000568  4a06              LDR      r2,|L1.1412|
00056a  3a08              SUBS     r2,r2,#8
00056c  6812              LDR      r2,[r2,#0]
00056e  400a              ANDS     r2,r2,r1
000570  b10a              CBZ      r2,|L1.1398|
;;;1764     {
;;;1765       bitstatus = SET;
000572  2001              MOVS     r0,#1
000574  e000              B        |L1.1400|
                  |L1.1398|
;;;1766     }
;;;1767     else
;;;1768     {
;;;1769       bitstatus = RESET;
000576  2000              MOVS     r0,#0
                  |L1.1400|
;;;1770     }
;;;1771     /* Return the RCC_IT status */
;;;1772     return  bitstatus;
;;;1773   }
000578  4770              BX       lr
;;;1774   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1787     */
;;;1788   void RCC_ClearITPendingBit(uint8_t RCC_IT)
00057a  4902              LDR      r1,|L1.1412|
;;;1789   {
;;;1790     /* Check the parameters */
;;;1791     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1792   
;;;1793     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1794        pending bits */
;;;1795     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
00057c  1f89              SUBS     r1,r1,#6
00057e  7008              STRB     r0,[r1,#0]
;;;1796   }
000580  4770              BX       lr
;;;1797   
                          ENDP

000582  0000              DCW      0x0000
                  |L1.1412|
                          DCD      0x40023814

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
