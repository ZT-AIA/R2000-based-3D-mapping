; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4x7_eth.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4x7_eth.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4x7_eth.crf ..\..\libraries\STM32F4x7_ETH_Driver\src\stm32f4x7_eth.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETH_Delay PROC
;;;149      */
;;;150    static void ETH_Delay(__IO uint32_t nCount)
000000  b501              PUSH     {r0,lr}
;;;151    {
000002  b081              SUB      sp,sp,#4
;;;152      __IO uint32_t index = 0; 
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;153      for(index = nCount; index != 0; index--)
000008  9801              LDR      r0,[sp,#4]
00000a  9000              STR      r0,[sp,#0]
00000c  e002              B        |L1.20|
                  |L1.14|
00000e  9800              LDR      r0,[sp,#0]
000010  1e40              SUBS     r0,r0,#1
000012  9000              STR      r0,[sp,#0]
                  |L1.20|
000014  9800              LDR      r0,[sp,#0]
000016  2800              CMP      r0,#0
000018  d1f9              BNE      |L1.14|
;;;154      {
;;;155      }
;;;156    }
00001a  bd0c              POP      {r2,r3,pc}
;;;157    #endif /* USE_Delay*/
                          ENDP

                  ETH_DeInit PROC
;;;169      */
;;;170    void ETH_DeInit(void)
00001c  b510              PUSH     {r4,lr}
;;;171    {
;;;172      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0648              LSLS     r0,r1,#25
000022  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;173      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f7000          MOV      r0,#0x2000000
00002c  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;174    }
000030  bd10              POP      {r4,pc}
;;;175    
                          ENDP

                  ETH_StructInit PROC
;;;181      */
;;;182    void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
000032  2101              MOVS     r1,#1
;;;183    {
;;;184      /* ETH_InitStruct members default value */
;;;185      /*------------------------   MAC Configuration   ---------------------------*/
;;;186      
;;;187      /* PHY Auto-negotiation enabled */
;;;188      ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
000034  6001              STR      r1,[r0,#0]
;;;189      /* MAC watchdog enabled: cuts-off long frame */
;;;190      ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
000036  2100              MOVS     r1,#0
000038  6041              STR      r1,[r0,#4]
;;;191      /* MAC Jabber enabled in Half-duplex mode */
;;;192      ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                       
00003a  6081              STR      r1,[r0,#8]
;;;193      /* Ethernet interframe gap set to 96 bits */
;;;194      ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                             
00003c  60c1              STR      r1,[r0,#0xc]
;;;195      /* Carrier Sense Enabled in Half-Duplex mode */ 
;;;196      ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                                
00003e  6101              STR      r1,[r0,#0x10]
;;;197      /* PHY speed configured to 100Mbit/s */
;;;198      ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
000040  f44f4180          MOV      r1,#0x4000
000044  6141              STR      r1,[r0,#0x14]
;;;199      /* Receive own Frames in Half-Duplex mode enabled */
;;;200      ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                
000046  2100              MOVS     r1,#0
000048  6181              STR      r1,[r0,#0x18]
;;;201      /* MAC MII loopback disabled */ 
;;;202      ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
00004a  61c1              STR      r1,[r0,#0x1c]
;;;203      /* Full-Duplex mode selected */
;;;204      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;                      
00004c  f44f6100          MOV      r1,#0x800
000050  6201              STR      r1,[r0,#0x20]
;;;205      /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
;;;206      ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                             
000052  2100              MOVS     r1,#0
000054  6241              STR      r1,[r0,#0x24]
;;;207      /* Retry Transmission enabled for half-duplex mode */ 
;;;208      ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                   
000056  6281              STR      r1,[r0,#0x28]
;;;209      /* Automatic PAD/CRC strip disabled*/
;;;210      ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                          
000058  62c1              STR      r1,[r0,#0x2c]
;;;211      /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
;;;212      ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;     
00005a  6301              STR      r1,[r0,#0x30]
;;;213      /* half-duplex mode Deferral check disabled */
;;;214      ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
00005c  6341              STR      r1,[r0,#0x34]
;;;215      /* Receive all frames disabled */ 
;;;216      ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
00005e  6381              STR      r1,[r0,#0x38]
;;;217      /* Source address filtering (on the optional MAC addresses) disabled */
;;;218      ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
000060  63c1              STR      r1,[r0,#0x3c]
;;;219      /* Do not forward control frames that do not pass the address filtering */
;;;220      ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
000062  2140              MOVS     r1,#0x40
000064  6401              STR      r1,[r0,#0x40]
;;;221      /* Disable reception of Broadcast frames */
;;;222      ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
000066  2120              MOVS     r1,#0x20
000068  6441              STR      r1,[r0,#0x44]
;;;223      /* Normal Destination address filtering (not reverse addressing) */
;;;224      ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
00006a  2100              MOVS     r1,#0
00006c  6481              STR      r1,[r0,#0x48]
;;;225      /* Promiscuous address filtering mode disabled */
;;;226      ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
00006e  64c1              STR      r1,[r0,#0x4c]
;;;227      /* Perfect address filtering for multicast addresses */
;;;228      ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;       
000070  6501              STR      r1,[r0,#0x50]
;;;229      /* Perfect address filtering for unicast addresses */
;;;230      ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
000072  6541              STR      r1,[r0,#0x54]
;;;231      /* Initialize hash table high and low regs */
;;;232      ETH_InitStruct->ETH_HashTableHigh = 0x0;                
000074  6581              STR      r1,[r0,#0x58]
;;;233      ETH_InitStruct->ETH_HashTableLow = 0x0;                     
000076  65c1              STR      r1,[r0,#0x5c]
;;;234      /* Flow control config (flow control disabled)*/
;;;235      ETH_InitStruct->ETH_PauseTime = 0x0;                 
000078  6601              STR      r1,[r0,#0x60]
;;;236      ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
00007a  2180              MOVS     r1,#0x80
00007c  6641              STR      r1,[r0,#0x64]
;;;237      ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
00007e  2100              MOVS     r1,#0
000080  6681              STR      r1,[r0,#0x68]
;;;238      ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
000082  66c1              STR      r1,[r0,#0x6c]
;;;239      ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
000084  6701              STR      r1,[r0,#0x70]
;;;240      ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
000086  6741              STR      r1,[r0,#0x74]
;;;241      /* VLANtag config (VLAN field not checked) */
;;;242      ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
000088  6781              STR      r1,[r0,#0x78]
;;;243      ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
00008a  67c1              STR      r1,[r0,#0x7c]
;;;244      
;;;245      /*---------------------- DMA Configuration   -------------------------------*/
;;;246    
;;;247      /* Drops frames with with TCP/IP checksum errors */
;;;248      ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
00008c  f04f6180          MOV      r1,#0x4000000
000090  f8c01080          STR      r1,[r0,#0x80]
;;;249      /* Store and forward mode enabled for receive */
;;;250      ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
000094  1049              ASRS     r1,r1,#1
000096  f8c01084          STR      r1,[r0,#0x84]
;;;251      /* Flush received frame that created FIFO overflow */
;;;252      ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
00009a  2100              MOVS     r1,#0
00009c  f8c01088          STR      r1,[r0,#0x88]
;;;253      /* Store and forward mode enabled for transmit */
;;;254      ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
0000a0  f44f1100          MOV      r1,#0x200000
0000a4  f8c0108c          STR      r1,[r0,#0x8c]
;;;255      /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
;;;256      ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
0000a8  2100              MOVS     r1,#0
0000aa  f8c01090          STR      r1,[r0,#0x90]
;;;257      /* Disable forwarding frames with errors (short frames, CRC,...)*/
;;;258      ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; 
0000ae  f8c01094          STR      r1,[r0,#0x94]
;;;259      /* Disable undersized good frames */
;;;260      ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
0000b2  f8c01098          STR      r1,[r0,#0x98]
;;;261      /* Threshold RXFIFO level set to 64 bytes (used when Cut-through mode is enabled) */
;;;262      ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;                             
0000b6  f8c0109c          STR      r1,[r0,#0x9c]
;;;263      /* Disable Operate on second frame (transmit a second frame to FIFO without 
;;;264      waiting status of previous frame*/                           
;;;265      ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
0000ba  f8c010a0          STR      r1,[r0,#0xa0]
;;;266      /* DMA works on 32-bit aligned start source and destinations addresses */
;;;267      ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
0000be  f04f7100          MOV      r1,#0x2000000
0000c2  f8c010a4          STR      r1,[r0,#0xa4]
;;;268      /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
;;;269      ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
0000c6  1249              ASRS     r1,r1,#9
0000c8  f8c010a8          STR      r1,[r0,#0xa8]
;;;270      /* DMA transfer max burst length = 32 beats = 32 x 32bits */
;;;271      ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
0000cc  0189              LSLS     r1,r1,#6
0000ce  f8c010ac          STR      r1,[r0,#0xac]
;;;272      ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
0000d2  1249              ASRS     r1,r1,#9
0000d4  f8c010b0          STR      r1,[r0,#0xb0]
;;;273      /* DMA Ring mode skip length = 0 */
;;;274      ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
0000d8  2100              MOVS     r1,#0
0000da  f8c010b4          STR      r1,[r0,#0xb4]
;;;275      /* Equal priority (round-robin) between transmit and receive DMA engines */
;;;276      ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
0000de  f8c010b8          STR      r1,[r0,#0xb8]
;;;277    }
0000e2  4770              BX       lr
;;;278    
                          ENDP

                  ETH_WritePHYRegister PROC
;;;2493     */
;;;2494   uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
0000e4  b538              PUSH     {r3-r5,lr}
;;;2495   {
0000e6  4603              MOV      r3,r0
0000e8  460c              MOV      r4,r1
;;;2496     uint32_t tmpreg = 0;     
0000ea  2100              MOVS     r1,#0
;;;2497     __IO uint32_t timeout = 0;
0000ec  2000              MOVS     r0,#0
0000ee  9000              STR      r0,[sp,#0]
;;;2498     /* Check the parameters */
;;;2499     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2500     assert_param(IS_ETH_PHY_REG(PHYReg));
;;;2501     
;;;2502     /* Get the ETHERNET MACMIIAR value */
;;;2503     tmpreg = ETH->MACMIIAR;
0000f0  48f8              LDR      r0,|L1.1236|
0000f2  6901              LDR      r1,[r0,#0x10]
;;;2504     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;2505     tmpreg &= ~MACMIIAR_CR_MASK;
0000f4  f001011c          AND      r1,r1,#0x1c
;;;2506     /* Prepare the MII register address value */
;;;2507     tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
0000f8  f44f4078          MOV      r0,#0xf800
0000fc  ea0020c3          AND      r0,r0,r3,LSL #11
000100  4301              ORRS     r1,r1,r0
;;;2508     tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
000102  f44f60f8          MOV      r0,#0x7c0
000106  ea001084          AND      r0,r0,r4,LSL #6
00010a  4301              ORRS     r1,r1,r0
;;;2509     tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
00010c  f0410102          ORR      r1,r1,#2
;;;2510     tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
000110  f0410101          ORR      r1,r1,#1
;;;2511     /* Give the value to the MII data register */
;;;2512     ETH->MACMIIDR = PHYValue;
000114  48ef              LDR      r0,|L1.1236|
000116  6142              STR      r2,[r0,#0x14]
;;;2513     /* Write the result value into the MII Address register */
;;;2514     ETH->MACMIIAR = tmpreg;
000118  6101              STR      r1,[r0,#0x10]
;;;2515     /* Check for the Busy flag */
;;;2516     do
00011a  bf00              NOP      
                  |L1.284|
;;;2517     {
;;;2518       timeout++;
00011c  9800              LDR      r0,[sp,#0]
00011e  1c40              ADDS     r0,r0,#1
000120  9000              STR      r0,[sp,#0]
;;;2519       tmpreg = ETH->MACMIIAR;
000122  48ec              LDR      r0,|L1.1236|
000124  6901              LDR      r1,[r0,#0x10]
;;;2520     } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
000126  f0010001          AND      r0,r1,#1
00012a  b118              CBZ      r0,|L1.308|
00012c  4dea              LDR      r5,|L1.1240|
00012e  9800              LDR      r0,[sp,#0]
000130  42a8              CMP      r0,r5
000132  d3f3              BCC      |L1.284|
                  |L1.308|
;;;2521     /* Return ERROR in case of timeout */
;;;2522     if(timeout == PHY_WRITE_TO)
000134  4de8              LDR      r5,|L1.1240|
000136  9800              LDR      r0,[sp,#0]
000138  42a8              CMP      r0,r5
00013a  d101              BNE      |L1.320|
;;;2523     {
;;;2524       return ETH_ERROR;
00013c  2000              MOVS     r0,#0
                  |L1.318|
;;;2525     }
;;;2526     
;;;2527     /* Return SUCCESS */
;;;2528     return ETH_SUCCESS;  
;;;2529   }
00013e  bd38              POP      {r3-r5,pc}
                  |L1.320|
000140  2001              MOVS     r0,#1                 ;2528
000142  e7fc              B        |L1.318|
;;;2530   
                          ENDP

                  ETH_ReadPHYRegister PROC
;;;2446     */
;;;2447   uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
000144  b518              PUSH     {r3,r4,lr}
;;;2448   {
000146  4602              MOV      r2,r0
000148  460b              MOV      r3,r1
;;;2449     uint32_t tmpreg = 0;     
00014a  2100              MOVS     r1,#0
;;;2450   __IO uint32_t timeout = 0;
00014c  2000              MOVS     r0,#0
00014e  9000              STR      r0,[sp,#0]
;;;2451     /* Check the parameters */
;;;2452     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2453     assert_param(IS_ETH_PHY_REG(PHYReg));
;;;2454     
;;;2455     /* Get the ETHERNET MACMIIAR value */
;;;2456     tmpreg = ETH->MACMIIAR;
000150  48e0              LDR      r0,|L1.1236|
000152  6901              LDR      r1,[r0,#0x10]
;;;2457     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;2458     tmpreg &= ~MACMIIAR_CR_MASK;
000154  f001011c          AND      r1,r1,#0x1c
;;;2459     /* Prepare the MII address register value */
;;;2460     tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
000158  f44f4078          MOV      r0,#0xf800
00015c  ea0020c2          AND      r0,r0,r2,LSL #11
000160  4301              ORRS     r1,r1,r0
;;;2461     tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
000162  f44f60f8          MOV      r0,#0x7c0
000166  ea001083          AND      r0,r0,r3,LSL #6
00016a  4301              ORRS     r1,r1,r0
;;;2462     tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
00016c  f0210102          BIC      r1,r1,#2
;;;2463     tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
000170  f0410101          ORR      r1,r1,#1
;;;2464     /* Write the result value into the MII Address register */
;;;2465     ETH->MACMIIAR = tmpreg;
000174  48d7              LDR      r0,|L1.1236|
000176  6101              STR      r1,[r0,#0x10]
;;;2466     /* Check for the Busy flag */
;;;2467     do
000178  bf00              NOP      
                  |L1.378|
;;;2468     {
;;;2469       timeout++;
00017a  9800              LDR      r0,[sp,#0]
00017c  1c40              ADDS     r0,r0,#1
00017e  9000              STR      r0,[sp,#0]
;;;2470       tmpreg = ETH->MACMIIAR;
000180  48d4              LDR      r0,|L1.1236|
000182  6901              LDR      r1,[r0,#0x10]
;;;2471     } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
000184  f0010001          AND      r0,r1,#1
000188  b118              CBZ      r0,|L1.402|
00018a  4cd3              LDR      r4,|L1.1240|
00018c  9800              LDR      r0,[sp,#0]
00018e  42a0              CMP      r0,r4
000190  d3f3              BCC      |L1.378|
                  |L1.402|
;;;2472     /* Return ERROR in case of timeout */
;;;2473     if(timeout == PHY_READ_TO)
000192  4cd1              LDR      r4,|L1.1240|
000194  9800              LDR      r0,[sp,#0]
000196  42a0              CMP      r0,r4
000198  d101              BNE      |L1.414|
;;;2474     {
;;;2475       return (uint16_t)ETH_ERROR;
00019a  2000              MOVS     r0,#0
                  |L1.412|
;;;2476     }
;;;2477     
;;;2478     /* Return data register value */
;;;2479     return (uint16_t)(ETH->MACMIIDR);
;;;2480   }
00019c  bd18              POP      {r3,r4,pc}
                  |L1.414|
00019e  48cd              LDR      r0,|L1.1236|
0001a0  6940              LDR      r0,[r0,#0x14]         ;2479
0001a2  b280              UXTH     r0,r0                 ;2479
0001a4  e7fa              B        |L1.412|
;;;2481   
                          ENDP

                  ETH_Init PROC
;;;288      */
;;;289    uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
0001a6  e92d41f0          PUSH     {r4-r8,lr}
;;;290    {
0001aa  b086              SUB      sp,sp,#0x18
0001ac  4604              MOV      r4,r0
0001ae  460f              MOV      r7,r1
;;;291      uint32_t RegValue = 0, tmpreg = 0;
0001b0  f04f0800          MOV      r8,#0
0001b4  2500              MOVS     r5,#0
;;;292      __IO uint32_t i = 0;
0001b6  2000              MOVS     r0,#0
0001b8  9005              STR      r0,[sp,#0x14]
;;;293      RCC_ClocksTypeDef  rcc_clocks;
;;;294      uint32_t hclk = 60000000;
0001ba  4ec8              LDR      r6,|L1.1244|
;;;295      __IO uint32_t timeout = 0;
0001bc  9000              STR      r0,[sp,#0]
;;;296      /* Check the parameters */
;;;297      /* MAC --------------------------*/ 
;;;298      assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct->ETH_AutoNegotiation));
;;;299      assert_param(IS_ETH_WATCHDOG(ETH_InitStruct->ETH_Watchdog));
;;;300      assert_param(IS_ETH_JABBER(ETH_InitStruct->ETH_Jabber));
;;;301      assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct->ETH_InterFrameGap));
;;;302      assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct->ETH_CarrierSense));
;;;303      assert_param(IS_ETH_SPEED(ETH_InitStruct->ETH_Speed));
;;;304      assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct->ETH_ReceiveOwn));
;;;305      assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct->ETH_LoopbackMode));
;;;306      assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct->ETH_Mode));
;;;307      assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct->ETH_ChecksumOffload));
;;;308      assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct->ETH_RetryTransmission));
;;;309      assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct->ETH_AutomaticPadCRCStrip));
;;;310      assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct->ETH_BackOffLimit));
;;;311      assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct->ETH_DeferralCheck));
;;;312      assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct->ETH_ReceiveAll));
;;;313      assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct->ETH_SourceAddrFilter));
;;;314      assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct->ETH_PassControlFrames));
;;;315      assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct->ETH_BroadcastFramesReception));
;;;316      assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct->ETH_DestinationAddrFilter));
;;;317      assert_param(IS_ETH_PROMISCIOUS_MODE(ETH_InitStruct->ETH_PromiscuousMode));
;;;318      assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct->ETH_MulticastFramesFilter));  
;;;319      assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct->ETH_UnicastFramesFilter));
;;;320      assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct->ETH_PauseTime));
;;;321      assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct->ETH_ZeroQuantaPause));
;;;322      assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct->ETH_PauseLowThreshold));
;;;323      assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct->ETH_UnicastPauseFrameDetect));
;;;324      assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct->ETH_ReceiveFlowControl));
;;;325      assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct->ETH_TransmitFlowControl));
;;;326      assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct->ETH_VLANTagComparison));
;;;327      assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct->ETH_VLANTagIdentifier));
;;;328      /* DMA --------------------------*/
;;;329      assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame));
;;;330      assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct->ETH_ReceiveStoreForward));
;;;331      assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct->ETH_FlushReceivedFrame));
;;;332      assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct->ETH_TransmitStoreForward));
;;;333      assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct->ETH_TransmitThresholdControl));
;;;334      assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct->ETH_ForwardErrorFrames));
;;;335      assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct->ETH_ForwardUndersizedGoodFrames));
;;;336      assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct->ETH_ReceiveThresholdControl));
;;;337      assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct->ETH_SecondFrameOperate));
;;;338      assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct->ETH_AddressAlignedBeats));
;;;339      assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct->ETH_FixedBurst));
;;;340      assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct->ETH_RxDMABurstLength));
;;;341      assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct->ETH_TxDMABurstLength)); 
;;;342      assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
;;;343      assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
;;;344      /*-------------------------------- MAC Config ------------------------------*/   
;;;345      /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
;;;346      /* Get the ETHERNET MACMIIAR value */
;;;347      tmpreg = ETH->MACMIIAR;
0001be  48c5              LDR      r0,|L1.1236|
0001c0  6905              LDR      r5,[r0,#0x10]
;;;348      /* Clear CSR Clock Range CR[2:0] bits */
;;;349      tmpreg &= MACMIIAR_CR_MASK;
0001c2  f025051c          BIC      r5,r5,#0x1c
;;;350      /* Get hclk frequency value */
;;;351      RCC_GetClocksFreq(&rcc_clocks);
0001c6  a801              ADD      r0,sp,#4
0001c8  f7fffffe          BL       RCC_GetClocksFreq
;;;352      hclk = rcc_clocks.HCLK_Frequency;
0001cc  9e02              LDR      r6,[sp,#8]
;;;353      
;;;354      /* Set CR bits depending on hclk value */
;;;355      if((hclk >= 20000000)&&(hclk < 35000000))
0001ce  48c4              LDR      r0,|L1.1248|
0001d0  4286              CMP      r6,r0
0001d2  d305              BCC      |L1.480|
0001d4  48c3              LDR      r0,|L1.1252|
0001d6  4286              CMP      r6,r0
0001d8  d202              BCS      |L1.480|
;;;356      {
;;;357        /* CSR Clock Range between 20-35 MHz */
;;;358        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
0001da  f0450508          ORR      r5,r5,#8
0001de  e01a              B        |L1.534|
                  |L1.480|
;;;359      }
;;;360      else if((hclk >= 35000000)&&(hclk < 60000000))
0001e0  48c0              LDR      r0,|L1.1252|
0001e2  4286              CMP      r6,r0
0001e4  d305              BCC      |L1.498|
0001e6  48bd              LDR      r0,|L1.1244|
0001e8  4286              CMP      r6,r0
0001ea  d202              BCS      |L1.498|
;;;361      {
;;;362        /* CSR Clock Range between 35-60 MHz */ 
;;;363        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
0001ec  f045050c          ORR      r5,r5,#0xc
0001f0  e011              B        |L1.534|
                  |L1.498|
;;;364      }  
;;;365      else if((hclk >= 60000000)&&(hclk < 100000000))
0001f2  48ba              LDR      r0,|L1.1244|
0001f4  4286              CMP      r6,r0
0001f6  d303              BCC      |L1.512|
0001f8  48bb              LDR      r0,|L1.1256|
0001fa  4286              CMP      r6,r0
0001fc  d200              BCS      |L1.512|
;;;366      {
;;;367        /* CSR Clock Range between 60-100 MHz */ 
;;;368        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
0001fe  e00a              B        |L1.534|
                  |L1.512|
;;;369      }  
;;;370      else if((hclk >= 100000000)&&(hclk < 150000000))
000200  48b9              LDR      r0,|L1.1256|
000202  4286              CMP      r6,r0
000204  d305              BCC      |L1.530|
000206  48b9              LDR      r0,|L1.1260|
000208  4286              CMP      r6,r0
00020a  d202              BCS      |L1.530|
;;;371      {
;;;372        /* CSR Clock Range between 100-150 MHz */ 
;;;373        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
00020c  f0450504          ORR      r5,r5,#4
000210  e001              B        |L1.534|
                  |L1.530|
;;;374      }   
;;;375      else /* ((hclk >= 150000000)&&(hclk <= 168000000)) */
;;;376      {
;;;377        /* CSR Clock Range between 150-168 MHz */ 
;;;378        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
000212  f0450510          ORR      r5,r5,#0x10
                  |L1.534|
;;;379      }
;;;380      
;;;381      /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
;;;382      ETH->MACMIIAR = (uint32_t)tmpreg;  
000216  48af              LDR      r0,|L1.1236|
000218  6105              STR      r5,[r0,#0x10]
;;;383      /*-------------------- PHY initialization and configuration ----------------*/
;;;384      /* Put the PHY in reset mode */
;;;385      if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
00021a  f44f4200          MOV      r2,#0x8000
00021e  2100              MOVS     r1,#0
000220  4638              MOV      r0,r7
000222  f7fffffe          BL       ETH_WritePHYRegister
000226  b918              CBNZ     r0,|L1.560|
;;;386      {
;;;387        /* Return ERROR in case of write timeout */
;;;388        return ETH_ERROR;
000228  2000              MOVS     r0,#0
                  |L1.554|
;;;389      }
;;;390      
;;;391      /* Delay to assure PHY reset */
;;;392      _eth_delay_(PHY_RESET_DELAY);
;;;393        
;;;394      if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
;;;395      {  
;;;396        /* We wait for linked status... */
;;;397        do
;;;398        {
;;;399          timeout++;
;;;400        } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
;;;401    
;;;402        /* Return ERROR in case of timeout */
;;;403        if(timeout == PHY_READ_TO)
;;;404        {
;;;405          return ETH_ERROR;
;;;406        }
;;;407    
;;;408        /* Reset Timeout counter */
;;;409        timeout = 0; 
;;;410        /* Enable Auto-Negotiation */
;;;411        if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
;;;412        {
;;;413          /* Return ERROR in case of write timeout */
;;;414          return ETH_ERROR;
;;;415        }
;;;416    
;;;417        /* Wait until the auto-negotiation will be completed */
;;;418        do
;;;419        {
;;;420          timeout++;
;;;421        } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
;;;422    
;;;423        /* Return ERROR in case of timeout */
;;;424        if(timeout == PHY_READ_TO)
;;;425        {
;;;426          return ETH_ERROR;
;;;427        }
;;;428    
;;;429        /* Reset Timeout counter */
;;;430        timeout = 0;
;;;431        
;;;432        /* Read the result of the auto-negotiation */
;;;433        RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
;;;434    		
;;;435    		/* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;436        if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
;;;437        {
;;;438          /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;439          ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
;;;440        }
;;;441        else
;;;442        {
;;;443          /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;444          ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
;;;445        }
;;;446    
;;;447        /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;448        if(RegValue & PHY_SPEED_STATUS)
;;;449        {  
;;;450          /* Set Ethernet speed to 10M following the auto-negotiation */    
;;;451          ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
;;;452        }
;;;453        else
;;;454        {   
;;;455          /* Set Ethernet speed to 100M following the auto-negotiation */ 
;;;456          ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
;;;457        }
;;;458      }
;;;459      else
;;;460      {
;;;461        if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
;;;462                                                       (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
;;;463        {
;;;464          /* Return ERROR in case of write timeout */
;;;465          return ETH_ERROR;
;;;466        }
;;;467        /* Delay to assure PHY configuration */
;;;468        _eth_delay_(PHY_CONFIG_DELAY);
;;;469        
;;;470      }
;;;471      /*------------------------ ETHERNET MACCR Configuration --------------------*/
;;;472      /* Get the ETHERNET MACCR value */  
;;;473      tmpreg = ETH->MACCR;
;;;474      /* Clear WD, PCE, PS, TE and RE bits */
;;;475      tmpreg &= MACCR_CLEAR_MASK;
;;;476      /* Set the WD bit according to ETH_Watchdog value */
;;;477      /* Set the JD: bit according to ETH_Jabber value */
;;;478      /* Set the IFG bit according to ETH_InterFrameGap value */ 
;;;479      /* Set the DCRS bit according to ETH_CarrierSense value */  
;;;480      /* Set the FES bit according to ETH_Speed value */ 
;;;481      /* Set the DO bit according to ETH_ReceiveOwn value */ 
;;;482      /* Set the LM bit according to ETH_LoopbackMode value */ 
;;;483      /* Set the DM bit according to ETH_Mode value */ 
;;;484      /* Set the IPCO bit according to ETH_ChecksumOffload value */                   
;;;485      /* Set the DR bit according to ETH_RetryTransmission value */ 
;;;486      /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
;;;487      /* Set the BL bit according to ETH_BackOffLimit value */ 
;;;488      /* Set the DC bit according to ETH_DeferralCheck value */                          
;;;489      tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
;;;490                      ETH_InitStruct->ETH_Jabber | 
;;;491                      ETH_InitStruct->ETH_InterFrameGap |
;;;492                      ETH_InitStruct->ETH_CarrierSense |
;;;493                      ETH_InitStruct->ETH_Speed | 
;;;494                      ETH_InitStruct->ETH_ReceiveOwn |
;;;495                      ETH_InitStruct->ETH_LoopbackMode |
;;;496                      ETH_InitStruct->ETH_Mode | 
;;;497                      ETH_InitStruct->ETH_ChecksumOffload |    
;;;498                      ETH_InitStruct->ETH_RetryTransmission | 
;;;499                      ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
;;;500                      ETH_InitStruct->ETH_BackOffLimit | 
;;;501                      ETH_InitStruct->ETH_DeferralCheck);
;;;502      /* Write to ETHERNET MACCR */
;;;503      ETH->MACCR = (uint32_t)tmpreg;
;;;504    	/* Wait until the write operation will be taken into account :
;;;505       at least four TX_CLK/RX_CLK clock cycles */
;;;506      tmpreg = ETH->MACCR;
;;;507      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;508      ETH->MACCR = tmpreg;
;;;509      
;;;510      /*----------------------- ETHERNET MACFFR Configuration --------------------*/ 
;;;511      /* Set the RA bit according to ETH_ReceiveAll value */
;;;512      /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */
;;;513      /* Set the PCF bit according to ETH_PassControlFrames value */
;;;514      /* Set the DBF bit according to ETH_BroadcastFramesReception value */
;;;515      /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
;;;516      /* Set the PR bit according to ETH_PromiscuousMode value */
;;;517      /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
;;;518      /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
;;;519      /* Write to ETHERNET MACFFR */  
;;;520      ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
;;;521                              ETH_InitStruct->ETH_SourceAddrFilter |
;;;522                              ETH_InitStruct->ETH_PassControlFrames |
;;;523                              ETH_InitStruct->ETH_BroadcastFramesReception | 
;;;524                              ETH_InitStruct->ETH_DestinationAddrFilter |
;;;525                              ETH_InitStruct->ETH_PromiscuousMode |
;;;526                              ETH_InitStruct->ETH_MulticastFramesFilter |
;;;527                              ETH_InitStruct->ETH_UnicastFramesFilter);
;;;528    
;;;529    	/* Wait until the write operation will be taken into account :
;;;530       at least four TX_CLK/RX_CLK clock cycles */
;;;531       tmpreg = ETH->MACFFR;
;;;532      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;533      ETH->MACFFR = tmpreg;
;;;534    	 
;;;535      /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
;;;536      /* Write to ETHERNET MACHTHR */
;;;537      ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
;;;538      /* Write to ETHERNET MACHTLR */
;;;539      ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
;;;540      /*----------------------- ETHERNET MACFCR Configuration --------------------*/
;;;541      /* Get the ETHERNET MACFCR value */  
;;;542      tmpreg = ETH->MACFCR;
;;;543      /* Clear xx bits */
;;;544      tmpreg &= MACFCR_CLEAR_MASK;
;;;545      
;;;546      /* Set the PT bit according to ETH_PauseTime value */
;;;547      /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
;;;548      /* Set the PLT bit according to ETH_PauseLowThreshold value */
;;;549      /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
;;;550      /* Set the RFE bit according to ETH_ReceiveFlowControl value */
;;;551      /* Set the TFE bit according to ETH_TransmitFlowControl value */  
;;;552      tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
;;;553                       ETH_InitStruct->ETH_ZeroQuantaPause |
;;;554                       ETH_InitStruct->ETH_PauseLowThreshold |
;;;555                       ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
;;;556                       ETH_InitStruct->ETH_ReceiveFlowControl |
;;;557                       ETH_InitStruct->ETH_TransmitFlowControl); 
;;;558      /* Write to ETHERNET MACFCR */
;;;559      ETH->MACFCR = (uint32_t)tmpreg;
;;;560    	
;;;561    	/* Wait until the write operation will be taken into account :
;;;562       at least four TX_CLK/RX_CLK clock cycles */
;;;563        tmpreg = ETH->MACFCR;
;;;564      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;565      ETH->MACFCR = tmpreg;
;;;566    		
;;;567      /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
;;;568      /* Set the ETV bit according to ETH_VLANTagComparison value */
;;;569      /* Set the VL bit according to ETH_VLANTagIdentifier value */  
;;;570      ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
;;;571                                 ETH_InitStruct->ETH_VLANTagIdentifier); 
;;;572    	/* Wait until the write operation will be taken into account :
;;;573       at least four TX_CLK/RX_CLK clock cycles */
;;;574      tmpreg = ETH->MACVLANTR;
;;;575      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;576      ETH->MACVLANTR = tmpreg;
;;;577           
;;;578      /*-------------------------------- DMA Config ------------------------------*/
;;;579      /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
;;;580      /* Get the ETHERNET DMAOMR value */  
;;;581      tmpreg = ETH->DMAOMR;
;;;582      /* Clear xx bits */
;;;583      tmpreg &= DMAOMR_CLEAR_MASK;
;;;584      
;;;585      /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */
;;;586      /* Set the RSF bit according to ETH_ReceiveStoreForward value */
;;;587      /* Set the DFF bit according to ETH_FlushReceivedFrame value */
;;;588      /* Set the TSF bit according to ETH_TransmitStoreForward value */
;;;589      /* Set the TTC bit according to ETH_TransmitThresholdControl value */
;;;590      /* Set the FEF bit according to ETH_ForwardErrorFrames value */
;;;591      /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
;;;592      /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
;;;593      /* Set the OSF bit according to ETH_SecondFrameOperate value */
;;;594      tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
;;;595                      ETH_InitStruct->ETH_ReceiveStoreForward |
;;;596                      ETH_InitStruct->ETH_FlushReceivedFrame |
;;;597                      ETH_InitStruct->ETH_TransmitStoreForward | 
;;;598                      ETH_InitStruct->ETH_TransmitThresholdControl |
;;;599                      ETH_InitStruct->ETH_ForwardErrorFrames |
;;;600                      ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
;;;601                      ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
;;;602                      ETH_InitStruct->ETH_SecondFrameOperate); 
;;;603      /* Write to ETHERNET DMAOMR */
;;;604      ETH->DMAOMR = (uint32_t)tmpreg;
;;;605    	/* Wait until the write operation will be taken into account :
;;;606       at least four TX_CLK/RX_CLK clock cycles */
;;;607      tmpreg = ETH->DMAOMR;
;;;608      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;609      ETH->DMAOMR = tmpreg;
;;;610      
;;;611      /*----------------------- ETHERNET DMABMR Configuration --------------------*/ 
;;;612      /* Set the AAL bit according to ETH_AddressAlignedBeats value */
;;;613      /* Set the FB bit according to ETH_FixedBurst value */
;;;614      /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
;;;615      /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
;;;616      /* Set the DSL bit according to ETH_DesciptorSkipLength value */
;;;617      /* Set the PR and DA bits according to ETH_DMAArbitration value */         
;;;618      ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
;;;619                              ETH_InitStruct->ETH_FixedBurst |
;;;620                              ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
;;;621                              ETH_InitStruct->ETH_TxDMABurstLength | 
;;;622                             (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
;;;623                              ETH_InitStruct->ETH_DMAArbitration |
;;;624                              ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
;;;625    	/* Wait until the write operation will be taken into account :
;;;626       at least four TX_CLK/RX_CLK clock cycles */
;;;627      tmpreg = ETH->DMABMR;
;;;628      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;629      ETH->DMABMR = tmpreg;
;;;630                              
;;;631      #ifdef USE_ENHANCED_DMA_DESCRIPTORS
;;;632        /* Enable the Enhanced DMA descriptors */
;;;633        ETH->DMABMR |= ETH_DMABMR_EDE;
;;;634    		/* Wait until the write operation will be taken into account :
;;;635       at least four TX_CLK/RX_CLK clock cycles */
;;;636      tmpreg = ETH->DMABMR;
;;;637      _eth_delay_(ETH_REG_WRITE_DELAY);
;;;638      ETH->DMABMR = tmpreg;
;;;639      #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
;;;640                                  
;;;641      /* Return Ethernet configuration success */
;;;642      return ETH_SUCCESS;
;;;643    }
00022a  b006              ADD      sp,sp,#0x18
00022c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.560|
000230  48af              LDR      r0,|L1.1264|
000232  f7fffffe          BL       ETH_Delay
000236  6820              LDR      r0,[r4,#0]            ;394
000238  2800              CMP      r0,#0                 ;394
00023a  d04e              BEQ      |L1.730|
00023c  bf00              NOP                            ;397
                  |L1.574|
00023e  9800              LDR      r0,[sp,#0]            ;399
000240  1c40              ADDS     r0,r0,#1              ;399
000242  9000              STR      r0,[sp,#0]            ;399
000244  2101              MOVS     r1,#1                 ;400
000246  4638              MOV      r0,r7                 ;400
000248  f7fffffe          BL       ETH_ReadPHYRegister
00024c  f0000004          AND      r0,r0,#4              ;400
000250  b918              CBNZ     r0,|L1.602|
000252  49a1              LDR      r1,|L1.1240|
000254  9800              LDR      r0,[sp,#0]            ;400
000256  4288              CMP      r0,r1                 ;400
000258  d3f1              BCC      |L1.574|
                  |L1.602|
00025a  499f              LDR      r1,|L1.1240|
00025c  9800              LDR      r0,[sp,#0]            ;403
00025e  4288              CMP      r0,r1                 ;403
000260  d101              BNE      |L1.614|
000262  2000              MOVS     r0,#0                 ;405
000264  e7e1              B        |L1.554|
                  |L1.614|
000266  2000              MOVS     r0,#0                 ;409
000268  9000              STR      r0,[sp,#0]            ;409
00026a  f44f5280          MOV      r2,#0x1000            ;411
00026e  2100              MOVS     r1,#0                 ;411
000270  4638              MOV      r0,r7                 ;411
000272  f7fffffe          BL       ETH_WritePHYRegister
000276  b908              CBNZ     r0,|L1.636|
000278  2000              MOVS     r0,#0                 ;414
00027a  e7d6              B        |L1.554|
                  |L1.636|
00027c  bf00              NOP                            ;418
                  |L1.638|
00027e  9800              LDR      r0,[sp,#0]            ;420
000280  1c40              ADDS     r0,r0,#1              ;420
000282  9000              STR      r0,[sp,#0]            ;420
000284  2101              MOVS     r1,#1                 ;421
000286  4638              MOV      r0,r7                 ;421
000288  f7fffffe          BL       ETH_ReadPHYRegister
00028c  f0000020          AND      r0,r0,#0x20           ;421
000290  b918              CBNZ     r0,|L1.666|
000292  4991              LDR      r1,|L1.1240|
000294  9800              LDR      r0,[sp,#0]            ;421
000296  4288              CMP      r0,r1                 ;421
000298  d3f1              BCC      |L1.638|
                  |L1.666|
00029a  498f              LDR      r1,|L1.1240|
00029c  9800              LDR      r0,[sp,#0]            ;424
00029e  4288              CMP      r0,r1                 ;424
0002a0  d101              BNE      |L1.678|
0002a2  2000              MOVS     r0,#0                 ;426
0002a4  e7c1              B        |L1.554|
                  |L1.678|
0002a6  2000              MOVS     r0,#0                 ;430
0002a8  9000              STR      r0,[sp,#0]            ;430
0002aa  2110              MOVS     r1,#0x10              ;433
0002ac  4638              MOV      r0,r7                 ;433
0002ae  f7fffffe          BL       ETH_ReadPHYRegister
0002b2  4680              MOV      r8,r0                 ;433
0002b4  f0080004          AND      r0,r8,#4              ;436
0002b8  b118              CBZ      r0,|L1.706|
0002ba  f44f6000          MOV      r0,#0x800             ;439
0002be  6220              STR      r0,[r4,#0x20]         ;439
0002c0  e001              B        |L1.710|
                  |L1.706|
0002c2  2000              MOVS     r0,#0                 ;444
0002c4  6220              STR      r0,[r4,#0x20]         ;444
                  |L1.710|
0002c6  f0080002          AND      r0,r8,#2              ;448
0002ca  b110              CBZ      r0,|L1.722|
0002cc  2000              MOVS     r0,#0                 ;451
0002ce  6160              STR      r0,[r4,#0x14]         ;451
0002d0  e016              B        |L1.768|
                  |L1.722|
0002d2  f44f4080          MOV      r0,#0x4000            ;456
0002d6  6160              STR      r0,[r4,#0x14]         ;456
0002d8  e012              B        |L1.768|
                  |L1.730|
0002da  6a20              LDR      r0,[r4,#0x20]         ;461
0002dc  f3c000cf          UBFX     r0,r0,#3,#16          ;461
0002e0  6961              LDR      r1,[r4,#0x14]         ;461
0002e2  f3c1014f          UBFX     r1,r1,#1,#16          ;461
0002e6  ea400201          ORR      r2,r0,r1              ;461
0002ea  2100              MOVS     r1,#0                 ;461
0002ec  4638              MOV      r0,r7                 ;461
0002ee  f7fffffe          BL       ETH_WritePHYRegister
0002f2  b908              CBNZ     r0,|L1.760|
0002f4  2000              MOVS     r0,#0                 ;465
0002f6  e798              B        |L1.554|
                  |L1.760|
0002f8  f06f407f          MVN      r0,#0xff000000        ;468
0002fc  f7fffffe          BL       ETH_Delay
                  |L1.768|
000300  4874              LDR      r0,|L1.1236|
000302  6805              LDR      r5,[r0,#0]            ;473
000304  487b              LDR      r0,|L1.1268|
000306  4005              ANDS     r5,r5,r0              ;475
000308  e9d40101          LDRD     r0,r1,[r4,#4]         ;489
00030c  4308              ORRS     r0,r0,r1              ;489
00030e  68e1              LDR      r1,[r4,#0xc]          ;489
000310  4308              ORRS     r0,r0,r1              ;489
000312  6921              LDR      r1,[r4,#0x10]         ;489
000314  4308              ORRS     r0,r0,r1              ;489
000316  6961              LDR      r1,[r4,#0x14]         ;489
000318  4308              ORRS     r0,r0,r1              ;489
00031a  69a1              LDR      r1,[r4,#0x18]         ;489
00031c  4308              ORRS     r0,r0,r1              ;489
00031e  69e1              LDR      r1,[r4,#0x1c]         ;489
000320  4308              ORRS     r0,r0,r1              ;489
000322  6a21              LDR      r1,[r4,#0x20]         ;489
000324  4308              ORRS     r0,r0,r1              ;489
000326  6a61              LDR      r1,[r4,#0x24]         ;489
000328  4308              ORRS     r0,r0,r1              ;489
00032a  6aa1              LDR      r1,[r4,#0x28]         ;489
00032c  4308              ORRS     r0,r0,r1              ;489
00032e  6ae1              LDR      r1,[r4,#0x2c]         ;489
000330  4308              ORRS     r0,r0,r1              ;489
000332  6b21              LDR      r1,[r4,#0x30]         ;489
000334  4308              ORRS     r0,r0,r1              ;489
000336  6b61              LDR      r1,[r4,#0x34]         ;489
000338  4308              ORRS     r0,r0,r1              ;489
00033a  4305              ORRS     r5,r5,r0              ;489
00033c  4865              LDR      r0,|L1.1236|
00033e  6005              STR      r5,[r0,#0]            ;503
000340  6805              LDR      r5,[r0,#0]            ;506
000342  f64f70ff          MOV      r0,#0xffff            ;507
000346  f7fffffe          BL       ETH_Delay
00034a  4862              LDR      r0,|L1.1236|
00034c  6005              STR      r5,[r0,#0]            ;508
00034e  e9d4010e          LDRD     r0,r1,[r4,#0x38]      ;520
000352  4308              ORRS     r0,r0,r1              ;520
000354  6c21              LDR      r1,[r4,#0x40]         ;520
000356  4308              ORRS     r0,r0,r1              ;520
000358  6c61              LDR      r1,[r4,#0x44]         ;520
00035a  4308              ORRS     r0,r0,r1              ;520
00035c  6ca1              LDR      r1,[r4,#0x48]         ;520
00035e  4308              ORRS     r0,r0,r1              ;520
000360  6ce1              LDR      r1,[r4,#0x4c]         ;520
000362  4308              ORRS     r0,r0,r1              ;520
000364  6d21              LDR      r1,[r4,#0x50]         ;520
000366  4308              ORRS     r0,r0,r1              ;520
000368  6d61              LDR      r1,[r4,#0x54]         ;520
00036a  4308              ORRS     r0,r0,r1              ;520
00036c  4959              LDR      r1,|L1.1236|
00036e  6048              STR      r0,[r1,#4]            ;520
000370  4608              MOV      r0,r1                 ;531
000372  6845              LDR      r5,[r0,#4]            ;531
000374  f64f70ff          MOV      r0,#0xffff            ;532
000378  f7fffffe          BL       ETH_Delay
00037c  4855              LDR      r0,|L1.1236|
00037e  6045              STR      r5,[r0,#4]            ;533
000380  4954              LDR      r1,|L1.1236|
000382  6da0              LDR      r0,[r4,#0x58]         ;537
000384  6088              STR      r0,[r1,#8]            ;537
000386  6de0              LDR      r0,[r4,#0x5c]         ;539
000388  60c8              STR      r0,[r1,#0xc]          ;539
00038a  4608              MOV      r0,r1                 ;542
00038c  6985              LDR      r5,[r0,#0x18]         ;542
00038e  f64f7041          MOV      r0,#0xff41            ;544
000392  4005              ANDS     r5,r5,r0              ;544
000394  f8b41060          LDRH     r1,[r4,#0x60]         ;552
000398  6e60              LDR      r0,[r4,#0x64]         ;552
00039a  ea404001          ORR      r0,r0,r1,LSL #16      ;552
00039e  6ea1              LDR      r1,[r4,#0x68]         ;552
0003a0  4308              ORRS     r0,r0,r1              ;552
0003a2  6ee1              LDR      r1,[r4,#0x6c]         ;552
0003a4  4308              ORRS     r0,r0,r1              ;552
0003a6  6f21              LDR      r1,[r4,#0x70]         ;552
0003a8  4308              ORRS     r0,r0,r1              ;552
0003aa  6f61              LDR      r1,[r4,#0x74]         ;552
0003ac  4308              ORRS     r0,r0,r1              ;552
0003ae  4305              ORRS     r5,r5,r0              ;552
0003b0  4848              LDR      r0,|L1.1236|
0003b2  6185              STR      r5,[r0,#0x18]         ;559
0003b4  6985              LDR      r5,[r0,#0x18]         ;563
0003b6  f64f70ff          MOV      r0,#0xffff            ;564
0003ba  f7fffffe          BL       ETH_Delay
0003be  4845              LDR      r0,|L1.1236|
0003c0  6185              STR      r5,[r0,#0x18]         ;565
0003c2  e9d4011e          LDRD     r0,r1,[r4,#0x78]      ;570
0003c6  4308              ORRS     r0,r0,r1              ;570
0003c8  4942              LDR      r1,|L1.1236|
0003ca  61c8              STR      r0,[r1,#0x1c]         ;570
0003cc  4608              MOV      r0,r1                 ;574
0003ce  69c5              LDR      r5,[r0,#0x1c]         ;574
0003d0  f64f70ff          MOV      r0,#0xffff            ;575
0003d4  f7fffffe          BL       ETH_Delay
0003d8  483e              LDR      r0,|L1.1236|
0003da  61c5              STR      r5,[r0,#0x1c]         ;576
0003dc  4846              LDR      r0,|L1.1272|
0003de  6985              LDR      r5,[r0,#0x18]         ;581
0003e0  4846              LDR      r0,|L1.1276|
0003e2  4005              ANDS     r5,r5,r0              ;583
0003e4  e9d40120          LDRD     r0,r1,[r4,#0x80]      ;594
0003e8  4308              ORRS     r0,r0,r1              ;594
0003ea  f8d41088          LDR      r1,[r4,#0x88]         ;594
0003ee  4308              ORRS     r0,r0,r1              ;594
0003f0  f8d4108c          LDR      r1,[r4,#0x8c]         ;594
0003f4  4308              ORRS     r0,r0,r1              ;594
0003f6  f8d41090          LDR      r1,[r4,#0x90]         ;594
0003fa  4308              ORRS     r0,r0,r1              ;594
0003fc  f8d41094          LDR      r1,[r4,#0x94]         ;594
000400  4308              ORRS     r0,r0,r1              ;594
000402  f8d41098          LDR      r1,[r4,#0x98]         ;594
000406  4308              ORRS     r0,r0,r1              ;594
000408  f8d4109c          LDR      r1,[r4,#0x9c]         ;594
00040c  4308              ORRS     r0,r0,r1              ;594
00040e  f8d410a0          LDR      r1,[r4,#0xa0]         ;594
000412  4308              ORRS     r0,r0,r1              ;594
000414  4305              ORRS     r5,r5,r0              ;594
000416  4838              LDR      r0,|L1.1272|
000418  6185              STR      r5,[r0,#0x18]         ;604
00041a  6985              LDR      r5,[r0,#0x18]         ;607
00041c  f64f70ff          MOV      r0,#0xffff            ;608
000420  f7fffffe          BL       ETH_Delay
000424  4834              LDR      r0,|L1.1272|
000426  6185              STR      r5,[r0,#0x18]         ;609
000428  e9d40129          LDRD     r0,r1,[r4,#0xa4]      ;618
00042c  4308              ORRS     r0,r0,r1              ;618
00042e  f8d410ac          LDR      r1,[r4,#0xac]         ;618
000432  4308              ORRS     r0,r0,r1              ;618
000434  f8d410b0          LDR      r1,[r4,#0xb0]         ;618
000438  4308              ORRS     r0,r0,r1              ;618
00043a  f8d410b4          LDR      r1,[r4,#0xb4]         ;618
00043e  ea400081          ORR      r0,r0,r1,LSL #2       ;618
000442  f8d410b8          LDR      r1,[r4,#0xb8]         ;618
000446  4308              ORRS     r0,r0,r1              ;618
000448  f4400000          ORR      r0,r0,#0x800000       ;618
00044c  492a              LDR      r1,|L1.1272|
00044e  6008              STR      r0,[r1,#0]            ;618
000450  4608              MOV      r0,r1                 ;627
000452  6805              LDR      r5,[r0,#0]            ;627
000454  f64f70ff          MOV      r0,#0xffff            ;628
000458  f7fffffe          BL       ETH_Delay
00045c  4826              LDR      r0,|L1.1272|
00045e  6005              STR      r5,[r0,#0]            ;629
000460  6800              LDR      r0,[r0,#0]            ;633
000462  f0400080          ORR      r0,r0,#0x80           ;633
000466  4924              LDR      r1,|L1.1272|
000468  6008              STR      r0,[r1,#0]            ;633
00046a  4608              MOV      r0,r1                 ;636
00046c  6805              LDR      r5,[r0,#0]            ;636
00046e  f64f70ff          MOV      r0,#0xffff            ;637
000472  f7fffffe          BL       ETH_Delay
000476  4820              LDR      r0,|L1.1272|
000478  6005              STR      r5,[r0,#0]            ;638
00047a  2001              MOVS     r0,#1                 ;642
00047c  e6d5              B        |L1.554|
;;;644    
                          ENDP

                  ETH_DMAReceptionCmd PROC
;;;2294     */
;;;2295   void ETH_DMAReceptionCmd(FunctionalState NewState)
00047e  b130              CBZ      r0,|L1.1166|
;;;2296   { 
;;;2297     /* Check the parameters */
;;;2298     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2299     
;;;2300     if (NewState != DISABLE)
;;;2301     {
;;;2302       /* Enable the DMA reception */
;;;2303       ETH->DMAOMR |= ETH_DMAOMR_SR;  
000480  491d              LDR      r1,|L1.1272|
000482  6989              LDR      r1,[r1,#0x18]
000484  f0410102          ORR      r1,r1,#2
000488  4a1b              LDR      r2,|L1.1272|
00048a  6191              STR      r1,[r2,#0x18]
00048c  e005              B        |L1.1178|
                  |L1.1166|
;;;2304     }
;;;2305     else
;;;2306     {
;;;2307       /* Disable the DMA reception */
;;;2308       ETH->DMAOMR &= ~ETH_DMAOMR_SR;
00048e  491a              LDR      r1,|L1.1272|
000490  6989              LDR      r1,[r1,#0x18]
000492  f0210102          BIC      r1,r1,#2
000496  4a18              LDR      r2,|L1.1272|
000498  6191              STR      r1,[r2,#0x18]
                  |L1.1178|
;;;2309     }
;;;2310   }
00049a  4770              BX       lr
;;;2311   
                          ENDP

                  ETH_DMATransmissionCmd PROC
;;;2271     */
;;;2272   void ETH_DMATransmissionCmd(FunctionalState NewState)
00049c  b130              CBZ      r0,|L1.1196|
;;;2273   { 
;;;2274     /* Check the parameters */
;;;2275     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2276     
;;;2277     if (NewState != DISABLE)
;;;2278     {
;;;2279       /* Enable the DMA transmission */
;;;2280       ETH->DMAOMR |= ETH_DMAOMR_ST;  
00049e  4916              LDR      r1,|L1.1272|
0004a0  6989              LDR      r1,[r1,#0x18]
0004a2  f4415100          ORR      r1,r1,#0x2000
0004a6  4a14              LDR      r2,|L1.1272|
0004a8  6191              STR      r1,[r2,#0x18]
0004aa  e005              B        |L1.1208|
                  |L1.1196|
;;;2281     }
;;;2282     else
;;;2283     {
;;;2284       /* Disable the DMA transmission */
;;;2285       ETH->DMAOMR &= ~ETH_DMAOMR_ST;
0004ac  4912              LDR      r1,|L1.1272|
0004ae  6989              LDR      r1,[r1,#0x18]
0004b0  f4215100          BIC      r1,r1,#0x2000
0004b4  4a10              LDR      r2,|L1.1272|
0004b6  6191              STR      r1,[r2,#0x18]
                  |L1.1208|
;;;2286     }
;;;2287   }
0004b8  4770              BX       lr
;;;2288   
                          ENDP

                  ETH_MACReceptionCmd PROC
;;;725      */
;;;726    void ETH_MACReceptionCmd(FunctionalState NewState)
0004ba  b538              PUSH     {r3-r5,lr}
;;;727    {
0004bc  4604              MOV      r4,r0
;;;728    	__IO uint32_t tmpreg = 0;
0004be  2000              MOVS     r0,#0
0004c0  9000              STR      r0,[sp,#0]
;;;729      /* Check the parameters */
;;;730      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;731      
;;;732      if (NewState != DISABLE)
0004c2  b1ec              CBZ      r4,|L1.1280|
;;;733      {
;;;734        /* Enable the MAC reception */
;;;735        ETH->MACCR |= ETH_MACCR_RE;  
0004c4  4803              LDR      r0,|L1.1236|
0004c6  6800              LDR      r0,[r0,#0]
0004c8  f0400004          ORR      r0,r0,#4
0004cc  4901              LDR      r1,|L1.1236|
0004ce  6008              STR      r0,[r1,#0]
0004d0  e01c              B        |L1.1292|
0004d2  0000              DCW      0x0000
                  |L1.1236|
                          DCD      0x40028000
                  |L1.1240|
                          DCD      0x0004ffff
                  |L1.1244|
                          DCD      0x03938700
                  |L1.1248|
                          DCD      0x01312d00
                  |L1.1252|
                          DCD      0x02160ec0
                  |L1.1256|
                          DCD      0x05f5e100
                  |L1.1260|
                          DCD      0x08f0d180
                  |L1.1264|
                          DCD      0x000fffff
                  |L1.1268|
                          DCD      0xff20810f
                  |L1.1272|
                          DCD      0x40029000
                  |L1.1276|
                          DCD      0xf8de3f23
                  |L1.1280|
;;;736      }
;;;737      else
;;;738      {
;;;739        /* Disable the MAC reception */
;;;740        ETH->MACCR &= ~ETH_MACCR_RE;
000500  48fe              LDR      r0,|L1.2300|
000502  6800              LDR      r0,[r0,#0]
000504  f0200004          BIC      r0,r0,#4
000508  49fc              LDR      r1,|L1.2300|
00050a  6008              STR      r0,[r1,#0]
                  |L1.1292|
;;;741      }
;;;742    	/* Wait until the write operation will be taken into account :
;;;743       at least four TX_CLK/RX_CLK clock cycles */
;;;744      tmpreg = ETH->MACCR;
00050c  48fb              LDR      r0,|L1.2300|
00050e  6800              LDR      r0,[r0,#0]
000510  9000              STR      r0,[sp,#0]
;;;745      _eth_delay_(ETH_REG_WRITE_DELAY);
000512  f64f70ff          MOV      r0,#0xffff
000516  f7fffffe          BL       ETH_Delay
;;;746      ETH->MACCR = tmpreg;
00051a  49f8              LDR      r1,|L1.2300|
00051c  9800              LDR      r0,[sp,#0]
00051e  6008              STR      r0,[r1,#0]
;;;747    }
000520  bd38              POP      {r3-r5,pc}
;;;748    
                          ENDP

                  ETH_FlushTransmitFIFO PROC
;;;2233     */
;;;2234   void ETH_FlushTransmitFIFO(void)
000522  b508              PUSH     {r3,lr}
;;;2235   {
;;;2236     __IO uint32_t tmpreg = 0;
000524  2000              MOVS     r0,#0
000526  9000              STR      r0,[sp,#0]
;;;2237     /* Set the Flush Transmit FIFO bit */
;;;2238     ETH->DMAOMR |= ETH_DMAOMR_FTF;
000528  48f5              LDR      r0,|L1.2304|
00052a  6980              LDR      r0,[r0,#0x18]
00052c  f4401080          ORR      r0,r0,#0x100000
000530  49f3              LDR      r1,|L1.2304|
000532  6188              STR      r0,[r1,#0x18]
;;;2239     
;;;2240     /* Wait until the write operation will be taken into account :
;;;2241      at least four TX_CLK/RX_CLK clock cycles */
;;;2242     tmpreg = ETH->DMAOMR;
000534  4608              MOV      r0,r1
000536  6980              LDR      r0,[r0,#0x18]
000538  9000              STR      r0,[sp,#0]
;;;2243     _eth_delay_(ETH_REG_WRITE_DELAY);
00053a  f64f70ff          MOV      r0,#0xffff
00053e  f7fffffe          BL       ETH_Delay
;;;2244     ETH->DMAOMR = tmpreg;
000542  49ef              LDR      r1,|L1.2304|
000544  9800              LDR      r0,[sp,#0]
000546  6188              STR      r0,[r1,#0x18]
;;;2245   }
000548  bd08              POP      {r3,pc}
;;;2246   
                          ENDP

                  ETH_MACTransmissionCmd PROC
;;;694      */
;;;695    void ETH_MACTransmissionCmd(FunctionalState NewState)
00054a  b538              PUSH     {r3-r5,lr}
;;;696    {
00054c  4604              MOV      r4,r0
;;;697    	__IO uint32_t tmpreg = 0;
00054e  2000              MOVS     r0,#0
000550  9000              STR      r0,[sp,#0]
;;;698      /* Check the parameters */
;;;699      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;700      
;;;701      if (NewState != DISABLE)
000552  b134              CBZ      r4,|L1.1378|
;;;702      {
;;;703        /* Enable the MAC transmission */
;;;704        ETH->MACCR |= ETH_MACCR_TE;  
000554  48e9              LDR      r0,|L1.2300|
000556  6800              LDR      r0,[r0,#0]
000558  f0400008          ORR      r0,r0,#8
00055c  49e7              LDR      r1,|L1.2300|
00055e  6008              STR      r0,[r1,#0]
000560  e005              B        |L1.1390|
                  |L1.1378|
;;;705      }
;;;706      else
;;;707      {
;;;708        /* Disable the MAC transmission */
;;;709        ETH->MACCR &= ~ETH_MACCR_TE;
000562  48e6              LDR      r0,|L1.2300|
000564  6800              LDR      r0,[r0,#0]
000566  f0200008          BIC      r0,r0,#8
00056a  49e4              LDR      r1,|L1.2300|
00056c  6008              STR      r0,[r1,#0]
                  |L1.1390|
;;;710      }
;;;711    	
;;;712    	/* Wait until the write operation will be taken into account :
;;;713       at least four TX_CLK/RX_CLK clock cycles */
;;;714      tmpreg = ETH->MACCR;
00056e  48e3              LDR      r0,|L1.2300|
000570  6800              LDR      r0,[r0,#0]
000572  9000              STR      r0,[sp,#0]
;;;715      _eth_delay_(ETH_REG_WRITE_DELAY);
000574  f64f70ff          MOV      r0,#0xffff
000578  f7fffffe          BL       ETH_Delay
;;;716      ETH->MACCR = tmpreg;
00057c  49df              LDR      r1,|L1.2300|
00057e  9800              LDR      r0,[sp,#0]
000580  6008              STR      r0,[r1,#0]
;;;717    }
000582  bd38              POP      {r3-r5,pc}
;;;718    
                          ENDP

                  ETH_Start PROC
;;;649      */
;;;650    void ETH_Start(void)
000584  b510              PUSH     {r4,lr}
;;;651    {
;;;652      /* Enable transmit state machine of the MAC for transmission on the MII */  
;;;653      ETH_MACTransmissionCmd(ENABLE);
000586  2001              MOVS     r0,#1
000588  f7fffffe          BL       ETH_MACTransmissionCmd
;;;654      /* Flush Transmit FIFO */
;;;655      ETH_FlushTransmitFIFO();
00058c  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;656      /* Enable receive state machine of the MAC for reception from the MII */  
;;;657      ETH_MACReceptionCmd(ENABLE);
000590  2001              MOVS     r0,#1
000592  f7fffffe          BL       ETH_MACReceptionCmd
;;;658     
;;;659      /* Start DMA transmission */
;;;660      ETH_DMATransmissionCmd(ENABLE); 
000596  2001              MOVS     r0,#1
000598  f7fffffe          BL       ETH_DMATransmissionCmd
;;;661      /* Start DMA reception */
;;;662      ETH_DMAReceptionCmd(ENABLE);   
00059c  2001              MOVS     r0,#1
00059e  f7fffffe          BL       ETH_DMAReceptionCmd
;;;663    }
0005a2  bd10              POP      {r4,pc}
;;;664    
                          ENDP

                  ETH_Stop PROC
;;;669      */
;;;670    void ETH_Stop(void)
0005a4  b510              PUSH     {r4,lr}
;;;671    {  
;;;672      /* Stop DMA transmission */
;;;673      ETH_DMATransmissionCmd(DISABLE);
0005a6  2000              MOVS     r0,#0
0005a8  f7fffffe          BL       ETH_DMATransmissionCmd
;;;674    
;;;675      /* Stop DMA reception */
;;;676      ETH_DMAReceptionCmd(DISABLE);
0005ac  2000              MOVS     r0,#0
0005ae  f7fffffe          BL       ETH_DMAReceptionCmd
;;;677    
;;;678      /* Disable receive state machine of the MAC for reception from the MII */
;;;679      ETH_MACReceptionCmd(DISABLE);
0005b2  2000              MOVS     r0,#0
0005b4  f7fffffe          BL       ETH_MACReceptionCmd
;;;680    
;;;681      /* Flush Transmit FIFO */
;;;682      ETH_FlushTransmitFIFO();
0005b8  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;683    
;;;684      /* Disable transmit state machine of the MAC for transmission on the MII */
;;;685      ETH_MACTransmissionCmd(DISABLE);
0005bc  2000              MOVS     r0,#0
0005be  f7fffffe          BL       ETH_MACTransmissionCmd
;;;686    }
0005c2  bd10              POP      {r4,pc}
;;;687    
                          ENDP

                  ETH_GetFlowControlBusyStatus PROC
;;;754      */
;;;755    FlagStatus ETH_GetFlowControlBusyStatus(void)
0005c4  2000              MOVS     r0,#0
;;;756    {
;;;757      FlagStatus bitstatus = RESET;
;;;758      /* The Flow Control register should not be written to until this bit is cleared */
;;;759      if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
0005c6  49cd              LDR      r1,|L1.2300|
0005c8  6989              LDR      r1,[r1,#0x18]
0005ca  f0010101          AND      r1,r1,#1
0005ce  b109              CBZ      r1,|L1.1492|
;;;760      {
;;;761        bitstatus = SET;
0005d0  2001              MOVS     r0,#1
0005d2  e000              B        |L1.1494|
                  |L1.1492|
;;;762      }
;;;763      else
;;;764      {
;;;765        bitstatus = RESET;
0005d4  2000              MOVS     r0,#0
                  |L1.1494|
;;;766      }
;;;767      return bitstatus;
;;;768    }
0005d6  4770              BX       lr
;;;769    
                          ENDP

                  ETH_InitiatePauseControlFrame PROC
;;;775      */
;;;776    void ETH_InitiatePauseControlFrame(void)  
0005d8  b508              PUSH     {r3,lr}
;;;777    { 
;;;778    	__IO uint32_t tmpreg = 0;
0005da  2000              MOVS     r0,#0
0005dc  9000              STR      r0,[sp,#0]
;;;779      /* When Set In full duplex MAC initiates pause control frame */
;;;780      ETH->MACFCR |= ETH_MACFCR_FCBBPA;
0005de  48c7              LDR      r0,|L1.2300|
0005e0  6980              LDR      r0,[r0,#0x18]
0005e2  f0400001          ORR      r0,r0,#1
0005e6  49c5              LDR      r1,|L1.2300|
0005e8  6188              STR      r0,[r1,#0x18]
;;;781      
;;;782      /* Wait until the write operation will be taken into account :
;;;783       at least four TX_CLK/RX_CLK clock cycles */
;;;784      tmpreg = ETH->MACFCR;
0005ea  4608              MOV      r0,r1
0005ec  6980              LDR      r0,[r0,#0x18]
0005ee  9000              STR      r0,[sp,#0]
;;;785      _eth_delay_(ETH_REG_WRITE_DELAY);
0005f0  f64f70ff          MOV      r0,#0xffff
0005f4  f7fffffe          BL       ETH_Delay
;;;786      ETH->MACFCR = tmpreg;
0005f8  49c0              LDR      r1,|L1.2300|
0005fa  9800              LDR      r0,[sp,#0]
0005fc  6188              STR      r0,[r1,#0x18]
;;;787    }
0005fe  bd08              POP      {r3,pc}
;;;788    
                          ENDP

                  ETH_BackPressureActivationCmd PROC
;;;795      */
;;;796    void ETH_BackPressureActivationCmd(FunctionalState NewState)   
000600  b538              PUSH     {r3-r5,lr}
;;;797    { 
000602  4604              MOV      r4,r0
;;;798    	__IO uint32_t tmpreg = 0;
000604  2000              MOVS     r0,#0
000606  9000              STR      r0,[sp,#0]
;;;799      /* Check the parameters */
;;;800      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;801        
;;;802      if (NewState != DISABLE)
000608  b134              CBZ      r4,|L1.1560|
;;;803      {
;;;804        /* Activate the MAC BackPressure operation */
;;;805        /* In Half duplex: during backpressure, when the MAC receives a new frame,
;;;806        the transmitter starts sending a JAM pattern resulting in a collision */
;;;807        ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
00060a  48bc              LDR      r0,|L1.2300|
00060c  6980              LDR      r0,[r0,#0x18]
00060e  f0400001          ORR      r0,r0,#1
000612  49ba              LDR      r1,|L1.2300|
000614  6188              STR      r0,[r1,#0x18]
000616  e005              B        |L1.1572|
                  |L1.1560|
;;;808      }
;;;809      else
;;;810      {
;;;811        /* Desactivate the MAC BackPressure operation */
;;;812        ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
000618  48b8              LDR      r0,|L1.2300|
00061a  6980              LDR      r0,[r0,#0x18]
00061c  f0200001          BIC      r0,r0,#1
000620  49b6              LDR      r1,|L1.2300|
000622  6188              STR      r0,[r1,#0x18]
                  |L1.1572|
;;;813      }
;;;814    	/* Wait until the write operation will be taken into account :
;;;815       at least four TX_CLK/RX_CLK clock cycles */
;;;816      tmpreg = ETH->MACFCR;
000624  48b5              LDR      r0,|L1.2300|
000626  6980              LDR      r0,[r0,#0x18]
000628  9000              STR      r0,[sp,#0]
;;;817      _eth_delay_(ETH_REG_WRITE_DELAY);
00062a  f64f70ff          MOV      r0,#0xffff
00062e  f7fffffe          BL       ETH_Delay
;;;818      ETH->MACFCR = tmpreg;	
000632  49b2              LDR      r1,|L1.2300|
000634  9800              LDR      r0,[sp,#0]
000636  6188              STR      r0,[r1,#0x18]
;;;819    }
000638  bd38              POP      {r3-r5,pc}
;;;820    
                          ENDP

                  ETH_GetMACFlagStatus PROC
;;;832      */
;;;833    FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
00063a  4601              MOV      r1,r0
;;;834    {
;;;835      FlagStatus bitstatus = RESET;
00063c  2000              MOVS     r0,#0
;;;836      /* Check the parameters */
;;;837      assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
;;;838      if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
00063e  4aaf              LDR      r2,|L1.2300|
000640  6b92              LDR      r2,[r2,#0x38]
000642  400a              ANDS     r2,r2,r1
000644  b10a              CBZ      r2,|L1.1610|
;;;839      {
;;;840        bitstatus = SET;
000646  2001              MOVS     r0,#1
000648  e000              B        |L1.1612|
                  |L1.1610|
;;;841      }
;;;842      else
;;;843      {
;;;844        bitstatus = RESET;
00064a  2000              MOVS     r0,#0
                  |L1.1612|
;;;845      }
;;;846      return bitstatus;
;;;847    }
00064c  4770              BX       lr
;;;848    
                          ENDP

                  ETH_GetMACITStatus PROC
;;;860      */
;;;861    ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
00064e  4601              MOV      r1,r0
;;;862    {
;;;863      ITStatus bitstatus = RESET;
000650  2000              MOVS     r0,#0
;;;864      /* Check the parameters */
;;;865      assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
;;;866      if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
000652  4aaa              LDR      r2,|L1.2300|
000654  6b92              LDR      r2,[r2,#0x38]
000656  400a              ANDS     r2,r2,r1
000658  b10a              CBZ      r2,|L1.1630|
;;;867      {
;;;868        bitstatus = SET;
00065a  2001              MOVS     r0,#1
00065c  e000              B        |L1.1632|
                  |L1.1630|
;;;869      }
;;;870      else
;;;871      {
;;;872        bitstatus = RESET;
00065e  2000              MOVS     r0,#0
                  |L1.1632|
;;;873      }
;;;874      return bitstatus;
;;;875    }
000660  4770              BX       lr
;;;876    
                          ENDP

                  ETH_MACITConfig PROC
;;;888      */
;;;889    void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
000662  b129              CBZ      r1,|L1.1648|
;;;890    {
;;;891      /* Check the parameters */
;;;892      assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
;;;893      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;894      
;;;895      if (NewState != DISABLE)
;;;896      {
;;;897        /* Enable the selected ETHERNET MAC interrupts */
;;;898        ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
000664  4aa5              LDR      r2,|L1.2300|
000666  6bd2              LDR      r2,[r2,#0x3c]
000668  4382              BICS     r2,r2,r0
00066a  4ba4              LDR      r3,|L1.2300|
00066c  63da              STR      r2,[r3,#0x3c]
00066e  e004              B        |L1.1658|
                  |L1.1648|
;;;899      }
;;;900      else
;;;901      {
;;;902        /* Disable the selected ETHERNET MAC interrupts */
;;;903        ETH->MACIMR |= ETH_MAC_IT;
000670  4aa2              LDR      r2,|L1.2300|
000672  6bd2              LDR      r2,[r2,#0x3c]
000674  4302              ORRS     r2,r2,r0
000676  4ba1              LDR      r3,|L1.2300|
000678  63da              STR      r2,[r3,#0x3c]
                  |L1.1658|
;;;904      }
;;;905    }
00067a  4770              BX       lr
;;;906    
                          ENDP

                  ETH_MACAddressConfig PROC
;;;918      */
;;;919    void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
00067c  b510              PUSH     {r4,lr}
;;;920    {
;;;921      uint32_t tmpreg;
;;;922      /* Check the parameters */
;;;923      assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;924      
;;;925      /* Calculate the selected MAC address high register */
;;;926      tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
00067e  790b              LDRB     r3,[r1,#4]
000680  794c              LDRB     r4,[r1,#5]
000682  ea432204          ORR      r2,r3,r4,LSL #8
;;;927      /* Load the selected MAC address high register */
;;;928      (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
000686  4b9d              LDR      r3,|L1.2300|
000688  4403              ADD      r3,r3,r0
00068a  641a              STR      r2,[r3,#0x40]
;;;929      /* Calculate the selected MAC address low register */
;;;930      tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
00068c  78cb              LDRB     r3,[r1,#3]
00068e  061b              LSLS     r3,r3,#24
000690  788c              LDRB     r4,[r1,#2]
000692  ea434304          ORR      r3,r3,r4,LSL #16
000696  784c              LDRB     r4,[r1,#1]
000698  ea432304          ORR      r3,r3,r4,LSL #8
00069c  780c              LDRB     r4,[r1,#0]
00069e  ea430204          ORR      r2,r3,r4
;;;931     
;;;932      /* Load the selected MAC address low register */
;;;933      (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
0006a2  4b96              LDR      r3,|L1.2300|
0006a4  4403              ADD      r3,r3,r0
0006a6  645a              STR      r2,[r3,#0x44]
;;;934    }
0006a8  bd10              POP      {r4,pc}
;;;935    
                          ENDP

                  ETH_GetMACAddress PROC
;;;947      */
;;;948    void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
0006aa  4602              MOV      r2,r0
;;;949    {
;;;950      uint32_t tmpreg;
;;;951      /* Check the parameters */
;;;952      assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;953      
;;;954      /* Get the selected MAC address high register */
;;;955      tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
0006ac  4b93              LDR      r3,|L1.2300|
0006ae  4413              ADD      r3,r3,r2
0006b0  6c18              LDR      r0,[r3,#0x40]
;;;956     
;;;957      /* Calculate the selected MAC address buffer */
;;;958      Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
0006b2  0a03              LSRS     r3,r0,#8
0006b4  714b              STRB     r3,[r1,#5]
;;;959      Addr[4] = (tmpreg & (uint8_t)0xFF);
0006b6  7108              STRB     r0,[r1,#4]
;;;960      /* Load the selected MAC address low register */
;;;961      tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
0006b8  4b90              LDR      r3,|L1.2300|
0006ba  4413              ADD      r3,r3,r2
0006bc  6c58              LDR      r0,[r3,#0x44]
;;;962      /* Calculate the selected MAC address buffer */
;;;963      Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
0006be  0e03              LSRS     r3,r0,#24
0006c0  70cb              STRB     r3,[r1,#3]
;;;964      Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
0006c2  0c03              LSRS     r3,r0,#16
0006c4  708b              STRB     r3,[r1,#2]
;;;965      Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
0006c6  0a03              LSRS     r3,r0,#8
0006c8  704b              STRB     r3,[r1,#1]
;;;966      Addr[0] = (tmpreg & (uint8_t)0xFF);
0006ca  7008              STRB     r0,[r1,#0]
;;;967    }
0006cc  4770              BX       lr
;;;968    
                          ENDP

                  ETH_MACAddressPerfectFilterCmd PROC
;;;981      */
;;;982    void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
0006ce  b538              PUSH     {r3-r5,lr}
;;;983    {
0006d0  4604              MOV      r4,r0
0006d2  460d              MOV      r5,r1
;;;984      __IO uint32_t tmpreg = 0;
0006d4  2000              MOVS     r0,#0
0006d6  9000              STR      r0,[sp,#0]
;;;985      /* Check the parameters */
;;;986      assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;987      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;988      
;;;989      if (NewState != DISABLE)
0006d8  b145              CBZ      r5,|L1.1772|
;;;990      {
;;;991        /* Enable the selected ETHERNET MAC address for perfect filtering */
;;;992        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
0006da  4888              LDR      r0,|L1.2300|
0006dc  4420              ADD      r0,r0,r4
0006de  6c00              LDR      r0,[r0,#0x40]
0006e0  f0404000          ORR      r0,r0,#0x80000000
0006e4  4985              LDR      r1,|L1.2300|
0006e6  4421              ADD      r1,r1,r4
0006e8  6408              STR      r0,[r1,#0x40]
0006ea  e007              B        |L1.1788|
                  |L1.1772|
;;;993      }
;;;994      else
;;;995      {
;;;996        /* Disable the selected ETHERNET MAC address for perfect filtering */
;;;997        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
0006ec  4883              LDR      r0,|L1.2300|
0006ee  4420              ADD      r0,r0,r4
0006f0  6c00              LDR      r0,[r0,#0x40]
0006f2  f0204000          BIC      r0,r0,#0x80000000
0006f6  4981              LDR      r1,|L1.2300|
0006f8  4421              ADD      r1,r1,r4
0006fa  6408              STR      r0,[r1,#0x40]
                  |L1.1788|
;;;998      }
;;;999      
;;;1000     /* Wait until the write operation will be taken into account :
;;;1001      at least four TX_CLK/RX_CLK clock cycles */
;;;1002     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
0006fc  487f              LDR      r0,|L1.2300|
0006fe  4420              ADD      r0,r0,r4
000700  6c00              LDR      r0,[r0,#0x40]
000702  9000              STR      r0,[sp,#0]
;;;1003     _eth_delay_(ETH_REG_WRITE_DELAY);
000704  f64f70ff          MOV      r0,#0xffff
000708  f7fffffe          BL       ETH_Delay
;;;1004     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
00070c  497b              LDR      r1,|L1.2300|
00070e  4421              ADD      r1,r1,r4
000710  9800              LDR      r0,[sp,#0]
000712  6408              STR      r0,[r1,#0x40]
;;;1005   }
000714  bd38              POP      {r3-r5,pc}
;;;1006   
                          ENDP

                  ETH_MACAddressFilterConfig PROC
;;;1022     */
;;;1023   void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
000716  b538              PUSH     {r3-r5,lr}
;;;1024   {
000718  4604              MOV      r4,r0
00071a  460d              MOV      r5,r1
;;;1025     __IO uint32_t tmpreg = 0;
00071c  2000              MOVS     r0,#0
00071e  9000              STR      r0,[sp,#0]
;;;1026     /* Check the parameters */
;;;1027     assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;1028     assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
;;;1029     
;;;1030     if (Filter != ETH_MAC_AddressFilter_DA)
000720  2d08              CMP      r5,#8
000722  d008              BEQ      |L1.1846|
;;;1031     {
;;;1032       /* The selected ETHERNET MAC address is used to compare with the SA fields of the
;;;1033       received frame. */
;;;1034       (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
000724  4875              LDR      r0,|L1.2300|
000726  4420              ADD      r0,r0,r4
000728  6c00              LDR      r0,[r0,#0x40]
00072a  f0404080          ORR      r0,r0,#0x40000000
00072e  4973              LDR      r1,|L1.2300|
000730  4421              ADD      r1,r1,r4
000732  6408              STR      r0,[r1,#0x40]
000734  e007              B        |L1.1862|
                  |L1.1846|
;;;1035     }
;;;1036     else
;;;1037     {
;;;1038       /* The selected ETHERNET MAC address is used to compare with the DA fields of the
;;;1039       received frame. */
;;;1040       (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
000736  4871              LDR      r0,|L1.2300|
000738  4420              ADD      r0,r0,r4
00073a  6c00              LDR      r0,[r0,#0x40]
00073c  f0204080          BIC      r0,r0,#0x40000000
000740  496e              LDR      r1,|L1.2300|
000742  4421              ADD      r1,r1,r4
000744  6408              STR      r0,[r1,#0x40]
                  |L1.1862|
;;;1041     }
;;;1042     
;;;1043     /* Wait until the write operation will be taken into account :
;;;1044      at least four TX_CLK/RX_CLK clock cycles */
;;;1045     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
000746  486d              LDR      r0,|L1.2300|
000748  4420              ADD      r0,r0,r4
00074a  6c00              LDR      r0,[r0,#0x40]
00074c  9000              STR      r0,[sp,#0]
;;;1046     _eth_delay_(ETH_REG_WRITE_DELAY);
00074e  f64f70ff          MOV      r0,#0xffff
000752  f7fffffe          BL       ETH_Delay
;;;1047     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
000756  4969              LDR      r1,|L1.2300|
000758  4421              ADD      r1,r1,r4
00075a  9800              LDR      r0,[sp,#0]
00075c  6408              STR      r0,[r1,#0x40]
;;;1048   }
00075e  bd38              POP      {r3-r5,pc}
;;;1049   
                          ENDP

                  ETH_MACAddressMaskBytesFilterConfig PROC
;;;1067     */
;;;1068   void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
000760  b538              PUSH     {r3-r5,lr}
;;;1069   {
000762  4604              MOV      r4,r0
000764  460d              MOV      r5,r1
;;;1070     __IO uint32_t tmpreg = 0;
000766  2000              MOVS     r0,#0
000768  9000              STR      r0,[sp,#0]
;;;1071     /* Check the parameters */
;;;1072     assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;1073     assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
;;;1074     
;;;1075     /* Clear MBC bits in the selected MAC address  high register */
;;;1076     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
00076a  4864              LDR      r0,|L1.2300|
00076c  4420              ADD      r0,r0,r4
00076e  6c00              LDR      r0,[r0,#0x40]
000770  f020507c          BIC      r0,r0,#0x3f000000
000774  4961              LDR      r1,|L1.2300|
000776  4421              ADD      r1,r1,r4
000778  6408              STR      r0,[r1,#0x40]
;;;1077     
;;;1078     /* Wait until the write operation will be taken into account :
;;;1079      at least four TX_CLK/RX_CLK clock cycles */
;;;1080     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
00077a  4860              LDR      r0,|L1.2300|
00077c  4420              ADD      r0,r0,r4
00077e  6c00              LDR      r0,[r0,#0x40]
000780  9000              STR      r0,[sp,#0]
;;;1081     _eth_delay_(ETH_REG_WRITE_DELAY);
000782  f64f70ff          MOV      r0,#0xffff
000786  f7fffffe          BL       ETH_Delay
;;;1082     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
00078a  495c              LDR      r1,|L1.2300|
00078c  4421              ADD      r1,r1,r4
00078e  9800              LDR      r0,[sp,#0]
000790  6408              STR      r0,[r1,#0x40]
;;;1083     
;;;1084     /* Set the selected Filter mask bytes */
;;;1085     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
000792  485a              LDR      r0,|L1.2300|
000794  4420              ADD      r0,r0,r4
000796  6c00              LDR      r0,[r0,#0x40]
000798  4328              ORRS     r0,r0,r5
00079a  4958              LDR      r1,|L1.2300|
00079c  4421              ADD      r1,r1,r4
00079e  6408              STR      r0,[r1,#0x40]
;;;1086     
;;;1087     /* Wait until the write operation will be taken into account :
;;;1088      at least four TX_CLK/RX_CLK clock cycles */
;;;1089     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
0007a0  4856              LDR      r0,|L1.2300|
0007a2  4420              ADD      r0,r0,r4
0007a4  6c00              LDR      r0,[r0,#0x40]
0007a6  9000              STR      r0,[sp,#0]
;;;1090     _eth_delay_(ETH_REG_WRITE_DELAY);
0007a8  f64f70ff          MOV      r0,#0xffff
0007ac  f7fffffe          BL       ETH_Delay
;;;1091     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
0007b0  4952              LDR      r1,|L1.2300|
0007b2  4421              ADD      r1,r1,r4
0007b4  9800              LDR      r0,[sp,#0]
0007b6  6408              STR      r0,[r1,#0x40]
;;;1092   }
0007b8  bd38              POP      {r3-r5,pc}
;;;1093   
                          ENDP

                  ETH_Get_Received_Frame PROC
;;;1104     */
;;;1105   FrameTypeDef ETH_Get_Received_Frame(void)
0007ba  b51e              PUSH     {r1-r4,lr}
;;;1106   { 
;;;1107     uint32_t framelength = 0;
0007bc  2100              MOVS     r1,#0
;;;1108     FrameTypeDef frame = {0,0,0}; 
0007be  2200              MOVS     r2,#0
0007c0  9200              STR      r2,[sp,#0]
0007c2  9201              STR      r2,[sp,#4]
0007c4  9202              STR      r2,[sp,#8]
;;;1109     
;;;1110     /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1111     framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
0007c6  4a4f              LDR      r2,|L1.2308|
0007c8  6812              LDR      r2,[r2,#0]  ; DMARxDescToGet
0007ca  6812              LDR      r2,[r2,#0]
0007cc  f3c2420d          UBFX     r2,r2,#16,#14
0007d0  1f11              SUBS     r1,r2,#4
;;;1112     frame.length = framelength;
0007d2  9100              STR      r1,[sp,#0]
;;;1113     
;;;1114     /* Get the address of the buffer start address */ 
;;;1115     /* Check if more than one segment in the frame */
;;;1116     if (DMA_RX_FRAME_infos->Seg_Count >1)
0007d4  4a4c              LDR      r2,|L1.2312|
0007d6  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
0007d8  6892              LDR      r2,[r2,#8]
0007da  2a01              CMP      r2,#1
0007dc  d905              BLS      |L1.2026|
;;;1117     {
;;;1118       frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
0007de  4a4a              LDR      r2,|L1.2312|
0007e0  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
0007e2  6812              LDR      r2,[r2,#0]
0007e4  6892              LDR      r2,[r2,#8]
0007e6  9201              STR      r2,[sp,#4]
0007e8  e003              B        |L1.2034|
                  |L1.2026|
;;;1119     }
;;;1120     else 
;;;1121     {
;;;1122       frame.buffer = DMARxDescToGet->Buffer1Addr;
0007ea  4a46              LDR      r2,|L1.2308|
0007ec  6812              LDR      r2,[r2,#0]  ; DMARxDescToGet
0007ee  6892              LDR      r2,[r2,#8]
0007f0  9201              STR      r2,[sp,#4]
                  |L1.2034|
;;;1123     }
;;;1124   
;;;1125     frame.descriptor = DMARxDescToGet;
0007f2  4a44              LDR      r2,|L1.2308|
0007f4  6812              LDR      r2,[r2,#0]  ; DMARxDescToGet
0007f6  9202              STR      r2,[sp,#8]
;;;1126     
;;;1127     /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
;;;1128     /* Chained Mode */    
;;;1129     /* Selects the next DMA Rx descriptor list for next buffer to read */ 
;;;1130     DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
0007f8  4a42              LDR      r2,|L1.2308|
0007fa  6812              LDR      r2,[r2,#0]  ; DMARxDescToGet
0007fc  68d2              LDR      r2,[r2,#0xc]
0007fe  4b41              LDR      r3,|L1.2308|
000800  601a              STR      r2,[r3,#0]  ; DMARxDescToGet
;;;1131     
;;;1132     /* Return Frame */
;;;1133     return (frame);  
000802  e89d001c          LDM      sp,{r2-r4}
000806  e880001c          STM      r0,{r2-r4}
;;;1134   }
00080a  bd1e              POP      {r1-r4,pc}
;;;1135   
                          ENDP

                  ETH_Get_Received_Frame_interrupt PROC
;;;1143     */
;;;1144   FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
00080c  b50f              PUSH     {r0-r3,lr}
;;;1145   { 
;;;1146     FrameTypeDef frame = {0, 0, 0};
00080e  2100              MOVS     r1,#0
000810  9101              STR      r1,[sp,#4]
000812  9102              STR      r1,[sp,#8]
000814  9103              STR      r1,[sp,#0xc]
;;;1147     __IO uint32_t descriptor_scan_counter = 0; 
000816  9100              STR      r1,[sp,#0]
;;;1148   
;;;1149     /* Scan descriptors owned by CPU */
;;;1150     while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t) RESET) && 
000818  e078              B        |L1.2316|
                  |L1.2074|
;;;1151   		     (descriptor_scan_counter<ETH_RXBUFNB))
;;;1152     {
;;;1153       /* Just by security */
;;;1154       descriptor_scan_counter++;
00081a  9900              LDR      r1,[sp,#0]
00081c  1c49              ADDS     r1,r1,#1
00081e  9100              STR      r1,[sp,#0]
;;;1155       
;;;1156       /* Check if first segment in frame */
;;;1157       if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t) RESET) &&
000820  4938              LDR      r1,|L1.2308|
000822  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
000824  6809              LDR      r1,[r1,#0]
000826  f4017100          AND      r1,r1,#0x200
00082a  b1a1              CBZ      r1,|L1.2134|
;;;1158          ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t) RESET))
00082c  4935              LDR      r1,|L1.2308|
00082e  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
000830  6809              LDR      r1,[r1,#0]
000832  f4017180          AND      r1,r1,#0x100
000836  b971              CBNZ     r1,|L1.2134|
;;;1159       {
;;;1160         DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
000838  4932              LDR      r1,|L1.2308|
00083a  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
00083c  4a32              LDR      r2,|L1.2312|
00083e  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
000840  6011              STR      r1,[r2,#0]
;;;1161         DMA_RX_FRAME_infos->Seg_Count = 1;   
000842  2101              MOVS     r1,#1
000844  4a30              LDR      r2,|L1.2312|
000846  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
000848  6091              STR      r1,[r2,#8]
;;;1162         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
00084a  492e              LDR      r1,|L1.2308|
00084c  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
00084e  68c9              LDR      r1,[r1,#0xc]
000850  4a2c              LDR      r2,|L1.2308|
000852  6011              STR      r1,[r2,#0]  ; DMARxDescToGet
000854  e05a              B        |L1.2316|
                  |L1.2134|
;;;1163       }
;;;1164       
;;;1165       /* Check if intermediate segment */
;;;1166       else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t) RESET)&&
000856  492b              LDR      r1,|L1.2308|
000858  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
00085a  6809              LDR      r1,[r1,#0]
00085c  f4017180          AND      r1,r1,#0x100
000860  b991              CBNZ     r1,|L1.2184|
;;;1167                ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t) RESET))
000862  4928              LDR      r1,|L1.2308|
000864  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
000866  6809              LDR      r1,[r1,#0]
000868  f4017100          AND      r1,r1,#0x200
00086c  b961              CBNZ     r1,|L1.2184|
;;;1168       {
;;;1169         (DMA_RX_FRAME_infos->Seg_Count)++;
00086e  4926              LDR      r1,|L1.2312|
000870  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
000872  6889              LDR      r1,[r1,#8]
000874  1c49              ADDS     r1,r1,#1
000876  4a24              LDR      r2,|L1.2312|
000878  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
00087a  6091              STR      r1,[r2,#8]
;;;1170         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
00087c  4921              LDR      r1,|L1.2308|
00087e  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
000880  68c9              LDR      r1,[r1,#0xc]
000882  4a20              LDR      r2,|L1.2308|
000884  6011              STR      r1,[r2,#0]  ; DMARxDescToGet
000886  e041              B        |L1.2316|
                  |L1.2184|
;;;1171       }
;;;1172       else /* Should be last segment */
;;;1173       { 
;;;1174         /* Last segment */
;;;1175         DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
000888  491e              LDR      r1,|L1.2308|
00088a  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
00088c  4a1e              LDR      r2,|L1.2312|
00088e  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
000890  6051              STR      r1,[r2,#4]
;;;1176         (DMA_RX_FRAME_infos->Seg_Count)++;
000892  491d              LDR      r1,|L1.2312|
000894  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
000896  6889              LDR      r1,[r1,#8]
000898  1c49              ADDS     r1,r1,#1
00089a  4a1b              LDR      r2,|L1.2312|
00089c  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
00089e  6091              STR      r1,[r2,#8]
;;;1177   
;;;1178         /* First segment is last segment */
;;;1179         if ((DMA_RX_FRAME_infos->Seg_Count) == 1)
0008a0  4919              LDR      r1,|L1.2312|
0008a2  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
0008a4  6889              LDR      r1,[r1,#8]
0008a6  2901              CMP      r1,#1
0008a8  d104              BNE      |L1.2228|
;;;1180           DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
0008aa  4916              LDR      r1,|L1.2308|
0008ac  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
0008ae  4a16              LDR      r2,|L1.2312|
0008b0  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
0008b2  6011              STR      r1,[r2,#0]
                  |L1.2228|
;;;1181   
;;;1182         /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1183         frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
0008b4  4913              LDR      r1,|L1.2308|
0008b6  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
0008b8  6809              LDR      r1,[r1,#0]
0008ba  f3c1410d          UBFX     r1,r1,#16,#14
0008be  1f09              SUBS     r1,r1,#4
0008c0  9101              STR      r1,[sp,#4]
;;;1184     
;;;1185         /* Get the address of the buffer start address */ 
;;;1186         /* Check if more than one segment in the frame */
;;;1187         if (DMA_RX_FRAME_infos->Seg_Count > 1)
0008c2  4911              LDR      r1,|L1.2312|
0008c4  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
0008c6  6889              LDR      r1,[r1,#8]
0008c8  2901              CMP      r1,#1
0008ca  d905              BLS      |L1.2264|
;;;1188         {
;;;1189           frame.buffer = (DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
0008cc  490e              LDR      r1,|L1.2312|
0008ce  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
0008d0  6809              LDR      r1,[r1,#0]
0008d2  6889              LDR      r1,[r1,#8]
0008d4  9102              STR      r1,[sp,#8]
0008d6  e003              B        |L1.2272|
                  |L1.2264|
;;;1190         }
;;;1191         else 
;;;1192         {
;;;1193           frame.buffer = DMARxDescToGet->Buffer1Addr;
0008d8  490a              LDR      r1,|L1.2308|
0008da  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
0008dc  6889              LDR      r1,[r1,#8]
0008de  9102              STR      r1,[sp,#8]
                  |L1.2272|
;;;1194         }
;;;1195         frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;//DMARxDescToGet;
0008e0  4909              LDR      r1,|L1.2312|
0008e2  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
0008e4  6809              LDR      r1,[r1,#0]
0008e6  9103              STR      r1,[sp,#0xc]
;;;1196     
;;;1197         /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
;;;1198         DMARxDescToGet = (ETH_DMADESCTypeDef *) (DMARxDescToGet->Buffer2NextDescAddr);
0008e8  4906              LDR      r1,|L1.2308|
0008ea  6809              LDR      r1,[r1,#0]  ; DMARxDescToGet
0008ec  68c9              LDR      r1,[r1,#0xc]
0008ee  4a05              LDR      r2,|L1.2308|
0008f0  6011              STR      r1,[r2,#0]  ; DMARxDescToGet
;;;1199        
;;;1200         /* Return Frame */
;;;1201         return frame;  
0008f2  a901              ADD      r1,sp,#4
0008f4  c90e              LDM      r1,{r1-r3}
0008f6  e880000e          STM      r0,{r1-r3}
                  |L1.2298|
;;;1202       }
;;;1203     }
;;;1204   
;;;1205     return frame; 
;;;1206   }
0008fa  bd0f              POP      {r0-r3,pc}
                  |L1.2300|
                          DCD      0x40028000
                  |L1.2304|
                          DCD      0x40029000
                  |L1.2308|
                          DCD      DMARxDescToGet
                  |L1.2312|
                          DCD      DMA_RX_FRAME_infos
                  |L1.2316|
00090c  49f7              LDR      r1,|L1.3308|
00090e  6809              LDR      r1,[r1,#0]            ;1150  ; DMARxDescToGet
000910  6809              LDR      r1,[r1,#0]            ;1150
000912  f0014100          AND      r1,r1,#0x80000000     ;1150
000916  b919              CBNZ     r1,|L1.2336|
000918  9900              LDR      r1,[sp,#0]            ;1151
00091a  2905              CMP      r1,#5                 ;1151
00091c  f4ffaf7d          BCC      |L1.2074|
                  |L1.2336|
000920  a901              ADD      r1,sp,#4              ;1205
000922  c90e              LDM      r1,{r1-r3}            ;1205
000924  e880000e          STM      r0,{r1-r3}            ;1205
000928  bf00              NOP                            ;1205
00092a  e7e6              B        |L1.2298|
;;;1207         
                          ENDP

                  ETH_Prepare_Transmit_Descriptors PROC
;;;1213     */
;;;1214   uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
00092c  b570              PUSH     {r4-r6,lr}
;;;1215   {   
00092e  4602              MOV      r2,r0
;;;1216     uint32_t buf_count =0, size=0,i=0;
000930  2300              MOVS     r3,#0
000932  2500              MOVS     r5,#0
000934  2400              MOVS     r4,#0
;;;1217     __IO ETH_DMADESCTypeDef *DMATxNextDesc;
;;;1218     
;;;1219     /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
;;;1220     if ((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32) RESET)
000936  48ee              LDR      r0,|L1.3312|
000938  6800              LDR      r0,[r0,#0]  ; DMATxDescToSet
00093a  6800              LDR      r0,[r0,#0]
00093c  f0004000          AND      r0,r0,#0x80000000
000940  b108              CBZ      r0,|L1.2374|
;;;1221     {  
;;;1222       /* Return ERROR: OWN bit set */
;;;1223       return ETH_ERROR;
000942  2000              MOVS     r0,#0
                  |L1.2372|
;;;1224     }
;;;1225     
;;;1226     DMATxNextDesc = DMATxDescToSet;
;;;1227     
;;;1228     if (FrameLength > ETH_TX_BUF_SIZE)
;;;1229     {
;;;1230       buf_count = FrameLength/ETH_TX_BUF_SIZE;
;;;1231       if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
;;;1232     }
;;;1233     else buf_count = 1;
;;;1234     
;;;1235     if (buf_count == 1)
;;;1236     {
;;;1237       /* Set LAST and FIRST segment */
;;;1238       DMATxDescToSet->Status |= ETH_DMATxDesc_FS | ETH_DMATxDesc_LS;
;;;1239       /* Set frame size */
;;;1240       DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
;;;1241       /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1242       DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
;;;1243       DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
;;;1244     }
;;;1245     else
;;;1246     {
;;;1247       for (i = 0; i < buf_count; i++)
;;;1248       {
;;;1249         if (i == 0) 
;;;1250         {
;;;1251           /* Setting the first segment bit */
;;;1252           DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
;;;1253         }
;;;1254         
;;;1255         /* Program size */
;;;1256         DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
;;;1257          
;;;1258         if (i == (buf_count - 1))
;;;1259         {
;;;1260           /* Setting the last segment bit */
;;;1261           DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
;;;1262           size = FrameLength - (buf_count - 1) * ETH_TX_BUF_SIZE;
;;;1263           DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
;;;1264         }
;;;1265           
;;;1266         /* Give back descriptor to DMA */
;;;1267         DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
;;;1268         
;;;1269         DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
;;;1270         /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1271       }
;;;1272       DMATxDescToSet = DMATxNextDesc ;
;;;1273     }
;;;1274       
;;;1275     /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
;;;1276     if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32) RESET)
;;;1277     {
;;;1278       /* Clear TBUS ETHERNET DMA flag */
;;;1279       ETH->DMASR = ETH_DMASR_TBUS;
;;;1280       /* Resume DMA transmission*/
;;;1281       ETH->DMATPDR = 0;
;;;1282     }
;;;1283     
;;;1284     /* Return SUCCESS */
;;;1285     return ETH_SUCCESS;   
;;;1286   }
000944  bd70              POP      {r4-r6,pc}
                  |L1.2374|
000946  48ea              LDR      r0,|L1.3312|
000948  6801              LDR      r1,[r0,#0]            ;1226  ; DMATxDescToSet
00094a  f24050f4          MOV      r0,#0x5f4             ;1228
00094e  4282              CMP      r2,r0                 ;1228
000950  dd08              BLE      |L1.2404|
000952  fb92f3f0          SDIV     r3,r2,r0              ;1230
000956  fb92f6f0          SDIV     r6,r2,r0              ;1231
00095a  fb002016          MLS      r0,r0,r6,r2           ;1231
00095e  b110              CBZ      r0,|L1.2406|
000960  1c5b              ADDS     r3,r3,#1              ;1231
000962  e000              B        |L1.2406|
                  |L1.2404|
000964  2301              MOVS     r3,#1                 ;1233
                  |L1.2406|
000966  2b01              CMP      r3,#1                 ;1235
000968  d11a              BNE      |L1.2464|
00096a  48e1              LDR      r0,|L1.3312|
00096c  6800              LDR      r0,[r0,#0]            ;1238  ; DMATxDescToSet
00096e  6800              LDR      r0,[r0,#0]            ;1238
000970  f0405040          ORR      r0,r0,#0x30000000     ;1238
000974  4ede              LDR      r6,|L1.3312|
000976  6836              LDR      r6,[r6,#0]            ;1238  ; DMATxDescToSet
000978  6030              STR      r0,[r6,#0]            ;1238
00097a  f3c2000c          UBFX     r0,r2,#0,#13          ;1240
00097e  4edc              LDR      r6,|L1.3312|
000980  6836              LDR      r6,[r6,#0]            ;1240  ; DMATxDescToSet
000982  6070              STR      r0,[r6,#4]            ;1240
000984  48da              LDR      r0,|L1.3312|
000986  6800              LDR      r0,[r0,#0]            ;1242  ; DMATxDescToSet
000988  6800              LDR      r0,[r0,#0]            ;1242
00098a  f0404000          ORR      r0,r0,#0x80000000     ;1242
00098e  4ed8              LDR      r6,|L1.3312|
000990  6836              LDR      r6,[r6,#0]            ;1242  ; DMATxDescToSet
000992  6030              STR      r0,[r6,#0]            ;1242
000994  48d6              LDR      r0,|L1.3312|
000996  6800              LDR      r0,[r0,#0]            ;1243  ; DMATxDescToSet
000998  68c0              LDR      r0,[r0,#0xc]          ;1243
00099a  4ed5              LDR      r6,|L1.3312|
00099c  6030              STR      r0,[r6,#0]            ;1243  ; DMATxDescToSet
00099e  e028              B        |L1.2546|
                  |L1.2464|
0009a0  2400              MOVS     r4,#0                 ;1247
0009a2  e022              B        |L1.2538|
                  |L1.2468|
0009a4  b93c              CBNZ     r4,|L1.2486|
0009a6  48d2              LDR      r0,|L1.3312|
0009a8  6800              LDR      r0,[r0,#0]            ;1252  ; DMATxDescToSet
0009aa  6800              LDR      r0,[r0,#0]            ;1252
0009ac  f0405080          ORR      r0,r0,#0x10000000     ;1252
0009b0  4ecf              LDR      r6,|L1.3312|
0009b2  6836              LDR      r6,[r6,#0]            ;1252  ; DMATxDescToSet
0009b4  6030              STR      r0,[r6,#0]            ;1252
                  |L1.2486|
0009b6  f24050f4          MOV      r0,#0x5f4             ;1256
0009ba  6048              STR      r0,[r1,#4]            ;1256
0009bc  1e58              SUBS     r0,r3,#1              ;1258
0009be  42a0              CMP      r0,r4                 ;1258
0009c0  d10d              BNE      |L1.2526|
0009c2  6808              LDR      r0,[r1,#0]            ;1261
0009c4  f0405000          ORR      r0,r0,#0x20000000     ;1261
0009c8  6008              STR      r0,[r1,#0]            ;1261
0009ca  1e58              SUBS     r0,r3,#1              ;1262
0009cc  ebc010c0          RSB      r0,r0,r0,LSL #7       ;1262
0009d0  eb000040          ADD      r0,r0,r0,LSL #1       ;1262
0009d4  eba20580          SUB      r5,r2,r0,LSL #2       ;1262
0009d8  f3c5000c          UBFX     r0,r5,#0,#13          ;1263
0009dc  6048              STR      r0,[r1,#4]            ;1263
                  |L1.2526|
0009de  6808              LDR      r0,[r1,#0]            ;1267
0009e0  f0404000          ORR      r0,r0,#0x80000000     ;1267
0009e4  6008              STR      r0,[r1,#0]            ;1267
0009e6  68c9              LDR      r1,[r1,#0xc]          ;1269
0009e8  1c64              ADDS     r4,r4,#1              ;1247
                  |L1.2538|
0009ea  429c              CMP      r4,r3                 ;1247
0009ec  d3da              BCC      |L1.2468|
0009ee  48c0              LDR      r0,|L1.3312|
0009f0  6001              STR      r1,[r0,#0]            ;1272  ; DMATxDescToSet
                  |L1.2546|
0009f2  48c0              LDR      r0,|L1.3316|
0009f4  6940              LDR      r0,[r0,#0x14]         ;1276
0009f6  f0000004          AND      r0,r0,#4              ;1276
0009fa  b120              CBZ      r0,|L1.2566|
0009fc  2004              MOVS     r0,#4                 ;1279
0009fe  4ebd              LDR      r6,|L1.3316|
000a00  6170              STR      r0,[r6,#0x14]         ;1279
000a02  2000              MOVS     r0,#0                 ;1281
000a04  6070              STR      r0,[r6,#4]            ;1281
                  |L1.2566|
000a06  2001              MOVS     r0,#1                 ;1285
000a08  e79c              B        |L1.2372|
;;;1287   
                          ENDP

                  ETH_Prepare_Transmit_Descriptors_TimeStamp PROC
;;;1293     */
;;;1294   uint32_t ETH_Prepare_Transmit_Descriptors_TimeStamp(u16 FrameLength, ETH_TimeStamp *TimeStamp)
000a0a  b5f0              PUSH     {r4-r7,lr}
;;;1295   {   
000a0c  4602              MOV      r2,r0
;;;1296     uint32_t timeout = 0, buf_count =0, size=0, i=0;
000a0e  2500              MOVS     r5,#0
000a10  2300              MOVS     r3,#0
000a12  2600              MOVS     r6,#0
000a14  2400              MOVS     r4,#0
;;;1297   
;;;1298   	/* Initialize the timestamp. */
;;;1299   	TimeStamp->TimeStampHigh = 0;
000a16  2000              MOVS     r0,#0
000a18  6048              STR      r0,[r1,#4]
;;;1300   	TimeStamp->TimeStampLow = 0;
000a1a  6008              STR      r0,[r1,#0]
;;;1301   
;;;1302   	/* Check timestamp.  */
;;;1303     if (TimeStamp == NULL)
000a1c  b901              CBNZ     r1,|L1.2592|
                  |L1.2590|
;;;1304     {
;;;1305       /* Return ERROR: Bad timestamp structure */
;;;1306   		return ETH_ERROR;
;;;1307     }
;;;1308     
;;;1309     /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
;;;1310     if ((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32) RESET)
;;;1311     {  
;;;1312       /* Return ERROR: OWN bit set */
;;;1313       return ETH_ERROR;
;;;1314     }
;;;1315   
;;;1316   	/* Determine the buffer count. */
;;;1317     if (FrameLength > ETH_TX_BUF_SIZE)
;;;1318     {
;;;1319       buf_count = FrameLength / ETH_TX_BUF_SIZE;
;;;1320       if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
;;;1321     }
;;;1322     else buf_count = 1;
;;;1323   
;;;1324   	/* Handle as a single descriptor transmit. */
;;;1325     if (buf_count == 1)
;;;1326     {
;;;1327   		/* Set transmit timestamp enable */
;;;1328   		DMATxDescToSet->Status |= ETH_DMATxDesc_TTSE;
;;;1329   
;;;1330   		/* Set LAST and FIRST segment */
;;;1331   		DMATxDescToSet->Status |= ETH_DMATxDesc_FS | ETH_DMATxDesc_LS;
;;;1332   
;;;1333       /* Set frame size */
;;;1334       DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
;;;1335   
;;;1336       /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1337       DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
;;;1338     }
;;;1339     else
;;;1340     {
;;;1341   		/* Transmit over multiple descriptors. */
;;;1342       for (i = 0; i < buf_count; i++)
;;;1343       {
;;;1344   			/* First segment handling. */
;;;1345         if (i == 0) 
;;;1346         {
;;;1347   				/* Set FIRST segment */
;;;1348   				DMATxDescToSet->Status |= ETH_DMATxDesc_FS;
;;;1349         }
;;;1350         
;;;1351   			/* Set frame size */
;;;1352         DMATxDescToSet->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
;;;1353          
;;;1354   			/* Last segment handling. */
;;;1355         if (i == (buf_count - 1))
;;;1356         {
;;;1357   				/* Set transmit timestamp enable on last descriptor */
;;;1358   				DMATxDescToSet->Status |= ETH_DMATxDesc_TTSE;
;;;1359   
;;;1360   				/* Set LAST segment */
;;;1361           DMATxDescToSet->Status |= ETH_DMATxDesc_LS;
;;;1362   
;;;1363           /* Setting the last segment bit */
;;;1364           size = FrameLength - (buf_count - 1) * ETH_TX_BUF_SIZE;
;;;1365           DMATxDescToSet->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
;;;1366         }
;;;1367           
;;;1368         /* Give back descriptor to DMA */
;;;1369         DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
;;;1370   
;;;1371   			/* Update the next descriptor to use. */
;;;1372         if (i < (buf_count - 1))
;;;1373         {
;;;1374   				/* Move to the next descriptor. */
;;;1375   				DMATxDescToSet = (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
;;;1376   			}
;;;1377       }
;;;1378   	}
;;;1379   
;;;1380     /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
;;;1381     if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32) RESET)
;;;1382     {
;;;1383       /* Clear TBUS ETHERNET DMA flag */
;;;1384       ETH->DMASR = ETH_DMASR_TBUS;
;;;1385   
;;;1386       /* Resume DMA transmission*/
;;;1387       ETH->DMATPDR = 0;
;;;1388     }
;;;1389   
;;;1390     /* Wait for ETH_DMATxDesc_TTSS flag to be set */
;;;1391     do
;;;1392     {
;;;1393       timeout++;
;;;1394     } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < PHY_READ_TO));
;;;1395   
;;;1396     /* Fill in time stamp of no timeout */
;;;1397     if (timeout < PHY_READ_TO)
;;;1398     {
;;;1399   		/* Fill in the time stamp */
;;;1400   		TimeStamp->TimeStampHigh = DMATxDescToSet->TimeStampHigh;
;;;1401   		TimeStamp->TimeStampLow = DMATxDescToSet->TimeStampLow;
;;;1402     }
;;;1403   
;;;1404     /* Clear the DMATxDescToSet status register TTSS flag */
;;;1405     DMATxDescToSet->Status &= ~ETH_DMATxDesc_TTSS;
;;;1406     
;;;1407     /* Selects the next DMA Tx descriptor list for next buffer to send */
;;;1408     DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet->Buffer2NextDescAddr);
;;;1409   
;;;1410     /* Return SUCCESS */
;;;1411     return ETH_SUCCESS;	
;;;1412   }
000a1e  bdf0              POP      {r4-r7,pc}
                  |L1.2592|
000a20  48b3              LDR      r0,|L1.3312|
000a22  6800              LDR      r0,[r0,#0]            ;1310  ; DMATxDescToSet
000a24  6800              LDR      r0,[r0,#0]            ;1310
000a26  f0004000          AND      r0,r0,#0x80000000     ;1310
000a2a  b108              CBZ      r0,|L1.2608|
000a2c  2000              MOVS     r0,#0                 ;1313
000a2e  e7f6              B        |L1.2590|
                  |L1.2608|
000a30  f24050f4          MOV      r0,#0x5f4             ;1317
000a34  4282              CMP      r2,r0                 ;1317
000a36  dd08              BLE      |L1.2634|
000a38  fb92f3f0          SDIV     r3,r2,r0              ;1319
000a3c  fb92f7f0          SDIV     r7,r2,r0              ;1320
000a40  fb002017          MLS      r0,r0,r7,r2           ;1320
000a44  b110              CBZ      r0,|L1.2636|
000a46  1c5b              ADDS     r3,r3,#1              ;1320
000a48  e000              B        |L1.2636|
                  |L1.2634|
000a4a  2301              MOVS     r3,#1                 ;1322
                  |L1.2636|
000a4c  2b01              CMP      r3,#1                 ;1325
000a4e  d11d              BNE      |L1.2700|
000a50  48a7              LDR      r0,|L1.3312|
000a52  6800              LDR      r0,[r0,#0]            ;1328  ; DMATxDescToSet
000a54  6800              LDR      r0,[r0,#0]            ;1328
000a56  f0407000          ORR      r0,r0,#0x2000000      ;1328
000a5a  4fa5              LDR      r7,|L1.3312|
000a5c  683f              LDR      r7,[r7,#0]            ;1328  ; DMATxDescToSet
000a5e  6038              STR      r0,[r7,#0]            ;1328
000a60  48a3              LDR      r0,|L1.3312|
000a62  6800              LDR      r0,[r0,#0]            ;1331  ; DMATxDescToSet
000a64  6800              LDR      r0,[r0,#0]            ;1331
000a66  f0405040          ORR      r0,r0,#0x30000000     ;1331
000a6a  4fa1              LDR      r7,|L1.3312|
000a6c  683f              LDR      r7,[r7,#0]            ;1331  ; DMATxDescToSet
000a6e  6038              STR      r0,[r7,#0]            ;1331
000a70  f3c2000c          UBFX     r0,r2,#0,#13          ;1334
000a74  4f9e              LDR      r7,|L1.3312|
000a76  683f              LDR      r7,[r7,#0]            ;1334  ; DMATxDescToSet
000a78  6078              STR      r0,[r7,#4]            ;1334
000a7a  489d              LDR      r0,|L1.3312|
000a7c  6800              LDR      r0,[r0,#0]            ;1337  ; DMATxDescToSet
000a7e  6800              LDR      r0,[r0,#0]            ;1337
000a80  f0404000          ORR      r0,r0,#0x80000000     ;1337
000a84  4f9a              LDR      r7,|L1.3312|
000a86  683f              LDR      r7,[r7,#0]            ;1337  ; DMATxDescToSet
000a88  6038              STR      r0,[r7,#0]            ;1337
000a8a  e041              B        |L1.2832|
                  |L1.2700|
000a8c  2400              MOVS     r4,#0                 ;1342
000a8e  e03d              B        |L1.2828|
                  |L1.2704|
000a90  b93c              CBNZ     r4,|L1.2722|
000a92  4897              LDR      r0,|L1.3312|
000a94  6800              LDR      r0,[r0,#0]            ;1348  ; DMATxDescToSet
000a96  6800              LDR      r0,[r0,#0]            ;1348
000a98  f0405080          ORR      r0,r0,#0x10000000     ;1348
000a9c  4f94              LDR      r7,|L1.3312|
000a9e  683f              LDR      r7,[r7,#0]            ;1348  ; DMATxDescToSet
000aa0  6038              STR      r0,[r7,#0]            ;1348
                  |L1.2722|
000aa2  f24050f4          MOV      r0,#0x5f4             ;1352
000aa6  4f92              LDR      r7,|L1.3312|
000aa8  683f              LDR      r7,[r7,#0]            ;1352  ; DMATxDescToSet
000aaa  6078              STR      r0,[r7,#4]            ;1352
000aac  1e58              SUBS     r0,r3,#1              ;1355
000aae  42a0              CMP      r0,r4                 ;1355
000ab0  d11b              BNE      |L1.2794|
000ab2  488f              LDR      r0,|L1.3312|
000ab4  6800              LDR      r0,[r0,#0]            ;1358  ; DMATxDescToSet
000ab6  6800              LDR      r0,[r0,#0]            ;1358
000ab8  f0407000          ORR      r0,r0,#0x2000000      ;1358
000abc  4f8c              LDR      r7,|L1.3312|
000abe  683f              LDR      r7,[r7,#0]            ;1358  ; DMATxDescToSet
000ac0  6038              STR      r0,[r7,#0]            ;1358
000ac2  488b              LDR      r0,|L1.3312|
000ac4  6800              LDR      r0,[r0,#0]            ;1361  ; DMATxDescToSet
000ac6  6800              LDR      r0,[r0,#0]            ;1361
000ac8  f0405000          ORR      r0,r0,#0x20000000     ;1361
000acc  4f88              LDR      r7,|L1.3312|
000ace  683f              LDR      r7,[r7,#0]            ;1361  ; DMATxDescToSet
000ad0  6038              STR      r0,[r7,#0]            ;1361
000ad2  1e58              SUBS     r0,r3,#1              ;1364
000ad4  ebc010c0          RSB      r0,r0,r0,LSL #7       ;1364
000ad8  eb000040          ADD      r0,r0,r0,LSL #1       ;1364
000adc  eba20680          SUB      r6,r2,r0,LSL #2       ;1364
000ae0  f3c6000c          UBFX     r0,r6,#0,#13          ;1365
000ae4  4f82              LDR      r7,|L1.3312|
000ae6  683f              LDR      r7,[r7,#0]            ;1365  ; DMATxDescToSet
000ae8  6078              STR      r0,[r7,#4]            ;1365
                  |L1.2794|
000aea  4881              LDR      r0,|L1.3312|
000aec  6800              LDR      r0,[r0,#0]            ;1369  ; DMATxDescToSet
000aee  6800              LDR      r0,[r0,#0]            ;1369
000af0  f0404000          ORR      r0,r0,#0x80000000     ;1369
000af4  4f7e              LDR      r7,|L1.3312|
000af6  683f              LDR      r7,[r7,#0]            ;1369  ; DMATxDescToSet
000af8  6038              STR      r0,[r7,#0]            ;1369
000afa  1e58              SUBS     r0,r3,#1              ;1372
000afc  42a0              CMP      r0,r4                 ;1372
000afe  d904              BLS      |L1.2826|
000b00  487b              LDR      r0,|L1.3312|
000b02  6800              LDR      r0,[r0,#0]            ;1375  ; DMATxDescToSet
000b04  68c0              LDR      r0,[r0,#0xc]          ;1375
000b06  4f7a              LDR      r7,|L1.3312|
000b08  6038              STR      r0,[r7,#0]            ;1375  ; DMATxDescToSet
                  |L1.2826|
000b0a  1c64              ADDS     r4,r4,#1              ;1342
                  |L1.2828|
000b0c  429c              CMP      r4,r3                 ;1342
000b0e  d3bf              BCC      |L1.2704|
                  |L1.2832|
000b10  4878              LDR      r0,|L1.3316|
000b12  6940              LDR      r0,[r0,#0x14]         ;1381
000b14  f0000004          AND      r0,r0,#4              ;1381
000b18  b120              CBZ      r0,|L1.2852|
000b1a  2004              MOVS     r0,#4                 ;1384
000b1c  4f75              LDR      r7,|L1.3316|
000b1e  6178              STR      r0,[r7,#0x14]         ;1384
000b20  2000              MOVS     r0,#0                 ;1387
000b22  6078              STR      r0,[r7,#4]            ;1387
                  |L1.2852|
000b24  bf00              NOP                            ;1391
                  |L1.2854|
000b26  1c6d              ADDS     r5,r5,#1              ;1393
000b28  4871              LDR      r0,|L1.3312|
000b2a  6800              LDR      r0,[r0,#0]            ;1394  ; DMATxDescToSet
000b2c  6800              LDR      r0,[r0,#0]            ;1394
000b2e  f4003000          AND      r0,r0,#0x20000        ;1394
000b32  b910              CBNZ     r0,|L1.2874|
000b34  4870              LDR      r0,|L1.3320|
000b36  4285              CMP      r5,r0                 ;1394
000b38  d3f5              BCC      |L1.2854|
                  |L1.2874|
000b3a  486f              LDR      r0,|L1.3320|
000b3c  4285              CMP      r5,r0                 ;1397
000b3e  d207              BCS      |L1.2896|
000b40  486b              LDR      r0,|L1.3312|
000b42  6800              LDR      r0,[r0,#0]            ;1400  ; DMATxDescToSet
000b44  69c0              LDR      r0,[r0,#0x1c]         ;1400
000b46  6048              STR      r0,[r1,#4]            ;1400
000b48  4869              LDR      r0,|L1.3312|
000b4a  6800              LDR      r0,[r0,#0]            ;1401  ; DMATxDescToSet
000b4c  6980              LDR      r0,[r0,#0x18]         ;1401
000b4e  6008              STR      r0,[r1,#0]            ;1401
                  |L1.2896|
000b50  4867              LDR      r0,|L1.3312|
000b52  6800              LDR      r0,[r0,#0]            ;1405  ; DMATxDescToSet
000b54  6800              LDR      r0,[r0,#0]            ;1405
000b56  f4203000          BIC      r0,r0,#0x20000        ;1405
000b5a  4f65              LDR      r7,|L1.3312|
000b5c  683f              LDR      r7,[r7,#0]            ;1405  ; DMATxDescToSet
000b5e  6038              STR      r0,[r7,#0]            ;1405
000b60  4863              LDR      r0,|L1.3312|
000b62  6800              LDR      r0,[r0,#0]            ;1408  ; DMATxDescToSet
000b64  68c0              LDR      r0,[r0,#0xc]          ;1408
000b66  4f62              LDR      r7,|L1.3312|
000b68  6038              STR      r0,[r7,#0]            ;1408  ; DMATxDescToSet
000b6a  2001              MOVS     r0,#1                 ;1411
000b6c  e757              B        |L1.2590|
;;;1413   
                          ENDP

                  ETH_DMARxDescChainInit PROC
;;;1421     */
;;;1422   void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
000b6e  b570              PUSH     {r4-r6,lr}
;;;1423   {
000b70  460c              MOV      r4,r1
000b72  4613              MOV      r3,r2
;;;1424     uint32_t i = 0;
000b74  2100              MOVS     r1,#0
;;;1425     ETH_DMADESCTypeDef *DMARxDesc;
;;;1426     
;;;1427     /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
;;;1428     DMARxDescToGet = DMARxDescTab; 
000b76  4d5d              LDR      r5,|L1.3308|
000b78  6028              STR      r0,[r5,#0]  ; DMARxDescToGet
;;;1429     /* Fill each DMARxDesc descriptor with the right values */
;;;1430     for(i=0; i < RxBuffCount; i++)
000b7a  bf00              NOP      
000b7c  e018              B        |L1.2992|
                  |L1.2942|
;;;1431     {
;;;1432       /* Get the pointer on the ith member of the Rx Desc list */
;;;1433       DMARxDesc = DMARxDescTab+i;
000b7e  eb001241          ADD      r2,r0,r1,LSL #5
;;;1434       /* Set Own bit of the Rx descriptor Status */
;;;1435       DMARxDesc->Status = ETH_DMARxDesc_OWN;
000b82  f04f4500          MOV      r5,#0x80000000
000b86  6015              STR      r5,[r2,#0]
;;;1436   
;;;1437       /* Set Buffer1 size and Second Address Chained bit */
;;;1438       DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
000b88  f24455f4          MOV      r5,#0x45f4
000b8c  6055              STR      r5,[r2,#4]
;;;1439       /* Set Buffer1 address pointer */
;;;1440       DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
000b8e  ebc115c1          RSB      r5,r1,r1,LSL #7
000b92  eb050545          ADD      r5,r5,r5,LSL #1
000b96  eb040585          ADD      r5,r4,r5,LSL #2
000b9a  6095              STR      r5,[r2,#8]
;;;1441       
;;;1442       /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;1443       if(i < (RxBuffCount-1))
000b9c  1e5d              SUBS     r5,r3,#1
000b9e  428d              CMP      r5,r1
000ba0  d904              BLS      |L1.2988|
;;;1444       {
;;;1445         /* Set next descriptor address register with next descriptor base address */
;;;1446         DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
000ba2  eb001541          ADD      r5,r0,r1,LSL #5
000ba6  3520              ADDS     r5,r5,#0x20
000ba8  60d5              STR      r5,[r2,#0xc]
000baa  e000              B        |L1.2990|
                  |L1.2988|
;;;1447       }
;;;1448       else
;;;1449       {
;;;1450         /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
;;;1451         DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
000bac  60d0              STR      r0,[r2,#0xc]
                  |L1.2990|
000bae  1c49              ADDS     r1,r1,#1              ;1430
                  |L1.2992|
000bb0  4299              CMP      r1,r3                 ;1430
000bb2  d3e4              BCC      |L1.2942|
;;;1452       }
;;;1453     }
;;;1454      
;;;1455     /* Set Receive Descriptor List Address Register */
;;;1456     ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
000bb4  4d4f              LDR      r5,|L1.3316|
000bb6  60e8              STR      r0,[r5,#0xc]
;;;1457     
;;;1458   
;;;1459     DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
000bb8  4d50              LDR      r5,|L1.3324|
000bba  4e51              LDR      r6,|L1.3328|
000bbc  6035              STR      r5,[r6,#0]  ; DMA_RX_FRAME_infos
;;;1460   
;;;1461   }
000bbe  bd70              POP      {r4-r6,pc}
;;;1462   
                          ENDP

                  ETH_CheckFrameReceived PROC
;;;1467     */
;;;1468   uint32_t ETH_CheckFrameReceived(void)
000bc0  484a              LDR      r0,|L1.3308|
;;;1469   { 
;;;1470     /* check if last segment */
;;;1471     if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
000bc2  6800              LDR      r0,[r0,#0]  ; DMARxDescToGet
000bc4  6800              LDR      r0,[r0,#0]
000bc6  f0004000          AND      r0,r0,#0x80000000
000bca  b998              CBNZ     r0,|L1.3060|
;;;1472        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
000bcc  4847              LDR      r0,|L1.3308|
000bce  6800              LDR      r0,[r0,#0]  ; DMARxDescToGet
000bd0  6800              LDR      r0,[r0,#0]
000bd2  f4007080          AND      r0,r0,#0x100
000bd6  b168              CBZ      r0,|L1.3060|
;;;1473       {   
;;;1474         DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
000bd8  4844              LDR      r0,|L1.3308|
000bda  6800              LDR      r0,[r0,#0]  ; DMARxDescToGet
000bdc  4948              LDR      r1,|L1.3328|
000bde  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
000be0  6048              STR      r0,[r1,#4]
;;;1475         DMA_RX_FRAME_infos->Seg_Count++;
000be2  4847              LDR      r0,|L1.3328|
000be4  6800              LDR      r0,[r0,#0]  ; DMA_RX_FRAME_infos
000be6  6880              LDR      r0,[r0,#8]
000be8  1c40              ADDS     r0,r0,#1
000bea  4945              LDR      r1,|L1.3328|
000bec  6809              LDR      r1,[r1,#0]  ; DMA_RX_FRAME_infos
000bee  6088              STR      r0,[r1,#8]
;;;1476         return 1;
000bf0  2001              MOVS     r0,#1
                  |L1.3058|
;;;1477       }
;;;1478     
;;;1479       /* check if first segment */
;;;1480       else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
;;;1481        ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
;;;1482        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
;;;1483       {
;;;1484         DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
;;;1485         DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
;;;1486         DMA_RX_FRAME_infos->Seg_Count = 1;   
;;;1487         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1488       }
;;;1489       
;;;1490       /* check if intermediate segment */ 
;;;1491       else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
;;;1492        ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
;;;1493        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
;;;1494       {
;;;1495         (DMA_RX_FRAME_infos->Seg_Count) ++;
;;;1496         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1497       } 
;;;1498       return 0;
;;;1499   }
000bf2  4770              BX       lr
                  |L1.3060|
000bf4  483d              LDR      r0,|L1.3308|
000bf6  6800              LDR      r0,[r0,#0]            ;1480  ; DMARxDescToGet
000bf8  6800              LDR      r0,[r0,#0]            ;1480
000bfa  f0004000          AND      r0,r0,#0x80000000     ;1480
000bfe  b9f0              CBNZ     r0,|L1.3134|
000c00  483a              LDR      r0,|L1.3308|
000c02  6800              LDR      r0,[r0,#0]            ;1481  ; DMARxDescToGet
000c04  6800              LDR      r0,[r0,#0]            ;1481
000c06  f4007000          AND      r0,r0,#0x200          ;1481
000c0a  b1c0              CBZ      r0,|L1.3134|
000c0c  4837              LDR      r0,|L1.3308|
000c0e  6800              LDR      r0,[r0,#0]            ;1482  ; DMARxDescToGet
000c10  6800              LDR      r0,[r0,#0]            ;1482
000c12  f4007080          AND      r0,r0,#0x100          ;1482
000c16  b990              CBNZ     r0,|L1.3134|
000c18  4834              LDR      r0,|L1.3308|
000c1a  6800              LDR      r0,[r0,#0]            ;1484  ; DMARxDescToGet
000c1c  4938              LDR      r1,|L1.3328|
000c1e  6809              LDR      r1,[r1,#0]            ;1484  ; DMA_RX_FRAME_infos
000c20  6008              STR      r0,[r1,#0]            ;1484
000c22  2000              MOVS     r0,#0                 ;1485
000c24  4936              LDR      r1,|L1.3328|
000c26  6809              LDR      r1,[r1,#0]            ;1485  ; DMA_RX_FRAME_infos
000c28  6048              STR      r0,[r1,#4]            ;1485
000c2a  2001              MOVS     r0,#1                 ;1486
000c2c  4934              LDR      r1,|L1.3328|
000c2e  6809              LDR      r1,[r1,#0]            ;1486  ; DMA_RX_FRAME_infos
000c30  6088              STR      r0,[r1,#8]            ;1486
000c32  482e              LDR      r0,|L1.3308|
000c34  6800              LDR      r0,[r0,#0]            ;1487  ; DMARxDescToGet
000c36  68c0              LDR      r0,[r0,#0xc]          ;1487
000c38  492c              LDR      r1,|L1.3308|
000c3a  6008              STR      r0,[r1,#0]            ;1487  ; DMARxDescToGet
000c3c  e01d              B        |L1.3194|
                  |L1.3134|
000c3e  482b              LDR      r0,|L1.3308|
000c40  6800              LDR      r0,[r0,#0]            ;1491  ; DMARxDescToGet
000c42  6800              LDR      r0,[r0,#0]            ;1491
000c44  f0004000          AND      r0,r0,#0x80000000     ;1491
000c48  b9b8              CBNZ     r0,|L1.3194|
000c4a  4828              LDR      r0,|L1.3308|
000c4c  6800              LDR      r0,[r0,#0]            ;1492  ; DMARxDescToGet
000c4e  6800              LDR      r0,[r0,#0]            ;1492
000c50  f4007000          AND      r0,r0,#0x200          ;1492
000c54  b988              CBNZ     r0,|L1.3194|
000c56  4825              LDR      r0,|L1.3308|
000c58  6800              LDR      r0,[r0,#0]            ;1493  ; DMARxDescToGet
000c5a  6800              LDR      r0,[r0,#0]            ;1493
000c5c  f4007080          AND      r0,r0,#0x100          ;1493
000c60  b958              CBNZ     r0,|L1.3194|
000c62  4827              LDR      r0,|L1.3328|
000c64  6800              LDR      r0,[r0,#0]            ;1495  ; DMA_RX_FRAME_infos
000c66  6880              LDR      r0,[r0,#8]            ;1495
000c68  1c40              ADDS     r0,r0,#1              ;1495
000c6a  4925              LDR      r1,|L1.3328|
000c6c  6809              LDR      r1,[r1,#0]            ;1495  ; DMA_RX_FRAME_infos
000c6e  6088              STR      r0,[r1,#8]            ;1495
000c70  481e              LDR      r0,|L1.3308|
000c72  6800              LDR      r0,[r0,#0]            ;1496  ; DMARxDescToGet
000c74  68c0              LDR      r0,[r0,#0xc]          ;1496
000c76  491d              LDR      r1,|L1.3308|
000c78  6008              STR      r0,[r1,#0]            ;1496  ; DMARxDescToGet
                  |L1.3194|
000c7a  2000              MOVS     r0,#0                 ;1498
000c7c  e7b9              B        |L1.3058|
;;;1500   
                          ENDP

                  ETH_DMATxDescChainInit PROC
;;;1509     */
;;;1510   void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
000c7e  b530              PUSH     {r4,r5,lr}
;;;1511   {
000c80  460c              MOV      r4,r1
000c82  4613              MOV      r3,r2
;;;1512     uint32_t i = 0;
000c84  2100              MOVS     r1,#0
;;;1513     ETH_DMADESCTypeDef *DMATxDesc;
;;;1514     
;;;1515     /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
;;;1516     DMATxDescToSet = DMATxDescTab;
000c86  4d1a              LDR      r5,|L1.3312|
000c88  6028              STR      r0,[r5,#0]  ; DMATxDescToSet
;;;1517     /* Fill each DMATxDesc descriptor with the right values */   
;;;1518     for(i=0; i < TxBuffCount; i++)
000c8a  bf00              NOP      
000c8c  e015              B        |L1.3258|
                  |L1.3214|
;;;1519     {
;;;1520       /* Get the pointer on the ith member of the Tx Desc list */
;;;1521       DMATxDesc = DMATxDescTab + i;
000c8e  eb001241          ADD      r2,r0,r1,LSL #5
;;;1522       /* Set Second Address Chained bit */
;;;1523       DMATxDesc->Status = ETH_DMATxDesc_TCH;  
000c92  f44f1580          MOV      r5,#0x100000
000c96  6015              STR      r5,[r2,#0]
;;;1524          
;;;1525       /* Set Buffer1 address pointer */
;;;1526       DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
000c98  ebc115c1          RSB      r5,r1,r1,LSL #7
000c9c  eb050545          ADD      r5,r5,r5,LSL #1
000ca0  eb040585          ADD      r5,r4,r5,LSL #2
000ca4  6095              STR      r5,[r2,#8]
;;;1527       
;;;1528       /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;1529       if(i < (TxBuffCount-1))
000ca6  1e5d              SUBS     r5,r3,#1
000ca8  428d              CMP      r5,r1
000caa  d904              BLS      |L1.3254|
;;;1530       {
;;;1531         /* Set next descriptor address register with next descriptor base address */
;;;1532         DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
000cac  eb001541          ADD      r5,r0,r1,LSL #5
000cb0  3520              ADDS     r5,r5,#0x20
000cb2  60d5              STR      r5,[r2,#0xc]
000cb4  e000              B        |L1.3256|
                  |L1.3254|
;;;1533       }
;;;1534       else
;;;1535       {
;;;1536         /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
;;;1537         DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
000cb6  60d0              STR      r0,[r2,#0xc]
                  |L1.3256|
000cb8  1c49              ADDS     r1,r1,#1              ;1518
                  |L1.3258|
000cba  4299              CMP      r1,r3                 ;1518
000cbc  d3e7              BCC      |L1.3214|
;;;1538       }
;;;1539     }
;;;1540      
;;;1541     /* Set Transmit Desciptor List Address Register */
;;;1542     ETH->DMATDLAR = (uint32_t) DMATxDescTab;
000cbe  4d0d              LDR      r5,|L1.3316|
000cc0  6128              STR      r0,[r5,#0x10]
;;;1543   }
000cc2  bd30              POP      {r4,r5,pc}
;;;1544   
                          ENDP

                  ETH_GetDMATxDescFlagStatus PROC
;;;1579     */
;;;1580   FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
000cc4  4602              MOV      r2,r0
;;;1581   {
;;;1582     FlagStatus bitstatus = RESET;
000cc6  2000              MOVS     r0,#0
;;;1583     /* Check the parameters */
;;;1584     assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
;;;1585     
;;;1586     if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
000cc8  6813              LDR      r3,[r2,#0]
000cca  400b              ANDS     r3,r3,r1
000ccc  b10b              CBZ      r3,|L1.3282|
;;;1587     {
;;;1588       bitstatus = SET;
000cce  2001              MOVS     r0,#1
000cd0  e000              B        |L1.3284|
                  |L1.3282|
;;;1589     }
;;;1590     else
;;;1591     {
;;;1592       bitstatus = RESET;
000cd2  2000              MOVS     r0,#0
                  |L1.3284|
;;;1593     }
;;;1594     return bitstatus;
;;;1595   }
000cd4  4770              BX       lr
;;;1596   
                          ENDP

                  ETH_GetDMATxDescCollisionCount PROC
;;;1601     */
;;;1602   uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
000cd6  4601              MOV      r1,r0
;;;1603   {
;;;1604     /* Return the Receive descriptor frame length */
;;;1605     return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
000cd8  6808              LDR      r0,[r1,#0]
000cda  f3c000c3          UBFX     r0,r0,#3,#4
;;;1606   }
000cde  4770              BX       lr
;;;1607   
                          ENDP

                  ETH_SetDMATxDescOwnBit PROC
;;;1612     */
;;;1613   void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
000ce0  6801              LDR      r1,[r0,#0]
;;;1614   {
;;;1615     /* Set the DMA Tx Desc Own bit */
;;;1616     DMATxDesc->Status |= ETH_DMATxDesc_OWN;
000ce2  f0414100          ORR      r1,r1,#0x80000000
000ce6  6001              STR      r1,[r0,#0]
;;;1617   }
000ce8  4770              BX       lr
000cea  0000              DCW      0x0000
                  |L1.3308|
                          DCD      DMARxDescToGet
                  |L1.3312|
                          DCD      DMATxDescToSet
                  |L1.3316|
                          DCD      0x40029000
                  |L1.3320|
                          DCD      0x0004ffff
                  |L1.3324|
                          DCD      RX_Frame_Descriptor
                  |L1.3328|
                          DCD      DMA_RX_FRAME_infos
                          ENDP

                  ETH_DMATxDescTransmitITConfig PROC
;;;1625     */
;;;1626   void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000d04  b121              CBZ      r1,|L1.3344|
;;;1627   {
;;;1628     /* Check the parameters */
;;;1629     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1630     
;;;1631     if (NewState != DISABLE)
;;;1632     {
;;;1633       /* Enable the DMA Tx Desc Transmit interrupt */
;;;1634       DMATxDesc->Status |= ETH_DMATxDesc_IC;
000d06  6802              LDR      r2,[r0,#0]
000d08  f0424280          ORR      r2,r2,#0x40000000
000d0c  6002              STR      r2,[r0,#0]
000d0e  e003              B        |L1.3352|
                  |L1.3344|
;;;1635     }
;;;1636     else
;;;1637     {
;;;1638       /* Disable the DMA Tx Desc Transmit interrupt */
;;;1639       DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
000d10  6802              LDR      r2,[r0,#0]
000d12  f0224280          BIC      r2,r2,#0x40000000
000d16  6002              STR      r2,[r0,#0]
                  |L1.3352|
;;;1640     }
;;;1641   }
000d18  4770              BX       lr
;;;1642   
                          ENDP

                  ETH_DMATxDescFrameSegmentConfig PROC
;;;1651     */
;;;1652   void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
000d1a  6802              LDR      r2,[r0,#0]
;;;1653   {
;;;1654     /* Check the parameters */
;;;1655     assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
;;;1656     
;;;1657     /* Selects the DMA Tx Desc Frame segment */
;;;1658     DMATxDesc->Status |= DMATxDesc_FrameSegment;
000d1c  430a              ORRS     r2,r2,r1
000d1e  6002              STR      r2,[r0,#0]
;;;1659   }
000d20  4770              BX       lr
;;;1660   
                          ENDP

                  ETH_DMATxDescChecksumInsertionConfig PROC
;;;1671     */
;;;1672   void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
000d22  6802              LDR      r2,[r0,#0]
;;;1673   {
;;;1674     /* Check the parameters */
;;;1675     assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
;;;1676     
;;;1677     /* Set the selected DMA Tx desc checksum insertion control */
;;;1678     DMATxDesc->Status |= DMATxDesc_Checksum;
000d24  430a              ORRS     r2,r2,r1
000d26  6002              STR      r2,[r0,#0]
;;;1679   }
000d28  4770              BX       lr
;;;1680   
                          ENDP

                  ETH_DMATxDescCRCCmd PROC
;;;1687     */
;;;1688   void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000d2a  b121              CBZ      r1,|L1.3382|
;;;1689   {
;;;1690     /* Check the parameters */
;;;1691     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1692     
;;;1693     if (NewState != DISABLE)
;;;1694     {
;;;1695       /* Enable the selected DMA Tx Desc CRC */
;;;1696       DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
000d2c  6802              LDR      r2,[r0,#0]
000d2e  f0226200          BIC      r2,r2,#0x8000000
000d32  6002              STR      r2,[r0,#0]
000d34  e003              B        |L1.3390|
                  |L1.3382|
;;;1697     }
;;;1698     else
;;;1699     {
;;;1700       /* Disable the selected DMA Tx Desc CRC */
;;;1701       DMATxDesc->Status |= ETH_DMATxDesc_DC; 
000d36  6802              LDR      r2,[r0,#0]
000d38  f0426200          ORR      r2,r2,#0x8000000
000d3c  6002              STR      r2,[r0,#0]
                  |L1.3390|
;;;1702     }
;;;1703   }
000d3e  4770              BX       lr
;;;1704   
                          ENDP

                  ETH_DMATxDescSecondAddressChainedCmd PROC
;;;1712     */
;;;1713   void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000d40  b121              CBZ      r1,|L1.3404|
;;;1714   {
;;;1715     /* Check the parameters */
;;;1716     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1717     
;;;1718     if (NewState != DISABLE)
;;;1719     {
;;;1720       /* Enable the selected DMA Tx Desc second address chained */
;;;1721       DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
000d42  6802              LDR      r2,[r0,#0]
000d44  f4421280          ORR      r2,r2,#0x100000
000d48  6002              STR      r2,[r0,#0]
000d4a  e003              B        |L1.3412|
                  |L1.3404|
;;;1722     }
;;;1723     else
;;;1724     {
;;;1725       /* Disable the selected DMA Tx Desc second address chained */
;;;1726       DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
000d4c  6802              LDR      r2,[r0,#0]
000d4e  f4221280          BIC      r2,r2,#0x100000
000d52  6002              STR      r2,[r0,#0]
                  |L1.3412|
;;;1727     }
;;;1728   }
000d54  4770              BX       lr
;;;1729   
                          ENDP

                  ETH_DMATxDescShortFramePaddingCmd PROC
;;;1736     */
;;;1737   void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000d56  b121              CBZ      r1,|L1.3426|
;;;1738   {
;;;1739     /* Check the parameters */
;;;1740     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1741     
;;;1742     if (NewState != DISABLE)
;;;1743     {
;;;1744       /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
;;;1745       DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
000d58  6802              LDR      r2,[r0,#0]
000d5a  f0226280          BIC      r2,r2,#0x4000000
000d5e  6002              STR      r2,[r0,#0]
000d60  e003              B        |L1.3434|
                  |L1.3426|
;;;1746     }
;;;1747     else
;;;1748     {
;;;1749       /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
;;;1750       DMATxDesc->Status |= ETH_DMATxDesc_DP; 
000d62  6802              LDR      r2,[r0,#0]
000d64  f0426280          ORR      r2,r2,#0x4000000
000d68  6002              STR      r2,[r0,#0]
                  |L1.3434|
;;;1751     }
;;;1752   }
000d6a  4770              BX       lr
;;;1753   
                          ENDP

                  ETH_DMATxDescBufferSizeConfig PROC
;;;1761     */
;;;1762   void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
000d6c  b510              PUSH     {r4,lr}
;;;1763   {
;;;1764     /* Check the parameters */
;;;1765     assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
;;;1766     assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
;;;1767     
;;;1768     /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
;;;1769     DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
000d6e  ea414402          ORR      r4,r1,r2,LSL #16
000d72  6843              LDR      r3,[r0,#4]
000d74  4323              ORRS     r3,r3,r4
000d76  6043              STR      r3,[r0,#4]
;;;1770   }
000d78  bd10              POP      {r4,pc}
;;;1771   
                          ENDP

                  ETH_GetDMARxDescFlagStatus PROC
;;;1797     */
;;;1798   FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
000d7a  4602              MOV      r2,r0
;;;1799   {
;;;1800     FlagStatus bitstatus = RESET;
000d7c  2000              MOVS     r0,#0
;;;1801     /* Check the parameters */
;;;1802     assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
;;;1803     if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
000d7e  6813              LDR      r3,[r2,#0]
000d80  400b              ANDS     r3,r3,r1
000d82  b10b              CBZ      r3,|L1.3464|
;;;1804     {
;;;1805       bitstatus = SET;
000d84  2001              MOVS     r0,#1
000d86  e000              B        |L1.3466|
                  |L1.3464|
;;;1806     }
;;;1807     else
;;;1808     {
;;;1809       bitstatus = RESET;
000d88  2000              MOVS     r0,#0
                  |L1.3466|
;;;1810     }
;;;1811     return bitstatus;
;;;1812   }
000d8a  4770              BX       lr
;;;1813   
                          ENDP

                  ETH_GetDMAPTPRxDescExtendedFlagStatus PROC
;;;1830     */
;;;1831   FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag)
000d8c  4602              MOV      r2,r0
;;;1832   {
;;;1833     FlagStatus bitstatus = RESET;
000d8e  2000              MOVS     r0,#0
;;;1834   
;;;1835     /* Check the parameters */
;;;1836     assert_param(IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(ETH_DMAPTPRxDescExtendedFlag));
;;;1837   
;;;1838     if ((DMAPTPRxDesc->ExtendedStatus & ETH_DMAPTPRxDescExtendedFlag) != (uint32_t)RESET)
000d90  6913              LDR      r3,[r2,#0x10]
000d92  400b              ANDS     r3,r3,r1
000d94  b10b              CBZ      r3,|L1.3482|
;;;1839     {
;;;1840       bitstatus = SET;
000d96  2001              MOVS     r0,#1
000d98  e000              B        |L1.3484|
                  |L1.3482|
;;;1841     }
;;;1842     else
;;;1843     {
;;;1844       bitstatus = RESET;
000d9a  2000              MOVS     r0,#0
                  |L1.3484|
;;;1845     }
;;;1846     return bitstatus;
;;;1847   }
000d9c  4770              BX       lr
;;;1848   #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                          ENDP

                  ETH_SetDMARxDescOwnBit PROC
;;;1854     */
;;;1855   void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
000d9e  6801              LDR      r1,[r0,#0]
;;;1856   {
;;;1857     /* Set the DMA Rx Desc Own bit */
;;;1858     DMARxDesc->Status |= ETH_DMARxDesc_OWN;
000da0  f0414100          ORR      r1,r1,#0x80000000
000da4  6001              STR      r1,[r0,#0]
;;;1859   }
000da6  4770              BX       lr
;;;1860   
                          ENDP

                  ETH_GetDMARxDescFrameLength PROC
;;;1865     */
;;;1866   uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
000da8  4601              MOV      r1,r0
;;;1867   {
;;;1868     /* Return the Receive descriptor frame length */
;;;1869     return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
000daa  6808              LDR      r0,[r1,#0]
000dac  f3c0400d          UBFX     r0,r0,#16,#14
;;;1870   }
000db0  4770              BX       lr
;;;1871   
                          ENDP

                  ETH_DMARxDescReceiveITConfig PROC
;;;1878     */
;;;1879   void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
000db2  b121              CBZ      r1,|L1.3518|
;;;1880   {
;;;1881     /* Check the parameters */
;;;1882     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1883     
;;;1884     if (NewState != DISABLE)
;;;1885     {
;;;1886       /* Enable the DMA Rx Desc receive interrupt */
;;;1887       DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
000db4  6842              LDR      r2,[r0,#4]
000db6  f0224200          BIC      r2,r2,#0x80000000
000dba  6042              STR      r2,[r0,#4]
000dbc  e003              B        |L1.3526|
                  |L1.3518|
;;;1888     }
;;;1889     else
;;;1890     {
;;;1891       /* Disable the DMA Rx Desc receive interrupt */
;;;1892       DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
000dbe  6842              LDR      r2,[r0,#4]
000dc0  f0424200          ORR      r2,r2,#0x80000000
000dc4  6042              STR      r2,[r0,#4]
                  |L1.3526|
;;;1893     }
;;;1894   }
000dc6  4770              BX       lr
;;;1895   
                          ENDP

                  ETH_GetDMARxDescBufferSize PROC
;;;1905     */
;;;1906   uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
000dc8  4602              MOV      r2,r0
;;;1907   {
;;;1908     /* Check the parameters */
;;;1909     assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
;;;1910     
;;;1911     if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
000dca  b119              CBZ      r1,|L1.3540|
;;;1912     {
;;;1913       /* Return the DMA Rx Desc buffer2 size */
;;;1914       return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
000dcc  6850              LDR      r0,[r2,#4]
000dce  f3c0400c          UBFX     r0,r0,#16,#13
                  |L1.3538|
;;;1915     }
;;;1916     else
;;;1917     {
;;;1918       /* Return the DMA Rx Desc buffer1 size */
;;;1919       return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
;;;1920     }
;;;1921   }
000dd2  4770              BX       lr
                  |L1.3540|
000dd4  8890              LDRH     r0,[r2,#4]            ;1919
000dd6  f3c0000c          UBFX     r0,r0,#0,#13          ;1919
000dda  e7fa              B        |L1.3538|
;;;1922   
                          ENDP

                  ETH_GetRxPktSize PROC
;;;1928     */
;;;1929   uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
000ddc  b500              PUSH     {lr}
;;;1930   {
000dde  4602              MOV      r2,r0
;;;1931     uint32_t frameLength = 0;
000de0  2300              MOVS     r3,#0
;;;1932     if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
000de2  6810              LDR      r0,[r2,#0]
000de4  f0004000          AND      r0,r0,#0x80000000
000de8  b958              CBNZ     r0,|L1.3586|
;;;1933        ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
000dea  6810              LDR      r0,[r2,#0]
000dec  f4004000          AND      r0,r0,#0x8000
000df0  b938              CBNZ     r0,|L1.3586|
;;;1934        ((DMARxDesc->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
000df2  6810              LDR      r0,[r2,#0]
000df4  f4007080          AND      r0,r0,#0x100
000df8  b118              CBZ      r0,|L1.3586|
;;;1935     {
;;;1936       /* Get the size of the packet: including 4 bytes of the CRC */
;;;1937       frameLength =  ETH_GetDMARxDescFrameLength(DMARxDesc);
000dfa  4610              MOV      r0,r2
000dfc  f7fffffe          BL       ETH_GetDMARxDescFrameLength
000e00  4603              MOV      r3,r0
                  |L1.3586|
;;;1938     }
;;;1939     
;;;1940     /* Return Frame Length */ 
;;;1941     return frameLength;
000e02  4618              MOV      r0,r3
;;;1942   }
000e04  bd00              POP      {pc}
;;;1943   
                          ENDP

                  ETH_EnhancedDescriptorCmd PROC
;;;1950     */
;;;1951   void ETH_EnhancedDescriptorCmd(FunctionalState NewState)
000e06  b538              PUSH     {r3-r5,lr}
;;;1952   { 
000e08  4604              MOV      r4,r0
;;;1953     __IO uint32_t tmpreg = 0;
000e0a  2000              MOVS     r0,#0
000e0c  9000              STR      r0,[sp,#0]
;;;1954     /* Check the parameters */
;;;1955     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1956     
;;;1957     if (NewState != DISABLE)
000e0e  b134              CBZ      r4,|L1.3614|
;;;1958     {
;;;1959       /* Enable enhanced descriptor structure */
;;;1960       ETH->DMABMR |= ETH_DMABMR_EDE;
000e10  48f8              LDR      r0,|L1.4596|
000e12  6800              LDR      r0,[r0,#0]
000e14  f0400080          ORR      r0,r0,#0x80
000e18  49f6              LDR      r1,|L1.4596|
000e1a  6008              STR      r0,[r1,#0]
000e1c  e005              B        |L1.3626|
                  |L1.3614|
;;;1961     }
;;;1962     else
;;;1963     {
;;;1964       /* Disable enhanced descriptor structure */
;;;1965       ETH->DMABMR &= ~ETH_DMABMR_EDE;
000e1e  48f5              LDR      r0,|L1.4596|
000e20  6800              LDR      r0,[r0,#0]
000e22  f0200080          BIC      r0,r0,#0x80
000e26  49f3              LDR      r1,|L1.4596|
000e28  6008              STR      r0,[r1,#0]
                  |L1.3626|
;;;1966     }
;;;1967     
;;;1968     /* Wait until the write operation will be taken into account :
;;;1969      at least four TX_CLK/RX_CLK clock cycles */
;;;1970     tmpreg = ETH->DMABMR;
000e2a  48f2              LDR      r0,|L1.4596|
000e2c  6800              LDR      r0,[r0,#0]
000e2e  9000              STR      r0,[sp,#0]
;;;1971     _eth_delay_(ETH_REG_WRITE_DELAY);
000e30  f64f70ff          MOV      r0,#0xffff
000e34  f7fffffe          BL       ETH_Delay
;;;1972     ETH->DMABMR = tmpreg;
000e38  49ee              LDR      r1,|L1.4596|
000e3a  9800              LDR      r0,[sp,#0]
000e3c  6008              STR      r0,[r1,#0]
;;;1973   }
000e3e  bd38              POP      {r3-r5,pc}
;;;1974   #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                          ENDP

                  ETH_SoftwareReset PROC
;;;1983     */
;;;1984   void ETH_SoftwareReset(void)
000e40  48ec              LDR      r0,|L1.4596|
;;;1985   {
;;;1986     /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
;;;1987     /* After reset all the registers holds their respective reset values */
;;;1988     ETH->DMABMR |= ETH_DMABMR_SR;
000e42  6800              LDR      r0,[r0,#0]
000e44  f0400001          ORR      r0,r0,#1
000e48  49ea              LDR      r1,|L1.4596|
000e4a  6008              STR      r0,[r1,#0]
;;;1989   }
000e4c  4770              BX       lr
;;;1990   
                          ENDP

                  ETH_GetSoftwareResetStatus PROC
;;;1995     */
;;;1996   FlagStatus ETH_GetSoftwareResetStatus(void)
000e4e  2000              MOVS     r0,#0
;;;1997   {
;;;1998     FlagStatus bitstatus = RESET;
;;;1999     if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
000e50  49e8              LDR      r1,|L1.4596|
000e52  6809              LDR      r1,[r1,#0]
000e54  f0010101          AND      r1,r1,#1
000e58  b109              CBZ      r1,|L1.3678|
;;;2000     {
;;;2001       bitstatus = SET;
000e5a  2001              MOVS     r0,#1
000e5c  e000              B        |L1.3680|
                  |L1.3678|
;;;2002     }
;;;2003     else
;;;2004     {
;;;2005       bitstatus = RESET;
000e5e  2000              MOVS     r0,#0
                  |L1.3680|
;;;2006     }
;;;2007     return bitstatus;
;;;2008   }
000e60  4770              BX       lr
;;;2009   
                          ENDP

                  ETH_GetDMAFlagStatus PROC
;;;2036     */
;;;2037   FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
000e62  4601              MOV      r1,r0
;;;2038   {  
;;;2039     FlagStatus bitstatus = RESET;
000e64  2000              MOVS     r0,#0
;;;2040     /* Check the parameters */
;;;2041     assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
;;;2042     if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
000e66  4ae3              LDR      r2,|L1.4596|
000e68  6952              LDR      r2,[r2,#0x14]
000e6a  400a              ANDS     r2,r2,r1
000e6c  b10a              CBZ      r2,|L1.3698|
;;;2043     {
;;;2044       bitstatus = SET;
000e6e  2001              MOVS     r0,#1
000e70  e000              B        |L1.3700|
                  |L1.3698|
;;;2045     }
;;;2046     else
;;;2047     {
;;;2048       bitstatus = RESET;
000e72  2000              MOVS     r0,#0
                  |L1.3700|
;;;2049     }
;;;2050     return bitstatus;
;;;2051   }
000e74  4770              BX       lr
;;;2052   
                          ENDP

                  ETH_DMAClearFlag PROC
;;;2073     */
;;;2074   void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
000e76  49df              LDR      r1,|L1.4596|
;;;2075   {
;;;2076     /* Check the parameters */
;;;2077     assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
;;;2078     
;;;2079     /* Clear the selected ETHERNET DMA FLAG */
;;;2080     ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
000e78  6148              STR      r0,[r1,#0x14]
;;;2081   }
000e7a  4770              BX       lr
;;;2082   
                          ENDP

                  ETH_DMAITConfig PROC
;;;2106     */
;;;2107   void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
000e7c  b129              CBZ      r1,|L1.3722|
;;;2108   {
;;;2109     /* Check the parameters */
;;;2110     assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
;;;2111     assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;2112     
;;;2113     if (NewState != DISABLE)
;;;2114     {
;;;2115       /* Enable the selected ETHERNET DMA interrupts */
;;;2116       ETH->DMAIER |= ETH_DMA_IT;
000e7e  4add              LDR      r2,|L1.4596|
000e80  69d2              LDR      r2,[r2,#0x1c]
000e82  4302              ORRS     r2,r2,r0
000e84  4bdb              LDR      r3,|L1.4596|
000e86  61da              STR      r2,[r3,#0x1c]
000e88  e004              B        |L1.3732|
                  |L1.3722|
;;;2117     }
;;;2118     else
;;;2119     {
;;;2120       /* Disable the selected ETHERNET DMA interrupts */
;;;2121       ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
000e8a  4ada              LDR      r2,|L1.4596|
000e8c  69d2              LDR      r2,[r2,#0x1c]
000e8e  4382              BICS     r2,r2,r0
000e90  4bd8              LDR      r3,|L1.4596|
000e92  61da              STR      r2,[r3,#0x1c]
                  |L1.3732|
;;;2122     }
;;;2123   }
000e94  4770              BX       lr
;;;2124   
                          ENDP

                  ETH_GetDMAITStatus PROC
;;;2148     */
;;;2149   ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
000e96  4601              MOV      r1,r0
;;;2150   {  
;;;2151     ITStatus bitstatus = RESET;
000e98  2000              MOVS     r0,#0
;;;2152     /* Check the parameters */
;;;2153     assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
;;;2154     if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
000e9a  4ad6              LDR      r2,|L1.4596|
000e9c  6952              LDR      r2,[r2,#0x14]
000e9e  400a              ANDS     r2,r2,r1
000ea0  b10a              CBZ      r2,|L1.3750|
;;;2155     {
;;;2156       bitstatus = SET;
000ea2  2001              MOVS     r0,#1
000ea4  e000              B        |L1.3752|
                  |L1.3750|
;;;2157     }
;;;2158     else
;;;2159     {
;;;2160       bitstatus = RESET;
000ea6  2000              MOVS     r0,#0
                  |L1.3752|
;;;2161     }
;;;2162     return bitstatus;
;;;2163   }
000ea8  4770              BX       lr
;;;2164   
                          ENDP

                  ETH_DMAClearITPendingBit PROC
;;;2185     */
;;;2186   void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
000eaa  49d2              LDR      r1,|L1.4596|
;;;2187   {
;;;2188     /* Check the parameters */
;;;2189     assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
;;;2190     
;;;2191     /* Clear the selected ETHERNET DMA IT */
;;;2192     ETH->DMASR = (uint32_t) ETH_DMA_IT;
000eac  6148              STR      r0,[r1,#0x14]
;;;2193   }
000eae  4770              BX       lr
;;;2194   
                          ENDP

                  ETH_GetTransmitProcessState PROC
;;;2206     */
;;;2207   uint32_t ETH_GetTransmitProcessState(void)
000eb0  48d0              LDR      r0,|L1.4596|
;;;2208   {
;;;2209     return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
000eb2  6940              LDR      r0,[r0,#0x14]
000eb4  f0000001          AND      r0,r0,#1
;;;2210   }
000eb8  4770              BX       lr
;;;2211   
                          ENDP

                  ETH_GetReceiveProcessState PROC
;;;2223     */
;;;2224   uint32_t ETH_GetReceiveProcessState(void)
000eba  48ce              LDR      r0,|L1.4596|
;;;2225   {
;;;2226     return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
000ebc  6940              LDR      r0,[r0,#0x14]
000ebe  f0000040          AND      r0,r0,#0x40
;;;2227   }
000ec2  4770              BX       lr
;;;2228   
                          ENDP

                  ETH_GetFlushTransmitFIFOStatus PROC
;;;2251     */
;;;2252   FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
000ec4  2000              MOVS     r0,#0
;;;2253   {   
;;;2254     FlagStatus bitstatus = RESET;
;;;2255     if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
000ec6  49cb              LDR      r1,|L1.4596|
000ec8  6989              LDR      r1,[r1,#0x18]
000eca  f4011180          AND      r1,r1,#0x100000
000ece  b109              CBZ      r1,|L1.3796|
;;;2256     {
;;;2257       bitstatus = SET;
000ed0  2001              MOVS     r0,#1
000ed2  e000              B        |L1.3798|
                  |L1.3796|
;;;2258     }
;;;2259     else
;;;2260     {
;;;2261       bitstatus = RESET;
000ed4  2000              MOVS     r0,#0
                  |L1.3798|
;;;2262     }
;;;2263     return bitstatus; 
;;;2264   }
000ed6  4770              BX       lr
;;;2265   
                          ENDP

                  ETH_GetDMAOverflowStatus PROC
;;;2319     */
;;;2320   FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
000ed8  4601              MOV      r1,r0
;;;2321   {
;;;2322     FlagStatus bitstatus = RESET;
000eda  2000              MOVS     r0,#0
;;;2323     /* Check the parameters */
;;;2324     assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
;;;2325     
;;;2326     if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
000edc  4ac5              LDR      r2,|L1.4596|
000ede  6a12              LDR      r2,[r2,#0x20]
000ee0  400a              ANDS     r2,r2,r1
000ee2  b10a              CBZ      r2,|L1.3816|
;;;2327     {
;;;2328       bitstatus = SET;
000ee4  2001              MOVS     r0,#1
000ee6  e000              B        |L1.3818|
                  |L1.3816|
;;;2329     }
;;;2330     else
;;;2331     {
;;;2332       bitstatus = RESET;
000ee8  2000              MOVS     r0,#0
                  |L1.3818|
;;;2333     }
;;;2334     return bitstatus;
;;;2335   }
000eea  4770              BX       lr
;;;2336   
                          ENDP

                  ETH_GetRxOverflowMissedFrameCounter PROC
;;;2341     */
;;;2342   uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
000eec  48c1              LDR      r0,|L1.4596|
;;;2343   {
;;;2344     return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
000eee  6a00              LDR      r0,[r0,#0x20]
000ef0  f3c0404a          UBFX     r0,r0,#17,#11
;;;2345   }
000ef4  4770              BX       lr
;;;2346   
                          ENDP

                  ETH_GetBufferUnavailableMissedFrameCounter PROC
;;;2351     */
;;;2352   uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
000ef6  48bf              LDR      r0,|L1.4596|
;;;2353   {
;;;2354     return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
000ef8  6a00              LDR      r0,[r0,#0x20]
000efa  b280              UXTH     r0,r0
;;;2355   }
000efc  4770              BX       lr
;;;2356   
                          ENDP

                  ETH_GetCurrentTxDescStartAddress PROC
;;;2361     */
;;;2362   uint32_t ETH_GetCurrentTxDescStartAddress(void)
000efe  48bd              LDR      r0,|L1.4596|
;;;2363   {
;;;2364     return ((uint32_t)(ETH->DMACHTDR));
000f00  6c80              LDR      r0,[r0,#0x48]
;;;2365   }
000f02  4770              BX       lr
;;;2366   
                          ENDP

                  ETH_GetCurrentRxDescStartAddress PROC
;;;2371     */
;;;2372   uint32_t ETH_GetCurrentRxDescStartAddress(void)
000f04  48bb              LDR      r0,|L1.4596|
;;;2373   {
;;;2374     return ((uint32_t)(ETH->DMACHRDR));
000f06  6cc0              LDR      r0,[r0,#0x4c]
;;;2375   }
000f08  4770              BX       lr
;;;2376   
                          ENDP

                  ETH_GetCurrentTxBufferAddress PROC
;;;2381     */
;;;2382   uint32_t ETH_GetCurrentTxBufferAddress(void)
000f0a  48ba              LDR      r0,|L1.4596|
;;;2383   {
;;;2384     return ((uint32_t)(ETH->DMACHTBAR));
000f0c  6d00              LDR      r0,[r0,#0x50]
;;;2385   }
000f0e  4770              BX       lr
;;;2386   
                          ENDP

                  ETH_GetCurrentRxBufferAddress PROC
;;;2391     */
;;;2392   uint32_t ETH_GetCurrentRxBufferAddress(void)
000f10  48b8              LDR      r0,|L1.4596|
;;;2393   {
;;;2394     return ((uint32_t)(ETH->DMACHRBAR));
000f12  6d40              LDR      r0,[r0,#0x54]
;;;2395   }
000f14  4770              BX       lr
;;;2396   
                          ENDP

                  ETH_ResumeDMATransmission PROC
;;;2402     */
;;;2403   void ETH_ResumeDMATransmission(void)
000f16  2000              MOVS     r0,#0
;;;2404   {
;;;2405     ETH->DMATPDR = 0;
000f18  49b6              LDR      r1,|L1.4596|
000f1a  6048              STR      r0,[r1,#4]
;;;2406   }
000f1c  4770              BX       lr
;;;2407   
                          ENDP

                  ETH_ResumeDMAReception PROC
;;;2413     */
;;;2414   void ETH_ResumeDMAReception(void)
000f1e  2000              MOVS     r0,#0
;;;2415   {
;;;2416     ETH->DMARPDR = 0;
000f20  49b4              LDR      r1,|L1.4596|
000f22  6088              STR      r0,[r1,#8]
;;;2417   }
000f24  4770              BX       lr
;;;2418   
                          ENDP

                  ETH_SetReceiveWatchdogTimer PROC
;;;2423     */
;;;2424   void ETH_SetReceiveWatchdogTimer(uint8_t Value)
000f26  49b3              LDR      r1,|L1.4596|
;;;2425   {
;;;2426     /* Set the DMA Receive status watchdog timer register */
;;;2427     ETH->DMARSWTR = Value;
000f28  6248              STR      r0,[r1,#0x24]
;;;2428   }
000f2a  4770              BX       lr
;;;2429   
                          ENDP

                  ETH_PHYLoopBackCmd PROC
;;;2540     */
;;;2541   uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
000f2c  b570              PUSH     {r4-r6,lr}
;;;2542   {
000f2e  4606              MOV      r6,r0
000f30  460d              MOV      r5,r1
;;;2543     uint16_t tmpreg = 0;
000f32  2400              MOVS     r4,#0
;;;2544     /* Check the parameters */
;;;2545     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2546     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2547       
;;;2548     /* Get the PHY configuration to update it */
;;;2549     tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
000f34  2100              MOVS     r1,#0
000f36  4630              MOV      r0,r6
000f38  f7fffffe          BL       ETH_ReadPHYRegister
000f3c  4604              MOV      r4,r0
;;;2550     
;;;2551     if (NewState != DISABLE)
000f3e  b115              CBZ      r5,|L1.3910|
;;;2552     {
;;;2553       /* Enable the PHY loopback mode */
;;;2554       tmpreg |= PHY_Loopback;  
000f40  f4444480          ORR      r4,r4,#0x4000
000f44  e002              B        |L1.3916|
                  |L1.3910|
;;;2555     }
;;;2556     else
;;;2557     {
;;;2558       /* Disable the PHY loopback mode: normal mode */
;;;2559       tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
000f46  f64b70ff          MOV      r0,#0xbfff
000f4a  4004              ANDS     r4,r4,r0
                  |L1.3916|
;;;2560     }
;;;2561     /* Update the PHY control register with the new configuration */
;;;2562     if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
000f4c  4622              MOV      r2,r4
000f4e  2100              MOVS     r1,#0
000f50  4630              MOV      r0,r6
000f52  f7fffffe          BL       ETH_WritePHYRegister
000f56  b108              CBZ      r0,|L1.3932|
;;;2563     {
;;;2564       return ETH_SUCCESS;
000f58  2001              MOVS     r0,#1
                  |L1.3930|
;;;2565     }
;;;2566     else
;;;2567     {
;;;2568       /* Return SUCCESS */
;;;2569       return ETH_ERROR; 
;;;2570     }   
;;;2571   } 
000f5a  bd70              POP      {r4-r6,pc}
                  |L1.3932|
000f5c  2000              MOVS     r0,#0                 ;2569
000f5e  e7fc              B        |L1.3930|
;;;2572   
                          ENDP

                  ETH_ResetWakeUpFrameFilterRegisterPointer PROC
;;;2580     */
;;;2581   void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
000f60  b508              PUSH     {r3,lr}
;;;2582   {
;;;2583     __IO uint32_t tmpreg = 0;
000f62  2000              MOVS     r0,#0
000f64  9000              STR      r0,[sp,#0]
;;;2584     /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
;;;2585     ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;
000f66  48a4              LDR      r0,|L1.4600|
000f68  6ac0              LDR      r0,[r0,#0x2c]
000f6a  f0404000          ORR      r0,r0,#0x80000000
000f6e  49a2              LDR      r1,|L1.4600|
000f70  62c8              STR      r0,[r1,#0x2c]
;;;2586     
;;;2587     /* Wait until the write operation will be taken into account :
;;;2588      at least four TX_CLK/RX_CLK clock cycles */
;;;2589     tmpreg = ETH->MACPMTCSR;
000f72  4608              MOV      r0,r1
000f74  6ac0              LDR      r0,[r0,#0x2c]
000f76  9000              STR      r0,[sp,#0]
;;;2590     _eth_delay_(ETH_REG_WRITE_DELAY);
000f78  f64f70ff          MOV      r0,#0xffff
000f7c  f7fffffe          BL       ETH_Delay
;;;2591     ETH->MACPMTCSR = tmpreg;
000f80  499d              LDR      r1,|L1.4600|
000f82  9800              LDR      r0,[sp,#0]
000f84  62c8              STR      r0,[r1,#0x2c]
;;;2592   }
000f86  bd08              POP      {r3,pc}
;;;2593   
                          ENDP

                  ETH_SetWakeUpFrameFilterRegister PROC
;;;2598     */
;;;2599   void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
000f88  b538              PUSH     {r3-r5,lr}
;;;2600   {
000f8a  4605              MOV      r5,r0
;;;2601     __IO uint32_t tmpreg = 0;
000f8c  2000              MOVS     r0,#0
000f8e  9000              STR      r0,[sp,#0]
;;;2602     uint32_t i = 0;
000f90  2400              MOVS     r4,#0
;;;2603   
;;;2604     /* Fill Remote Wake-up Frame Filter register with Buffer data */
;;;2605     for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
000f92  bf00              NOP      
000f94  e00e              B        |L1.4020|
                  |L1.3990|
;;;2606     {
;;;2607       /* Write each time to the same register */ 
;;;2608       ETH->MACRWUFFR = Buffer[i];
000f96  f8550024          LDR      r0,[r5,r4,LSL #2]
000f9a  4997              LDR      r1,|L1.4600|
000f9c  6288              STR      r0,[r1,#0x28]
;;;2609   
;;;2610       /* Wait until the write operation will be taken into account :
;;;2611        at least four TX_CLK/RX_CLK clock cycles */
;;;2612       tmpreg = ETH->MACRWUFFR;
000f9e  4608              MOV      r0,r1
000fa0  6a80              LDR      r0,[r0,#0x28]
000fa2  9000              STR      r0,[sp,#0]
;;;2613       _eth_delay_(ETH_REG_WRITE_DELAY);
000fa4  f64f70ff          MOV      r0,#0xffff
000fa8  f7fffffe          BL       ETH_Delay
;;;2614       ETH->MACRWUFFR = tmpreg;
000fac  4992              LDR      r1,|L1.4600|
000fae  9800              LDR      r0,[sp,#0]
000fb0  6288              STR      r0,[r1,#0x28]
000fb2  1c64              ADDS     r4,r4,#1              ;2605
                  |L1.4020|
000fb4  2c08              CMP      r4,#8                 ;2605
000fb6  d3ee              BCC      |L1.3990|
;;;2615     }
;;;2616   }
000fb8  bd38              POP      {r3-r5,pc}
;;;2617   
                          ENDP

                  ETH_GlobalUnicastWakeUpCmd PROC
;;;2624     */
;;;2625   void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
000fba  b538              PUSH     {r3-r5,lr}
;;;2626   { 
000fbc  4604              MOV      r4,r0
;;;2627     __IO uint32_t tmpreg = 0;
000fbe  2000              MOVS     r0,#0
000fc0  9000              STR      r0,[sp,#0]
;;;2628     /* Check the parameters */
;;;2629     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2630   
;;;2631     if (NewState != DISABLE)
000fc2  b134              CBZ      r4,|L1.4050|
;;;2632     {
;;;2633       /* Enable the MAC Global Unicast Wake-Up */
;;;2634       ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;
000fc4  488c              LDR      r0,|L1.4600|
000fc6  6ac0              LDR      r0,[r0,#0x2c]
000fc8  f4407000          ORR      r0,r0,#0x200
000fcc  498a              LDR      r1,|L1.4600|
000fce  62c8              STR      r0,[r1,#0x2c]
000fd0  e005              B        |L1.4062|
                  |L1.4050|
;;;2635     }
;;;2636     else
;;;2637     {
;;;2638       /* Disable the MAC Global Unicast Wake-Up */
;;;2639       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
000fd2  4889              LDR      r0,|L1.4600|
000fd4  6ac0              LDR      r0,[r0,#0x2c]
000fd6  f4207000          BIC      r0,r0,#0x200
000fda  4987              LDR      r1,|L1.4600|
000fdc  62c8              STR      r0,[r1,#0x2c]
                  |L1.4062|
;;;2640     }
;;;2641   
;;;2642     /* Wait until the write operation will be taken into account :
;;;2643      at least four TX_CLK/RX_CLK clock cycles */
;;;2644     tmpreg = ETH->MACPMTCSR;
000fde  4886              LDR      r0,|L1.4600|
000fe0  6ac0              LDR      r0,[r0,#0x2c]
000fe2  9000              STR      r0,[sp,#0]
;;;2645     _eth_delay_(ETH_REG_WRITE_DELAY);
000fe4  f64f70ff          MOV      r0,#0xffff
000fe8  f7fffffe          BL       ETH_Delay
;;;2646     ETH->MACPMTCSR = tmpreg;
000fec  4982              LDR      r1,|L1.4600|
000fee  9800              LDR      r0,[sp,#0]
000ff0  62c8              STR      r0,[r1,#0x2c]
;;;2647   }
000ff2  bd38              POP      {r3-r5,pc}
;;;2648   
                          ENDP

                  ETH_GetPMTFlagStatus PROC
;;;2657     */
;;;2658   FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
000ff4  4601              MOV      r1,r0
;;;2659   {
;;;2660     FlagStatus bitstatus = RESET;
000ff6  2000              MOVS     r0,#0
;;;2661     /* Check the parameters */
;;;2662     assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
;;;2663     
;;;2664     if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
000ff8  4a7f              LDR      r2,|L1.4600|
000ffa  6ad2              LDR      r2,[r2,#0x2c]
000ffc  400a              ANDS     r2,r2,r1
000ffe  b10a              CBZ      r2,|L1.4100|
;;;2665     {
;;;2666       bitstatus = SET;
001000  2001              MOVS     r0,#1
001002  e000              B        |L1.4102|
                  |L1.4100|
;;;2667     }
;;;2668     else
;;;2669     {
;;;2670       bitstatus = RESET;
001004  2000              MOVS     r0,#0
                  |L1.4102|
;;;2671     }
;;;2672     return bitstatus;
;;;2673   }
001006  4770              BX       lr
;;;2674   
                          ENDP

                  ETH_WakeUpFrameDetectionCmd PROC
;;;2680     */
;;;2681   void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
001008  b538              PUSH     {r3-r5,lr}
;;;2682   { 
00100a  4604              MOV      r4,r0
;;;2683     __IO uint32_t tmpreg = 0;
00100c  2000              MOVS     r0,#0
00100e  9000              STR      r0,[sp,#0]
;;;2684     /* Check the parameters */
;;;2685     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2686     
;;;2687     if (NewState != DISABLE)
001010  b134              CBZ      r4,|L1.4128|
;;;2688     {
;;;2689       /* Enable the MAC Wake-Up Frame Detection */
;;;2690       ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;
001012  4879              LDR      r0,|L1.4600|
001014  6ac0              LDR      r0,[r0,#0x2c]
001016  f0400004          ORR      r0,r0,#4
00101a  4977              LDR      r1,|L1.4600|
00101c  62c8              STR      r0,[r1,#0x2c]
00101e  e005              B        |L1.4140|
                  |L1.4128|
;;;2691     }
;;;2692     else
;;;2693     {
;;;2694       /* Disable the MAC Wake-Up Frame Detection */ 
;;;2695       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
001020  4875              LDR      r0,|L1.4600|
001022  6ac0              LDR      r0,[r0,#0x2c]
001024  f0200004          BIC      r0,r0,#4
001028  4973              LDR      r1,|L1.4600|
00102a  62c8              STR      r0,[r1,#0x2c]
                  |L1.4140|
;;;2696     }
;;;2697     /* Wait until the write operation will be taken into account :
;;;2698      at least four TX_CLK/RX_CLK clock cycles */
;;;2699     tmpreg = ETH->MACPMTCSR;
00102c  4872              LDR      r0,|L1.4600|
00102e  6ac0              LDR      r0,[r0,#0x2c]
001030  9000              STR      r0,[sp,#0]
;;;2700     _eth_delay_(ETH_REG_WRITE_DELAY);
001032  f64f70ff          MOV      r0,#0xffff
001036  f7fffffe          BL       ETH_Delay
;;;2701     ETH->MACPMTCSR = tmpreg;
00103a  496f              LDR      r1,|L1.4600|
00103c  9800              LDR      r0,[sp,#0]
00103e  62c8              STR      r0,[r1,#0x2c]
;;;2702   }
001040  bd38              POP      {r3-r5,pc}
;;;2703   
                          ENDP

                  ETH_MagicPacketDetectionCmd PROC
;;;2709     */
;;;2710   void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
001042  b538              PUSH     {r3-r5,lr}
;;;2711   { 
001044  4604              MOV      r4,r0
;;;2712     __IO uint32_t tmpreg = 0;
001046  2000              MOVS     r0,#0
001048  9000              STR      r0,[sp,#0]
;;;2713     /* Check the parameters */
;;;2714     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2715   
;;;2716     if (NewState != DISABLE)
00104a  b134              CBZ      r4,|L1.4186|
;;;2717     {
;;;2718       /* Enable the MAC Magic Packet Detection */
;;;2719       ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;
00104c  486a              LDR      r0,|L1.4600|
00104e  6ac0              LDR      r0,[r0,#0x2c]
001050  f0400002          ORR      r0,r0,#2
001054  4968              LDR      r1,|L1.4600|
001056  62c8              STR      r0,[r1,#0x2c]
001058  e005              B        |L1.4198|
                  |L1.4186|
;;;2720     }
;;;2721     else
;;;2722     {
;;;2723       /* Disable the MAC Magic Packet Detection */
;;;2724       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
00105a  4867              LDR      r0,|L1.4600|
00105c  6ac0              LDR      r0,[r0,#0x2c]
00105e  f0200002          BIC      r0,r0,#2
001062  4965              LDR      r1,|L1.4600|
001064  62c8              STR      r0,[r1,#0x2c]
                  |L1.4198|
;;;2725     }
;;;2726   
;;;2727     /* Wait until the write operation will be taken into account :
;;;2728      at least four TX_CLK/RX_CLK clock cycles */
;;;2729     tmpreg = ETH->MACPMTCSR;
001066  4864              LDR      r0,|L1.4600|
001068  6ac0              LDR      r0,[r0,#0x2c]
00106a  9000              STR      r0,[sp,#0]
;;;2730     _eth_delay_(ETH_REG_WRITE_DELAY);
00106c  f64f70ff          MOV      r0,#0xffff
001070  f7fffffe          BL       ETH_Delay
;;;2731     ETH->MACPMTCSR = tmpreg;
001074  4960              LDR      r1,|L1.4600|
001076  9800              LDR      r0,[sp,#0]
001078  62c8              STR      r0,[r1,#0x2c]
;;;2732   }
00107a  bd38              POP      {r3-r5,pc}
;;;2733   
                          ENDP

                  ETH_PowerDownCmd PROC
;;;2739     */
;;;2740   void ETH_PowerDownCmd(FunctionalState NewState)
00107c  b538              PUSH     {r3-r5,lr}
;;;2741   { 
00107e  4604              MOV      r4,r0
;;;2742     __IO uint32_t tmpreg = 0;
001080  2000              MOVS     r0,#0
001082  9000              STR      r0,[sp,#0]
;;;2743     /* Check the parameters */
;;;2744     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2745     
;;;2746     if (NewState != DISABLE)
001084  b134              CBZ      r4,|L1.4244|
;;;2747     {
;;;2748       /* Enable the MAC Power Down */
;;;2749       /* This puts the MAC in power down mode */
;;;2750       ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;
001086  485c              LDR      r0,|L1.4600|
001088  6ac0              LDR      r0,[r0,#0x2c]
00108a  f0400001          ORR      r0,r0,#1
00108e  495a              LDR      r1,|L1.4600|
001090  62c8              STR      r0,[r1,#0x2c]
001092  e005              B        |L1.4256|
                  |L1.4244|
;;;2751     }
;;;2752     else
;;;2753     {
;;;2754       /* Disable the MAC Power Down */ 
;;;2755       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
001094  4858              LDR      r0,|L1.4600|
001096  6ac0              LDR      r0,[r0,#0x2c]
001098  f0200001          BIC      r0,r0,#1
00109c  4956              LDR      r1,|L1.4600|
00109e  62c8              STR      r0,[r1,#0x2c]
                  |L1.4256|
;;;2756     }
;;;2757   
;;;2758     /* Wait until the write operation will be taken into account :
;;;2759      at least four TX_CLK/RX_CLK clock cycles */
;;;2760     tmpreg = ETH->MACPMTCSR;
0010a0  4855              LDR      r0,|L1.4600|
0010a2  6ac0              LDR      r0,[r0,#0x2c]
0010a4  9000              STR      r0,[sp,#0]
;;;2761     _eth_delay_(ETH_REG_WRITE_DELAY);
0010a6  f64f70ff          MOV      r0,#0xffff
0010aa  f7fffffe          BL       ETH_Delay
;;;2762     ETH->MACPMTCSR = tmpreg;
0010ae  4952              LDR      r1,|L1.4600|
0010b0  9800              LDR      r0,[sp,#0]
0010b2  62c8              STR      r0,[r1,#0x2c]
;;;2763   }
0010b4  bd38              POP      {r3-r5,pc}
;;;2764   
                          ENDP

                  ETH_MMCCounterFullPreset PROC
;;;2772     */
;;;2773   void ETH_MMCCounterFullPreset(void)
0010b6  4851              LDR      r0,|L1.4604|
;;;2774   {
;;;2775     /* Preset and Initialize the MMC counters to almost-full value */
;;;2776     ETH->MMCCR |= ETH_MMCCR_MCFHP | ETH_MMCCR_MCP;
0010b8  6800              LDR      r0,[r0,#0]
0010ba  f0400030          ORR      r0,r0,#0x30
0010be  494e              LDR      r1,|L1.4600|
0010c0  f8c10100          STR      r0,[r1,#0x100]
;;;2777   }
0010c4  4770              BX       lr
;;;2778   
                          ENDP

                  ETH_MMCCounterHalfPreset PROC
;;;2783     */
;;;2784   void ETH_MMCCounterHalfPreset(void)
0010c6  484d              LDR      r0,|L1.4604|
;;;2785   {
;;;2786     /* Preset the MMC counters to almost-full value */
;;;2787     ETH->MMCCR &= ~ETH_MMCCR_MCFHP;
0010c8  6800              LDR      r0,[r0,#0]
0010ca  f0200020          BIC      r0,r0,#0x20
0010ce  494a              LDR      r1,|L1.4600|
0010d0  f8c10100          STR      r0,[r1,#0x100]
;;;2788     /* Initialize the MMC counters to almost-half value */
;;;2789     ETH->MMCCR |= ETH_MMCCR_MCP;
0010d4  4608              MOV      r0,r1
0010d6  f8d00100          LDR      r0,[r0,#0x100]
0010da  f0400010          ORR      r0,r0,#0x10
0010de  f8c10100          STR      r0,[r1,#0x100]
;;;2790   }
0010e2  4770              BX       lr
;;;2791   
                          ENDP

                  ETH_MMCCounterFreezeCmd PROC
;;;2797     */
;;;2798   void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
0010e4  b138              CBZ      r0,|L1.4342|
;;;2799   {
;;;2800     /* Check the parameters */
;;;2801     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2802     
;;;2803     if (NewState != DISABLE)
;;;2804     {
;;;2805       /* Enable the MMC Counter Freeze */
;;;2806       ETH->MMCCR |= ETH_MMCCR_MCF;
0010e6  4945              LDR      r1,|L1.4604|
0010e8  6809              LDR      r1,[r1,#0]
0010ea  f0410108          ORR      r1,r1,#8
0010ee  4a42              LDR      r2,|L1.4600|
0010f0  f8c21100          STR      r1,[r2,#0x100]
0010f4  e006              B        |L1.4356|
                  |L1.4342|
;;;2807     }
;;;2808     else
;;;2809     {
;;;2810       /* Disable the MMC Counter Freeze */
;;;2811       ETH->MMCCR &= ~ETH_MMCCR_MCF;
0010f6  4941              LDR      r1,|L1.4604|
0010f8  6809              LDR      r1,[r1,#0]
0010fa  f0210108          BIC      r1,r1,#8
0010fe  4a3e              LDR      r2,|L1.4600|
001100  f8c21100          STR      r1,[r2,#0x100]
                  |L1.4356|
;;;2812     }
;;;2813   }
001104  4770              BX       lr
;;;2814   
                          ENDP

                  ETH_MMCResetOnReadCmd PROC
;;;2820     */
;;;2821   void ETH_MMCResetOnReadCmd(FunctionalState NewState)
001106  b138              CBZ      r0,|L1.4376|
;;;2822   {
;;;2823     /* Check the parameters */
;;;2824     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2825     
;;;2826     if (NewState != DISABLE)
;;;2827     {
;;;2828       /* Enable the MMC Counter reset on read */
;;;2829       ETH->MMCCR |= ETH_MMCCR_ROR; 
001108  493c              LDR      r1,|L1.4604|
00110a  6809              LDR      r1,[r1,#0]
00110c  f0410104          ORR      r1,r1,#4
001110  4a39              LDR      r2,|L1.4600|
001112  f8c21100          STR      r1,[r2,#0x100]
001116  e006              B        |L1.4390|
                  |L1.4376|
;;;2830     }
;;;2831     else
;;;2832     {
;;;2833       /* Disable the MMC Counter reset on read */
;;;2834       ETH->MMCCR &= ~ETH_MMCCR_ROR;
001118  4938              LDR      r1,|L1.4604|
00111a  6809              LDR      r1,[r1,#0]
00111c  f0210104          BIC      r1,r1,#4
001120  4a35              LDR      r2,|L1.4600|
001122  f8c21100          STR      r1,[r2,#0x100]
                  |L1.4390|
;;;2835     }
;;;2836   }
001126  4770              BX       lr
;;;2837   
                          ENDP

                  ETH_MMCCounterRolloverCmd PROC
;;;2843     */
;;;2844   void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
001128  b138              CBZ      r0,|L1.4410|
;;;2845   {
;;;2846     /* Check the parameters */
;;;2847     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2848     
;;;2849     if (NewState != DISABLE)
;;;2850     {
;;;2851       /* Disable the MMC Counter Stop Rollover  */
;;;2852       ETH->MMCCR &= ~ETH_MMCCR_CSR;
00112a  4934              LDR      r1,|L1.4604|
00112c  6809              LDR      r1,[r1,#0]
00112e  f0210102          BIC      r1,r1,#2
001132  4a31              LDR      r2,|L1.4600|
001134  f8c21100          STR      r1,[r2,#0x100]
001138  e006              B        |L1.4424|
                  |L1.4410|
;;;2853     }
;;;2854     else
;;;2855     {
;;;2856       /* Enable the MMC Counter Stop Rollover */
;;;2857       ETH->MMCCR |= ETH_MMCCR_CSR; 
00113a  4930              LDR      r1,|L1.4604|
00113c  6809              LDR      r1,[r1,#0]
00113e  f0410102          ORR      r1,r1,#2
001142  4a2d              LDR      r2,|L1.4600|
001144  f8c21100          STR      r1,[r2,#0x100]
                  |L1.4424|
;;;2858     }
;;;2859   }
001148  4770              BX       lr
;;;2860   
                          ENDP

                  ETH_MMCCountersReset PROC
;;;2865     */
;;;2866   void ETH_MMCCountersReset(void)
00114a  482c              LDR      r0,|L1.4604|
;;;2867   {
;;;2868     /* Resets the MMC Counters */
;;;2869     ETH->MMCCR |= ETH_MMCCR_CR; 
00114c  6800              LDR      r0,[r0,#0]
00114e  f0400001          ORR      r0,r0,#1
001152  4929              LDR      r1,|L1.4600|
001154  f8c10100          STR      r0,[r1,#0x100]
;;;2870   }
001158  4770              BX       lr
;;;2871   
                          ENDP

                  ETH_MMCITConfig PROC
;;;2886     */
;;;2887   void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
00115a  f0005280          AND      r2,r0,#0x10000000
;;;2888   { 
;;;2889     /* Check the parameters */
;;;2890     assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
;;;2891     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2892      
;;;2893     if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
00115e  b192              CBZ      r2,|L1.4486|
;;;2894     {
;;;2895       /* Remove Register mak from IT */
;;;2896       ETH_MMC_IT &= 0xEFFFFFFF;
001160  f0205080          BIC      r0,r0,#0x10000000
;;;2897     
;;;2898       /* ETHERNET MMC Rx interrupts selected */
;;;2899       if (NewState != DISABLE)
001164  b139              CBZ      r1,|L1.4470|
;;;2900       {
;;;2901         /* Enable the selected ETHERNET MMC interrupts */
;;;2902         ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
001166  4a25              LDR      r2,|L1.4604|
001168  320c              ADDS     r2,r2,#0xc
00116a  6812              LDR      r2,[r2,#0]
00116c  4382              BICS     r2,r2,r0
00116e  4b22              LDR      r3,|L1.4600|
001170  f8c3210c          STR      r2,[r3,#0x10c]
001174  e017              B        |L1.4518|
                  |L1.4470|
;;;2903       }
;;;2904       else
;;;2905       {
;;;2906         /* Disable the selected ETHERNET MMC interrupts */
;;;2907         ETH->MMCRIMR |= ETH_MMC_IT;    
001176  4a21              LDR      r2,|L1.4604|
001178  320c              ADDS     r2,r2,#0xc
00117a  6812              LDR      r2,[r2,#0]
00117c  4302              ORRS     r2,r2,r0
00117e  4b1e              LDR      r3,|L1.4600|
001180  f8c3210c          STR      r2,[r3,#0x10c]
001184  e00f              B        |L1.4518|
                  |L1.4486|
;;;2908       }
;;;2909     }
;;;2910     else
;;;2911     {
;;;2912       /* ETHERNET MMC Tx interrupts selected */
;;;2913       if (NewState != DISABLE)
001186  b139              CBZ      r1,|L1.4504|
;;;2914       {
;;;2915         /* Enable the selected ETHERNET MMC interrupts */
;;;2916         ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
001188  4a1c              LDR      r2,|L1.4604|
00118a  3210              ADDS     r2,r2,#0x10
00118c  6812              LDR      r2,[r2,#0]
00118e  4382              BICS     r2,r2,r0
001190  4b19              LDR      r3,|L1.4600|
001192  f8c32110          STR      r2,[r3,#0x110]
001196  e006              B        |L1.4518|
                  |L1.4504|
;;;2917       }
;;;2918       else
;;;2919       {
;;;2920         /* Disable the selected ETHERNET MMC interrupts */
;;;2921         ETH->MMCTIMR |= ETH_MMC_IT;    
001198  4a18              LDR      r2,|L1.4604|
00119a  3210              ADDS     r2,r2,#0x10
00119c  6812              LDR      r2,[r2,#0]
00119e  4302              ORRS     r2,r2,r0
0011a0  4b15              LDR      r3,|L1.4600|
0011a2  f8c32110          STR      r2,[r3,#0x110]
                  |L1.4518|
;;;2922       }  
;;;2923     }
;;;2924   }
0011a6  4770              BX       lr
;;;2925   
                          ENDP

                  ETH_GetMMCITStatus PROC
;;;2937     */
;;;2938   ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
0011a8  4601              MOV      r1,r0
;;;2939   {
;;;2940     ITStatus bitstatus = RESET;
0011aa  2000              MOVS     r0,#0
;;;2941     /* Check the parameters */
;;;2942     assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
;;;2943     
;;;2944     if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
0011ac  f0015280          AND      r2,r1,#0x10000000
0011b0  b16a              CBZ      r2,|L1.4558|
;;;2945     {
;;;2946       /* ETHERNET MMC Rx interrupts selected */
;;;2947       /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
;;;2948       if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
0011b2  4a12              LDR      r2,|L1.4604|
0011b4  1d12              ADDS     r2,r2,#4
0011b6  6812              LDR      r2,[r2,#0]
0011b8  400a              ANDS     r2,r2,r1
0011ba  b132              CBZ      r2,|L1.4554|
0011bc  4a0f              LDR      r2,|L1.4604|
0011be  320c              ADDS     r2,r2,#0xc
0011c0  6812              LDR      r2,[r2,#0]
0011c2  400a              ANDS     r2,r2,r1
0011c4  b90a              CBNZ     r2,|L1.4554|
;;;2949       {
;;;2950         bitstatus = SET;
0011c6  2001              MOVS     r0,#1
0011c8  e00e              B        |L1.4584|
                  |L1.4554|
;;;2951       }
;;;2952       else
;;;2953       {
;;;2954         bitstatus = RESET;
0011ca  2000              MOVS     r0,#0
0011cc  e00c              B        |L1.4584|
                  |L1.4558|
;;;2955       }
;;;2956     }
;;;2957     else
;;;2958     {
;;;2959       /* ETHERNET MMC Tx interrupts selected */
;;;2960       /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
;;;2961       if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
0011ce  4a0b              LDR      r2,|L1.4604|
0011d0  3208              ADDS     r2,r2,#8
0011d2  6812              LDR      r2,[r2,#0]
0011d4  400a              ANDS     r2,r2,r1
0011d6  b132              CBZ      r2,|L1.4582|
0011d8  4a08              LDR      r2,|L1.4604|
0011da  320c              ADDS     r2,r2,#0xc
0011dc  6812              LDR      r2,[r2,#0]
0011de  400a              ANDS     r2,r2,r1
0011e0  b90a              CBNZ     r2,|L1.4582|
;;;2962       {
;;;2963         bitstatus = SET;
0011e2  2001              MOVS     r0,#1
0011e4  e000              B        |L1.4584|
                  |L1.4582|
;;;2964       }
;;;2965       else
;;;2966       {
;;;2967         bitstatus = RESET;
0011e6  2000              MOVS     r0,#0
                  |L1.4584|
;;;2968       }  
;;;2969     }    
;;;2970       
;;;2971     return bitstatus;
;;;2972   }
0011e8  4770              BX       lr
;;;2973   
                          ENDP

                  ETH_GetMMCRegister PROC
;;;2990     */
;;;2991   uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
0011ea  4601              MOV      r1,r0
;;;2992   {
;;;2993     /* Check the parameters */
;;;2994     assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
;;;2995     
;;;2996     /* Return the selected register value */
;;;2997     return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
0011ec  4802              LDR      r0,|L1.4600|
0011ee  5808              LDR      r0,[r1,r0]
;;;2998   }
0011f0  4770              BX       lr
0011f2  0000              DCW      0x0000
                  |L1.4596|
                          DCD      0x40029000
                  |L1.4600|
                          DCD      0x40028000
                  |L1.4604|
                          DCD      0x40028100
                          ENDP

                  ETH_EnablePTPTimeStampAddend PROC
;;;3006     */
;;;3007   void ETH_EnablePTPTimeStampAddend(void)
001200  4830              LDR      r0,|L1.4804|
;;;3008   {
;;;3009     /* Enable the PTP block update with the Time Stamp Addend register value */
;;;3010     ETH->PTPTSCR |= ETH_PTPTSCR_TSARU;    
001202  6800              LDR      r0,[r0,#0]
001204  f0400020          ORR      r0,r0,#0x20
001208  492e              LDR      r1,|L1.4804|
00120a  6008              STR      r0,[r1,#0]
;;;3011   }
00120c  4770              BX       lr
;;;3012   
                          ENDP

                  ETH_EnablePTPTimeStampInterruptTrigger PROC
;;;3017     */
;;;3018   void ETH_EnablePTPTimeStampInterruptTrigger(void)
00120e  482d              LDR      r0,|L1.4804|
;;;3019   {
;;;3020     /* Enable the PTP target time interrupt */
;;;3021     ETH->PTPTSCR |= ETH_PTPTSCR_TSITE;    
001210  6800              LDR      r0,[r0,#0]
001212  f0400010          ORR      r0,r0,#0x10
001216  492b              LDR      r1,|L1.4804|
001218  6008              STR      r0,[r1,#0]
;;;3022   }
00121a  4770              BX       lr
;;;3023   
                          ENDP

                  ETH_EnablePTPTimeStampUpdate PROC
;;;3028     */
;;;3029   void ETH_EnablePTPTimeStampUpdate(void)
00121c  4829              LDR      r0,|L1.4804|
;;;3030   {
;;;3031     /* Enable the PTP system time update with the Time Stamp Update register value */
;;;3032     ETH->PTPTSCR |= ETH_PTPTSCR_TSSTU;    
00121e  6800              LDR      r0,[r0,#0]
001220  f0400008          ORR      r0,r0,#8
001224  4927              LDR      r1,|L1.4804|
001226  6008              STR      r0,[r1,#0]
;;;3033   }
001228  4770              BX       lr
;;;3034   
                          ENDP

                  ETH_InitializePTPTimeStamp PROC
;;;3039     */
;;;3040   void ETH_InitializePTPTimeStamp(void)
00122a  4826              LDR      r0,|L1.4804|
;;;3041   {
;;;3042     /* Initialize the PTP Time Stamp */
;;;3043     ETH->PTPTSCR |= ETH_PTPTSCR_TSSTI;    
00122c  6800              LDR      r0,[r0,#0]
00122e  f0400004          ORR      r0,r0,#4
001232  4924              LDR      r1,|L1.4804|
001234  6008              STR      r0,[r1,#0]
;;;3044   }
001236  4770              BX       lr
;;;3045   
                          ENDP

                  ETH_PTPUpdateMethodConfig PROC
;;;3053     */
;;;3054   void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod)
001238  b130              CBZ      r0,|L1.4680|
;;;3055   {
;;;3056     /* Check the parameters */
;;;3057     assert_param(IS_ETH_PTP_UPDATE(UpdateMethod));
;;;3058     
;;;3059     if (UpdateMethod != ETH_PTP_CoarseUpdate)
;;;3060     {
;;;3061       /* Enable the PTP Fine Update method */
;;;3062       ETH->PTPTSCR |= ETH_PTPTSCR_TSFCU;
00123a  4922              LDR      r1,|L1.4804|
00123c  6809              LDR      r1,[r1,#0]
00123e  f0410102          ORR      r1,r1,#2
001242  4a20              LDR      r2,|L1.4804|
001244  6011              STR      r1,[r2,#0]
001246  e005              B        |L1.4692|
                  |L1.4680|
;;;3063     }
;;;3064     else
;;;3065     {
;;;3066       /* Disable the PTP Coarse Update method */
;;;3067       ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSFCU);
001248  491e              LDR      r1,|L1.4804|
00124a  6809              LDR      r1,[r1,#0]
00124c  f0210102          BIC      r1,r1,#2
001250  4a1c              LDR      r2,|L1.4804|
001252  6011              STR      r1,[r2,#0]
                  |L1.4692|
;;;3068     } 
;;;3069   }
001254  4770              BX       lr
;;;3070   
                          ENDP

                  ETH_PTPTimeStampCmd PROC
;;;3076     */
;;;3077   void ETH_PTPTimeStampCmd(FunctionalState NewState)
001256  b138              CBZ      r0,|L1.4712|
;;;3078   {
;;;3079     /* Check the parameters */
;;;3080     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3081     
;;;3082     if (NewState != DISABLE)
;;;3083     {
;;;3084       /* Enable the PTP time stamp for transmit and receive frames */
;;;3085       ETH->PTPTSCR |= ETH_PTPTSCR_TSE | ETH_PTPTSSR_TSSIPV4FE | ETH_PTPTSSR_TSSIPV6FE | ETH_PTPTSSR_TSSARFE;
001258  491a              LDR      r1,|L1.4804|
00125a  6809              LDR      r1,[r1,#0]
00125c  f2431201          MOV      r2,#0x3101
001260  4311              ORRS     r1,r1,r2
001262  4a18              LDR      r2,|L1.4804|
001264  6011              STR      r1,[r2,#0]
001266  e005              B        |L1.4724|
                  |L1.4712|
;;;3086     }
;;;3087     else
;;;3088     {
;;;3089       /* Disable the PTP time stamp for transmit and receive frames */
;;;3090       ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSE);
001268  4916              LDR      r1,|L1.4804|
00126a  6809              LDR      r1,[r1,#0]
00126c  f0210101          BIC      r1,r1,#1
001270  4a14              LDR      r2,|L1.4804|
001272  6011              STR      r1,[r2,#0]
                  |L1.4724|
;;;3091     }
;;;3092   }
001274  4770              BX       lr
;;;3093   
                          ENDP

                  ETH_GetPTPFlagStatus PROC
;;;3103     */
;;;3104   FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG)
001276  4601              MOV      r1,r0
;;;3105   {
;;;3106     FlagStatus bitstatus = RESET;
001278  2000              MOVS     r0,#0
;;;3107     /* Check the parameters */
;;;3108     assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG));
;;;3109     
;;;3110     if ((ETH->PTPTSCR & ETH_PTP_FLAG) != (uint32_t)RESET)
00127a  4a12              LDR      r2,|L1.4804|
00127c  6812              LDR      r2,[r2,#0]
00127e  400a              ANDS     r2,r2,r1
001280  b10a              CBZ      r2,|L1.4742|
;;;3111     {
;;;3112       bitstatus = SET;
001282  2001              MOVS     r0,#1
001284  e000              B        |L1.4744|
                  |L1.4742|
;;;3113     }
;;;3114     else
;;;3115     {
;;;3116       bitstatus = RESET;
001286  2000              MOVS     r0,#0
                  |L1.4744|
;;;3117     }
;;;3118     return bitstatus;
;;;3119   }
001288  4770              BX       lr
;;;3120   
                          ENDP

                  ETH_SetPTPSubSecondIncrement PROC
;;;3125     */
;;;3126   void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue)
00128a  490e              LDR      r1,|L1.4804|
;;;3127   {
;;;3128     /* Check the parameters */
;;;3129     assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue));
;;;3130     /* Set the PTP Sub-Second Increment Register */
;;;3131     ETH->PTPSSIR = SubSecondValue;    
00128c  1d09              ADDS     r1,r1,#4
00128e  6008              STR      r0,[r1,#0]
;;;3132   }
001290  4770              BX       lr
;;;3133   
                          ENDP

                  ETH_SetPTPTimeStampUpdate PROC
;;;3144     */
;;;3145   void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue)
001292  b510              PUSH     {r4,lr}
;;;3146   {
;;;3147     /* Check the parameters */
;;;3148     assert_param(IS_ETH_PTP_TIME_SIGN(Sign));  
;;;3149     assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); 
;;;3150     /* Set the PTP Time Update High Register */
;;;3151     ETH->PTPTSHUR = SecondValue;
001294  4b0b              LDR      r3,|L1.4804|
001296  3310              ADDS     r3,r3,#0x10
001298  6019              STR      r1,[r3,#0]
;;;3152     
;;;3153     /* Set the PTP Time Update Low Register with sign */
;;;3154     ETH->PTPTSLUR = Sign | SubSecondValue;   
00129a  ea400302          ORR      r3,r0,r2
00129e  4c09              LDR      r4,|L1.4804|
0012a0  3414              ADDS     r4,r4,#0x14
0012a2  6023              STR      r3,[r4,#0]
;;;3155   }
0012a4  bd10              POP      {r4,pc}
;;;3156   
                          ENDP

                  ETH_SetPTPTimeStampAddend PROC
;;;3161     */
;;;3162   void ETH_SetPTPTimeStampAddend(uint32_t Value)
0012a6  4907              LDR      r1,|L1.4804|
;;;3163   {
;;;3164     /* Set the PTP Time Stamp Addend Register */
;;;3165     ETH->PTPTSAR = Value;    
0012a8  3118              ADDS     r1,r1,#0x18
0012aa  6008              STR      r0,[r1,#0]
;;;3166   }
0012ac  4770              BX       lr
;;;3167   
                          ENDP

                  ETH_SetPTPTargetTime PROC
;;;3173     */
;;;3174   void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue)
0012ae  4a05              LDR      r2,|L1.4804|
;;;3175   {
;;;3176     /* Set the PTP Target Time High Register */
;;;3177     ETH->PTPTTHR = HighValue;
0012b0  321c              ADDS     r2,r2,#0x1c
0012b2  6010              STR      r0,[r2,#0]
;;;3178     /* Set the PTP Target Time Low Register */
;;;3179     ETH->PTPTTLR = LowValue;    
0012b4  1d12              ADDS     r2,r2,#4
0012b6  6011              STR      r1,[r2,#0]
;;;3180   }
0012b8  4770              BX       lr
;;;3181   
                          ENDP

                  ETH_GetPTPRegister PROC
;;;3196     */
;;;3197   uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg)
0012ba  4601              MOV      r1,r0
;;;3198   {
;;;3199     /* Check the parameters */
;;;3200     assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg));
;;;3201     
;;;3202     /* Return the selected register value */
;;;3203     return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg));
0012bc  4802              LDR      r0,|L1.4808|
0012be  5808              LDR      r0,[r1,r0]
;;;3204   }
0012c0  4770              BX       lr
;;;3205   
                          ENDP

0012c2  0000              DCW      0x0000
                  |L1.4804|
                          DCD      0x40028700
                  |L1.4808|
                          DCD      0x40028000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMARxDscrTab
                          %        160
                  DMATxDscrTab
                          %        160
                  Rx_Buff
                          %        7620
                  Tx_Buff
                          %        7620
                  RX_Frame_Descriptor
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  DMATxDescToSet
                          DCD      0x00000000
                  DMARxDescToGet
                          DCD      0x00000000
                  DMA_RX_FRAME_infos
                          DCD      0x00000000
                  Frame_Rx_index
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\libraries\\STM32F4x7_ETH_Driver\\src\\stm32f4x7_eth.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4x7_eth_c_195bd0ff____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4x7_eth_c_195bd0ff____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4x7_eth_c_195bd0ff____REVSH|
#line 128
|__asm___15_stm32f4x7_eth_c_195bd0ff____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
