; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\sockets.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\sockets.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\sockets.crf ..\..\libraries\lwip-1.4.1\src\api\sockets.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  lwip_socket_init PROC
;;;183    void
;;;184    lwip_socket_init(void)
000000  4770              BX       lr
;;;185    {
;;;186    }
;;;187    
                          ENDP

                  get_socket PROC
;;;194    static struct lwip_sock *
;;;195    get_socket(int s)
000002  4601              MOV      r1,r0
;;;196    {
;;;197      struct lwip_sock *sock;
;;;198    
;;;199      if ((s < 0) || (s >= NUM_SOCKETS)) {
000004  2900              CMP      r1,#0
000006  db01              BLT      |L1.12|
000008  2914              CMP      r1,#0x14
00000a  db03              BLT      |L1.20|
                  |L1.12|
;;;200        LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;201        set_errno(EBADF);
;;;202        return NULL;
000010  2000              MOVS     r0,#0
                  |L1.18|
;;;203      }
;;;204    
;;;205      sock = &sockets[s];
;;;206    
;;;207      if (!sock->conn) {
;;;208        LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
;;;209        set_errno(EBADF);
;;;210        return NULL;
;;;211      }
;;;212    
;;;213      return sock;
;;;214    }
000012  4770              BX       lr
                  |L1.20|
000014  eb010041          ADD      r0,r1,r1,LSL #1       ;205
000018  4bfb              LDR      r3,|L1.1032|
00001a  eb0302c0          ADD      r2,r3,r0,LSL #3       ;205
00001e  6810              LDR      r0,[r2,#0]            ;207
000020  b918              CBNZ     r0,|L1.42|
000022  bf00              NOP                            ;208
000024  bf00              NOP                            ;208
000026  2000              MOVS     r0,#0                 ;210
000028  e7f3              B        |L1.18|
                  |L1.42|
00002a  4610              MOV      r0,r2                 ;213
00002c  e7f1              B        |L1.18|
;;;215    
                          ENDP

                  tryget_socket PROC
;;;222    static struct lwip_sock *
;;;223    tryget_socket(int s)
00002e  4601              MOV      r1,r0
;;;224    {
;;;225      if ((s < 0) || (s >= NUM_SOCKETS)) {
000030  2900              CMP      r1,#0
000032  db01              BLT      |L1.56|
000034  2914              CMP      r1,#0x14
000036  db01              BLT      |L1.60|
                  |L1.56|
;;;226        return NULL;
000038  2000              MOVS     r0,#0
                  |L1.58|
;;;227      }
;;;228      if (!sockets[s].conn) {
;;;229        return NULL;
;;;230      }
;;;231      return &sockets[s];
;;;232    }
00003a  4770              BX       lr
                  |L1.60|
00003c  eb010041          ADD      r0,r1,r1,LSL #1       ;228
000040  4af1              LDR      r2,|L1.1032|
000042  f8520030          LDR      r0,[r2,r0,LSL #3]     ;228
000046  b908              CBNZ     r0,|L1.76|
000048  2000              MOVS     r0,#0                 ;229
00004a  e7f6              B        |L1.58|
                  |L1.76|
00004c  eb010041          ADD      r0,r1,r1,LSL #1       ;231
000050  4aed              LDR      r2,|L1.1032|
000052  eb0200c0          ADD      r0,r2,r0,LSL #3       ;231
000056  e7f0              B        |L1.58|
;;;233    
                          ENDP

                  alloc_socket PROC
;;;242    static int
;;;243    alloc_socket(struct netconn *newconn, int accepted)
000058  e92d41f0          PUSH     {r4-r8,lr}
;;;244    {
00005c  4605              MOV      r5,r0
00005e  460e              MOV      r6,r1
;;;245      int i;
;;;246      SYS_ARCH_DECL_PROTECT(lev);
;;;247    
;;;248      /* allocate a new socket identifier */
;;;249      for (i = 0; i < NUM_SOCKETS; ++i) {
000060  2400              MOVS     r4,#0
000062  e047              B        |L1.244|
                  |L1.100|
;;;250        /* Protect socket array */
;;;251        SYS_ARCH_PROTECT(lev);
000064  f7fffffe          BL       sys_arch_protect
000068  4607              MOV      r7,r0
;;;252        if (!sockets[i].conn) {
00006a  eb040044          ADD      r0,r4,r4,LSL #1
00006e  49e6              LDR      r1,|L1.1032|
000070  f8510030          LDR      r0,[r1,r0,LSL #3]
000074  bbc8              CBNZ     r0,|L1.234|
;;;253          sockets[i].conn       = newconn;
000076  eb040044          ADD      r0,r4,r4,LSL #1
00007a  f8415030          STR      r5,[r1,r0,LSL #3]
;;;254          /* The socket is not yet known to anyone, so no need to protect
;;;255             after having marked it as used. */
;;;256          SYS_ARCH_UNPROTECT(lev);
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       sys_arch_unprotect
;;;257          sockets[i].lastdata   = NULL;
000084  2000              MOVS     r0,#0
000086  eb040144          ADD      r1,r4,r4,LSL #1
00008a  4adf              LDR      r2,|L1.1032|
00008c  eb0201c1          ADD      r1,r2,r1,LSL #3
000090  6048              STR      r0,[r1,#4]
;;;258          sockets[i].lastoffset = 0;
000092  eb040144          ADD      r1,r4,r4,LSL #1
000096  eb0201c1          ADD      r1,r2,r1,LSL #3
00009a  8108              STRH     r0,[r1,#8]
;;;259          sockets[i].rcvevent   = 0;
00009c  eb040144          ADD      r1,r4,r4,LSL #1
0000a0  eb0201c1          ADD      r1,r2,r1,LSL #3
0000a4  8148              STRH     r0,[r1,#0xa]
;;;260          /* TCP sendbuf is empty, but the socket is not yet writable until connected
;;;261           * (unless it has been created by accept()). */
;;;262          sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
0000a6  7828              LDRB     r0,[r5,#0]
0000a8  2810              CMP      r0,#0x10
0000aa  d104              BNE      |L1.182|
0000ac  b10e              CBZ      r6,|L1.178|
0000ae  2001              MOVS     r0,#1
0000b0  e002              B        |L1.184|
                  |L1.178|
0000b2  2000              MOVS     r0,#0
0000b4  e000              B        |L1.184|
                  |L1.182|
0000b6  2001              MOVS     r0,#1
                  |L1.184|
0000b8  eb040144          ADD      r1,r4,r4,LSL #1
0000bc  4ad2              LDR      r2,|L1.1032|
0000be  eb0201c1          ADD      r1,r2,r1,LSL #3
0000c2  8188              STRH     r0,[r1,#0xc]
;;;263          sockets[i].errevent   = 0;
0000c4  2000              MOVS     r0,#0
0000c6  eb040144          ADD      r1,r4,r4,LSL #1
0000ca  eb0201c1          ADD      r1,r2,r1,LSL #3
0000ce  81c8              STRH     r0,[r1,#0xe]
;;;264          sockets[i].err        = 0;
0000d0  eb040144          ADD      r1,r4,r4,LSL #1
0000d4  eb0201c1          ADD      r1,r2,r1,LSL #3
0000d8  6108              STR      r0,[r1,#0x10]
;;;265          sockets[i].select_waiting = 0;
0000da  eb040144          ADD      r1,r4,r4,LSL #1
0000de  eb0201c1          ADD      r1,r2,r1,LSL #3
0000e2  6148              STR      r0,[r1,#0x14]
;;;266          return i;
0000e4  4620              MOV      r0,r4
                  |L1.230|
;;;267        }
;;;268        SYS_ARCH_UNPROTECT(lev);
;;;269      }
;;;270      return -1;
;;;271    }
0000e6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.234|
0000ea  e7ff              B        |L1.236|
                  |L1.236|
0000ec  4638              MOV      r0,r7                 ;268
0000ee  f7fffffe          BL       sys_arch_unprotect
0000f2  1c64              ADDS     r4,r4,#1              ;249
                  |L1.244|
0000f4  2c14              CMP      r4,#0x14              ;249
0000f6  dbb5              BLT      |L1.100|
0000f8  f04f30ff          MOV      r0,#0xffffffff        ;270
0000fc  e7f3              B        |L1.230|
;;;272    
                          ENDP

                  free_socket PROC
;;;279    static void
;;;280    free_socket(struct lwip_sock *sock, int is_tcp)
0000fe  e92d41f0          PUSH     {r4-r8,lr}
;;;281    {
000102  4604              MOV      r4,r0
000104  460d              MOV      r5,r1
;;;282      void *lastdata;
;;;283      SYS_ARCH_DECL_PROTECT(lev);
;;;284    
;;;285      lastdata         = sock->lastdata;
000106  6866              LDR      r6,[r4,#4]
;;;286      sock->lastdata   = NULL;
000108  2000              MOVS     r0,#0
00010a  6060              STR      r0,[r4,#4]
;;;287      sock->lastoffset = 0;
00010c  8120              STRH     r0,[r4,#8]
;;;288      sock->err        = 0;
00010e  6120              STR      r0,[r4,#0x10]
;;;289    
;;;290      /* Protect socket array */
;;;291      SYS_ARCH_PROTECT(lev);
000110  f7fffffe          BL       sys_arch_protect
000114  4607              MOV      r7,r0
;;;292      sock->conn       = NULL;
000116  2000              MOVS     r0,#0
000118  6020              STR      r0,[r4,#0]
;;;293      SYS_ARCH_UNPROTECT(lev);
00011a  4638              MOV      r0,r7
00011c  f7fffffe          BL       sys_arch_unprotect
;;;294      /* don't use 'sock' after this line, as another task might have allocated it */
;;;295    
;;;296      if (lastdata != NULL) {
000120  b13e              CBZ      r6,|L1.306|
;;;297        if (is_tcp) {
000122  b11d              CBZ      r5,|L1.300|
;;;298          pbuf_free((struct pbuf *)lastdata);
000124  4630              MOV      r0,r6
000126  f7fffffe          BL       pbuf_free
00012a  e002              B        |L1.306|
                  |L1.300|
;;;299        } else {
;;;300          netbuf_delete((struct netbuf *)lastdata);
00012c  4630              MOV      r0,r6
00012e  f7fffffe          BL       netbuf_delete
                  |L1.306|
;;;301        }
;;;302      }
;;;303    }
000132  e8bd81f0          POP      {r4-r8,pc}
;;;304    
                          ENDP

                  lwip_accept PROC
;;;311    int
;;;312    lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
000136  e92d4ff0          PUSH     {r4-r11,lr}
;;;313    {
00013a  b087              SUB      sp,sp,#0x1c
00013c  4682              MOV      r10,r0
00013e  4688              MOV      r8,r1
000140  4617              MOV      r7,r2
;;;314      struct lwip_sock *sock, *nsock;
;;;315      struct netconn *newconn;
;;;316      ip_addr_t naddr;
;;;317      u16_t port;
;;;318      int newsock;
;;;319      struct sockaddr_in sin;
;;;320      err_t err;
;;;321      SYS_ARCH_DECL_PROTECT(lev);
;;;322    
;;;323      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
000142  bf00              NOP      
000144  bf00              NOP      
;;;324      sock = get_socket(s);
000146  4650              MOV      r0,r10
000148  f7fffffe          BL       get_socket
00014c  4604              MOV      r4,r0
;;;325      if (!sock) {
00014e  b924              CBNZ     r4,|L1.346|
;;;326        return -1;
000150  f04f30ff          MOV      r0,#0xffffffff
                  |L1.340|
;;;327      }
;;;328    
;;;329      if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
;;;330        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
;;;331        sock_set_errno(sock, EWOULDBLOCK);
;;;332        return -1;
;;;333      }
;;;334    
;;;335      /* wait for a new connection */
;;;336      err = netconn_accept(sock->conn, &newconn);
;;;337      if (err != ERR_OK) {
;;;338        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
;;;339        if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;340          sock_set_errno(sock, EOPNOTSUPP);
;;;341          return EOPNOTSUPP;
;;;342        }
;;;343        sock_set_errno(sock, err_to_errno(err));
;;;344        return -1;
;;;345      }
;;;346      LWIP_ASSERT("newconn != NULL", newconn != NULL);
;;;347      /* Prevent automatic window updates, we do this on our own! */
;;;348      netconn_set_noautorecved(newconn, 1);
;;;349    
;;;350      /* get the IP address and port of the remote host */
;;;351      err = netconn_peer(newconn, &naddr, &port);
;;;352      if (err != ERR_OK) {
;;;353        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
;;;354        netconn_delete(newconn);
;;;355        sock_set_errno(sock, err_to_errno(err));
;;;356        return -1;
;;;357      }
;;;358    
;;;359      /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
;;;360       * not be NULL if addr is valid.
;;;361       */
;;;362      if (NULL != addr) {
;;;363        LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
;;;364        memset(&sin, 0, sizeof(sin));
;;;365        sin.sin_len = sizeof(sin);
;;;366        sin.sin_family = AF_INET;
;;;367        sin.sin_port = htons(port);
;;;368        inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
;;;369    
;;;370        if (*addrlen > sizeof(sin))
;;;371          *addrlen = sizeof(sin);
;;;372    
;;;373        MEMCPY(addr, &sin, *addrlen);
;;;374      }
;;;375    
;;;376      newsock = alloc_socket(newconn, 1);
;;;377      if (newsock == -1) {
;;;378        netconn_delete(newconn);
;;;379        sock_set_errno(sock, ENFILE);
;;;380        return -1;
;;;381      }
;;;382      LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
;;;383      LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
;;;384      nsock = &sockets[newsock];
;;;385    
;;;386      /* See event_callback: If data comes in right away after an accept, even
;;;387       * though the server task might not have created a new socket yet.
;;;388       * In that case, newconn->socket is counted down (newconn->socket--),
;;;389       * so nsock->rcvevent is >= 1 here!
;;;390       */
;;;391      SYS_ARCH_PROTECT(lev);
;;;392      nsock->rcvevent += (s16_t)(-1 - newconn->socket);
;;;393      newconn->socket = newsock;
;;;394      SYS_ARCH_UNPROTECT(lev);
;;;395    
;;;396      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
;;;397      ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
;;;398      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));
;;;399    
;;;400      sock_set_errno(sock, 0);
;;;401      return newsock;
;;;402    }
000154  b007              ADD      sp,sp,#0x1c
000156  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.346|
00015a  6820              LDR      r0,[r4,#0]            ;329
00015c  f89000d8          LDRB     r0,[r0,#0xd8]         ;329
000160  f0000002          AND      r0,r0,#2              ;329
000164  b160              CBZ      r0,|L1.384|
000166  f9b4000a          LDRSH    r0,[r4,#0xa]          ;329
00016a  2800              CMP      r0,#0                 ;329
00016c  dc08              BGT      |L1.384|
00016e  bf00              NOP                            ;330
000170  bf00              NOP                            ;330
000172  bf00              NOP                            ;331
000174  200b              MOVS     r0,#0xb               ;331
000176  6120              STR      r0,[r4,#0x10]         ;331
000178  bf00              NOP                            ;331
00017a  f04f30ff          MOV      r0,#0xffffffff        ;332
00017e  e7e9              B        |L1.340|
                  |L1.384|
000180  a906              ADD      r1,sp,#0x18           ;336
000182  6820              LDR      r0,[r4,#0]            ;336
000184  f7fffffe          BL       netconn_accept
000188  4605              MOV      r5,r0                 ;336
00018a  b1cd              CBZ      r5,|L1.448|
00018c  bf00              NOP                            ;338
00018e  bf00              NOP                            ;338
000190  6820              LDR      r0,[r4,#0]            ;339
000192  7800              LDRB     r0,[r0,#0]            ;339
000194  2810              CMP      r0,#0x10              ;339
000196  d004              BEQ      |L1.418|
000198  bf00              NOP                            ;340
00019a  205f              MOVS     r0,#0x5f              ;340
00019c  6120              STR      r0,[r4,#0x10]         ;340
00019e  bf00              NOP                            ;340
0001a0  e7d8              B        |L1.340|
                  |L1.418|
0001a2  bf00              NOP                            ;343
0001a4  4268              RSBS     r0,r5,#0              ;343
0001a6  2810              CMP      r0,#0x10              ;343
0001a8  d204              BCS      |L1.436|
0001aa  4898              LDR      r0,|L1.1036|
0001ac  4269              RSBS     r1,r5,#0              ;343
0001ae  f8500021          LDR      r0,[r0,r1,LSL #2]     ;343
0001b2  e000              B        |L1.438|
                  |L1.436|
0001b4  2005              MOVS     r0,#5                 ;343
                  |L1.438|
0001b6  6120              STR      r0,[r4,#0x10]         ;343
0001b8  bf00              NOP                            ;343
0001ba  f04f30ff          MOV      r0,#0xffffffff        ;344
0001be  e7c9              B        |L1.340|
                  |L1.448|
0001c0  bf00              NOP                            ;346
0001c2  bf00              NOP                            ;346
0001c4  bf00              NOP                            ;348
0001c6  9806              LDR      r0,[sp,#0x18]         ;348
0001c8  f89000d8          LDRB     r0,[r0,#0xd8]         ;348
0001cc  f0400008          ORR      r0,r0,#8              ;348
0001d0  9906              LDR      r1,[sp,#0x18]         ;348
0001d2  f88100d8          STRB     r0,[r1,#0xd8]         ;348
0001d6  bf00              NOP                            ;348
0001d8  2300              MOVS     r3,#0                 ;351
0001da  aa04              ADD      r2,sp,#0x10           ;351
0001dc  a905              ADD      r1,sp,#0x14           ;351
0001de  9806              LDR      r0,[sp,#0x18]         ;351
0001e0  f7fffffe          BL       netconn_getaddr
0001e4  4605              MOV      r5,r0                 ;351
0001e6  b19d              CBZ      r5,|L1.528|
0001e8  bf00              NOP                            ;353
0001ea  bf00              NOP                            ;353
0001ec  9806              LDR      r0,[sp,#0x18]         ;354
0001ee  f7fffffe          BL       netconn_delete
0001f2  bf00              NOP                            ;355
0001f4  4268              RSBS     r0,r5,#0              ;355
0001f6  2810              CMP      r0,#0x10              ;355
0001f8  d204              BCS      |L1.516|
0001fa  4884              LDR      r0,|L1.1036|
0001fc  4269              RSBS     r1,r5,#0              ;355
0001fe  f8500021          LDR      r0,[r0,r1,LSL #2]     ;355
000202  e000              B        |L1.518|
                  |L1.516|
000204  2005              MOVS     r0,#5                 ;355
                  |L1.518|
000206  6120              STR      r0,[r4,#0x10]         ;355
000208  bf00              NOP                            ;355
00020a  f04f30ff          MOV      r0,#0xffffffff        ;356
00020e  e7a1              B        |L1.340|
                  |L1.528|
000210  f1b80f00          CMP      r8,#0                 ;362
000214  d01e              BEQ      |L1.596|
000216  bf00              NOP                            ;363
000218  bf00              NOP                            ;363
00021a  2000              MOVS     r0,#0                 ;364
00021c  9000              STR      r0,[sp,#0]            ;364
00021e  9001              STR      r0,[sp,#4]            ;364
000220  9002              STR      r0,[sp,#8]            ;364
000222  9003              STR      r0,[sp,#0xc]          ;364
000224  2010              MOVS     r0,#0x10              ;365
000226  f88d0000          STRB     r0,[sp,#0]            ;365
00022a  2002              MOVS     r0,#2                 ;366
00022c  f88d0001          STRB     r0,[sp,#1]            ;366
000230  f8bd0010          LDRH     r0,[sp,#0x10]         ;367
000234  f7fffffe          BL       lwip_htons
000238  f8ad0002          STRH     r0,[sp,#2]            ;367
00023c  9805              LDR      r0,[sp,#0x14]         ;368
00023e  9001              STR      r0,[sp,#4]            ;368
000240  6838              LDR      r0,[r7,#0]            ;370
000242  2810              CMP      r0,#0x10              ;370
000244  d901              BLS      |L1.586|
000246  2010              MOVS     r0,#0x10              ;371
000248  6038              STR      r0,[r7,#0]            ;371
                  |L1.586|
00024a  4669              MOV      r1,sp                 ;373
00024c  4640              MOV      r0,r8                 ;373
00024e  683a              LDR      r2,[r7,#0]            ;373
000250  f7fffffe          BL       __aeabi_memcpy
                  |L1.596|
000254  2101              MOVS     r1,#1                 ;376
000256  9806              LDR      r0,[sp,#0x18]         ;376
000258  f7fffffe          BL       alloc_socket
00025c  4606              MOV      r6,r0                 ;376
00025e  1c70              ADDS     r0,r6,#1              ;377
000260  b948              CBNZ     r0,|L1.630|
000262  9806              LDR      r0,[sp,#0x18]         ;378
000264  f7fffffe          BL       netconn_delete
000268  bf00              NOP                            ;379
00026a  2017              MOVS     r0,#0x17              ;379
00026c  6120              STR      r0,[r4,#0x10]         ;379
00026e  bf00              NOP                            ;379
000270  f04f30ff          MOV      r0,#0xffffffff        ;380
000274  e76e              B        |L1.340|
                  |L1.630|
000276  bf00              NOP                            ;382
000278  bf00              NOP                            ;382
00027a  bf00              NOP                            ;383
00027c  bf00              NOP                            ;383
00027e  eb060046          ADD      r0,r6,r6,LSL #1       ;384
000282  4961              LDR      r1,|L1.1032|
000284  eb0109c0          ADD      r9,r1,r0,LSL #3       ;384
000288  f7fffffe          BL       sys_arch_protect
00028c  4683              MOV      r11,r0                ;391
00028e  f8b9100a          LDRH     r1,[r9,#0xa]          ;392
000292  9806              LDR      r0,[sp,#0x18]         ;392
000294  f8d000d4          LDR      r0,[r0,#0xd4]         ;392
000298  f1c030ff          RSB      r0,r0,#0xffffffff     ;392
00029c  4408              ADD      r0,r0,r1              ;392
00029e  b200              SXTH     r0,r0                 ;392
0002a0  f8a9000a          STRH     r0,[r9,#0xa]          ;392
0002a4  9806              LDR      r0,[sp,#0x18]         ;393
0002a6  f8c060d4          STR      r6,[r0,#0xd4]         ;393
0002aa  4658              MOV      r0,r11                ;394
0002ac  f7fffffe          BL       sys_arch_unprotect
0002b0  bf00              NOP                            ;396
0002b2  bf00              NOP                            ;396
0002b4  bf00              NOP                            ;397
0002b6  bf00              NOP                            ;397
0002b8  bf00              NOP                            ;398
0002ba  bf00              NOP                            ;398
0002bc  bf00              NOP                            ;400
0002be  2000              MOVS     r0,#0                 ;400
0002c0  6120              STR      r0,[r4,#0x10]         ;400
0002c2  bf00              NOP                            ;400
0002c4  4630              MOV      r0,r6                 ;401
0002c6  e745              B        |L1.340|
;;;403    
                          ENDP

                  lwip_bind PROC
;;;404    int
;;;405    lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
0002c8  e92d4ff8          PUSH     {r3-r11,lr}
;;;406    {
0002cc  4682              MOV      r10,r0
0002ce  460c              MOV      r4,r1
0002d0  4690              MOV      r8,r2
;;;407      struct lwip_sock *sock;
;;;408      ip_addr_t local_addr;
;;;409      u16_t local_port;
;;;410      err_t err;
;;;411      const struct sockaddr_in *name_in;
;;;412    
;;;413      sock = get_socket(s);
0002d2  4650              MOV      r0,r10
0002d4  f7fffffe          BL       get_socket
0002d8  4605              MOV      r5,r0
;;;414      if (!sock) {
0002da  b91d              CBNZ     r5,|L1.740|
;;;415        return -1;
0002dc  f04f30ff          MOV      r0,#0xffffffff
                  |L1.736|
;;;416      }
;;;417    
;;;418      /* check size, familiy and alignment of 'name' */
;;;419      LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
;;;420                 ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
;;;421                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;422      name_in = (const struct sockaddr_in *)(void*)name;
;;;423    
;;;424      inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
;;;425      local_port = name_in->sin_port;
;;;426    
;;;427      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
;;;428      ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
;;;429      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));
;;;430    
;;;431      err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
;;;432    
;;;433      if (err != ERR_OK) {
;;;434        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
;;;435        sock_set_errno(sock, err_to_errno(err));
;;;436        return -1;
;;;437      }
;;;438    
;;;439      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
;;;440      sock_set_errno(sock, 0);
;;;441      return 0;
;;;442    }
0002e0  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.740|
0002e4  bf00              NOP                            ;419
0002e6  f1b80f10          CMP      r8,#0x10              ;419
0002ea  d105              BNE      |L1.760|
0002ec  7860              LDRB     r0,[r4,#1]            ;419
0002ee  2802              CMP      r0,#2                 ;419
0002f0  d102              BNE      |L1.760|
0002f2  f0040003          AND      r0,r4,#3              ;419
0002f6  b138              CBZ      r0,|L1.776|
                  |L1.760|
0002f8  bf00              NOP                            ;419
0002fa  4844              LDR      r0,|L1.1036|
0002fc  6b80              LDR      r0,[r0,#0x38]         ;419  ; err_to_errno_table
0002fe  6128              STR      r0,[r5,#0x10]         ;419
000300  bf00              NOP                            ;419
000302  f04f30ff          MOV      r0,#0xffffffff        ;419
000306  e7eb              B        |L1.736|
                  |L1.776|
000308  bf00              NOP                            ;419
00030a  4627              MOV      r7,r4                 ;422
00030c  463c              MOV      r4,r7                 ;424
00030e  6878              LDR      r0,[r7,#4]            ;424
000310  9000              STR      r0,[sp,#0]            ;424
000312  f8b79002          LDRH     r9,[r7,#2]            ;425
000316  bf00              NOP                            ;427
000318  bf00              NOP                            ;427
00031a  bf00              NOP                            ;428
00031c  bf00              NOP                            ;428
00031e  bf00              NOP                            ;429
000320  bf00              NOP                            ;429
000322  4648              MOV      r0,r9                 ;431
000324  f7fffffe          BL       lwip_ntohs
000328  4683              MOV      r11,r0                ;431
00032a  465a              MOV      r2,r11                ;431
00032c  4669              MOV      r1,sp                 ;431
00032e  6828              LDR      r0,[r5,#0]            ;431
000330  f7fffffe          BL       netconn_bind
000334  4606              MOV      r6,r0                 ;431
000336  b186              CBZ      r6,|L1.858|
000338  bf00              NOP                            ;434
00033a  bf00              NOP                            ;434
00033c  bf00              NOP                            ;435
00033e  4270              RSBS     r0,r6,#0              ;435
000340  2810              CMP      r0,#0x10              ;435
000342  d204              BCS      |L1.846|
000344  4831              LDR      r0,|L1.1036|
000346  4271              RSBS     r1,r6,#0              ;435
000348  f8500021          LDR      r0,[r0,r1,LSL #2]     ;435
00034c  e000              B        |L1.848|
                  |L1.846|
00034e  2005              MOVS     r0,#5                 ;435
                  |L1.848|
000350  6128              STR      r0,[r5,#0x10]         ;435
000352  bf00              NOP                            ;435
000354  f04f30ff          MOV      r0,#0xffffffff        ;436
000358  e7c2              B        |L1.736|
                  |L1.858|
00035a  bf00              NOP                            ;439
00035c  bf00              NOP                            ;439
00035e  bf00              NOP                            ;440
000360  2000              MOVS     r0,#0                 ;440
000362  6128              STR      r0,[r5,#0x10]         ;440
000364  bf00              NOP                            ;440
000366  bf00              NOP                            ;441
000368  e7ba              B        |L1.736|
;;;443    
                          ENDP

                  lwip_close PROC
;;;444    int
;;;445    lwip_close(int s)
00036a  b570              PUSH     {r4-r6,lr}
;;;446    {
00036c  4605              MOV      r5,r0
;;;447      struct lwip_sock *sock;
;;;448      int is_tcp = 0;
00036e  2600              MOVS     r6,#0
;;;449    
;;;450      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
000370  bf00              NOP      
000372  bf00              NOP      
;;;451    
;;;452      sock = get_socket(s);
000374  4628              MOV      r0,r5
000376  f7fffffe          BL       get_socket
00037a  4604              MOV      r4,r0
;;;453      if (!sock) {
00037c  b90c              CBNZ     r4,|L1.898|
;;;454        return -1;
00037e  1e70              SUBS     r0,r6,#1
                  |L1.896|
;;;455      }
;;;456    
;;;457      if(sock->conn != NULL) {
;;;458        is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
;;;459      } else {
;;;460        LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
;;;461      }
;;;462    
;;;463      netconn_delete(sock->conn);
;;;464    
;;;465      free_socket(sock, is_tcp);
;;;466      set_errno(0);
;;;467      return 0;
;;;468    }
000380  bd70              POP      {r4-r6,pc}
                  |L1.898|
000382  6820              LDR      r0,[r4,#0]            ;457
000384  b140              CBZ      r0,|L1.920|
000386  6820              LDR      r0,[r4,#0]            ;458
000388  7800              LDRB     r0,[r0,#0]            ;458
00038a  2810              CMP      r0,#0x10              ;458
00038c  d101              BNE      |L1.914|
00038e  2001              MOVS     r0,#1                 ;458
000390  e000              B        |L1.916|
                  |L1.914|
000392  2000              MOVS     r0,#0                 ;458
                  |L1.916|
000394  4606              MOV      r6,r0                 ;458
000396  e001              B        |L1.924|
                  |L1.920|
000398  bf00              NOP                            ;460
00039a  bf00              NOP                            ;460
                  |L1.924|
00039c  6820              LDR      r0,[r4,#0]            ;463
00039e  f7fffffe          BL       netconn_delete
0003a2  4631              MOV      r1,r6                 ;465
0003a4  4620              MOV      r0,r4                 ;465
0003a6  f7fffffe          BL       free_socket
0003aa  2000              MOVS     r0,#0                 ;467
0003ac  e7e8              B        |L1.896|
;;;469    
                          ENDP

                  lwip_connect PROC
;;;470    int
;;;471    lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
0003ae  e92d4ff8          PUSH     {r3-r11,lr}
;;;472    {
0003b2  4681              MOV      r9,r0
0003b4  460e              MOV      r6,r1
0003b6  4690              MOV      r8,r2
;;;473      struct lwip_sock *sock;
;;;474      err_t err;
;;;475      const struct sockaddr_in *name_in;
;;;476    
;;;477      sock = get_socket(s);
0003b8  4648              MOV      r0,r9
0003ba  f7fffffe          BL       get_socket
0003be  4604              MOV      r4,r0
;;;478      if (!sock) {
0003c0  b91c              CBNZ     r4,|L1.970|
;;;479        return -1;
0003c2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.966|
;;;480      }
;;;481    
;;;482      /* check size, familiy and alignment of 'name' */
;;;483      LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
;;;484                 ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
;;;485                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;486      name_in = (const struct sockaddr_in *)(void*)name;
;;;487    
;;;488      if (name_in->sin_family == AF_UNSPEC) {
;;;489        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
;;;490        err = netconn_disconnect(sock->conn);
;;;491      } else {
;;;492        ip_addr_t remote_addr;
;;;493        u16_t remote_port;
;;;494    
;;;495        inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
;;;496        remote_port = name_in->sin_port;
;;;497    
;;;498        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
;;;499        ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
;;;500        LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));
;;;501    
;;;502        err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
;;;503      }
;;;504    
;;;505      if (err != ERR_OK) {
;;;506        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
;;;507        sock_set_errno(sock, err_to_errno(err));
;;;508        return -1;
;;;509      }
;;;510    
;;;511      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
;;;512      sock_set_errno(sock, 0);
;;;513      return 0;
;;;514    }
0003c6  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.970|
0003ca  bf00              NOP                            ;483
0003cc  f1b80f10          CMP      r8,#0x10              ;483
0003d0  d105              BNE      |L1.990|
0003d2  7870              LDRB     r0,[r6,#1]            ;483
0003d4  2802              CMP      r0,#2                 ;483
0003d6  d102              BNE      |L1.990|
0003d8  f0060003          AND      r0,r6,#3              ;483
0003dc  b138              CBZ      r0,|L1.1006|
                  |L1.990|
0003de  bf00              NOP                            ;483
0003e0  480a              LDR      r0,|L1.1036|
0003e2  6b80              LDR      r0,[r0,#0x38]         ;483  ; err_to_errno_table
0003e4  6120              STR      r0,[r4,#0x10]         ;483
0003e6  bf00              NOP                            ;483
0003e8  f04f30ff          MOV      r0,#0xffffffff        ;483
0003ec  e7eb              B        |L1.966|
                  |L1.1006|
0003ee  bf00              NOP                            ;483
0003f0  4637              MOV      r7,r6                 ;486
0003f2  463e              MOV      r6,r7                 ;488
0003f4  7878              LDRB     r0,[r7,#1]            ;488
0003f6  b958              CBNZ     r0,|L1.1040|
0003f8  bf00              NOP                            ;489
0003fa  bf00              NOP                            ;489
0003fc  6820              LDR      r0,[r4,#0]            ;490
0003fe  f7fffffe          BL       netconn_disconnect
000402  4605              MOV      r5,r0                 ;490
000404  e019              B        |L1.1082|
000406  0000              DCW      0x0000
                  |L1.1032|
                          DCD      sockets
                  |L1.1036|
                          DCD      err_to_errno_table
                  |L1.1040|
000410  6878              LDR      r0,[r7,#4]            ;495
000412  9000              STR      r0,[sp,#0]            ;495
000414  f8b7a002          LDRH     r10,[r7,#2]           ;496
000418  bf00              NOP                            ;498
00041a  bf00              NOP                            ;498
00041c  bf00              NOP                            ;499
00041e  bf00              NOP                            ;499
000420  bf00              NOP                            ;500
000422  bf00              NOP                            ;500
000424  4650              MOV      r0,r10                ;502
000426  f7fffffe          BL       lwip_ntohs
00042a  4683              MOV      r11,r0                ;502
00042c  465a              MOV      r2,r11                ;502
00042e  4669              MOV      r1,sp                 ;502
000430  6820              LDR      r0,[r4,#0]            ;502
000432  f7fffffe          BL       netconn_connect
000436  4605              MOV      r5,r0                 ;502
000438  bf00              NOP                            ;503
                  |L1.1082|
00043a  b185              CBZ      r5,|L1.1118|
00043c  bf00              NOP                            ;506
00043e  bf00              NOP                            ;506
000440  bf00              NOP                            ;507
000442  4268              RSBS     r0,r5,#0              ;507
000444  2810              CMP      r0,#0x10              ;507
000446  d204              BCS      |L1.1106|
000448  48fe              LDR      r0,|L1.2116|
00044a  4269              RSBS     r1,r5,#0              ;507
00044c  f8500021          LDR      r0,[r0,r1,LSL #2]     ;507
000450  e000              B        |L1.1108|
                  |L1.1106|
000452  2005              MOVS     r0,#5                 ;507
                  |L1.1108|
000454  6120              STR      r0,[r4,#0x10]         ;507
000456  bf00              NOP                            ;507
000458  f04f30ff          MOV      r0,#0xffffffff        ;508
00045c  e7b3              B        |L1.966|
                  |L1.1118|
00045e  bf00              NOP                            ;511
000460  bf00              NOP                            ;511
000462  bf00              NOP                            ;512
000464  2000              MOVS     r0,#0                 ;512
000466  6120              STR      r0,[r4,#0x10]         ;512
000468  bf00              NOP                            ;512
00046a  bf00              NOP                            ;513
00046c  e7ab              B        |L1.966|
;;;515    
                          ENDP

                  lwip_listen PROC
;;;524    int
;;;525    lwip_listen(int s, int backlog)
00046e  e92d41f0          PUSH     {r4-r8,lr}
;;;526    {
000472  4607              MOV      r7,r0
000474  460e              MOV      r6,r1
;;;527      struct lwip_sock *sock;
;;;528      err_t err;
;;;529    
;;;530      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
000476  bf00              NOP      
000478  bf00              NOP      
;;;531    
;;;532      sock = get_socket(s);
00047a  4638              MOV      r0,r7
00047c  f7fffffe          BL       get_socket
000480  4604              MOV      r4,r0
;;;533      if (!sock) {
000482  b91c              CBNZ     r4,|L1.1164|
;;;534        return -1;
000484  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1160|
;;;535      }
;;;536    
;;;537      /* limit the "backlog" parameter to fit in an u8_t */
;;;538      backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
;;;539    
;;;540      err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
;;;541    
;;;542      if (err != ERR_OK) {
;;;543        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
;;;544        if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;545          sock_set_errno(sock, EOPNOTSUPP);
;;;546          return EOPNOTSUPP;
;;;547        }
;;;548        sock_set_errno(sock, err_to_errno(err));
;;;549        return -1;
;;;550      }
;;;551    
;;;552      sock_set_errno(sock, 0);
;;;553      return 0;
;;;554    }
000488  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1164|
00048c  2e00              CMP      r6,#0                 ;538
00048e  dd01              BLE      |L1.1172|
000490  4630              MOV      r0,r6                 ;538
000492  e000              B        |L1.1174|
                  |L1.1172|
000494  2000              MOVS     r0,#0                 ;538
                  |L1.1174|
000496  28ff              CMP      r0,#0xff              ;538
000498  da05              BGE      |L1.1190|
00049a  2e00              CMP      r6,#0                 ;538
00049c  dd01              BLE      |L1.1186|
00049e  4630              MOV      r0,r6                 ;538
0004a0  e002              B        |L1.1192|
                  |L1.1186|
0004a2  2000              MOVS     r0,#0                 ;538
0004a4  e000              B        |L1.1192|
                  |L1.1190|
0004a6  20ff              MOVS     r0,#0xff              ;538
                  |L1.1192|
0004a8  4606              MOV      r6,r0                 ;538
0004aa  b2f1              UXTB     r1,r6                 ;540
0004ac  6820              LDR      r0,[r4,#0]            ;540
0004ae  f7fffffe          BL       netconn_listen_with_backlog
0004b2  4605              MOV      r5,r0                 ;540
0004b4  b1cd              CBZ      r5,|L1.1258|
0004b6  bf00              NOP                            ;543
0004b8  bf00              NOP                            ;543
0004ba  6820              LDR      r0,[r4,#0]            ;544
0004bc  7800              LDRB     r0,[r0,#0]            ;544
0004be  2810              CMP      r0,#0x10              ;544
0004c0  d004              BEQ      |L1.1228|
0004c2  bf00              NOP                            ;545
0004c4  205f              MOVS     r0,#0x5f              ;545
0004c6  6120              STR      r0,[r4,#0x10]         ;545
0004c8  bf00              NOP                            ;545
0004ca  e7dd              B        |L1.1160|
                  |L1.1228|
0004cc  bf00              NOP                            ;548
0004ce  4268              RSBS     r0,r5,#0              ;548
0004d0  2810              CMP      r0,#0x10              ;548
0004d2  d204              BCS      |L1.1246|
0004d4  48db              LDR      r0,|L1.2116|
0004d6  4269              RSBS     r1,r5,#0              ;548
0004d8  f8500021          LDR      r0,[r0,r1,LSL #2]     ;548
0004dc  e000              B        |L1.1248|
                  |L1.1246|
0004de  2005              MOVS     r0,#5                 ;548
                  |L1.1248|
0004e0  6120              STR      r0,[r4,#0x10]         ;548
0004e2  bf00              NOP                            ;548
0004e4  f04f30ff          MOV      r0,#0xffffffff        ;549
0004e8  e7ce              B        |L1.1160|
                  |L1.1258|
0004ea  bf00              NOP                            ;552
0004ec  2000              MOVS     r0,#0                 ;552
0004ee  6120              STR      r0,[r4,#0x10]         ;552
0004f0  bf00              NOP                            ;552
0004f2  bf00              NOP                            ;553
0004f4  e7c8              B        |L1.1160|
;;;555    
                          ENDP

                  lwip_recvfrom PROC
;;;556    int
;;;557    lwip_recvfrom(int s, void *mem, size_t len, int flags,
0004f6  e92d4fff          PUSH     {r0-r11,lr}
;;;558            struct sockaddr *from, socklen_t *fromlen)
;;;559    {
0004fa  b08b              SUB      sp,sp,#0x2c
0004fc  4616              MOV      r6,r2
0004fe  4698              MOV      r8,r3
000500  f8dd9064          LDR      r9,[sp,#0x64]
;;;560      struct lwip_sock *sock;
;;;561      void             *buf = NULL;
000504  2000              MOVS     r0,#0
000506  900a              STR      r0,[sp,#0x28]
;;;562      struct pbuf      *p;
;;;563      u16_t            buflen, copylen;
;;;564      int              off = 0;
000508  2500              MOVS     r5,#0
;;;565      ip_addr_t        *addr;
;;;566      u16_t            port;
;;;567      u8_t             done = 0;
00050a  9006              STR      r0,[sp,#0x18]
;;;568      err_t            err;
;;;569    
;;;570      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
00050c  bf00              NOP      
00050e  bf00              NOP      
;;;571      sock = get_socket(s);
000510  980b              LDR      r0,[sp,#0x2c]
000512  f7fffffe          BL       get_socket
000516  4604              MOV      r4,r0
;;;572      if (!sock) {
000518  b91c              CBNZ     r4,|L1.1314|
;;;573        return -1;
00051a  1e68              SUBS     r0,r5,#1
                  |L1.1308|
;;;574      }
;;;575    
;;;576      do {
;;;577        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
;;;578        /* Check if there is data left from the last recv operation. */
;;;579        if (sock->lastdata) {
;;;580          buf = sock->lastdata;
;;;581        } else {
;;;582          /* If this is non-blocking call, then check first */
;;;583          if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
;;;584              (sock->rcvevent <= 0)) {
;;;585            if (off > 0) {
;;;586              /* update receive window */
;;;587              netconn_recved(sock->conn, (u32_t)off);
;;;588              /* already received data, return that */
;;;589              sock_set_errno(sock, 0);
;;;590              return off;
;;;591            }
;;;592            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
;;;593            sock_set_errno(sock, EWOULDBLOCK);
;;;594            return -1;
;;;595          }
;;;596    
;;;597          /* No data was left from the previous operation, so we try to get
;;;598             some from the network. */
;;;599          if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;600            err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
;;;601          } else {
;;;602            err = netconn_recv(sock->conn, (struct netbuf **)&buf);
;;;603          }
;;;604          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
;;;605            err, buf));
;;;606    
;;;607          if (err != ERR_OK) {
;;;608            if (off > 0) {
;;;609              /* update receive window */
;;;610              netconn_recved(sock->conn, (u32_t)off);
;;;611              /* already received data, return that */
;;;612              sock_set_errno(sock, 0);
;;;613              return off;
;;;614            }
;;;615            /* We should really do some error checking here. */
;;;616            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
;;;617              s, lwip_strerr(err)));
;;;618            sock_set_errno(sock, err_to_errno(err));
;;;619            if (err == ERR_CLSD) {
;;;620              return 0;
;;;621            } else {
;;;622              return -1;
;;;623            }
;;;624          }
;;;625          LWIP_ASSERT("buf != NULL", buf != NULL);
;;;626          sock->lastdata = buf;
;;;627        }
;;;628    
;;;629        if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;630          p = (struct pbuf *)buf;
;;;631        } else {
;;;632          p = ((struct netbuf *)buf)->p;
;;;633        }
;;;634        buflen = p->tot_len;
;;;635        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
;;;636          buflen, len, off, sock->lastoffset));
;;;637    
;;;638        buflen -= sock->lastoffset;
;;;639    
;;;640        if (len > buflen) {
;;;641          copylen = buflen;
;;;642        } else {
;;;643          copylen = (u16_t)len;
;;;644        }
;;;645    
;;;646        /* copy the contents of the received buffer into
;;;647        the supplied memory pointer mem */
;;;648        pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
;;;649    
;;;650        off += copylen;
;;;651    
;;;652        if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;653          LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
;;;654          len -= copylen;
;;;655          if ( (len <= 0) || 
;;;656               (p->flags & PBUF_FLAG_PUSH) || 
;;;657               (sock->rcvevent <= 0) || 
;;;658               ((flags & MSG_PEEK)!=0)) {
;;;659            done = 1;
;;;660          }
;;;661        } else {
;;;662          done = 1;
;;;663        }
;;;664    
;;;665        /* Check to see from where the data was.*/
;;;666        if (done) {
;;;667          ip_addr_t fromaddr;
;;;668          if (from && fromlen) {
;;;669            struct sockaddr_in sin;
;;;670    
;;;671            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;672              addr = &fromaddr;
;;;673              netconn_getaddr(sock->conn, addr, &port, 0);
;;;674            } else {
;;;675              addr = netbuf_fromaddr((struct netbuf *)buf);
;;;676              port = netbuf_fromport((struct netbuf *)buf);
;;;677            }
;;;678    
;;;679            memset(&sin, 0, sizeof(sin));
;;;680            sin.sin_len = sizeof(sin);
;;;681            sin.sin_family = AF_INET;
;;;682            sin.sin_port = htons(port);
;;;683            inet_addr_from_ipaddr(&sin.sin_addr, addr);
;;;684    
;;;685            if (*fromlen > sizeof(sin)) {
;;;686              *fromlen = sizeof(sin);
;;;687            }
;;;688    
;;;689            MEMCPY(from, &sin, *fromlen);
;;;690    
;;;691            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
;;;692            ip_addr_debug_print(SOCKETS_DEBUG, addr);
;;;693            LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
;;;694          } else {
;;;695    #if SOCKETS_DEBUG
;;;696            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;697              addr = &fromaddr;
;;;698              netconn_getaddr(sock->conn, addr, &port, 0);
;;;699            } else {
;;;700              addr = netbuf_fromaddr((struct netbuf *)buf);
;;;701              port = netbuf_fromport((struct netbuf *)buf);
;;;702            }
;;;703    
;;;704            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
;;;705            ip_addr_debug_print(SOCKETS_DEBUG, addr);
;;;706            LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
;;;707    #endif /*  SOCKETS_DEBUG */
;;;708          }
;;;709        }
;;;710    
;;;711        /* If we don't peek the incoming message... */
;;;712        if ((flags & MSG_PEEK) == 0) {
;;;713          /* If this is a TCP socket, check if there is data left in the
;;;714             buffer. If so, it should be saved in the sock structure for next
;;;715             time around. */
;;;716          if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
;;;717            sock->lastdata = buf;
;;;718            sock->lastoffset += copylen;
;;;719            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
;;;720          } else {
;;;721            sock->lastdata = NULL;
;;;722            sock->lastoffset = 0;
;;;723            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
;;;724            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;725              pbuf_free((struct pbuf *)buf);
;;;726            } else {
;;;727              netbuf_delete((struct netbuf *)buf);
;;;728            }
;;;729          }
;;;730        }
;;;731      } while (!done);
;;;732    
;;;733      if (off > 0) {
;;;734        /* update receive window */
;;;735        netconn_recved(sock->conn, (u32_t)off);
;;;736      }
;;;737      sock_set_errno(sock, 0);
;;;738      return off;
;;;739    }
00051c  b00f              ADD      sp,sp,#0x3c
00051e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1314|
000522  bf00              NOP                            ;576
                  |L1.1316|
000524  bf00              NOP                            ;577
000526  bf00              NOP                            ;577
000528  6860              LDR      r0,[r4,#4]            ;579
00052a  b110              CBZ      r0,|L1.1330|
00052c  6860              LDR      r0,[r4,#4]            ;580
00052e  900a              STR      r0,[sp,#0x28]         ;580
000530  e05d              B        |L1.1518|
                  |L1.1330|
000532  f0080008          AND      r0,r8,#8              ;583
000536  b928              CBNZ     r0,|L1.1348|
000538  6820              LDR      r0,[r4,#0]            ;583
00053a  f89000d8          LDRB     r0,[r0,#0xd8]         ;583
00053e  f0000002          AND      r0,r0,#2              ;583
000542  b1c0              CBZ      r0,|L1.1398|
                  |L1.1348|
000544  f9b4000a          LDRSH    r0,[r4,#0xa]          ;584
000548  2800              CMP      r0,#0                 ;584
00054a  dc14              BGT      |L1.1398|
00054c  2d00              CMP      r5,#0                 ;585
00054e  dd09              BLE      |L1.1380|
000550  4629              MOV      r1,r5                 ;587
000552  6820              LDR      r0,[r4,#0]            ;587
000554  f7fffffe          BL       netconn_recved
000558  bf00              NOP                            ;589
00055a  2000              MOVS     r0,#0                 ;589
00055c  6120              STR      r0,[r4,#0x10]         ;589
00055e  bf00              NOP                            ;589
000560  4628              MOV      r0,r5                 ;590
000562  e7db              B        |L1.1308|
                  |L1.1380|
000564  bf00              NOP                            ;592
000566  bf00              NOP                            ;592
000568  bf00              NOP                            ;593
00056a  200b              MOVS     r0,#0xb               ;593
00056c  6120              STR      r0,[r4,#0x10]         ;593
00056e  bf00              NOP                            ;593
000570  f04f30ff          MOV      r0,#0xffffffff        ;594
000574  e7d2              B        |L1.1308|
                  |L1.1398|
000576  6820              LDR      r0,[r4,#0]            ;599
000578  7800              LDRB     r0,[r0,#0]            ;599
00057a  2810              CMP      r0,#0x10              ;599
00057c  d105              BNE      |L1.1418|
00057e  a90a              ADD      r1,sp,#0x28           ;600
000580  6820              LDR      r0,[r4,#0]            ;600
000582  f7fffffe          BL       netconn_recv_tcp_pbuf
000586  4683              MOV      r11,r0                ;600
000588  e004              B        |L1.1428|
                  |L1.1418|
00058a  a90a              ADD      r1,sp,#0x28           ;602
00058c  6820              LDR      r0,[r4,#0]            ;602
00058e  f7fffffe          BL       netconn_recv
000592  4683              MOV      r11,r0                ;602
                  |L1.1428|
000594  bf00              NOP                            ;604
000596  bf00              NOP                            ;604
000598  f1bb0f00          CMP      r11,#0                ;607
00059c  d023              BEQ      |L1.1510|
00059e  2d00              CMP      r5,#0                 ;608
0005a0  dd09              BLE      |L1.1462|
0005a2  4629              MOV      r1,r5                 ;610
0005a4  6820              LDR      r0,[r4,#0]            ;610
0005a6  f7fffffe          BL       netconn_recved
0005aa  bf00              NOP                            ;612
0005ac  2000              MOVS     r0,#0                 ;612
0005ae  6120              STR      r0,[r4,#0x10]         ;612
0005b0  bf00              NOP                            ;612
0005b2  4628              MOV      r0,r5                 ;613
0005b4  e7b2              B        |L1.1308|
                  |L1.1462|
0005b6  bf00              NOP                            ;616
0005b8  bf00              NOP                            ;616
0005ba  bf00              NOP                            ;618
0005bc  f1cb0000          RSB      r0,r11,#0             ;618
0005c0  2810              CMP      r0,#0x10              ;618
0005c2  d205              BCS      |L1.1488|
0005c4  489f              LDR      r0,|L1.2116|
0005c6  f1cb0100          RSB      r1,r11,#0             ;618
0005ca  f8500021          LDR      r0,[r0,r1,LSL #2]     ;618
0005ce  e000              B        |L1.1490|
                  |L1.1488|
0005d0  2005              MOVS     r0,#5                 ;618
                  |L1.1490|
0005d2  6120              STR      r0,[r4,#0x10]         ;618
0005d4  bf00              NOP                            ;618
0005d6  f10b000c          ADD      r0,r11,#0xc           ;619
0005da  b908              CBNZ     r0,|L1.1504|
0005dc  2000              MOVS     r0,#0                 ;620
0005de  e79d              B        |L1.1308|
                  |L1.1504|
0005e0  f04f30ff          MOV      r0,#0xffffffff        ;622
0005e4  e79a              B        |L1.1308|
                  |L1.1510|
0005e6  bf00              NOP                            ;625
0005e8  bf00              NOP                            ;625
0005ea  980a              LDR      r0,[sp,#0x28]         ;626
0005ec  6060              STR      r0,[r4,#4]            ;626
                  |L1.1518|
0005ee  6820              LDR      r0,[r4,#0]            ;629
0005f0  7800              LDRB     r0,[r0,#0]            ;629
0005f2  2810              CMP      r0,#0x10              ;629
0005f4  d102              BNE      |L1.1532|
0005f6  980a              LDR      r0,[sp,#0x28]         ;630
0005f8  9009              STR      r0,[sp,#0x24]         ;630
0005fa  e002              B        |L1.1538|
                  |L1.1532|
0005fc  980a              LDR      r0,[sp,#0x28]         ;632
0005fe  6800              LDR      r0,[r0,#0]            ;632
000600  9009              STR      r0,[sp,#0x24]         ;632
                  |L1.1538|
000602  9809              LDR      r0,[sp,#0x24]         ;634
000604  f8b0a008          LDRH     r10,[r0,#8]           ;634
000608  bf00              NOP                            ;635
00060a  bf00              NOP                            ;635
00060c  8920              LDRH     r0,[r4,#8]            ;638
00060e  ebaa0000          SUB      r0,r10,r0             ;638
000612  fa1ffa80          UXTH     r10,r0                ;638
000616  4556              CMP      r6,r10                ;640
000618  d901              BLS      |L1.1566|
00061a  4657              MOV      r7,r10                ;641
00061c  e000              B        |L1.1568|
                  |L1.1566|
00061e  b2b7              UXTH     r7,r6                 ;643
                  |L1.1568|
000620  8923              LDRH     r3,[r4,#8]            ;648
000622  980c              LDR      r0,[sp,#0x30]         ;648
000624  1941              ADDS     r1,r0,r5              ;648
000626  463a              MOV      r2,r7                 ;648
000628  9809              LDR      r0,[sp,#0x24]         ;648
00062a  f7fffffe          BL       pbuf_copy_partial
00062e  443d              ADD      r5,r5,r7              ;650
000630  6820              LDR      r0,[r4,#0]            ;652
000632  7800              LDRB     r0,[r0,#0]            ;652
000634  2810              CMP      r0,#0x10              ;652
000636  d112              BNE      |L1.1630|
000638  bf00              NOP                            ;653
00063a  bf00              NOP                            ;653
00063c  1bf6              SUBS     r6,r6,r7              ;654
00063e  b15e              CBZ      r6,|L1.1624|
000640  9809              LDR      r0,[sp,#0x24]         ;656
000642  7b40              LDRB     r0,[r0,#0xd]          ;656
000644  f0000001          AND      r0,r0,#1              ;656
000648  b930              CBNZ     r0,|L1.1624|
00064a  f9b4000a          LDRSH    r0,[r4,#0xa]          ;657
00064e  2800              CMP      r0,#0                 ;657
000650  dd02              BLE      |L1.1624|
000652  f0080001          AND      r0,r8,#1              ;658
000656  b120              CBZ      r0,|L1.1634|
                  |L1.1624|
000658  2001              MOVS     r0,#1                 ;659
00065a  9006              STR      r0,[sp,#0x18]         ;659
00065c  e001              B        |L1.1634|
                  |L1.1630|
00065e  2001              MOVS     r0,#1                 ;662
000660  9006              STR      r0,[sp,#0x18]         ;662
                  |L1.1634|
000662  9806              LDR      r0,[sp,#0x18]         ;666
000664  b3f0              CBZ      r0,|L1.1764|
000666  9818              LDR      r0,[sp,#0x60]         ;668
000668  b3e8              CBZ      r0,|L1.1766|
00066a  f1b90f00          CMP      r9,#0                 ;668
00066e  d03d              BEQ      |L1.1772|
000670  6820              LDR      r0,[r4,#0]            ;671
000672  7800              LDRB     r0,[r0,#0]            ;671
000674  2810              CMP      r0,#0x10              ;671
000676  d108              BNE      |L1.1674|
000678  a805              ADD      r0,sp,#0x14           ;672
00067a  9008              STR      r0,[sp,#0x20]         ;672
00067c  2300              MOVS     r3,#0                 ;673
00067e  aa07              ADD      r2,sp,#0x1c           ;673
000680  6820              LDR      r0,[r4,#0]            ;673
000682  9908              LDR      r1,[sp,#0x20]         ;673
000684  f7fffffe          BL       netconn_getaddr
000688  e005              B        |L1.1686|
                  |L1.1674|
00068a  980a              LDR      r0,[sp,#0x28]         ;675
00068c  3008              ADDS     r0,r0,#8              ;675
00068e  9008              STR      r0,[sp,#0x20]         ;675
000690  980a              LDR      r0,[sp,#0x28]         ;676
000692  8980              LDRH     r0,[r0,#0xc]          ;676
000694  9007              STR      r0,[sp,#0x1c]         ;676
                  |L1.1686|
000696  2000              MOVS     r0,#0                 ;679
000698  9001              STR      r0,[sp,#4]            ;679
00069a  9002              STR      r0,[sp,#8]            ;679
00069c  9003              STR      r0,[sp,#0xc]          ;679
00069e  9004              STR      r0,[sp,#0x10]         ;679
0006a0  2010              MOVS     r0,#0x10              ;680
0006a2  f88d0004          STRB     r0,[sp,#4]            ;680
0006a6  2002              MOVS     r0,#2                 ;681
0006a8  f88d0005          STRB     r0,[sp,#5]            ;681
0006ac  f8bd001c          LDRH     r0,[sp,#0x1c]         ;682
0006b0  f7fffffe          BL       lwip_htons
0006b4  f8ad0006          STRH     r0,[sp,#6]            ;682
0006b8  9808              LDR      r0,[sp,#0x20]         ;683
0006ba  6800              LDR      r0,[r0,#0]            ;683
0006bc  9002              STR      r0,[sp,#8]            ;683
0006be  f8d90000          LDR      r0,[r9,#0]            ;685
0006c2  2810              CMP      r0,#0x10              ;685
0006c4  d902              BLS      |L1.1740|
0006c6  2010              MOVS     r0,#0x10              ;686
0006c8  f8c90000          STR      r0,[r9,#0]            ;686
                  |L1.1740|
0006cc  a901              ADD      r1,sp,#4              ;689
0006ce  f8d92000          LDR      r2,[r9,#0]            ;689
0006d2  9818              LDR      r0,[sp,#0x60]         ;689
0006d4  f7fffffe          BL       __aeabi_memcpy
0006d8  bf00              NOP                            ;691
0006da  bf00              NOP                            ;691
0006dc  bf00              NOP                            ;692
0006de  bf00              NOP                            ;692
0006e0  bf00              NOP                            ;693
0006e2  e001              B        |L1.1768|
                  |L1.1764|
0006e4  e003              B        |L1.1774|
                  |L1.1766|
0006e6  e001              B        |L1.1772|
                  |L1.1768|
0006e8  bf00              NOP                            ;693
0006ea  bf00              NOP                            ;694
                  |L1.1772|
0006ec  bf00              NOP                            ;709
                  |L1.1774|
0006ee  f0080001          AND      r0,r8,#1              ;712
0006f2  b9f0              CBNZ     r0,|L1.1842|
0006f4  6820              LDR      r0,[r4,#0]            ;716
0006f6  7800              LDRB     r0,[r0,#0]            ;716
0006f8  2810              CMP      r0,#0x10              ;716
0006fa  d10a              BNE      |L1.1810|
0006fc  ebaa0007          SUB      r0,r10,r7             ;716
000700  2800              CMP      r0,#0                 ;716
000702  dd06              BLE      |L1.1810|
000704  980a              LDR      r0,[sp,#0x28]         ;717
000706  6060              STR      r0,[r4,#4]            ;717
000708  8920              LDRH     r0,[r4,#8]            ;718
00070a  4438              ADD      r0,r0,r7              ;718
00070c  8120              STRH     r0,[r4,#8]            ;718
00070e  bf00              NOP                            ;719
000710  e00f              B        |L1.1842|
                  |L1.1810|
000712  2000              MOVS     r0,#0                 ;721
000714  6060              STR      r0,[r4,#4]            ;721
000716  8120              STRH     r0,[r4,#8]            ;722
000718  bf00              NOP                            ;723
00071a  bf00              NOP                            ;723
00071c  6820              LDR      r0,[r4,#0]            ;724
00071e  7800              LDRB     r0,[r0,#0]            ;724
000720  2810              CMP      r0,#0x10              ;724
000722  d103              BNE      |L1.1836|
000724  980a              LDR      r0,[sp,#0x28]         ;725
000726  f7fffffe          BL       pbuf_free
00072a  e002              B        |L1.1842|
                  |L1.1836|
00072c  980a              LDR      r0,[sp,#0x28]         ;727
00072e  f7fffffe          BL       netbuf_delete
                  |L1.1842|
000732  9806              LDR      r0,[sp,#0x18]         ;731
000734  2800              CMP      r0,#0                 ;731
000736  f43faef5          BEQ      |L1.1316|
00073a  2d00              CMP      r5,#0                 ;733
00073c  dd03              BLE      |L1.1862|
00073e  4629              MOV      r1,r5                 ;735
000740  6820              LDR      r0,[r4,#0]            ;735
000742  f7fffffe          BL       netconn_recved
                  |L1.1862|
000746  bf00              NOP                            ;737
000748  2000              MOVS     r0,#0                 ;737
00074a  6120              STR      r0,[r4,#0x10]         ;737
00074c  bf00              NOP                            ;737
00074e  4628              MOV      r0,r5                 ;738
000750  e6e4              B        |L1.1308|
;;;740    
                          ENDP

                  lwip_read PROC
;;;741    int
;;;742    lwip_read(int s, void *mem, size_t len)
000752  b57c              PUSH     {r2-r6,lr}
;;;743    {
000754  4604              MOV      r4,r0
000756  460d              MOV      r5,r1
000758  4616              MOV      r6,r2
;;;744      return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
00075a  2000              MOVS     r0,#0
00075c  9000              STR      r0,[sp,#0]
00075e  4603              MOV      r3,r0
000760  4632              MOV      r2,r6
000762  4629              MOV      r1,r5
000764  9001              STR      r0,[sp,#4]
000766  4620              MOV      r0,r4
000768  f7fffffe          BL       lwip_recvfrom
;;;745    }
00076c  bd7c              POP      {r2-r6,pc}
;;;746    
                          ENDP

                  lwip_recv PROC
;;;747    int
;;;748    lwip_recv(int s, void *mem, size_t len, int flags)
00076e  e92d41fc          PUSH     {r2-r8,lr}
;;;749    {
000772  4604              MOV      r4,r0
000774  460d              MOV      r5,r1
000776  4616              MOV      r6,r2
000778  461f              MOV      r7,r3
;;;750      return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
00077a  2000              MOVS     r0,#0
00077c  9000              STR      r0,[sp,#0]
00077e  463b              MOV      r3,r7
000780  4632              MOV      r2,r6
000782  4629              MOV      r1,r5
000784  9001              STR      r0,[sp,#4]
000786  4620              MOV      r0,r4
000788  f7fffffe          BL       lwip_recvfrom
;;;751    }
00078c  e8bd81fc          POP      {r2-r8,pc}
;;;752    
                          ENDP

                  lwip_sendto PROC
;;;789    int
;;;790    lwip_sendto(int s, const void *data, size_t size, int flags,
000790  e92d4fff          PUSH     {r0-r11,lr}
;;;791           const struct sockaddr *to, socklen_t tolen)
;;;792    {
000794  b085              SUB      sp,sp,#0x14
000796  4691              MOV      r9,r2
000798  e9dd5a12          LDRD     r5,r10,[sp,#0x48]
;;;793      struct lwip_sock *sock;
;;;794      err_t err;
;;;795      u16_t short_size;
;;;796      const struct sockaddr_in *to_in;
;;;797      u16_t remote_port;
;;;798    #if !LWIP_TCPIP_CORE_LOCKING
;;;799      struct netbuf buf;
;;;800    #endif
;;;801    
;;;802      sock = get_socket(s);
00079c  9805              LDR      r0,[sp,#0x14]
00079e  f7fffffe          BL       get_socket
0007a2  4606              MOV      r6,r0
;;;803      if (!sock) {
0007a4  b926              CBNZ     r6,|L1.1968|
;;;804        return -1;
0007a6  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1962|
;;;805      }
;;;806    
;;;807      if (sock->conn->type == NETCONN_TCP) {
;;;808    #if LWIP_TCP
;;;809        return lwip_send(s, data, size, flags);
;;;810    #else /* LWIP_TCP */
;;;811        LWIP_UNUSED_ARG(flags);
;;;812        sock_set_errno(sock, err_to_errno(ERR_ARG));
;;;813        return -1;
;;;814    #endif /* LWIP_TCP */
;;;815      }
;;;816    
;;;817      /* @todo: split into multiple sendto's? */
;;;818      LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
;;;819      short_size = (u16_t)size;
;;;820      LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
;;;821                 ((tolen == sizeof(struct sockaddr_in)) &&
;;;822                 ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
;;;823                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;824      to_in = (const struct sockaddr_in *)(void*)to;
;;;825    
;;;826    #if LWIP_TCPIP_CORE_LOCKING
;;;827      /* Should only be consider like a sample or a simple way to experiment this option (no check of "to" field...) */
;;;828      {
;;;829        struct pbuf* p;
;;;830        ip_addr_t *remote_addr;
;;;831    
;;;832    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;833        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_RAM);
;;;834        if (p != NULL) {
;;;835    #if LWIP_CHECKSUM_ON_COPY
;;;836          u16_t chksum = 0;
;;;837          if (sock->conn->type != NETCONN_RAW) {
;;;838            chksum = LWIP_CHKSUM_COPY(p->payload, data, short_size);
;;;839          } else
;;;840    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;841          MEMCPY(p->payload, data, size);
;;;842    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;843        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_REF);
;;;844        if (p != NULL) {
;;;845          p->payload = (void*)data;
;;;846    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;847    
;;;848          if (to_in != NULL) {
;;;849            inet_addr_to_ipaddr_p(remote_addr, &to_in->sin_addr);
;;;850            remote_port = ntohs(to_in->sin_port);
;;;851          } else {
;;;852            remote_addr = &sock->conn->pcb.ip->remote_ip;
;;;853    #if LWIP_UDP
;;;854            if (NETCONNTYPE_GROUP(sock->conn->type) == NETCONN_UDP) {
;;;855              remote_port = sock->conn->pcb.udp->remote_port;
;;;856            } else
;;;857    #endif /* LWIP_UDP */
;;;858            {
;;;859              remote_port = 0;
;;;860            }
;;;861          }
;;;862    
;;;863          LOCK_TCPIP_CORE();
;;;864          if (netconn_type(sock->conn) == NETCONN_RAW) {
;;;865    #if LWIP_RAW
;;;866            err = sock->conn->last_err = raw_sendto(sock->conn->pcb.raw, p, remote_addr);
;;;867    #else /* LWIP_RAW */
;;;868            err = ERR_ARG;
;;;869    #endif /* LWIP_RAW */
;;;870          }
;;;871    #if LWIP_UDP && LWIP_RAW
;;;872          else
;;;873    #endif /* LWIP_UDP && LWIP_RAW */
;;;874          {
;;;875    #if LWIP_UDP
;;;876    #if LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF
;;;877            err = sock->conn->last_err = udp_sendto_chksum(sock->conn->pcb.udp, p,
;;;878              remote_addr, remote_port, 1, chksum);
;;;879    #else /* LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF */
;;;880            err = sock->conn->last_err = udp_sendto(sock->conn->pcb.udp, p,
;;;881              remote_addr, remote_port);
;;;882    #endif /* LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF */
;;;883    #else /* LWIP_UDP */
;;;884            err = ERR_ARG;
;;;885    #endif /* LWIP_UDP */
;;;886          }
;;;887          UNLOCK_TCPIP_CORE();
;;;888          
;;;889          pbuf_free(p);
;;;890        } else {
;;;891          err = ERR_MEM;
;;;892        }
;;;893      }
;;;894    #else /* LWIP_TCPIP_CORE_LOCKING */
;;;895      /* initialize a buffer */
;;;896      buf.p = buf.ptr = NULL;
;;;897    #if LWIP_CHECKSUM_ON_COPY
;;;898      buf.flags = 0;
;;;899    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;900      if (to) {
;;;901        inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
;;;902        remote_port           = ntohs(to_in->sin_port);
;;;903        netbuf_fromport(&buf) = remote_port;
;;;904      } else {
;;;905        remote_port           = 0;
;;;906        ip_addr_set_any(&buf.addr);
;;;907        netbuf_fromport(&buf) = 0;
;;;908      }
;;;909    
;;;910      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, short_size=%"U16_F", flags=0x%x to=",
;;;911                  s, data, short_size, flags));
;;;912      ip_addr_debug_print(SOCKETS_DEBUG, &buf.addr);
;;;913      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", remote_port));
;;;914    
;;;915      /* make the buffer point to the data that should be sent */
;;;916    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;917      /* Allocate a new netbuf and copy the data into it. */
;;;918      if (netbuf_alloc(&buf, short_size) == NULL) {
;;;919        err = ERR_MEM;
;;;920      } else {
;;;921    #if LWIP_CHECKSUM_ON_COPY
;;;922        if (sock->conn->type != NETCONN_RAW) {
;;;923          u16_t chksum = LWIP_CHKSUM_COPY(buf.p->payload, data, short_size);
;;;924          netbuf_set_chksum(&buf, chksum);
;;;925          err = ERR_OK;
;;;926        } else
;;;927    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;928        {
;;;929          err = netbuf_take(&buf, data, short_size);
;;;930        }
;;;931      }
;;;932    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;933      err = netbuf_ref(&buf, data, short_size);
;;;934    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;935      if (err == ERR_OK) {
;;;936        /* send the data */
;;;937        err = netconn_send(sock->conn, &buf);
;;;938      }
;;;939    
;;;940      /* deallocated the buffer */
;;;941      netbuf_free(&buf);
;;;942    #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;943      sock_set_errno(sock, err_to_errno(err));
;;;944      return (err == ERR_OK ? short_size : -1);
;;;945    }
0007aa  b009              ADD      sp,sp,#0x24
0007ac  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1968|
0007b0  6830              LDR      r0,[r6,#0]            ;807
0007b2  7800              LDRB     r0,[r0,#0]            ;807
0007b4  2810              CMP      r0,#0x10              ;807
0007b6  d106              BNE      |L1.1990|
0007b8  464a              MOV      r2,r9                 ;809
0007ba  9b08              LDR      r3,[sp,#0x20]         ;809
0007bc  e9dd0105          LDRD     r0,r1,[sp,#0x14]      ;809
0007c0  f7fffffe          BL       lwip_send
0007c4  e7f1              B        |L1.1962|
                  |L1.1990|
0007c6  bf00              NOP                            ;818
0007c8  bf00              NOP                            ;818
0007ca  fa1ffb89          UXTH     r11,r9                ;819
0007ce  bf00              NOP                            ;820
0007d0  b915              CBNZ     r5,|L1.2008|
0007d2  f1ba0f00          CMP      r10,#0                ;820
0007d6  d010              BEQ      |L1.2042|
                  |L1.2008|
0007d8  f1ba0f10          CMP      r10,#0x10             ;820
0007dc  d105              BNE      |L1.2026|
0007de  7868              LDRB     r0,[r5,#1]            ;820
0007e0  2802              CMP      r0,#2                 ;820
0007e2  d102              BNE      |L1.2026|
0007e4  f0050003          AND      r0,r5,#3              ;820
0007e8  b138              CBZ      r0,|L1.2042|
                  |L1.2026|
0007ea  bf00              NOP                            ;820
0007ec  4815              LDR      r0,|L1.2116|
0007ee  6b80              LDR      r0,[r0,#0x38]         ;820  ; err_to_errno_table
0007f0  6130              STR      r0,[r6,#0x10]         ;820
0007f2  bf00              NOP                            ;820
0007f4  f04f30ff          MOV      r0,#0xffffffff        ;820
0007f8  e7d7              B        |L1.1962|
                  |L1.2042|
0007fa  bf00              NOP                            ;820
0007fc  462f              MOV      r7,r5                 ;824
0007fe  2000              MOVS     r0,#0                 ;896
000800  9002              STR      r0,[sp,#8]            ;896
000802  9001              STR      r0,[sp,#4]            ;896
000804  b145              CBZ      r5,|L1.2072|
000806  6878              LDR      r0,[r7,#4]            ;901
000808  9003              STR      r0,[sp,#0xc]          ;901
00080a  8878              LDRH     r0,[r7,#2]            ;902
00080c  f7fffffe          BL       lwip_ntohs
000810  4680              MOV      r8,r0                 ;902
000812  f8ad8010          STRH     r8,[sp,#0x10]         ;903
000816  e005              B        |L1.2084|
                  |L1.2072|
000818  f04f0800          MOV      r8,#0                 ;905
00081c  2000              MOVS     r0,#0                 ;906
00081e  9003              STR      r0,[sp,#0xc]          ;906
000820  f8ad0010          STRH     r0,[sp,#0x10]         ;907
                  |L1.2084|
000824  bf00              NOP                            ;910
000826  bf00              NOP                            ;910
000828  bf00              NOP                            ;912
00082a  bf00              NOP                            ;912
00082c  bf00              NOP                            ;913
00082e  bf00              NOP                            ;913
000830  465a              MOV      r2,r11                ;933
000832  a801              ADD      r0,sp,#4              ;933
000834  9906              LDR      r1,[sp,#0x18]         ;933
000836  f7fffffe          BL       netbuf_ref
00083a  4604              MOV      r4,r0                 ;933
00083c  b93c              CBNZ     r4,|L1.2126|
00083e  a901              ADD      r1,sp,#4              ;937
000840  6830              LDR      r0,[r6,#0]            ;937
000842  e001              B        |L1.2120|
                  |L1.2116|
                          DCD      err_to_errno_table
                  |L1.2120|
000848  f7fffffe          BL       netconn_send
00084c  4604              MOV      r4,r0                 ;937
                  |L1.2126|
00084e  a801              ADD      r0,sp,#4              ;941
000850  f7fffffe          BL       netbuf_free
000854  bf00              NOP                            ;943
000856  4260              RSBS     r0,r4,#0              ;943
000858  2810              CMP      r0,#0x10              ;943
00085a  d204              BCS      |L1.2150|
00085c  48fe              LDR      r0,|L1.3160|
00085e  4261              RSBS     r1,r4,#0              ;943
000860  f8500021          LDR      r0,[r0,r1,LSL #2]     ;943
000864  e000              B        |L1.2152|
                  |L1.2150|
000866  2005              MOVS     r0,#5                 ;943
                  |L1.2152|
000868  6130              STR      r0,[r6,#0x10]         ;943
00086a  bf00              NOP                            ;943
00086c  b90c              CBNZ     r4,|L1.2162|
00086e  4658              MOV      r0,r11                ;944
000870  e79b              B        |L1.1962|
                  |L1.2162|
000872  f04f30ff          MOV      r0,#0xffffffff        ;944
000876  e798              B        |L1.1962|
;;;946    
                          ENDP

                  lwip_send PROC
;;;753    int
;;;754    lwip_send(int s, const void *data, size_t size, int flags)
000878  e92d4ffe          PUSH     {r1-r11,lr}
;;;755    {
00087c  4680              MOV      r8,r0
00087e  4689              MOV      r9,r1
000880  4692              MOV      r10,r2
000882  461e              MOV      r6,r3
;;;756      struct lwip_sock *sock;
;;;757      err_t err;
;;;758      u8_t write_flags;
;;;759      size_t written;
;;;760    
;;;761      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
000884  bf00              NOP      
000886  bf00              NOP      
;;;762                                  s, data, size, flags));
;;;763    
;;;764      sock = get_socket(s);
000888  4640              MOV      r0,r8
00088a  f7fffffe          BL       get_socket
00088e  4604              MOV      r4,r0
;;;765      if (!sock) {
000890  b91c              CBNZ     r4,|L1.2202|
;;;766        return -1;
000892  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2198|
;;;767      }
;;;768    
;;;769      if (sock->conn->type != NETCONN_TCP) {
;;;770    #if (LWIP_UDP || LWIP_RAW)
;;;771        return lwip_sendto(s, data, size, flags, NULL, 0);
;;;772    #else /* (LWIP_UDP || LWIP_RAW) */
;;;773        sock_set_errno(sock, err_to_errno(ERR_ARG));
;;;774        return -1;
;;;775    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;776      }
;;;777    
;;;778      write_flags = NETCONN_COPY |
;;;779        ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
;;;780        ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
;;;781      written = 0;
;;;782      err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
;;;783    
;;;784      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
;;;785      sock_set_errno(sock, err_to_errno(err));
;;;786      return (err == ERR_OK ? (int)written : -1);
;;;787    }
000896  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.2202|
00089a  6820              LDR      r0,[r4,#0]            ;769
00089c  7800              LDRB     r0,[r0,#0]            ;769
00089e  2810              CMP      r0,#0x10              ;769
0008a0  d009              BEQ      |L1.2230|
0008a2  2000              MOVS     r0,#0                 ;771
0008a4  9000              STR      r0,[sp,#0]            ;771
0008a6  4633              MOV      r3,r6                 ;771
0008a8  4652              MOV      r2,r10                ;771
0008aa  4649              MOV      r1,r9                 ;771
0008ac  9001              STR      r0,[sp,#4]            ;771
0008ae  4640              MOV      r0,r8                 ;771
0008b0  f7fffffe          BL       lwip_sendto
0008b4  e7ef              B        |L1.2198|
                  |L1.2230|
0008b6  f0060010          AND      r0,r6,#0x10           ;778
0008ba  b108              CBZ      r0,|L1.2240|
0008bc  2002              MOVS     r0,#2                 ;779
0008be  e000              B        |L1.2242|
                  |L1.2240|
0008c0  2000              MOVS     r0,#0                 ;779
                  |L1.2242|
0008c2  f0400001          ORR      r0,r0,#1              ;779
0008c6  f0060108          AND      r1,r6,#8              ;779
0008ca  b109              CBZ      r1,|L1.2256|
0008cc  2104              MOVS     r1,#4                 ;780
0008ce  e000              B        |L1.2258|
                  |L1.2256|
0008d0  2100              MOVS     r1,#0                 ;780
                  |L1.2258|
0008d2  ea400701          ORR      r7,r0,r1              ;780
0008d6  2000              MOVS     r0,#0                 ;781
0008d8  9002              STR      r0,[sp,#8]            ;781
0008da  a802              ADD      r0,sp,#8              ;782
0008dc  9000              STR      r0,[sp,#0]            ;782
0008de  463b              MOV      r3,r7                 ;782
0008e0  4652              MOV      r2,r10                ;782
0008e2  4649              MOV      r1,r9                 ;782
0008e4  6820              LDR      r0,[r4,#0]            ;782
0008e6  f7fffffe          BL       netconn_write_partly
0008ea  4605              MOV      r5,r0                 ;782
0008ec  bf00              NOP                            ;784
0008ee  bf00              NOP                            ;784
0008f0  bf00              NOP                            ;785
0008f2  4268              RSBS     r0,r5,#0              ;785
0008f4  2810              CMP      r0,#0x10              ;785
0008f6  d204              BCS      |L1.2306|
0008f8  48d7              LDR      r0,|L1.3160|
0008fa  4269              RSBS     r1,r5,#0              ;785
0008fc  f8500021          LDR      r0,[r0,r1,LSL #2]     ;785
000900  e000              B        |L1.2308|
                  |L1.2306|
000902  2005              MOVS     r0,#5                 ;785
                  |L1.2308|
000904  6120              STR      r0,[r4,#0x10]         ;785
000906  bf00              NOP                            ;785
000908  b90d              CBNZ     r5,|L1.2318|
00090a  9802              LDR      r0,[sp,#8]            ;786
00090c  e7c3              B        |L1.2198|
                  |L1.2318|
00090e  f04f30ff          MOV      r0,#0xffffffff        ;786
000912  e7c0              B        |L1.2198|
;;;788    
                          ENDP

                  event_callback PROC
;;;1246   static void
;;;1247   event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
000914  e92d5ff0          PUSH     {r4-r12,lr}
;;;1248   {
000918  4607              MOV      r7,r0
00091a  4688              MOV      r8,r1
;;;1249     int s;
;;;1250     struct lwip_sock *sock;
;;;1251     struct lwip_select_cb *scb;
;;;1252     int last_select_cb_ctr;
;;;1253     SYS_ARCH_DECL_PROTECT(lev);
;;;1254   
;;;1255     LWIP_UNUSED_ARG(len);
;;;1256   
;;;1257     /* Get socket */
;;;1258     if (conn) {
00091c  b317              CBZ      r7,|L1.2404|
;;;1259       s = conn->socket;
00091e  f8d740d4          LDR      r4,[r7,#0xd4]
;;;1260       if (s < 0) {
000922  2c00              CMP      r4,#0
000924  da18              BGE      |L1.2392|
;;;1261         /* Data comes in right away after an accept, even though
;;;1262          * the server task might not have created a new socket yet.
;;;1263          * Just count down (or up) if that's the case and we
;;;1264          * will use the data later. Note that only receive events
;;;1265          * can happen before the new socket is set up. */
;;;1266         SYS_ARCH_PROTECT(lev);
000926  f7fffffe          BL       sys_arch_protect
00092a  4683              MOV      r11,r0
;;;1267         if (conn->socket < 0) {
00092c  f8d700d4          LDR      r0,[r7,#0xd4]
000930  2800              CMP      r0,#0
000932  da0c              BGE      |L1.2382|
;;;1268           if (evt == NETCONN_EVT_RCVPLUS) {
000934  f1b80f00          CMP      r8,#0
000938  d104              BNE      |L1.2372|
;;;1269             conn->socket--;
00093a  f8d700d4          LDR      r0,[r7,#0xd4]
00093e  1e40              SUBS     r0,r0,#1
000940  f8c700d4          STR      r0,[r7,#0xd4]
                  |L1.2372|
;;;1270           }
;;;1271           SYS_ARCH_UNPROTECT(lev);
000944  4658              MOV      r0,r11
000946  f7fffffe          BL       sys_arch_unprotect
                  |L1.2378|
;;;1272           return;
;;;1273         }
;;;1274         s = conn->socket;
;;;1275         SYS_ARCH_UNPROTECT(lev);
;;;1276       }
;;;1277   
;;;1278       sock = get_socket(s);
;;;1279       if (!sock) {
;;;1280         return;
;;;1281       }
;;;1282     } else {
;;;1283       return;
;;;1284     }
;;;1285   
;;;1286     SYS_ARCH_PROTECT(lev);
;;;1287     /* Set event as required */
;;;1288     switch (evt) {
;;;1289       case NETCONN_EVT_RCVPLUS:
;;;1290         sock->rcvevent++;
;;;1291         break;
;;;1292       case NETCONN_EVT_RCVMINUS:
;;;1293         sock->rcvevent--;
;;;1294         break;
;;;1295       case NETCONN_EVT_SENDPLUS:
;;;1296         sock->sendevent = 1;
;;;1297         break;
;;;1298       case NETCONN_EVT_SENDMINUS:
;;;1299         sock->sendevent = 0;
;;;1300         break;
;;;1301       case NETCONN_EVT_ERROR:
;;;1302         sock->errevent = 1;
;;;1303         break;
;;;1304       default:
;;;1305         LWIP_ASSERT("unknown event", 0);
;;;1306         break;
;;;1307     }
;;;1308   
;;;1309     if (sock->select_waiting == 0) {
;;;1310       /* noone is waiting for this socket, no need to check select_cb_list */
;;;1311       SYS_ARCH_UNPROTECT(lev);
;;;1312       return;
;;;1313     }
;;;1314   
;;;1315     /* Now decide if anyone is waiting for this socket */
;;;1316     /* NOTE: This code goes through the select_cb_list list multiple times
;;;1317        ONLY IF a select was actually waiting. We go through the list the number
;;;1318        of waiting select calls + 1. This list is expected to be small. */
;;;1319   
;;;1320     /* At this point, SYS_ARCH is still protected! */
;;;1321   again:
;;;1322     for (scb = select_cb_list; scb != NULL; scb = scb->next) {
;;;1323       if (scb->sem_signalled == 0) {
;;;1324         /* semaphore not signalled yet */
;;;1325         int do_signal = 0;
;;;1326         /* Test this select call for our socket */
;;;1327         if (sock->rcvevent > 0) {
;;;1328           if (scb->readset && FD_ISSET(s, scb->readset)) {
;;;1329             do_signal = 1;
;;;1330           }
;;;1331         }
;;;1332         if (sock->sendevent != 0) {
;;;1333           if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
;;;1334             do_signal = 1;
;;;1335           }
;;;1336         }
;;;1337         if (sock->errevent != 0) {
;;;1338           if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
;;;1339             do_signal = 1;
;;;1340           }
;;;1341         }
;;;1342         if (do_signal) {
;;;1343           scb->sem_signalled = 1;
;;;1344           /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
;;;1345              lead to the select thread taking itself off the list, invalidagin the semaphore. */
;;;1346           sys_sem_signal(&scb->sem);
;;;1347         }
;;;1348       }
;;;1349       /* unlock interrupts with each step */
;;;1350       last_select_cb_ctr = select_cb_ctr;
;;;1351       SYS_ARCH_UNPROTECT(lev);
;;;1352       /* this makes sure interrupt protection time is short */
;;;1353       SYS_ARCH_PROTECT(lev);
;;;1354       if (last_select_cb_ctr != select_cb_ctr) {
;;;1355         /* someone has changed select_cb_list, restart at the beginning */
;;;1356         goto again;
;;;1357       }
;;;1358     }
;;;1359     SYS_ARCH_UNPROTECT(lev);
;;;1360   }
00094a  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2382|
00094e  f8d740d4          LDR      r4,[r7,#0xd4]         ;1274
000952  4658              MOV      r0,r11                ;1275
000954  f7fffffe          BL       sys_arch_unprotect
                  |L1.2392|
000958  4620              MOV      r0,r4                 ;1278
00095a  f7fffffe          BL       get_socket
00095e  4605              MOV      r5,r0                 ;1278
000960  b90d              CBNZ     r5,|L1.2406|
000962  e7f2              B        |L1.2378|
                  |L1.2404|
000964  e7f1              B        |L1.2378|
                  |L1.2406|
000966  f7fffffe          BL       sys_arch_protect
00096a  4683              MOV      r11,r0                ;1286
00096c  f1b80f05          CMP      r8,#5                 ;1288
000970  d217              BCS      |L1.2466|
000972  e8dff008          TBB      [pc,r8]               ;1288
000976  0308              DCB      0x03,0x08
000978  0d101300          DCB      0x0d,0x10,0x13,0x00
00097c  8968              LDRH     r0,[r5,#0xa]          ;1290
00097e  1c40              ADDS     r0,r0,#1              ;1290
000980  b200              SXTH     r0,r0                 ;1290
000982  8168              STRH     r0,[r5,#0xa]          ;1290
000984  e010              B        |L1.2472|
000986  8968              LDRH     r0,[r5,#0xa]          ;1293
000988  1e40              SUBS     r0,r0,#1              ;1293
00098a  b200              SXTH     r0,r0                 ;1293
00098c  8168              STRH     r0,[r5,#0xa]          ;1293
00098e  e00b              B        |L1.2472|
000990  2001              MOVS     r0,#1                 ;1296
000992  81a8              STRH     r0,[r5,#0xc]          ;1296
000994  e008              B        |L1.2472|
000996  2000              MOVS     r0,#0                 ;1299
000998  81a8              STRH     r0,[r5,#0xc]          ;1299
00099a  e005              B        |L1.2472|
00099c  2001              MOVS     r0,#1                 ;1302
00099e  81e8              STRH     r0,[r5,#0xe]          ;1302
0009a0  e002              B        |L1.2472|
                  |L1.2466|
0009a2  bf00              NOP                            ;1305
0009a4  bf00              NOP                            ;1305
0009a6  bf00              NOP                            ;1306
                  |L1.2472|
0009a8  bf00              NOP                            ;1291
0009aa  6968              LDR      r0,[r5,#0x14]         ;1309
0009ac  b918              CBNZ     r0,|L1.2486|
0009ae  4658              MOV      r0,r11                ;1311
0009b0  f7fffffe          BL       sys_arch_unprotect
0009b4  e7c9              B        |L1.2378|
                  |L1.2486|
0009b6  bf00              NOP                            ;1321
                  |L1.2488|
0009b8  48a8              LDR      r0,|L1.3164|
0009ba  6806              LDR      r6,[r0,#0]            ;1322  ; select_cb_list
0009bc  e05a              B        |L1.2676|
                  |L1.2494|
0009be  6970              LDR      r0,[r6,#0x14]         ;1323
0009c0  2800              CMP      r0,#0                 ;1323
0009c2  d148              BNE      |L1.2646|
0009c4  4681              MOV      r9,r0                 ;1325
0009c6  f9b5000a          LDRSH    r0,[r5,#0xa]          ;1327
0009ca  2800              CMP      r0,#0                 ;1327
0009cc  dd0f              BLE      |L1.2542|
0009ce  68b1              LDR      r1,[r6,#8]            ;1328
0009d0  b169              CBZ      r1,|L1.2542|
0009d2  17e1              ASRS     r1,r4,#31             ;1328
0009d4  eb047151          ADD      r1,r4,r1,LSR #29      ;1328
0009d8  10c9              ASRS     r1,r1,#3              ;1328
0009da  68b2              LDR      r2,[r6,#8]            ;1328
0009dc  5c51              LDRB     r1,[r2,r1]            ;1328
0009de  f0040307          AND      r3,r4,#7              ;1328
0009e2  2201              MOVS     r2,#1                 ;1328
0009e4  409a              LSLS     r2,r2,r3              ;1328
0009e6  4011              ANDS     r1,r1,r2              ;1328
0009e8  b109              CBZ      r1,|L1.2542|
0009ea  f04f0901          MOV      r9,#1                 ;1329
                  |L1.2542|
0009ee  89a8              LDRH     r0,[r5,#0xc]          ;1332
0009f0  b190              CBZ      r0,|L1.2584|
0009f2  f1b90f00          CMP      r9,#0                 ;1333
0009f6  d10f              BNE      |L1.2584|
0009f8  68f1              LDR      r1,[r6,#0xc]          ;1333
0009fa  b169              CBZ      r1,|L1.2584|
0009fc  17e1              ASRS     r1,r4,#31             ;1333
0009fe  eb047151          ADD      r1,r4,r1,LSR #29      ;1333
000a02  10c9              ASRS     r1,r1,#3              ;1333
000a04  68f2              LDR      r2,[r6,#0xc]          ;1333
000a06  5c51              LDRB     r1,[r2,r1]            ;1333
000a08  f0040307          AND      r3,r4,#7              ;1333
000a0c  2201              MOVS     r2,#1                 ;1333
000a0e  409a              LSLS     r2,r2,r3              ;1333
000a10  4011              ANDS     r1,r1,r2              ;1333
000a12  b109              CBZ      r1,|L1.2584|
000a14  f04f0901          MOV      r9,#1                 ;1334
                  |L1.2584|
000a18  89e8              LDRH     r0,[r5,#0xe]          ;1337
000a1a  b190              CBZ      r0,|L1.2626|
000a1c  f1b90f00          CMP      r9,#0                 ;1338
000a20  d10f              BNE      |L1.2626|
000a22  6931              LDR      r1,[r6,#0x10]         ;1338
000a24  b169              CBZ      r1,|L1.2626|
000a26  17e1              ASRS     r1,r4,#31             ;1338
000a28  eb047151          ADD      r1,r4,r1,LSR #29      ;1338
000a2c  10c9              ASRS     r1,r1,#3              ;1338
000a2e  6932              LDR      r2,[r6,#0x10]         ;1338
000a30  5c51              LDRB     r1,[r2,r1]            ;1338
000a32  f0040307          AND      r3,r4,#7              ;1338
000a36  2201              MOVS     r2,#1                 ;1338
000a38  409a              LSLS     r2,r2,r3              ;1338
000a3a  4011              ANDS     r1,r1,r2              ;1338
000a3c  b109              CBZ      r1,|L1.2626|
000a3e  f04f0901          MOV      r9,#1                 ;1339
                  |L1.2626|
000a42  f1b90f00          CMP      r9,#0                 ;1342
000a46  d005              BEQ      |L1.2644|
000a48  2001              MOVS     r0,#1                 ;1343
000a4a  6170              STR      r0,[r6,#0x14]         ;1343
000a4c  f1060018          ADD      r0,r6,#0x18           ;1346
000a50  f7fffffe          BL       sys_sem_signal
                  |L1.2644|
000a54  bf00              NOP                            ;1348
                  |L1.2646|
000a56  4882              LDR      r0,|L1.3168|
000a58  f8d0a000          LDR      r10,[r0,#0]           ;1350  ; select_cb_ctr
000a5c  4658              MOV      r0,r11                ;1351
000a5e  f7fffffe          BL       sys_arch_unprotect
000a62  f7fffffe          BL       sys_arch_protect
000a66  4683              MOV      r11,r0                ;1353
000a68  487d              LDR      r0,|L1.3168|
000a6a  6800              LDR      r0,[r0,#0]            ;1354  ; select_cb_ctr
000a6c  4582              CMP      r10,r0                ;1354
000a6e  d000              BEQ      |L1.2674|
000a70  e7a2              B        |L1.2488|
                  |L1.2674|
000a72  6836              LDR      r6,[r6,#0]            ;1322
                  |L1.2676|
000a74  2e00              CMP      r6,#0                 ;1322
000a76  d1a2              BNE      |L1.2494|
000a78  4658              MOV      r0,r11                ;1359
000a7a  f7fffffe          BL       sys_arch_unprotect
000a7e  bf00              NOP      
000a80  e763              B        |L1.2378|
;;;1361   
                          ENDP

                  lwip_socket PROC
;;;947    int
;;;948    lwip_socket(int domain, int type, int protocol)
000a82  e92d41f0          PUSH     {r4-r8,lr}
;;;949    {
000a86  4680              MOV      r8,r0
000a88  460f              MOV      r7,r1
000a8a  4616              MOV      r6,r2
;;;950      struct netconn *conn;
;;;951      int i;
;;;952    
;;;953      LWIP_UNUSED_ARG(domain);
;;;954    
;;;955      /* create a netconn */
;;;956      switch (type) {
000a8c  2f01              CMP      r7,#1
000a8e  d01a              BEQ      |L1.2758|
000a90  2f02              CMP      r7,#2
000a92  d00a              BEQ      |L1.2730|
000a94  2f03              CMP      r7,#3
000a96  d128              BNE      |L1.2794|
;;;957      case SOCK_RAW:
;;;958        conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
000a98  b2f1              UXTB     r1,r6
000a9a  4a72              LDR      r2,|L1.3172|
000a9c  2040              MOVS     r0,#0x40
000a9e  f7fffffe          BL       netconn_new_with_proto_and_callback
000aa2  4604              MOV      r4,r0
;;;959        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
000aa4  bf00              NOP      
000aa6  bf00              NOP      
;;;960                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;961        break;
000aa8  e025              B        |L1.2806|
                  |L1.2730|
;;;962      case SOCK_DGRAM:
;;;963        conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
000aaa  2e88              CMP      r6,#0x88
000aac  d101              BNE      |L1.2738|
000aae  2121              MOVS     r1,#0x21
000ab0  e000              B        |L1.2740|
                  |L1.2738|
000ab2  2120              MOVS     r1,#0x20
                  |L1.2740|
000ab4  4608              MOV      r0,r1
000ab6  4a6b              LDR      r2,|L1.3172|
000ab8  2100              MOVS     r1,#0
000aba  f7fffffe          BL       netconn_new_with_proto_and_callback
000abe  4604              MOV      r4,r0
;;;964                     NETCONN_UDPLITE : NETCONN_UDP, event_callback);
;;;965        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
000ac0  bf00              NOP      
000ac2  bf00              NOP      
;;;966                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;967        break;
000ac4  e017              B        |L1.2806|
                  |L1.2758|
;;;968      case SOCK_STREAM:
;;;969        conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
000ac6  4a67              LDR      r2,|L1.3172|
000ac8  2100              MOVS     r1,#0
000aca  2010              MOVS     r0,#0x10
000acc  f7fffffe          BL       netconn_new_with_proto_and_callback
000ad0  4604              MOV      r4,r0
;;;970        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
000ad2  bf00              NOP      
000ad4  bf00              NOP      
;;;971                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;972        if (conn != NULL) {
000ad6  b13c              CBZ      r4,|L1.2792|
;;;973          /* Prevent automatic window updates, we do this on our own! */
;;;974          netconn_set_noautorecved(conn, 1);
000ad8  bf00              NOP      
000ada  f89400d8          LDRB     r0,[r4,#0xd8]
000ade  f0400008          ORR      r0,r0,#8
000ae2  f88400d8          STRB     r0,[r4,#0xd8]
000ae6  bf00              NOP      
                  |L1.2792|
;;;975        }
;;;976        break;
000ae8  e005              B        |L1.2806|
                  |L1.2794|
;;;977      default:
;;;978        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
000aea  bf00              NOP      
000aec  bf00              NOP      
;;;979                                     domain, type, protocol));
;;;980        set_errno(EINVAL);
;;;981        return -1;
000aee  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2802|
;;;982      }
;;;983    
;;;984      if (!conn) {
;;;985        LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
;;;986        set_errno(ENOBUFS);
;;;987        return -1;
;;;988      }
;;;989    
;;;990      i = alloc_socket(conn, 0);
;;;991    
;;;992      if (i == -1) {
;;;993        netconn_delete(conn);
;;;994        set_errno(ENFILE);
;;;995        return -1;
;;;996      }
;;;997      conn->socket = i;
;;;998      LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
;;;999      set_errno(0);
;;;1000     return i;
;;;1001   }
000af2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2806|
000af6  bf00              NOP                            ;961
000af8  b924              CBNZ     r4,|L1.2820|
000afa  bf00              NOP                            ;985
000afc  bf00              NOP                            ;985
000afe  f04f30ff          MOV      r0,#0xffffffff        ;987
000b02  e7f6              B        |L1.2802|
                  |L1.2820|
000b04  2100              MOVS     r1,#0                 ;990
000b06  4620              MOV      r0,r4                 ;990
000b08  f7fffffe          BL       alloc_socket
000b0c  4605              MOV      r5,r0                 ;990
000b0e  1c68              ADDS     r0,r5,#1              ;992
000b10  b928              CBNZ     r0,|L1.2846|
000b12  4620              MOV      r0,r4                 ;993
000b14  f7fffffe          BL       netconn_delete
000b18  f04f30ff          MOV      r0,#0xffffffff        ;995
000b1c  e7e9              B        |L1.2802|
                  |L1.2846|
000b1e  f8c450d4          STR      r5,[r4,#0xd4]         ;997
000b22  bf00              NOP                            ;998
000b24  bf00              NOP                            ;998
000b26  4628              MOV      r0,r5                 ;1000
000b28  e7e3              B        |L1.2802|
;;;1002   
                          ENDP

                  lwip_write PROC
;;;1003   int
;;;1004   lwip_write(int s, const void *data, size_t size)
000b2a  b570              PUSH     {r4-r6,lr}
;;;1005   {
000b2c  4604              MOV      r4,r0
000b2e  460d              MOV      r5,r1
000b30  4616              MOV      r6,r2
;;;1006     return lwip_send(s, data, size, 0);
000b32  2300              MOVS     r3,#0
000b34  4632              MOV      r2,r6
000b36  4629              MOV      r1,r5
000b38  4620              MOV      r0,r4
000b3a  f7fffffe          BL       lwip_send
;;;1007   }
000b3e  bd70              POP      {r4-r6,pc}
;;;1008   
                          ENDP

                  lwip_selscan PROC
;;;1025   static int
;;;1026   lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
000b40  e92d4ff0          PUSH     {r4-r11,lr}
;;;1027                fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
;;;1028   {
000b44  b087              SUB      sp,sp,#0x1c
000b46  4682              MOV      r10,r0
000b48  460f              MOV      r7,r1
000b4a  4690              MOV      r8,r2
000b4c  4699              MOV      r9,r3
;;;1029     int i, nready = 0;
000b4e  2600              MOVS     r6,#0
;;;1030     fd_set lreadset, lwriteset, lexceptset;
;;;1031     struct lwip_sock *sock;
;;;1032     SYS_ARCH_DECL_PROTECT(lev);
;;;1033   
;;;1034     FD_ZERO(&lreadset);
000b50  2000              MOVS     r0,#0
000b52  9006              STR      r0,[sp,#0x18]
;;;1035     FD_ZERO(&lwriteset);
000b54  9005              STR      r0,[sp,#0x14]
;;;1036     FD_ZERO(&lexceptset);
000b56  9004              STR      r0,[sp,#0x10]
;;;1037   
;;;1038     /* Go through each socket in each list to count number of sockets which
;;;1039        currently match */
;;;1040     for(i = 0; i < maxfdp1; i++) {
000b58  2400              MOVS     r4,#0
000b5a  e096              B        |L1.3210|
                  |L1.2908|
;;;1041       void* lastdata = NULL;
000b5c  f04f0b00          MOV      r11,#0
;;;1042       s16_t rcvevent = 0;
000b60  2000              MOVS     r0,#0
000b62  9002              STR      r0,[sp,#8]
;;;1043       u16_t sendevent = 0;
000b64  9001              STR      r0,[sp,#4]
;;;1044       u16_t errevent = 0;
000b66  9000              STR      r0,[sp,#0]
;;;1045       /* First get the socket's status (protected)... */
;;;1046       SYS_ARCH_PROTECT(lev);
000b68  f7fffffe          BL       sys_arch_protect
000b6c  9003              STR      r0,[sp,#0xc]
;;;1047       sock = tryget_socket(i);
000b6e  4620              MOV      r0,r4
000b70  f7fffffe          BL       tryget_socket
000b74  4605              MOV      r5,r0
;;;1048       if (sock != NULL) {
000b76  b145              CBZ      r5,|L1.2954|
;;;1049         lastdata = sock->lastdata;
000b78  f8d5b004          LDR      r11,[r5,#4]
;;;1050         rcvevent = sock->rcvevent;
000b7c  f9b5000a          LDRSH    r0,[r5,#0xa]
000b80  9002              STR      r0,[sp,#8]
;;;1051         sendevent = sock->sendevent;
000b82  89a8              LDRH     r0,[r5,#0xc]
000b84  9001              STR      r0,[sp,#4]
;;;1052         errevent = sock->errevent;
000b86  89e8              LDRH     r0,[r5,#0xe]
000b88  9000              STR      r0,[sp,#0]
                  |L1.2954|
;;;1053       }
;;;1054       SYS_ARCH_UNPROTECT(lev);
000b8a  9803              LDR      r0,[sp,#0xc]
000b8c  f7fffffe          BL       sys_arch_unprotect
;;;1055       /* ... then examine it: */
;;;1056       /* See if netconn of this socket is ready for read */
;;;1057       if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
000b90  b32f              CBZ      r7,|L1.3038|
000b92  17e1              ASRS     r1,r4,#31
000b94  eb047151          ADD      r1,r4,r1,LSR #29
000b98  10c9              ASRS     r1,r1,#3
000b9a  5c79              LDRB     r1,[r7,r1]
000b9c  f0040307          AND      r3,r4,#7
000ba0  2201              MOVS     r2,#1
000ba2  409a              LSLS     r2,r2,r3
000ba4  4011              ANDS     r1,r1,r2
000ba6  b1d1              CBZ      r1,|L1.3038|
000ba8  f1bb0f00          CMP      r11,#0
000bac  d102              BNE      |L1.2996|
000bae  9902              LDR      r1,[sp,#8]
000bb0  2900              CMP      r1,#0
000bb2  dd14              BLE      |L1.3038|
                  |L1.2996|
;;;1058         FD_SET(i, &lreadset);
000bb4  17e1              ASRS     r1,r4,#31
000bb6  eb047151          ADD      r1,r4,r1,LSR #29
000bba  10c9              ASRS     r1,r1,#3
000bbc  aa06              ADD      r2,sp,#0x18
000bbe  5c51              LDRB     r1,[r2,r1]
000bc0  f0040307          AND      r3,r4,#7
000bc4  2201              MOVS     r2,#1
000bc6  409a              LSLS     r2,r2,r3
000bc8  4311              ORRS     r1,r1,r2
000bca  4620              MOV      r0,r4
000bcc  17e2              ASRS     r2,r4,#31
000bce  eb047252          ADD      r2,r4,r2,LSR #29
000bd2  10d2              ASRS     r2,r2,#3
000bd4  ab06              ADD      r3,sp,#0x18
000bd6  5499              STRB     r1,[r3,r2]
;;;1059         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
000bd8  bf00              NOP      
000bda  bf00              NOP      
;;;1060         nready++;
000bdc  1c76              ADDS     r6,r6,#1
                  |L1.3038|
;;;1061       }
;;;1062       /* See if netconn of this socket is ready for write */
;;;1063       if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
000bde  f1b80f00          CMP      r8,#0
000be2  d022              BEQ      |L1.3114|
000be4  17e1              ASRS     r1,r4,#31
000be6  eb047151          ADD      r1,r4,r1,LSR #29
000bea  10c9              ASRS     r1,r1,#3
000bec  f8181001          LDRB     r1,[r8,r1]
000bf0  f0040307          AND      r3,r4,#7
000bf4  2201              MOVS     r2,#1
000bf6  409a              LSLS     r2,r2,r3
000bf8  4011              ANDS     r1,r1,r2
000bfa  b1b1              CBZ      r1,|L1.3114|
000bfc  9901              LDR      r1,[sp,#4]
000bfe  b1a1              CBZ      r1,|L1.3114|
;;;1064         FD_SET(i, &lwriteset);
000c00  17e1              ASRS     r1,r4,#31
000c02  eb047151          ADD      r1,r4,r1,LSR #29
000c06  10c9              ASRS     r1,r1,#3
000c08  aa05              ADD      r2,sp,#0x14
000c0a  5c51              LDRB     r1,[r2,r1]
000c0c  f0040307          AND      r3,r4,#7
000c10  2201              MOVS     r2,#1
000c12  409a              LSLS     r2,r2,r3
000c14  4311              ORRS     r1,r1,r2
000c16  4620              MOV      r0,r4
000c18  17e2              ASRS     r2,r4,#31
000c1a  eb047252          ADD      r2,r4,r2,LSR #29
000c1e  10d2              ASRS     r2,r2,#3
000c20  ab05              ADD      r3,sp,#0x14
000c22  5499              STRB     r1,[r3,r2]
;;;1065         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
000c24  bf00              NOP      
000c26  bf00              NOP      
;;;1066         nready++;
000c28  1c76              ADDS     r6,r6,#1
                  |L1.3114|
;;;1067       }
;;;1068       /* See if netconn of this socket had an error */
;;;1069       if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
000c2a  f1b90f00          CMP      r9,#0
000c2e  d02b              BEQ      |L1.3208|
000c30  17e1              ASRS     r1,r4,#31
000c32  eb047151          ADD      r1,r4,r1,LSR #29
000c36  10c9              ASRS     r1,r1,#3
000c38  f8191001          LDRB     r1,[r9,r1]
000c3c  f0040307          AND      r3,r4,#7
000c40  2201              MOVS     r2,#1
000c42  409a              LSLS     r2,r2,r3
000c44  4011              ANDS     r1,r1,r2
000c46  b1f9              CBZ      r1,|L1.3208|
000c48  9900              LDR      r1,[sp,#0]
000c4a  b1e9              CBZ      r1,|L1.3208|
;;;1070         FD_SET(i, &lexceptset);
000c4c  17e1              ASRS     r1,r4,#31
000c4e  eb047151          ADD      r1,r4,r1,LSR #29
000c52  10c9              ASRS     r1,r1,#3
000c54  aa04              ADD      r2,sp,#0x10
000c56  e007              B        |L1.3176|
                  |L1.3160|
                          DCD      err_to_errno_table
                  |L1.3164|
                          DCD      select_cb_list
                  |L1.3168|
                          DCD      select_cb_ctr
                  |L1.3172|
                          DCD      event_callback
                  |L1.3176|
000c68  5c51              LDRB     r1,[r2,r1]
000c6a  f0040307          AND      r3,r4,#7
000c6e  2201              MOVS     r2,#1
000c70  409a              LSLS     r2,r2,r3
000c72  4311              ORRS     r1,r1,r2
000c74  4620              MOV      r0,r4
000c76  17e2              ASRS     r2,r4,#31
000c78  eb047252          ADD      r2,r4,r2,LSR #29
000c7c  10d2              ASRS     r2,r2,#3
000c7e  ab04              ADD      r3,sp,#0x10
000c80  5499              STRB     r1,[r3,r2]
;;;1071         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
000c82  bf00              NOP      
000c84  bf00              NOP      
;;;1072         nready++;
000c86  1c76              ADDS     r6,r6,#1
                  |L1.3208|
000c88  1c64              ADDS     r4,r4,#1              ;1040
                  |L1.3210|
000c8a  4554              CMP      r4,r10                ;1040
000c8c  f6ffaf66          BLT      |L1.2908|
;;;1073       }
;;;1074     }
;;;1075     /* copy local sets to the ones provided as arguments */
;;;1076     *readset_out = lreadset;
000c90  f8bd1018          LDRH     r1,[sp,#0x18]
000c94  9810              LDR      r0,[sp,#0x40]
000c96  8001              STRH     r1,[r0,#0]
000c98  f89d101a          LDRB     r1,[sp,#0x1a]
000c9c  7081              STRB     r1,[r0,#2]
;;;1077     *writeset_out = lwriteset;
000c9e  f8bd1014          LDRH     r1,[sp,#0x14]
000ca2  9811              LDR      r0,[sp,#0x44]
000ca4  8001              STRH     r1,[r0,#0]
000ca6  f89d1016          LDRB     r1,[sp,#0x16]
000caa  7081              STRB     r1,[r0,#2]
;;;1078     *exceptset_out = lexceptset;
000cac  f8bd1010          LDRH     r1,[sp,#0x10]
000cb0  9812              LDR      r0,[sp,#0x48]
000cb2  8001              STRH     r1,[r0,#0]
000cb4  f89d1012          LDRB     r1,[sp,#0x12]
000cb8  7081              STRB     r1,[r0,#2]
;;;1079   
;;;1080     LWIP_ASSERT("nready >= 0", nready >= 0);
000cba  bf00              NOP      
000cbc  bf00              NOP      
;;;1081     return nready;
000cbe  4630              MOV      r0,r6
;;;1082   }
000cc0  b007              ADD      sp,sp,#0x1c
000cc2  e8bd8ff0          POP      {r4-r11,pc}
;;;1083   
                          ENDP

                  lwip_select PROC
;;;1087   int
;;;1088   lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
000cc6  e92d4ff0          PUSH     {r4-r11,lr}
;;;1089               struct timeval *timeout)
;;;1090   {
000cca  b093              SUB      sp,sp,#0x4c
000ccc  4683              MOV      r11,r0
000cce  460d              MOV      r5,r1
000cd0  4616              MOV      r6,r2
000cd2  461f              MOV      r7,r3
000cd4  f8dd8070          LDR      r8,[sp,#0x70]
;;;1091     u32_t waitres = 0;
000cd8  2000              MOVS     r0,#0
000cda  9012              STR      r0,[sp,#0x48]
;;;1092     int nready;
;;;1093     fd_set lreadset, lwriteset, lexceptset;
;;;1094     u32_t msectimeout;
;;;1095     struct lwip_select_cb select_cb;
;;;1096     err_t err;
;;;1097     int i;
;;;1098     SYS_ARCH_DECL_PROTECT(lev);
;;;1099   
;;;1100     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%"S32_F" tvusec=%"S32_F")\n",
000cdc  bf00              NOP      
000cde  bf00              NOP      
;;;1101                     maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
;;;1102                     timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
;;;1103                     timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));
;;;1104   
;;;1105     /* Go through each socket in each list to count number of sockets which
;;;1106        currently match */
;;;1107     nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
000ce0  a80f              ADD      r0,sp,#0x3c
000ce2  a910              ADD      r1,sp,#0x40
000ce4  aa11              ADD      r2,sp,#0x44
000ce6  463b              MOV      r3,r7
000ce8  e9cd2100          STRD     r2,r1,[sp,#0]
000cec  9002              STR      r0,[sp,#8]
000cee  4632              MOV      r2,r6
000cf0  4629              MOV      r1,r5
000cf2  4658              MOV      r0,r11
000cf4  f7fffffe          BL       lwip_selscan
000cf8  4681              MOV      r9,r0
;;;1108   
;;;1109     /* If we don't have any current events, then suspend if we are supposed to */
;;;1110     if (!nready) {
000cfa  f1b90f00          CMP      r9,#0
000cfe  d17d              BNE      |L1.3580|
;;;1111       if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
000d00  f1b80f00          CMP      r8,#0
000d04  d008              BEQ      |L1.3352|
000d06  f8d80000          LDR      r0,[r8,#0]
000d0a  b928              CBNZ     r0,|L1.3352|
000d0c  f8d80004          LDR      r0,[r8,#4]
000d10  b910              CBNZ     r0,|L1.3352|
;;;1112         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
000d12  bf00              NOP      
000d14  bf00              NOP      
;;;1113         /* This is OK as the local fdsets are empty and nready is zero,
;;;1114            or we would have returned earlier. */
;;;1115         goto return_copy_fdsets;
000d16  e121              B        |L1.3932|
                  |L1.3352|
;;;1116       }
;;;1117   
;;;1118       /* None ready: add our semaphore to list:
;;;1119          We don't actually need any dynamic memory. Our entry on the
;;;1120          list is only valid while we are in this function, so it's ok
;;;1121          to use local variables. */
;;;1122   
;;;1123       select_cb.next = NULL;
000d18  2000              MOVS     r0,#0
000d1a  9005              STR      r0,[sp,#0x14]
;;;1124       select_cb.prev = NULL;
000d1c  9006              STR      r0,[sp,#0x18]
;;;1125       select_cb.readset = readset;
000d1e  9507              STR      r5,[sp,#0x1c]
;;;1126       select_cb.writeset = writeset;
000d20  9608              STR      r6,[sp,#0x20]
;;;1127       select_cb.exceptset = exceptset;
000d22  9709              STR      r7,[sp,#0x24]
;;;1128       select_cb.sem_signalled = 0;
000d24  900a              STR      r0,[sp,#0x28]
;;;1129       err = sys_sem_new(&select_cb.sem, 0);
000d26  2100              MOVS     r1,#0
000d28  a80b              ADD      r0,sp,#0x2c
000d2a  f7fffffe          BL       sys_sem_new
000d2e  9004              STR      r0,[sp,#0x10]
;;;1130       if (err != ERR_OK) {
000d30  9804              LDR      r0,[sp,#0x10]
000d32  b120              CBZ      r0,|L1.3390|
;;;1131         /* failed to create semaphore */
;;;1132         set_errno(ENOMEM);
;;;1133         return -1;
000d34  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3384|
;;;1134       }
;;;1135   
;;;1136       /* Protect the select_cb_list */
;;;1137       SYS_ARCH_PROTECT(lev);
;;;1138   
;;;1139       /* Put this select_cb on top of list */
;;;1140       select_cb.next = select_cb_list;
;;;1141       if (select_cb_list != NULL) {
;;;1142         select_cb_list->prev = &select_cb;
;;;1143       }
;;;1144       select_cb_list = &select_cb;
;;;1145       /* Increasing this counter tells even_callback that the list has changed. */
;;;1146       select_cb_ctr++;
;;;1147   
;;;1148       /* Now we can safely unprotect */
;;;1149       SYS_ARCH_UNPROTECT(lev);
;;;1150   
;;;1151       /* Increase select_waiting for each socket we are interested in */
;;;1152       for(i = 0; i < maxfdp1; i++) {
;;;1153         if ((readset && FD_ISSET(i, readset)) ||
;;;1154             (writeset && FD_ISSET(i, writeset)) ||
;;;1155             (exceptset && FD_ISSET(i, exceptset))) {
;;;1156           struct lwip_sock *sock = tryget_socket(i);
;;;1157           LWIP_ASSERT("sock != NULL", sock != NULL);
;;;1158           SYS_ARCH_PROTECT(lev);
;;;1159           sock->select_waiting++;
;;;1160           LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
;;;1161           SYS_ARCH_UNPROTECT(lev);
;;;1162         }
;;;1163       }
;;;1164   
;;;1165       /* Call lwip_selscan again: there could have been events between
;;;1166          the last scan (whithout us on the list) and putting us on the list! */
;;;1167       nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
;;;1168       if (!nready) {
;;;1169         /* Still none ready, just wait to be woken */
;;;1170         if (timeout == 0) {
;;;1171           /* Wait forever */
;;;1172           msectimeout = 0;
;;;1173         } else {
;;;1174           msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
;;;1175           if (msectimeout == 0) {
;;;1176             /* Wait 1ms at least (0 means wait forever) */
;;;1177             msectimeout = 1;
;;;1178           }
;;;1179         }
;;;1180   
;;;1181         waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
;;;1182       }
;;;1183       /* Increase select_waiting for each socket we are interested in */
;;;1184       for(i = 0; i < maxfdp1; i++) {
;;;1185         if ((readset && FD_ISSET(i, readset)) ||
;;;1186             (writeset && FD_ISSET(i, writeset)) ||
;;;1187             (exceptset && FD_ISSET(i, exceptset))) {
;;;1188           struct lwip_sock *sock = tryget_socket(i);
;;;1189           LWIP_ASSERT("sock != NULL", sock != NULL);
;;;1190           SYS_ARCH_PROTECT(lev);
;;;1191           sock->select_waiting--;
;;;1192           LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
;;;1193           SYS_ARCH_UNPROTECT(lev);
;;;1194         }
;;;1195       }
;;;1196       /* Take us off the list */
;;;1197       SYS_ARCH_PROTECT(lev);
;;;1198       if (select_cb.next != NULL) {
;;;1199         select_cb.next->prev = select_cb.prev;
;;;1200       }
;;;1201       if (select_cb_list == &select_cb) {
;;;1202         LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
;;;1203         select_cb_list = select_cb.next;
;;;1204       } else {
;;;1205         LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
;;;1206         select_cb.prev->next = select_cb.next;
;;;1207       }
;;;1208       /* Increasing this counter tells even_callback that the list has changed. */
;;;1209       select_cb_ctr++;
;;;1210       SYS_ARCH_UNPROTECT(lev);
;;;1211   
;;;1212       sys_sem_free(&select_cb.sem);
;;;1213       if (waitres == SYS_ARCH_TIMEOUT)  {
;;;1214         /* Timeout */
;;;1215         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
;;;1216         /* This is OK as the local fdsets are empty and nready is zero,
;;;1217            or we would have returned earlier. */
;;;1218         goto return_copy_fdsets;
;;;1219       }
;;;1220   
;;;1221       /* See what's set */
;;;1222       nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
;;;1223     }
;;;1224   
;;;1225     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
;;;1226   return_copy_fdsets:
;;;1227     set_errno(0);
;;;1228     if (readset) {
;;;1229       *readset = lreadset;
;;;1230     }
;;;1231     if (writeset) {
;;;1232       *writeset = lwriteset;
;;;1233     }
;;;1234     if (exceptset) {
;;;1235       *exceptset = lexceptset;
;;;1236     }
;;;1237   
;;;1238   
;;;1239     return nready;
;;;1240   }
000d38  b013              ADD      sp,sp,#0x4c
000d3a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3390|
000d3e  f7fffffe          BL       sys_arch_protect
000d42  9003              STR      r0,[sp,#0xc]          ;1137
000d44  48f7              LDR      r0,|L1.4388|
000d46  6800              LDR      r0,[r0,#0]            ;1140  ; select_cb_list
000d48  9005              STR      r0,[sp,#0x14]         ;1140
000d4a  48f6              LDR      r0,|L1.4388|
000d4c  6800              LDR      r0,[r0,#0]            ;1141  ; select_cb_list
000d4e  b118              CBZ      r0,|L1.3416|
000d50  a805              ADD      r0,sp,#0x14           ;1142
000d52  49f4              LDR      r1,|L1.4388|
000d54  6809              LDR      r1,[r1,#0]            ;1142  ; select_cb_list
000d56  6048              STR      r0,[r1,#4]            ;1142
                  |L1.3416|
000d58  a805              ADD      r0,sp,#0x14           ;1144
000d5a  49f2              LDR      r1,|L1.4388|
000d5c  6008              STR      r0,[r1,#0]            ;1144  ; select_cb_list
000d5e  48f2              LDR      r0,|L1.4392|
000d60  6800              LDR      r0,[r0,#0]            ;1146  ; select_cb_ctr
000d62  1c40              ADDS     r0,r0,#1              ;1146
000d64  49f0              LDR      r1,|L1.4392|
000d66  6008              STR      r0,[r1,#0]            ;1146  ; select_cb_ctr
000d68  9803              LDR      r0,[sp,#0xc]          ;1149
000d6a  f7fffffe          BL       sys_arch_unprotect
000d6e  2400              MOVS     r4,#0                 ;1152
000d70  e041              B        |L1.3574|
                  |L1.3442|
000d72  b16d              CBZ      r5,|L1.3472|
000d74  17e3              ASRS     r3,r4,#31             ;1153
000d76  eb047353          ADD      r3,r4,r3,LSR #29      ;1153
000d7a  10db              ASRS     r3,r3,#3              ;1153
000d7c  5ceb              LDRB     r3,[r5,r3]            ;1153
000d7e  f0040e07          AND      lr,r4,#7              ;1153
000d82  f04f0c01          MOV      r12,#1                ;1153
000d86  fa0cfc0e          LSL      r12,r12,lr            ;1153
000d8a  ea03030c          AND      r3,r3,r12             ;1153
000d8e  b9eb              CBNZ     r3,|L1.3532|
                  |L1.3472|
000d90  b16e              CBZ      r6,|L1.3502|
000d92  17e3              ASRS     r3,r4,#31             ;1154
000d94  eb047353          ADD      r3,r4,r3,LSR #29      ;1154
000d98  10db              ASRS     r3,r3,#3              ;1154
000d9a  5cf3              LDRB     r3,[r6,r3]            ;1154
000d9c  f0040e07          AND      lr,r4,#7              ;1154
000da0  f04f0c01          MOV      r12,#1                ;1154
000da4  fa0cfc0e          LSL      r12,r12,lr            ;1154
000da8  ea03030c          AND      r3,r3,r12             ;1154
000dac  b973              CBNZ     r3,|L1.3532|
                  |L1.3502|
000dae  b30f              CBZ      r7,|L1.3572|
000db0  17e3              ASRS     r3,r4,#31             ;1155
000db2  eb047353          ADD      r3,r4,r3,LSR #29      ;1155
000db6  10db              ASRS     r3,r3,#3              ;1155
000db8  5cfb              LDRB     r3,[r7,r3]            ;1155
000dba  f0040e07          AND      lr,r4,#7              ;1155
000dbe  f04f0c01          MOV      r12,#1                ;1155
000dc2  fa0cfc0e          LSL      r12,r12,lr            ;1155
000dc6  ea03030c          AND      r3,r3,r12             ;1155
000dca  b19b              CBZ      r3,|L1.3572|
                  |L1.3532|
000dcc  4620              MOV      r0,r4                 ;1156
000dce  f7fffffe          BL       tryget_socket
000dd2  9002              STR      r0,[sp,#8]            ;1156
000dd4  bf00              NOP                            ;1157
000dd6  bf00              NOP                            ;1157
000dd8  f7fffffe          BL       sys_arch_protect
000ddc  9003              STR      r0,[sp,#0xc]          ;1158
000dde  9802              LDR      r0,[sp,#8]            ;1159
000de0  6940              LDR      r0,[r0,#0x14]         ;1159
000de2  1c40              ADDS     r0,r0,#1              ;1159
000de4  9902              LDR      r1,[sp,#8]            ;1159
000de6  6148              STR      r0,[r1,#0x14]         ;1159
000de8  bf00              NOP                            ;1160
000dea  bf00              NOP                            ;1160
000dec  9803              LDR      r0,[sp,#0xc]          ;1161
000dee  f7fffffe          BL       sys_arch_unprotect
000df2  bf00              NOP                            ;1162
                  |L1.3572|
000df4  1c64              ADDS     r4,r4,#1              ;1152
                  |L1.3574|
000df6  455c              CMP      r4,r11                ;1152
000df8  dbbb              BLT      |L1.3442|
000dfa  e000              B        |L1.3582|
                  |L1.3580|
000dfc  e0ab              B        |L1.3926|
                  |L1.3582|
000dfe  a80f              ADD      r0,sp,#0x3c           ;1167
000e00  a910              ADD      r1,sp,#0x40           ;1167
000e02  aa11              ADD      r2,sp,#0x44           ;1167
000e04  463b              MOV      r3,r7                 ;1167
000e06  e9cd2100          STRD     r2,r1,[sp,#0]         ;1167
000e0a  9002              STR      r0,[sp,#8]            ;1167
000e0c  4632              MOV      r2,r6                 ;1167
000e0e  4629              MOV      r1,r5                 ;1167
000e10  4658              MOV      r0,r11                ;1167
000e12  f7fffffe          BL       lwip_selscan
000e16  4681              MOV      r9,r0                 ;1167
000e18  f1b90f00          CMP      r9,#0                 ;1168
000e1c  d11f              BNE      |L1.3678|
000e1e  f1b80f00          CMP      r8,#0                 ;1170
000e22  d102              BNE      |L1.3626|
000e24  f04f0a00          MOV      r10,#0                ;1172
000e28  e014              B        |L1.3668|
                  |L1.3626|
000e2a  f8d80004          LDR      r0,[r8,#4]            ;1174
000e2e  f50070fa          ADD      r0,r0,#0x1f4          ;1174
000e32  f44f717a          MOV      r1,#0x3e8             ;1174
000e36  fb90f0f1          SDIV     r0,r0,r1              ;1174
000e3a  f8d81000          LDR      r1,[r8,#0]            ;1174
000e3e  eb010241          ADD      r2,r1,r1,LSL #1       ;1174
000e42  ebc211c1          RSB      r1,r2,r1,LSL #7       ;1174
000e46  eb000ac1          ADD      r10,r0,r1,LSL #3      ;1174
000e4a  f1ba0f00          CMP      r10,#0                ;1175
000e4e  d101              BNE      |L1.3668|
000e50  f04f0a01          MOV      r10,#1                ;1177
                  |L1.3668|
000e54  4651              MOV      r1,r10                ;1181
000e56  a80b              ADD      r0,sp,#0x2c           ;1181
000e58  f7fffffe          BL       sys_arch_sem_wait
000e5c  9012              STR      r0,[sp,#0x48]         ;1181
                  |L1.3678|
000e5e  2400              MOVS     r4,#0                 ;1184
000e60  e041              B        |L1.3814|
                  |L1.3682|
000e62  b16d              CBZ      r5,|L1.3712|
000e64  17e3              ASRS     r3,r4,#31             ;1185
000e66  eb047353          ADD      r3,r4,r3,LSR #29      ;1185
000e6a  10db              ASRS     r3,r3,#3              ;1185
000e6c  5ceb              LDRB     r3,[r5,r3]            ;1185
000e6e  f0040e07          AND      lr,r4,#7              ;1185
000e72  f04f0c01          MOV      r12,#1                ;1185
000e76  fa0cfc0e          LSL      r12,r12,lr            ;1185
000e7a  ea03030c          AND      r3,r3,r12             ;1185
000e7e  b9eb              CBNZ     r3,|L1.3772|
                  |L1.3712|
000e80  b16e              CBZ      r6,|L1.3742|
000e82  17e3              ASRS     r3,r4,#31             ;1186
000e84  eb047353          ADD      r3,r4,r3,LSR #29      ;1186
000e88  10db              ASRS     r3,r3,#3              ;1186
000e8a  5cf3              LDRB     r3,[r6,r3]            ;1186
000e8c  f0040e07          AND      lr,r4,#7              ;1186
000e90  f04f0c01          MOV      r12,#1                ;1186
000e94  fa0cfc0e          LSL      r12,r12,lr            ;1186
000e98  ea03030c          AND      r3,r3,r12             ;1186
000e9c  b973              CBNZ     r3,|L1.3772|
                  |L1.3742|
000e9e  b30f              CBZ      r7,|L1.3812|
000ea0  17e3              ASRS     r3,r4,#31             ;1187
000ea2  eb047353          ADD      r3,r4,r3,LSR #29      ;1187
000ea6  10db              ASRS     r3,r3,#3              ;1187
000ea8  5cfb              LDRB     r3,[r7,r3]            ;1187
000eaa  f0040e07          AND      lr,r4,#7              ;1187
000eae  f04f0c01          MOV      r12,#1                ;1187
000eb2  fa0cfc0e          LSL      r12,r12,lr            ;1187
000eb6  ea03030c          AND      r3,r3,r12             ;1187
000eba  b19b              CBZ      r3,|L1.3812|
                  |L1.3772|
000ebc  4620              MOV      r0,r4                 ;1188
000ebe  f7fffffe          BL       tryget_socket
000ec2  9002              STR      r0,[sp,#8]            ;1188
000ec4  bf00              NOP                            ;1189
000ec6  bf00              NOP                            ;1189
000ec8  f7fffffe          BL       sys_arch_protect
000ecc  9003              STR      r0,[sp,#0xc]          ;1190
000ece  9802              LDR      r0,[sp,#8]            ;1191
000ed0  6940              LDR      r0,[r0,#0x14]         ;1191
000ed2  1e40              SUBS     r0,r0,#1              ;1191
000ed4  9902              LDR      r1,[sp,#8]            ;1191
000ed6  6148              STR      r0,[r1,#0x14]         ;1191
000ed8  bf00              NOP                            ;1192
000eda  bf00              NOP                            ;1192
000edc  9803              LDR      r0,[sp,#0xc]          ;1193
000ede  f7fffffe          BL       sys_arch_unprotect
000ee2  bf00              NOP                            ;1194
                  |L1.3812|
000ee4  1c64              ADDS     r4,r4,#1              ;1184
                  |L1.3814|
000ee6  455c              CMP      r4,r11                ;1184
000ee8  dbbb              BLT      |L1.3682|
000eea  f7fffffe          BL       sys_arch_protect
000eee  9003              STR      r0,[sp,#0xc]          ;1197
000ef0  9805              LDR      r0,[sp,#0x14]         ;1198
000ef2  b110              CBZ      r0,|L1.3834|
000ef4  e9dd1005          LDRD     r1,r0,[sp,#0x14]      ;1199
000ef8  6048              STR      r0,[r1,#4]            ;1199
                  |L1.3834|
000efa  488a              LDR      r0,|L1.4388|
000efc  6800              LDR      r0,[r0,#0]            ;1201  ; select_cb_list
000efe  a905              ADD      r1,sp,#0x14           ;1201
000f00  4288              CMP      r0,r1                 ;1201
000f02  d105              BNE      |L1.3856|
000f04  bf00              NOP                            ;1202
000f06  bf00              NOP                            ;1202
000f08  4986              LDR      r1,|L1.4388|
000f0a  9805              LDR      r0,[sp,#0x14]         ;1203
000f0c  6008              STR      r0,[r1,#0]            ;1203  ; select_cb_list
000f0e  e004              B        |L1.3866|
                  |L1.3856|
000f10  bf00              NOP                            ;1205
000f12  bf00              NOP                            ;1205
000f14  e9dd0105          LDRD     r0,r1,[sp,#0x14]      ;1206
000f18  6008              STR      r0,[r1,#0]            ;1206
                  |L1.3866|
000f1a  4883              LDR      r0,|L1.4392|
000f1c  6800              LDR      r0,[r0,#0]            ;1209  ; select_cb_ctr
000f1e  1c40              ADDS     r0,r0,#1              ;1209
000f20  4981              LDR      r1,|L1.4392|
000f22  6008              STR      r0,[r1,#0]            ;1209  ; select_cb_ctr
000f24  9803              LDR      r0,[sp,#0xc]          ;1210
000f26  f7fffffe          BL       sys_arch_unprotect
000f2a  a80b              ADD      r0,sp,#0x2c           ;1212
000f2c  f7fffffe          BL       sys_sem_free
000f30  9812              LDR      r0,[sp,#0x48]         ;1213
000f32  1c40              ADDS     r0,r0,#1              ;1213
000f34  b910              CBNZ     r0,|L1.3900|
000f36  bf00              NOP                            ;1215
000f38  bf00              NOP                            ;1215
000f3a  e00f              B        |L1.3932|
                  |L1.3900|
000f3c  a80f              ADD      r0,sp,#0x3c           ;1222
000f3e  a910              ADD      r1,sp,#0x40           ;1222
000f40  aa11              ADD      r2,sp,#0x44           ;1222
000f42  463b              MOV      r3,r7                 ;1222
000f44  e9cd2100          STRD     r2,r1,[sp,#0]         ;1222
000f48  9002              STR      r0,[sp,#8]            ;1222
000f4a  4632              MOV      r2,r6                 ;1222
000f4c  4629              MOV      r1,r5                 ;1222
000f4e  4658              MOV      r0,r11                ;1222
000f50  f7fffffe          BL       lwip_selscan
000f54  4681              MOV      r9,r0                 ;1222
                  |L1.3926|
000f56  bf00              NOP                            ;1225
000f58  bf00              NOP                            ;1225
000f5a  bf00              NOP                            ;1226
                  |L1.3932|
000f5c  b12d              CBZ      r5,|L1.3946|
000f5e  f8bd0044          LDRH     r0,[sp,#0x44]         ;1229
000f62  8028              STRH     r0,[r5,#0]            ;1229
000f64  f89d0046          LDRB     r0,[sp,#0x46]         ;1229
000f68  70a8              STRB     r0,[r5,#2]            ;1229
                  |L1.3946|
000f6a  b12e              CBZ      r6,|L1.3960|
000f6c  f8bd0040          LDRH     r0,[sp,#0x40]         ;1232
000f70  8030              STRH     r0,[r6,#0]            ;1232
000f72  f89d0042          LDRB     r0,[sp,#0x42]         ;1232
000f76  70b0              STRB     r0,[r6,#2]            ;1232
                  |L1.3960|
000f78  b12f              CBZ      r7,|L1.3974|
000f7a  f8bd003c          LDRH     r0,[sp,#0x3c]         ;1235
000f7e  8038              STRH     r0,[r7,#0]            ;1235
000f80  f89d003e          LDRB     r0,[sp,#0x3e]         ;1235
000f84  70b8              STRB     r0,[r7,#2]            ;1235
                  |L1.3974|
000f86  4648              MOV      r0,r9                 ;1239
000f88  e6d6              B        |L1.3384|
;;;1241   
                          ENDP

                  lwip_shutdown PROC
;;;1366   int
;;;1367   lwip_shutdown(int s, int how)
000f8a  e92d47f0          PUSH     {r4-r10,lr}
;;;1368   {
000f8e  4607              MOV      r7,r0
000f90  460e              MOV      r6,r1
;;;1369     struct lwip_sock *sock;
;;;1370     err_t err;
;;;1371     u8_t shut_rx = 0, shut_tx = 0;
000f92  f04f0800          MOV      r8,#0
000f96  46c1              MOV      r9,r8
;;;1372   
;;;1373     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
000f98  bf00              NOP      
000f9a  bf00              NOP      
;;;1374   
;;;1375     sock = get_socket(s);
000f9c  4638              MOV      r0,r7
000f9e  f7fffffe          BL       get_socket
000fa2  4604              MOV      r4,r0
;;;1376     if (!sock) {
000fa4  b91c              CBNZ     r4,|L1.4014|
;;;1377       return -1;
000fa6  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4010|
;;;1378     }
;;;1379   
;;;1380     if (sock->conn != NULL) {
;;;1381       if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;1382         sock_set_errno(sock, EOPNOTSUPP);
;;;1383         return EOPNOTSUPP;
;;;1384       }
;;;1385     } else {
;;;1386       sock_set_errno(sock, ENOTCONN);
;;;1387       return ENOTCONN;
;;;1388     }
;;;1389   
;;;1390     if (how == SHUT_RD) {
;;;1391       shut_rx = 1;
;;;1392     } else if (how == SHUT_WR) {
;;;1393       shut_tx = 1;
;;;1394     } else if(how == SHUT_RDWR) {
;;;1395       shut_rx = 1;
;;;1396       shut_tx = 1;
;;;1397     } else {
;;;1398       sock_set_errno(sock, EINVAL);
;;;1399       return EINVAL;
;;;1400     }
;;;1401     err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
;;;1402   
;;;1403     sock_set_errno(sock, err_to_errno(err));
;;;1404     return (err == ERR_OK ? 0 : -1);
;;;1405   }
000faa  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4014|
000fae  6820              LDR      r0,[r4,#0]            ;1380
000fb0  b140              CBZ      r0,|L1.4036|
000fb2  6820              LDR      r0,[r4,#0]            ;1381
000fb4  7800              LDRB     r0,[r0,#0]            ;1381
000fb6  2810              CMP      r0,#0x10              ;1381
000fb8  d009              BEQ      |L1.4046|
000fba  bf00              NOP                            ;1382
000fbc  205f              MOVS     r0,#0x5f              ;1382
000fbe  6120              STR      r0,[r4,#0x10]         ;1382
000fc0  bf00              NOP                            ;1382
000fc2  e7f2              B        |L1.4010|
                  |L1.4036|
000fc4  bf00              NOP                            ;1386
000fc6  206b              MOVS     r0,#0x6b              ;1386
000fc8  6120              STR      r0,[r4,#0x10]         ;1386
000fca  bf00              NOP                            ;1386
000fcc  e7ed              B        |L1.4010|
                  |L1.4046|
000fce  b916              CBNZ     r6,|L1.4054|
000fd0  f04f0801          MOV      r8,#1                 ;1391
000fd4  e00f              B        |L1.4086|
                  |L1.4054|
000fd6  2e01              CMP      r6,#1                 ;1392
000fd8  d101              BNE      |L1.4062|
000fda  46b1              MOV      r9,r6                 ;1393
000fdc  e00b              B        |L1.4086|
                  |L1.4062|
000fde  2e02              CMP      r6,#2                 ;1394
000fe0  d104              BNE      |L1.4076|
000fe2  f04f0801          MOV      r8,#1                 ;1395
000fe6  f04f0901          MOV      r9,#1                 ;1396
000fea  e004              B        |L1.4086|
                  |L1.4076|
000fec  bf00              NOP                            ;1398
000fee  2016              MOVS     r0,#0x16              ;1398
000ff0  6120              STR      r0,[r4,#0x10]         ;1398
000ff2  bf00              NOP                            ;1398
000ff4  e7d9              B        |L1.4010|
                  |L1.4086|
000ff6  464a              MOV      r2,r9                 ;1401
000ff8  4641              MOV      r1,r8                 ;1401
000ffa  6820              LDR      r0,[r4,#0]            ;1401
000ffc  f7fffffe          BL       netconn_shutdown
001000  4605              MOV      r5,r0                 ;1401
001002  bf00              NOP                            ;1403
001004  4268              RSBS     r0,r5,#0              ;1403
001006  2810              CMP      r0,#0x10              ;1403
001008  d204              BCS      |L1.4116|
00100a  4848              LDR      r0,|L1.4396|
00100c  4269              RSBS     r1,r5,#0              ;1403
00100e  f8500021          LDR      r0,[r0,r1,LSL #2]     ;1403
001012  e000              B        |L1.4118|
                  |L1.4116|
001014  2005              MOVS     r0,#5                 ;1403
                  |L1.4118|
001016  6120              STR      r0,[r4,#0x10]         ;1403
001018  bf00              NOP                            ;1403
00101a  b90d              CBNZ     r5,|L1.4128|
00101c  2000              MOVS     r0,#0                 ;1404
00101e  e7c4              B        |L1.4010|
                  |L1.4128|
001020  f04f30ff          MOV      r0,#0xffffffff        ;1404
001024  e7c1              B        |L1.4010|
;;;1406   
                          ENDP

                  lwip_getaddrname PROC
;;;1407   static int
;;;1408   lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
001026  e92d41f0          PUSH     {r4-r8,lr}
;;;1409   {
00102a  b086              SUB      sp,sp,#0x18
00102c  4607              MOV      r7,r0
00102e  460e              MOV      r6,r1
001030  4614              MOV      r4,r2
001032  4698              MOV      r8,r3
;;;1410     struct lwip_sock *sock;
;;;1411     struct sockaddr_in sin;
;;;1412     ip_addr_t naddr;
;;;1413   
;;;1414     sock = get_socket(s);
001034  4638              MOV      r0,r7
001036  f7fffffe          BL       get_socket
00103a  4605              MOV      r5,r0
;;;1415     if (!sock) {
00103c  b925              CBNZ     r5,|L1.4168|
;;;1416       return -1;
00103e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4162|
;;;1417     }
;;;1418   
;;;1419     memset(&sin, 0, sizeof(sin));
;;;1420     sin.sin_len = sizeof(sin);
;;;1421     sin.sin_family = AF_INET;
;;;1422   
;;;1423     /* get the IP address and port */
;;;1424     netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
;;;1425   
;;;1426     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
;;;1427     ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
;;;1428     LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));
;;;1429   
;;;1430     sin.sin_port = htons(sin.sin_port);
;;;1431     inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
;;;1432   
;;;1433     if (*namelen > sizeof(sin)) {
;;;1434       *namelen = sizeof(sin);
;;;1435     }
;;;1436   
;;;1437     MEMCPY(name, &sin, *namelen);
;;;1438     sock_set_errno(sock, 0);
;;;1439     return 0;
;;;1440   }
001042  b006              ADD      sp,sp,#0x18
001044  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4168|
001048  2000              MOVS     r0,#0                 ;1419
00104a  9002              STR      r0,[sp,#8]            ;1419
00104c  9003              STR      r0,[sp,#0xc]          ;1419
00104e  9004              STR      r0,[sp,#0x10]         ;1419
001050  9005              STR      r0,[sp,#0x14]         ;1419
001052  2010              MOVS     r0,#0x10              ;1420
001054  f88d0008          STRB     r0,[sp,#8]            ;1420
001058  2002              MOVS     r0,#2                 ;1421
00105a  f88d0009          STRB     r0,[sp,#9]            ;1421
00105e  4643              MOV      r3,r8                 ;1424
001060  f10d020a          ADD      r2,sp,#0xa            ;1424
001064  a901              ADD      r1,sp,#4              ;1424
001066  6828              LDR      r0,[r5,#0]            ;1424
001068  f7fffffe          BL       netconn_getaddr
00106c  bf00              NOP                            ;1426
00106e  bf00              NOP                            ;1426
001070  bf00              NOP                            ;1427
001072  bf00              NOP                            ;1427
001074  bf00              NOP                            ;1428
001076  bf00              NOP                            ;1428
001078  f8bd000a          LDRH     r0,[sp,#0xa]          ;1430
00107c  f7fffffe          BL       lwip_htons
001080  f8ad000a          STRH     r0,[sp,#0xa]          ;1430
001084  9801              LDR      r0,[sp,#4]            ;1431
001086  9003              STR      r0,[sp,#0xc]          ;1431
001088  6820              LDR      r0,[r4,#0]            ;1433
00108a  2810              CMP      r0,#0x10              ;1433
00108c  d901              BLS      |L1.4242|
00108e  2010              MOVS     r0,#0x10              ;1434
001090  6020              STR      r0,[r4,#0]            ;1434
                  |L1.4242|
001092  a902              ADD      r1,sp,#8              ;1437
001094  4630              MOV      r0,r6                 ;1437
001096  6822              LDR      r2,[r4,#0]            ;1437
001098  f7fffffe          BL       __aeabi_memcpy
00109c  bf00              NOP                            ;1438
00109e  2000              MOVS     r0,#0                 ;1438
0010a0  6128              STR      r0,[r5,#0x10]         ;1438
0010a2  bf00              NOP                            ;1438
0010a4  bf00              NOP                            ;1439
0010a6  e7cc              B        |L1.4162|
;;;1441   
                          ENDP

                  lwip_getpeername PROC
;;;1442   int
;;;1443   lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
0010a8  b570              PUSH     {r4-r6,lr}
;;;1444   {
0010aa  4604              MOV      r4,r0
0010ac  460d              MOV      r5,r1
0010ae  4616              MOV      r6,r2
;;;1445     return lwip_getaddrname(s, name, namelen, 0);
0010b0  2300              MOVS     r3,#0
0010b2  4632              MOV      r2,r6
0010b4  4629              MOV      r1,r5
0010b6  4620              MOV      r0,r4
0010b8  f7fffffe          BL       lwip_getaddrname
;;;1446   }
0010bc  bd70              POP      {r4-r6,pc}
;;;1447   
                          ENDP

                  lwip_getsockname PROC
;;;1448   int
;;;1449   lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
0010be  b570              PUSH     {r4-r6,lr}
;;;1450   {
0010c0  4604              MOV      r4,r0
0010c2  460d              MOV      r5,r1
0010c4  4616              MOV      r6,r2
;;;1451     return lwip_getaddrname(s, name, namelen, 1);
0010c6  2301              MOVS     r3,#1
0010c8  4632              MOV      r2,r6
0010ca  4629              MOV      r1,r5
0010cc  4620              MOV      r0,r4
0010ce  f7fffffe          BL       lwip_getaddrname
;;;1452   }
0010d2  bd70              POP      {r4-r6,pc}
;;;1453   
                          ENDP

                  lwip_getsockopt_internal PROC
;;;1654   static void
;;;1655   lwip_getsockopt_internal(void *arg)
0010d4  e92d47f0          PUSH     {r4-r10,lr}
;;;1656   {
0010d8  4606              MOV      r6,r0
;;;1657     struct lwip_sock *sock;
;;;1658   #ifdef LWIP_DEBUG
;;;1659     int s;
;;;1660   #endif /* LWIP_DEBUG */
;;;1661     int level, optname;
;;;1662     void *optval;
;;;1663     struct lwip_setgetsockopt_data *data;
;;;1664   
;;;1665     LWIP_ASSERT("arg != NULL", arg != NULL);
0010da  bf00              NOP      
0010dc  bf00              NOP      
;;;1666   
;;;1667     data = (struct lwip_setgetsockopt_data*)arg;
0010de  46b0              MOV      r8,r6
;;;1668     sock = data->sock;
0010e0  4646              MOV      r6,r8
0010e2  f8d84000          LDR      r4,[r8,#0]
;;;1669   #ifdef LWIP_DEBUG
;;;1670     s = data->s;
0010e6  f8d8a004          LDR      r10,[r8,#4]
;;;1671   #endif /* LWIP_DEBUG */
;;;1672     level = data->level;
0010ea  f8d89008          LDR      r9,[r8,#8]
;;;1673     optname = data->optname;
0010ee  f8d8700c          LDR      r7,[r8,#0xc]
;;;1674     optval = data->optval;
0010f2  f8d85010          LDR      r5,[r8,#0x10]
;;;1675   
;;;1676     switch (level) {
0010f6  f1b90f00          CMP      r9,#0
0010fa  d072              BEQ      |L1.4578|
0010fc  f1b90f06          CMP      r9,#6
001100  d06d              BEQ      |L1.4574|
001102  f6a970ff          SUB      r0,r9,#0xfff
001106  2800              CMP      r0,#0
001108  d16a              BNE      |L1.4576|
;;;1677   
;;;1678   /* Level: SOL_SOCKET */
;;;1679     case SOL_SOCKET:
;;;1680       switch (optname) {
00110a  f2410107          MOV      r1,#0x1007
00110e  1a78              SUBS     r0,r7,r1
001110  428f              CMP      r7,r1
001112  d039              BEQ      |L1.4488|
001114  dc0c              BGT      |L1.4400|
001116  2f02              CMP      r7,#2
001118  d00f              BEQ      |L1.4410|
00111a  2f08              CMP      r7,#8
00111c  d00f              BEQ      |L1.4414|
00111e  2f20              CMP      r7,#0x20
001120  d157              BNE      |L1.4562|
001122  e00b              B        |L1.4412|
                  |L1.4388|
                          DCD      select_cb_list
                  |L1.4392|
                          DCD      select_cb_ctr
                  |L1.4396|
                          DCD      err_to_errno_table
                  |L1.4400|
001130  2801              CMP      r0,#1
001132  d00c              BEQ      |L1.4430|
001134  2803              CMP      r0,#3
001136  d14c              BNE      |L1.4562|
001138  e044              B        |L1.4548|
                  |L1.4410|
;;;1681   
;;;1682       /* The option flags */
;;;1683       case SO_ACCEPTCONN:
;;;1684       case SO_BROADCAST:
00113a  bf00              NOP      
                  |L1.4412|
;;;1685       /* UNIMPL case SO_DEBUG: */
;;;1686       /* UNIMPL case SO_DONTROUTE: */
;;;1687       case SO_KEEPALIVE:
00113c  bf00              NOP      
                  |L1.4414|
;;;1688       /* UNIMPL case SO_OOBINCLUDE: */
;;;1689   #if SO_REUSE
;;;1690       case SO_REUSEADDR:
;;;1691       case SO_REUSEPORT:
;;;1692   #endif /* SO_REUSE */
;;;1693       /*case SO_USELOOPBACK: UNIMPL */
;;;1694         *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
00113e  6820              LDR      r0,[r4,#0]
001140  6840              LDR      r0,[r0,#4]
001142  7a00              LDRB     r0,[r0,#8]
001144  4038              ANDS     r0,r0,r7
001146  6028              STR      r0,[r5,#0]
;;;1695         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
001148  bf00              NOP      
00114a  bf00              NOP      
;;;1696                                     s, optname, (*(int*)optval?"on":"off")));
;;;1697         break;
00114c  e044              B        |L1.4568|
                  |L1.4430|
;;;1698   
;;;1699       case SO_TYPE:
;;;1700         switch (NETCONNTYPE_GROUP(sock->conn->type)) {
00114e  6820              LDR      r0,[r4,#0]
001150  7800              LDRB     r0,[r0,#0]
001152  f00000f0          AND      r0,r0,#0xf0
001156  2810              CMP      r0,#0x10
001158  d006              BEQ      |L1.4456|
00115a  2820              CMP      r0,#0x20
00115c  d007              BEQ      |L1.4462|
00115e  2840              CMP      r0,#0x40
001160  d108              BNE      |L1.4468|
;;;1701         case NETCONN_RAW:
;;;1702           *(int*)optval = SOCK_RAW;
001162  2003              MOVS     r0,#3
001164  6028              STR      r0,[r5,#0]
;;;1703           break;
001166  e00b              B        |L1.4480|
                  |L1.4456|
;;;1704         case NETCONN_TCP:
;;;1705           *(int*)optval = SOCK_STREAM;
001168  2001              MOVS     r0,#1
00116a  6028              STR      r0,[r5,#0]
;;;1706           break;
00116c  e008              B        |L1.4480|
                  |L1.4462|
;;;1707         case NETCONN_UDP:
;;;1708           *(int*)optval = SOCK_DGRAM;
00116e  2002              MOVS     r0,#2
001170  6028              STR      r0,[r5,#0]
;;;1709           break;
001172  e005              B        |L1.4480|
                  |L1.4468|
;;;1710         default: /* unrecognized socket type */
;;;1711           *(int*)optval = sock->conn->type;
001174  6820              LDR      r0,[r4,#0]
001176  7800              LDRB     r0,[r0,#0]
001178  6028              STR      r0,[r5,#0]
;;;1712           LWIP_DEBUGF(SOCKETS_DEBUG,
00117a  bf00              NOP      
00117c  bf00              NOP      
00117e  bf00              NOP                            ;1700
                  |L1.4480|
001180  bf00              NOP                            ;1703
;;;1713                       ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
;;;1714                       s, *(int *)optval));
;;;1715         }  /* switch (sock->conn->type) */
;;;1716         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
001182  bf00              NOP      
001184  bf00              NOP      
;;;1717                     s, *(int *)optval));
;;;1718         break;
001186  e027              B        |L1.4568|
                  |L1.4488|
;;;1719   
;;;1720       case SO_ERROR:
;;;1721         /* only overwrite ERR_OK or tempoary errors */
;;;1722         if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
001188  6920              LDR      r0,[r4,#0x10]
00118a  b110              CBZ      r0,|L1.4498|
00118c  6920              LDR      r0,[r4,#0x10]
00118e  2873              CMP      r0,#0x73
001190  d111              BNE      |L1.4534|
                  |L1.4498|
;;;1723           sock_set_errno(sock, err_to_errno(sock->conn->last_err));
001192  bf00              NOP      
001194  6820              LDR      r0,[r4,#0]
001196  f9900008          LDRSB    r0,[r0,#8]
00119a  4240              RSBS     r0,r0,#0
00119c  2810              CMP      r0,#0x10
00119e  d207              BCS      |L1.4528|
0011a0  6820              LDR      r0,[r4,#0]
0011a2  f9900008          LDRSB    r0,[r0,#8]
0011a6  4240              RSBS     r0,r0,#0
0011a8  49f9              LDR      r1,|L1.5520|
0011aa  f8510020          LDR      r0,[r1,r0,LSL #2]
0011ae  e000              B        |L1.4530|
                  |L1.4528|
0011b0  2005              MOVS     r0,#5
                  |L1.4530|
0011b2  6120              STR      r0,[r4,#0x10]
0011b4  bf00              NOP      
                  |L1.4534|
;;;1724         } 
;;;1725         *(int *)optval = sock->err;
0011b6  6920              LDR      r0,[r4,#0x10]
0011b8  6028              STR      r0,[r5,#0]
;;;1726         sock->err = 0;
0011ba  2000              MOVS     r0,#0
0011bc  6120              STR      r0,[r4,#0x10]
;;;1727         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
0011be  bf00              NOP      
0011c0  bf00              NOP      
;;;1728                     s, *(int *)optval));
;;;1729         break;
0011c2  e009              B        |L1.4568|
                  |L1.4548|
;;;1730   
;;;1731   #if LWIP_SO_SNDTIMEO
;;;1732       case SO_SNDTIMEO:
;;;1733         *(int *)optval = netconn_get_sendtimeout(sock->conn);
;;;1734         break;
;;;1735   #endif /* LWIP_SO_SNDTIMEO */
;;;1736   #if LWIP_SO_RCVTIMEO
;;;1737       case SO_RCVTIMEO:
;;;1738         *(int *)optval = netconn_get_recvtimeout(sock->conn);
;;;1739         break;
;;;1740   #endif /* LWIP_SO_RCVTIMEO */
;;;1741   #if LWIP_SO_RCVBUF
;;;1742       case SO_RCVBUF:
;;;1743         *(int *)optval = netconn_get_recvbufsize(sock->conn);
;;;1744         break;
;;;1745   #endif /* LWIP_SO_RCVBUF */
;;;1746   #if LWIP_UDP
;;;1747       case SO_NO_CHECK:
;;;1748         *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
0011c4  6820              LDR      r0,[r4,#0]
0011c6  6840              LDR      r0,[r0,#4]
0011c8  7c00              LDRB     r0,[r0,#0x10]
0011ca  f0000001          AND      r0,r0,#1
0011ce  6028              STR      r0,[r5,#0]
;;;1749         break;
0011d0  e002              B        |L1.4568|
                  |L1.4562|
;;;1750   #endif /* LWIP_UDP*/
;;;1751       default:
;;;1752         LWIP_ASSERT("unhandled optname", 0);
0011d2  bf00              NOP      
0011d4  bf00              NOP      
;;;1753         break;
0011d6  bf00              NOP      
                  |L1.4568|
0011d8  bf00              NOP                            ;1697
;;;1754       }  /* switch (optname) */
;;;1755       break;
0011da  e057              B        |L1.4748|
0011dc  e001              B        |L1.4578|
                  |L1.4574|
0011de  e037              B        |L1.4688|
                  |L1.4576|
0011e0  e051              B        |L1.4742|
                  |L1.4578|
;;;1756   
;;;1757   /* Level: IPPROTO_IP */
;;;1758     case IPPROTO_IP:
;;;1759       switch (optname) {
0011e2  2f08              CMP      r7,#8
0011e4  d22f              BCS      |L1.4678|
0011e6  e8dff007          TBB      [pc,r7]
0011ea  2e0b              DCB      0x2e,0x0b
0011ec  042e2e12          DCB      0x04,0x2e,0x2e,0x12
0011f0  1920              DCB      0x19,0x20
;;;1760       case IP_TTL:
;;;1761         *(int*)optval = sock->conn->pcb.ip->ttl;
0011f2  6820              LDR      r0,[r4,#0]
0011f4  6840              LDR      r0,[r0,#4]
0011f6  7a80              LDRB     r0,[r0,#0xa]
0011f8  6028              STR      r0,[r5,#0]
;;;1762         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
0011fa  bf00              NOP      
0011fc  bf00              NOP      
;;;1763                     s, *(int *)optval));
;;;1764         break;
0011fe  e025              B        |L1.4684|
;;;1765       case IP_TOS:
;;;1766         *(int*)optval = sock->conn->pcb.ip->tos;
001200  6820              LDR      r0,[r4,#0]
001202  6840              LDR      r0,[r0,#4]
001204  7a40              LDRB     r0,[r0,#9]
001206  6028              STR      r0,[r5,#0]
;;;1767         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
001208  bf00              NOP      
00120a  bf00              NOP      
;;;1768                     s, *(int *)optval));
;;;1769         break;
00120c  e01e              B        |L1.4684|
;;;1770   #if LWIP_IGMP
;;;1771       case IP_MULTICAST_TTL:
;;;1772         *(u8_t*)optval = sock->conn->pcb.ip->ttl;
00120e  6820              LDR      r0,[r4,#0]
001210  6840              LDR      r0,[r0,#4]
001212  7a80              LDRB     r0,[r0,#0xa]
001214  7028              STRB     r0,[r5,#0]
;;;1773         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
001216  bf00              NOP      
001218  bf00              NOP      
;;;1774                     s, *(int *)optval));
;;;1775         break;
00121a  e017              B        |L1.4684|
;;;1776       case IP_MULTICAST_IF:
;;;1777         inet_addr_from_ipaddr((struct in_addr*)optval, &sock->conn->pcb.udp->multicast_ip);
00121c  6820              LDR      r0,[r4,#0]
00121e  6840              LDR      r0,[r0,#4]
001220  6980              LDR      r0,[r0,#0x18]
001222  6028              STR      r0,[r5,#0]
;;;1778         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%"X32_F"\n",
001224  bf00              NOP      
001226  bf00              NOP      
;;;1779                     s, *(u32_t *)optval));
;;;1780         break;
001228  e010              B        |L1.4684|
;;;1781       case IP_MULTICAST_LOOP:
;;;1782         if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) {
00122a  6820              LDR      r0,[r4,#0]
00122c  6840              LDR      r0,[r0,#4]
00122e  7c00              LDRB     r0,[r0,#0x10]
001230  f0000008          AND      r0,r0,#8
001234  b110              CBZ      r0,|L1.4668|
;;;1783           *(u8_t*)optval = 1;
001236  2001              MOVS     r0,#1
001238  7028              STRB     r0,[r5,#0]
00123a  e001              B        |L1.4672|
                  |L1.4668|
;;;1784         } else {
;;;1785           *(u8_t*)optval = 0;
00123c  2000              MOVS     r0,#0
00123e  7028              STRB     r0,[r5,#0]
                  |L1.4672|
;;;1786         }
;;;1787         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
001240  bf00              NOP      
001242  bf00              NOP      
;;;1788                     s, *(int *)optval));
;;;1789         break;
001244  e002              B        |L1.4684|
                  |L1.4678|
;;;1790   #endif /* LWIP_IGMP */
;;;1791       default:
;;;1792         LWIP_ASSERT("unhandled optname", 0);
001246  bf00              NOP      
001248  bf00              NOP      
;;;1793         break;
00124a  bf00              NOP      
                  |L1.4684|
00124c  bf00              NOP                            ;1764
;;;1794       }  /* switch (optname) */
;;;1795       break;
00124e  e01d              B        |L1.4748|
                  |L1.4688|
;;;1796   
;;;1797   #if LWIP_TCP
;;;1798   /* Level: IPPROTO_TCP */
;;;1799     case IPPROTO_TCP:
;;;1800       switch (optname) {
001250  2f01              CMP      r7,#1
001252  d002              BEQ      |L1.4698|
001254  2f02              CMP      r7,#2
001256  d111              BNE      |L1.4732|
001258  e008              B        |L1.4716|
                  |L1.4698|
;;;1801       case TCP_NODELAY:
;;;1802         *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
00125a  6820              LDR      r0,[r4,#0]
00125c  6840              LDR      r0,[r0,#4]
00125e  7f80              LDRB     r0,[r0,#0x1e]
001260  f3c01080          UBFX     r0,r0,#6,#1
001264  6028              STR      r0,[r5,#0]
;;;1803         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
001266  bf00              NOP      
001268  bf00              NOP      
;;;1804                     s, (*(int*)optval)?"on":"off") );
;;;1805         break;
00126a  e00a              B        |L1.4738|
                  |L1.4716|
;;;1806       case TCP_KEEPALIVE:
;;;1807         *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
00126c  6820              LDR      r0,[r4,#0]
00126e  6840              LDR      r0,[r0,#4]
001270  f8d0008c          LDR      r0,[r0,#0x8c]
001274  6028              STR      r0,[r5,#0]
;;;1808         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
001276  bf00              NOP      
001278  bf00              NOP      
;;;1809                     s, *(int *)optval));
;;;1810         break;
00127a  e002              B        |L1.4738|
                  |L1.4732|
;;;1811   
;;;1812   #if LWIP_TCP_KEEPALIVE
;;;1813       case TCP_KEEPIDLE:
;;;1814         *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
;;;1815         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
;;;1816                     s, *(int *)optval));
;;;1817         break;
;;;1818       case TCP_KEEPINTVL:
;;;1819         *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
;;;1820         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
;;;1821                     s, *(int *)optval));
;;;1822         break;
;;;1823       case TCP_KEEPCNT:
;;;1824         *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
;;;1825         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
;;;1826                     s, *(int *)optval));
;;;1827         break;
;;;1828   #endif /* LWIP_TCP_KEEPALIVE */
;;;1829       default:
;;;1830         LWIP_ASSERT("unhandled optname", 0);
00127c  bf00              NOP      
00127e  bf00              NOP      
;;;1831         break;
001280  bf00              NOP      
                  |L1.4738|
001282  bf00              NOP                            ;1805
;;;1832       }  /* switch (optname) */
;;;1833       break;
001284  e002              B        |L1.4748|
                  |L1.4742|
;;;1834   #endif /* LWIP_TCP */
;;;1835   #if LWIP_UDP && LWIP_UDPLITE
;;;1836     /* Level: IPPROTO_UDPLITE */
;;;1837     case IPPROTO_UDPLITE:
;;;1838       switch (optname) {
;;;1839       case UDPLITE_SEND_CSCOV:
;;;1840         *(int*)optval = sock->conn->pcb.udp->chksum_len_tx;
;;;1841         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",
;;;1842                     s, (*(int*)optval)) );
;;;1843         break;
;;;1844       case UDPLITE_RECV_CSCOV:
;;;1845         *(int*)optval = sock->conn->pcb.udp->chksum_len_rx;
;;;1846         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",
;;;1847                     s, (*(int*)optval)) );
;;;1848         break;
;;;1849       default:
;;;1850         LWIP_ASSERT("unhandled optname", 0);
;;;1851         break;
;;;1852       }  /* switch (optname) */
;;;1853       break;
;;;1854   #endif /* LWIP_UDP */
;;;1855     default:
;;;1856       LWIP_ASSERT("unhandled level", 0);
001286  bf00              NOP      
001288  bf00              NOP      
;;;1857       break;
00128a  bf00              NOP      
                  |L1.4748|
00128c  bf00              NOP                            ;1755
;;;1858     } /* switch (level) */
;;;1859     sys_sem_signal(&sock->conn->op_completed);
00128e  6821              LDR      r1,[r4,#0]
001290  f101000c          ADD      r0,r1,#0xc
001294  f7fffffe          BL       sys_sem_signal
;;;1860   }
001298  e8bd87f0          POP      {r4-r10,pc}
;;;1861   
                          ENDP

                  lwip_getsockopt PROC
;;;1454   int
;;;1455   lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
00129c  e92d47f0          PUSH     {r4-r10,lr}
;;;1456   {
0012a0  b088              SUB      sp,sp,#0x20
0012a2  4682              MOV      r10,r0
0012a4  4688              MOV      r8,r1
0012a6  4616              MOV      r6,r2
0012a8  4699              MOV      r9,r3
0012aa  9d10              LDR      r5,[sp,#0x40]
;;;1457     err_t err = ERR_OK;
0012ac  2700              MOVS     r7,#0
;;;1458     struct lwip_sock *sock = get_socket(s);
0012ae  4650              MOV      r0,r10
0012b0  f7fffffe          BL       get_socket
0012b4  4604              MOV      r4,r0
;;;1459     struct lwip_setgetsockopt_data data;
;;;1460   
;;;1461     if (!sock) {
0012b6  b91c              CBNZ     r4,|L1.4800|
;;;1462       return -1;
0012b8  1e78              SUBS     r0,r7,#1
                  |L1.4794|
;;;1463     }
;;;1464   
;;;1465     if ((NULL == optval) || (NULL == optlen)) {
;;;1466       sock_set_errno(sock, EFAULT);
;;;1467       return -1;
;;;1468     }
;;;1469   
;;;1470     /* Do length and type checks for the various options first, to keep it readable. */
;;;1471     switch (level) {
;;;1472      
;;;1473   /* Level: SOL_SOCKET */
;;;1474     case SOL_SOCKET:
;;;1475       switch (optname) {
;;;1476          
;;;1477       case SO_ACCEPTCONN:
;;;1478       case SO_BROADCAST:
;;;1479       /* UNIMPL case SO_DEBUG: */
;;;1480       /* UNIMPL case SO_DONTROUTE: */
;;;1481       case SO_ERROR:
;;;1482       case SO_KEEPALIVE:
;;;1483       /* UNIMPL case SO_CONTIMEO: */
;;;1484   #if LWIP_SO_SNDTIMEO
;;;1485       case SO_SNDTIMEO:
;;;1486   #endif /* LWIP_SO_SNDTIMEO */
;;;1487   #if LWIP_SO_RCVTIMEO
;;;1488       case SO_RCVTIMEO:
;;;1489   #endif /* LWIP_SO_RCVTIMEO */
;;;1490   #if LWIP_SO_RCVBUF
;;;1491       case SO_RCVBUF:
;;;1492   #endif /* LWIP_SO_RCVBUF */
;;;1493       /* UNIMPL case SO_OOBINLINE: */
;;;1494       /* UNIMPL case SO_SNDBUF: */
;;;1495       /* UNIMPL case SO_RCVLOWAT: */
;;;1496       /* UNIMPL case SO_SNDLOWAT: */
;;;1497   #if SO_REUSE
;;;1498       case SO_REUSEADDR:
;;;1499       case SO_REUSEPORT:
;;;1500   #endif /* SO_REUSE */
;;;1501       case SO_TYPE:
;;;1502       /* UNIMPL case SO_USELOOPBACK: */
;;;1503         if (*optlen < sizeof(int)) {
;;;1504           err = EINVAL;
;;;1505         }
;;;1506         break;
;;;1507   
;;;1508       case SO_NO_CHECK:
;;;1509         if (*optlen < sizeof(int)) {
;;;1510           err = EINVAL;
;;;1511         }
;;;1512   #if LWIP_UDP
;;;1513         if ((sock->conn->type != NETCONN_UDP) ||
;;;1514             ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
;;;1515           /* this flag is only available for UDP, not for UDP lite */
;;;1516           err = EAFNOSUPPORT;
;;;1517         }
;;;1518   #endif /* LWIP_UDP */
;;;1519         break;
;;;1520   
;;;1521       default:
;;;1522         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
;;;1523                                     s, optname));
;;;1524         err = ENOPROTOOPT;
;;;1525       }  /* switch (optname) */
;;;1526       break;
;;;1527                        
;;;1528   /* Level: IPPROTO_IP */
;;;1529     case IPPROTO_IP:
;;;1530       switch (optname) {
;;;1531       /* UNIMPL case IP_HDRINCL: */
;;;1532       /* UNIMPL case IP_RCVDSTADDR: */
;;;1533       /* UNIMPL case IP_RCVIF: */
;;;1534       case IP_TTL:
;;;1535       case IP_TOS:
;;;1536         if (*optlen < sizeof(int)) {
;;;1537           err = EINVAL;
;;;1538         }
;;;1539         break;
;;;1540   #if LWIP_IGMP
;;;1541       case IP_MULTICAST_TTL:
;;;1542         if (*optlen < sizeof(u8_t)) {
;;;1543           err = EINVAL;
;;;1544         }
;;;1545         break;
;;;1546       case IP_MULTICAST_IF:
;;;1547         if (*optlen < sizeof(struct in_addr)) {
;;;1548           err = EINVAL;
;;;1549         }
;;;1550         break;
;;;1551       case IP_MULTICAST_LOOP:
;;;1552         if (*optlen < sizeof(u8_t)) {
;;;1553           err = EINVAL;
;;;1554         }
;;;1555         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1556           err = EAFNOSUPPORT;
;;;1557         }
;;;1558         break;
;;;1559   #endif /* LWIP_IGMP */
;;;1560   
;;;1561       default:
;;;1562         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
;;;1563                                     s, optname));
;;;1564         err = ENOPROTOOPT;
;;;1565       }  /* switch (optname) */
;;;1566       break;
;;;1567            
;;;1568   #if LWIP_TCP
;;;1569   /* Level: IPPROTO_TCP */
;;;1570     case IPPROTO_TCP:
;;;1571       if (*optlen < sizeof(int)) {
;;;1572         err = EINVAL;
;;;1573         break;
;;;1574       }
;;;1575       
;;;1576       /* If this is no TCP socket, ignore any options. */
;;;1577       if (sock->conn->type != NETCONN_TCP)
;;;1578         return 0;
;;;1579   
;;;1580       switch (optname) {
;;;1581       case TCP_NODELAY:
;;;1582       case TCP_KEEPALIVE:
;;;1583   #if LWIP_TCP_KEEPALIVE
;;;1584       case TCP_KEEPIDLE:
;;;1585       case TCP_KEEPINTVL:
;;;1586       case TCP_KEEPCNT:
;;;1587   #endif /* LWIP_TCP_KEEPALIVE */
;;;1588         break;
;;;1589          
;;;1590       default:
;;;1591         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
;;;1592                                     s, optname));
;;;1593         err = ENOPROTOOPT;
;;;1594       }  /* switch (optname) */
;;;1595       break;
;;;1596   #endif /* LWIP_TCP */
;;;1597   #if LWIP_UDP && LWIP_UDPLITE
;;;1598   /* Level: IPPROTO_UDPLITE */
;;;1599     case IPPROTO_UDPLITE:
;;;1600       if (*optlen < sizeof(int)) {
;;;1601         err = EINVAL;
;;;1602         break;
;;;1603       }
;;;1604       
;;;1605       /* If this is no UDP lite socket, ignore any options. */
;;;1606       if (sock->conn->type != NETCONN_UDPLITE) {
;;;1607         return 0;
;;;1608       }
;;;1609   
;;;1610       switch (optname) {
;;;1611       case UDPLITE_SEND_CSCOV:
;;;1612       case UDPLITE_RECV_CSCOV:
;;;1613         break;
;;;1614          
;;;1615       default:
;;;1616         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
;;;1617                                     s, optname));
;;;1618         err = ENOPROTOOPT;
;;;1619       }  /* switch (optname) */
;;;1620       break;
;;;1621   #endif /* LWIP_UDP && LWIP_UDPLITE*/
;;;1622   /* UNDEFINED LEVEL */
;;;1623     default:
;;;1624         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
;;;1625                                     s, level, optname));
;;;1626         err = ENOPROTOOPT;
;;;1627     }  /* switch */
;;;1628   
;;;1629      
;;;1630     if (err != ERR_OK) {
;;;1631       sock_set_errno(sock, err);
;;;1632       return -1;
;;;1633     }
;;;1634   
;;;1635     /* Now do the actual option processing */
;;;1636     data.sock = sock;
;;;1637   #ifdef LWIP_DEBUG
;;;1638     data.s = s;
;;;1639   #endif /* LWIP_DEBUG */
;;;1640     data.level = level;
;;;1641     data.optname = optname;
;;;1642     data.optval = optval;
;;;1643     data.optlen = optlen;
;;;1644     data.err = err;
;;;1645     tcpip_callback(lwip_getsockopt_internal, &data);
;;;1646     sys_arch_sem_wait(&sock->conn->op_completed, 0);
;;;1647     /* maybe lwip_getsockopt_internal has changed err */
;;;1648     err = data.err;
;;;1649   
;;;1650     sock_set_errno(sock, err);
;;;1651     return err ? -1 : 0;
;;;1652   }
0012ba  b008              ADD      sp,sp,#0x20
0012bc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4800|
0012c0  f1b90f00          CMP      r9,#0                 ;1465
0012c4  d000              BEQ      |L1.4808|
0012c6  b935              CBNZ     r5,|L1.4822|
                  |L1.4808|
0012c8  bf00              NOP                            ;1466
0012ca  200e              MOVS     r0,#0xe               ;1466
0012cc  6120              STR      r0,[r4,#0x10]         ;1466
0012ce  bf00              NOP                            ;1466
0012d0  f04f30ff          MOV      r0,#0xffffffff        ;1467
0012d4  e7f1              B        |L1.4794|
                  |L1.4822|
0012d6  f1b80f00          CMP      r8,#0                 ;1471
0012da  d037              BEQ      |L1.4940|
0012dc  f1b80f06          CMP      r8,#6                 ;1471
0012e0  d05c              BEQ      |L1.5020|
0012e2  f6a870ff          SUB      r0,r8,#0xfff          ;1471
0012e6  2800              CMP      r0,#0                 ;1471
0012e8  d171              BNE      |L1.5070|
0012ea  f2410107          MOV      r1,#0x1007            ;1475
0012ee  1a70              SUBS     r0,r6,r1              ;1475
0012f0  428e              CMP      r6,r1                 ;1475
0012f2  d00e              BEQ      |L1.4882|
0012f4  dc06              BGT      |L1.4868|
0012f6  2e02              CMP      r6,#2                 ;1475
0012f8  d009              BEQ      |L1.4878|
0012fa  2e08              CMP      r6,#8                 ;1475
0012fc  d00a              BEQ      |L1.4884|
0012fe  2e20              CMP      r6,#0x20              ;1475
001300  d11e              BNE      |L1.4928|
001302  e005              B        |L1.4880|
                  |L1.4868|
001304  2801              CMP      r0,#1                 ;1475
001306  d006              BEQ      |L1.4886|
001308  2803              CMP      r0,#3                 ;1475
00130a  d119              BNE      |L1.4928|
00130c  e008              B        |L1.4896|
                  |L1.4878|
00130e  bf00              NOP                            ;1478
                  |L1.4880|
001310  bf00              NOP                            ;1481
                  |L1.4882|
001312  bf00              NOP                            ;1482
                  |L1.4884|
001314  bf00              NOP                            ;1501
                  |L1.4886|
001316  6828              LDR      r0,[r5,#0]            ;1503
001318  2804              CMP      r0,#4                 ;1503
00131a  d200              BCS      |L1.4894|
00131c  2716              MOVS     r7,#0x16              ;1504
                  |L1.4894|
00131e  e013              B        |L1.4936|
                  |L1.4896|
001320  6828              LDR      r0,[r5,#0]            ;1509
001322  2804              CMP      r0,#4                 ;1509
001324  d200              BCS      |L1.4904|
001326  2716              MOVS     r7,#0x16              ;1510
                  |L1.4904|
001328  6820              LDR      r0,[r4,#0]            ;1513
00132a  7800              LDRB     r0,[r0,#0]            ;1513
00132c  2820              CMP      r0,#0x20              ;1513
00132e  d105              BNE      |L1.4924|
001330  6820              LDR      r0,[r4,#0]            ;1514
001332  6840              LDR      r0,[r0,#4]            ;1514
001334  7c00              LDRB     r0,[r0,#0x10]         ;1514
001336  f0000002          AND      r0,r0,#2              ;1514
00133a  b100              CBZ      r0,|L1.4926|
                  |L1.4924|
00133c  2761              MOVS     r7,#0x61              ;1516
                  |L1.4926|
00133e  e003              B        |L1.4936|
                  |L1.4928|
001340  bf00              NOP                            ;1522
001342  bf00              NOP                            ;1522
001344  275c              MOVS     r7,#0x5c              ;1524
001346  bf00              NOP                            ;1475
                  |L1.4936|
001348  bf00              NOP                            ;1506
00134a  e044              B        |L1.5078|
                  |L1.4940|
00134c  2e08              CMP      r6,#8                 ;1530
00134e  d21f              BCS      |L1.5008|
001350  e8dff006          TBB      [pc,r6]               ;1530
001354  1e05041e          DCB      0x1e,0x05,0x04,0x1e
001358  1e0a0e13          DCB      0x1e,0x0a,0x0e,0x13
00135c  bf00              NOP                            ;1535
00135e  6828              LDR      r0,[r5,#0]            ;1536
001360  2804              CMP      r0,#4                 ;1536
001362  d200              BCS      |L1.4966|
001364  2716              MOVS     r7,#0x16              ;1537
                  |L1.4966|
001366  e017              B        |L1.5016|
001368  6828              LDR      r0,[r5,#0]            ;1542
00136a  b900              CBNZ     r0,|L1.4974|
00136c  2716              MOVS     r7,#0x16              ;1543
                  |L1.4974|
00136e  e013              B        |L1.5016|
001370  6828              LDR      r0,[r5,#0]            ;1547
001372  2804              CMP      r0,#4                 ;1547
001374  d200              BCS      |L1.4984|
001376  2716              MOVS     r7,#0x16              ;1548
                  |L1.4984|
001378  e00e              B        |L1.5016|
00137a  6828              LDR      r0,[r5,#0]            ;1552
00137c  b900              CBNZ     r0,|L1.4992|
00137e  2716              MOVS     r7,#0x16              ;1553
                  |L1.4992|
001380  6820              LDR      r0,[r4,#0]            ;1555
001382  7800              LDRB     r0,[r0,#0]            ;1555
001384  f00000f0          AND      r0,r0,#0xf0           ;1555
001388  2820              CMP      r0,#0x20              ;1555
00138a  d000              BEQ      |L1.5006|
00138c  2761              MOVS     r7,#0x61              ;1556
                  |L1.5006|
00138e  e003              B        |L1.5016|
                  |L1.5008|
001390  bf00              NOP                            ;1562
001392  bf00              NOP                            ;1562
001394  275c              MOVS     r7,#0x5c              ;1564
001396  bf00              NOP                            ;1530
                  |L1.5016|
001398  bf00              NOP                            ;1539
00139a  e01c              B        |L1.5078|
                  |L1.5020|
00139c  6828              LDR      r0,[r5,#0]            ;1571
00139e  2804              CMP      r0,#4                 ;1571
0013a0  d201              BCS      |L1.5030|
0013a2  2716              MOVS     r7,#0x16              ;1572
0013a4  e017              B        |L1.5078|
                  |L1.5030|
0013a6  6820              LDR      r0,[r4,#0]            ;1577
0013a8  7800              LDRB     r0,[r0,#0]            ;1577
0013aa  2810              CMP      r0,#0x10              ;1577
0013ac  d001              BEQ      |L1.5042|
0013ae  2000              MOVS     r0,#0                 ;1578
0013b0  e783              B        |L1.4794|
                  |L1.5042|
0013b2  2e01              CMP      r6,#1                 ;1580
0013b4  d002              BEQ      |L1.5052|
0013b6  2e02              CMP      r6,#2                 ;1580
0013b8  d102              BNE      |L1.5056|
0013ba  e000              B        |L1.5054|
                  |L1.5052|
0013bc  bf00              NOP                            ;1582
                  |L1.5054|
0013be  e003              B        |L1.5064|
                  |L1.5056|
0013c0  bf00              NOP                            ;1591
0013c2  bf00              NOP                            ;1591
0013c4  275c              MOVS     r7,#0x5c              ;1593
0013c6  bf00              NOP                            ;1580
                  |L1.5064|
0013c8  bf00              NOP                            ;1588
0013ca  e004              B        |L1.5078|
0013cc  e7ff              B        |L1.5070|
                  |L1.5070|
0013ce  bf00              NOP                            ;1624
0013d0  bf00              NOP                            ;1624
0013d2  275c              MOVS     r7,#0x5c              ;1626
0013d4  bf00              NOP                            ;1471
                  |L1.5078|
0013d6  bf00              NOP                            ;1526
0013d8  b12f              CBZ      r7,|L1.5094|
0013da  bf00              NOP                            ;1631
0013dc  6127              STR      r7,[r4,#0x10]         ;1631
0013de  bf00              NOP                            ;1631
0013e0  f04f30ff          MOV      r0,#0xffffffff        ;1632
0013e4  e769              B        |L1.4794|
                  |L1.5094|
0013e6  9401              STR      r4,[sp,#4]            ;1636
0013e8  f8cda008          STR      r10,[sp,#8]           ;1638
0013ec  f8cd800c          STR      r8,[sp,#0xc]          ;1640
0013f0  9604              STR      r6,[sp,#0x10]         ;1641
0013f2  f8cd9014          STR      r9,[sp,#0x14]         ;1642
0013f6  9506              STR      r5,[sp,#0x18]         ;1643
0013f8  f88d701c          STRB     r7,[sp,#0x1c]         ;1644
0013fc  2201              MOVS     r2,#1                 ;1645
0013fe  a901              ADD      r1,sp,#4              ;1645
001400  4864              LDR      r0,|L1.5524|
001402  f7fffffe          BL       tcpip_callback_with_block
001406  6821              LDR      r1,[r4,#0]            ;1646
001408  f101000c          ADD      r0,r1,#0xc            ;1646
00140c  2100              MOVS     r1,#0                 ;1646
00140e  f7fffffe          BL       sys_arch_sem_wait
001412  f99d701c          LDRSB    r7,[sp,#0x1c]         ;1648
001416  bf00              NOP                            ;1650
001418  6127              STR      r7,[r4,#0x10]         ;1650
00141a  bf00              NOP                            ;1650
00141c  b117              CBZ      r7,|L1.5156|
00141e  f04f30ff          MOV      r0,#0xffffffff        ;1651
001422  e74a              B        |L1.4794|
                  |L1.5156|
001424  2000              MOVS     r0,#0                 ;1651
001426  e748              B        |L1.4794|
;;;1653   
                          ENDP

                  lwip_setsockopt_internal PROC
;;;2071   static void
;;;2072   lwip_setsockopt_internal(void *arg)
001428  e92d5ffc          PUSH     {r2-r12,lr}
;;;2073   {
00142c  4680              MOV      r8,r0
;;;2074     struct lwip_sock *sock;
;;;2075   #ifdef LWIP_DEBUG
;;;2076     int s;
;;;2077   #endif /* LWIP_DEBUG */
;;;2078     int level, optname;
;;;2079     const void *optval;
;;;2080     struct lwip_setgetsockopt_data *data;
;;;2081   
;;;2082     LWIP_ASSERT("arg != NULL", arg != NULL);
00142e  bf00              NOP      
001430  bf00              NOP      
;;;2083   
;;;2084     data = (struct lwip_setgetsockopt_data*)arg;
001432  4646              MOV      r6,r8
;;;2085     sock = data->sock;
001434  6834              LDR      r4,[r6,#0]
;;;2086   #ifdef LWIP_DEBUG
;;;2087     s = data->s;
001436  f8d6b004          LDR      r11,[r6,#4]
;;;2088   #endif /* LWIP_DEBUG */
;;;2089     level = data->level;
00143a  f8d69008          LDR      r9,[r6,#8]
;;;2090     optname = data->optname;
00143e  68f7              LDR      r7,[r6,#0xc]
;;;2091     optval = data->optval;
001440  6935              LDR      r5,[r6,#0x10]
;;;2092   
;;;2093     switch (level) {
001442  f1b90f00          CMP      r9,#0
001446  d03d              BEQ      |L1.5316|
001448  f1b90f06          CMP      r9,#6
00144c  d07e              BEQ      |L1.5452|
00144e  f6a970ff          SUB      r0,r9,#0xfff
001452  2800              CMP      r0,#0
001454  d17b              BNE      |L1.5454|
;;;2094   
;;;2095   /* Level: SOL_SOCKET */
;;;2096     case SOL_SOCKET:
;;;2097       switch (optname) {
001456  2f08              CMP      r7,#8
001458  d007              BEQ      |L1.5226|
00145a  2f20              CMP      r7,#0x20
00145c  d004              BEQ      |L1.5224|
00145e  f5a75080          SUB      r0,r7,#0x1000
001462  380a              SUBS     r0,r0,#0xa
001464  bb48              CBNZ     r0,|L1.5306|
001466  e014              B        |L1.5266|
                  |L1.5224|
;;;2098   
;;;2099       /* The option flags */
;;;2100       case SO_BROADCAST:
;;;2101       /* UNIMPL case SO_DEBUG: */
;;;2102       /* UNIMPL case SO_DONTROUTE: */
;;;2103       case SO_KEEPALIVE:
001468  bf00              NOP      
                  |L1.5226|
;;;2104       /* UNIMPL case SO_OOBINCLUDE: */
;;;2105   #if SO_REUSE
;;;2106       case SO_REUSEADDR:
;;;2107       case SO_REUSEPORT:
;;;2108   #endif /* SO_REUSE */
;;;2109       /* UNIMPL case SO_USELOOPBACK: */
;;;2110         if (*(int*)optval) {
00146a  6828              LDR      r0,[r5,#0]
00146c  b138              CBZ      r0,|L1.5246|
;;;2111           ip_set_option(sock->conn->pcb.ip, optname);
00146e  6820              LDR      r0,[r4,#0]
001470  6840              LDR      r0,[r0,#4]
001472  7a00              LDRB     r0,[r0,#8]
001474  4338              ORRS     r0,r0,r7
001476  6821              LDR      r1,[r4,#0]
001478  6849              LDR      r1,[r1,#4]
00147a  7208              STRB     r0,[r1,#8]
00147c  e006              B        |L1.5260|
                  |L1.5246|
;;;2112         } else {
;;;2113           ip_reset_option(sock->conn->pcb.ip, optname);
00147e  6820              LDR      r0,[r4,#0]
001480  6840              LDR      r0,[r0,#4]
001482  7a00              LDRB     r0,[r0,#8]
001484  43b8              BICS     r0,r0,r7
001486  6821              LDR      r1,[r4,#0]
001488  6849              LDR      r1,[r1,#4]
00148a  7208              STRB     r0,[r1,#8]
                  |L1.5260|
;;;2114         }
;;;2115         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
00148c  bf00              NOP      
00148e  bf00              NOP      
;;;2116                     s, optname, (*(int*)optval?"on":"off")));
;;;2117         break;
001490  e016              B        |L1.5312|
                  |L1.5266|
;;;2118   #if LWIP_SO_SNDTIMEO
;;;2119       case SO_SNDTIMEO:
;;;2120         netconn_set_sendtimeout(sock->conn, (s32_t)*(int*)optval);
;;;2121         break;
;;;2122   #endif /* LWIP_SO_SNDTIMEO */
;;;2123   #if LWIP_SO_RCVTIMEO
;;;2124       case SO_RCVTIMEO:
;;;2125         netconn_set_recvtimeout(sock->conn, *(int*)optval);
;;;2126         break;
;;;2127   #endif /* LWIP_SO_RCVTIMEO */
;;;2128   #if LWIP_SO_RCVBUF
;;;2129       case SO_RCVBUF:
;;;2130         netconn_set_recvbufsize(sock->conn, *(int*)optval);
;;;2131         break;
;;;2132   #endif /* LWIP_SO_RCVBUF */
;;;2133   #if LWIP_UDP
;;;2134       case SO_NO_CHECK:
;;;2135         if (*(int*)optval) {
001492  6828              LDR      r0,[r5,#0]
001494  b140              CBZ      r0,|L1.5288|
;;;2136           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
001496  6820              LDR      r0,[r4,#0]
001498  6840              LDR      r0,[r0,#4]
00149a  7c00              LDRB     r0,[r0,#0x10]
00149c  f0400001          ORR      r0,r0,#1
0014a0  6821              LDR      r1,[r4,#0]
0014a2  6849              LDR      r1,[r1,#4]
0014a4  7408              STRB     r0,[r1,#0x10]
0014a6  e007              B        |L1.5304|
                  |L1.5288|
;;;2137         } else {
;;;2138           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
0014a8  6820              LDR      r0,[r4,#0]
0014aa  6840              LDR      r0,[r0,#4]
0014ac  7c00              LDRB     r0,[r0,#0x10]
0014ae  f0200001          BIC      r0,r0,#1
0014b2  6821              LDR      r1,[r4,#0]
0014b4  6849              LDR      r1,[r1,#4]
0014b6  7408              STRB     r0,[r1,#0x10]
                  |L1.5304|
;;;2139         }
;;;2140         break;
0014b8  e002              B        |L1.5312|
                  |L1.5306|
;;;2141   #endif /* LWIP_UDP */
;;;2142       default:
;;;2143         LWIP_ASSERT("unhandled optname", 0);
0014ba  bf00              NOP      
0014bc  bf00              NOP      
;;;2144         break;
0014be  bf00              NOP      
                  |L1.5312|
0014c0  bf00              NOP                            ;2117
;;;2145       }  /* switch (optname) */
;;;2146       break;
0014c2  e084              B        |L1.5582|
                  |L1.5316|
;;;2147   
;;;2148   /* Level: IPPROTO_IP */
;;;2149     case IPPROTO_IP:
;;;2150       switch (optname) {
0014c4  2f08              CMP      r7,#8
0014c6  d24d              BCS      |L1.5476|
0014c8  e8dff007          TBB      [pc,r7]
0014cc  4c0b0430          DCB      0x4c,0x0b,0x04,0x30
0014d0  3112171c          DCB      0x31,0x12,0x17,0x1c
;;;2151       case IP_TTL:
;;;2152         sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
0014d4  7828              LDRB     r0,[r5,#0]
0014d6  6821              LDR      r1,[r4,#0]
0014d8  6849              LDR      r1,[r1,#4]
0014da  7288              STRB     r0,[r1,#0xa]
;;;2153         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
0014dc  bf00              NOP      
0014de  bf00              NOP      
;;;2154                     s, sock->conn->pcb.ip->ttl));
;;;2155         break;
0014e0  e043              B        |L1.5482|
;;;2156       case IP_TOS:
;;;2157         sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
0014e2  7828              LDRB     r0,[r5,#0]
0014e4  6821              LDR      r1,[r4,#0]
0014e6  6849              LDR      r1,[r1,#4]
0014e8  7248              STRB     r0,[r1,#9]
;;;2158         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
0014ea  bf00              NOP      
0014ec  bf00              NOP      
;;;2159                     s, sock->conn->pcb.ip->tos));
;;;2160         break;
0014ee  e03c              B        |L1.5482|
;;;2161   #if LWIP_IGMP
;;;2162       case IP_MULTICAST_TTL:
;;;2163         sock->conn->pcb.udp->ttl = (u8_t)(*(u8_t*)optval);
0014f0  7828              LDRB     r0,[r5,#0]
0014f2  6821              LDR      r1,[r4,#0]
0014f4  6849              LDR      r1,[r1,#4]
0014f6  7288              STRB     r0,[r1,#0xa]
;;;2164         break;
0014f8  e037              B        |L1.5482|
;;;2165       case IP_MULTICAST_IF:
;;;2166         inet_addr_to_ipaddr(&sock->conn->pcb.udp->multicast_ip, (struct in_addr*)optval);
0014fa  6828              LDR      r0,[r5,#0]
0014fc  6821              LDR      r1,[r4,#0]
0014fe  6849              LDR      r1,[r1,#4]
001500  6188              STR      r0,[r1,#0x18]
;;;2167         break;
001502  e032              B        |L1.5482|
;;;2168       case IP_MULTICAST_LOOP:
;;;2169         if (*(u8_t*)optval) {
001504  7828              LDRB     r0,[r5,#0]
001506  b140              CBZ      r0,|L1.5402|
;;;2170           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_MULTICAST_LOOP);
001508  6820              LDR      r0,[r4,#0]
00150a  6840              LDR      r0,[r0,#4]
00150c  7c00              LDRB     r0,[r0,#0x10]
00150e  f0400008          ORR      r0,r0,#8
001512  6821              LDR      r1,[r4,#0]
001514  6849              LDR      r1,[r1,#4]
001516  7408              STRB     r0,[r1,#0x10]
001518  e007              B        |L1.5418|
                  |L1.5402|
;;;2171         } else {
;;;2172           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_MULTICAST_LOOP);
00151a  6820              LDR      r0,[r4,#0]
00151c  6840              LDR      r0,[r0,#4]
00151e  7c00              LDRB     r0,[r0,#0x10]
001520  f0200008          BIC      r0,r0,#8
001524  6821              LDR      r1,[r4,#0]
001526  6849              LDR      r1,[r1,#4]
001528  7408              STRB     r0,[r1,#0x10]
                  |L1.5418|
;;;2173         }
;;;2174         break;
00152a  e01e              B        |L1.5482|
;;;2175       case IP_ADD_MEMBERSHIP:
;;;2176       case IP_DROP_MEMBERSHIP:
00152c  bf00              NOP      
;;;2177         {
;;;2178           /* If this is a TCP or a RAW socket, ignore these options. */
;;;2179           struct ip_mreq *imr = (struct ip_mreq *)optval;
00152e  46aa              MOV      r10,r5
;;;2180           ip_addr_t if_addr;
;;;2181           ip_addr_t multi_addr;
;;;2182           inet_addr_to_ipaddr(&if_addr, &imr->imr_interface);
001530  f8da0004          LDR      r0,[r10,#4]
001534  9001              STR      r0,[sp,#4]
;;;2183           inet_addr_to_ipaddr(&multi_addr, &imr->imr_multiaddr);
001536  f8da0000          LDR      r0,[r10,#0]
00153a  9000              STR      r0,[sp,#0]
;;;2184           if(optname == IP_ADD_MEMBERSHIP){
00153c  2f03              CMP      r7,#3
00153e  d107              BNE      |L1.5456|
;;;2185             data->err = igmp_joingroup(&if_addr, &multi_addr);
001540  4669              MOV      r1,sp
001542  a801              ADD      r0,sp,#4
001544  f7fffffe          BL       igmp_joingroup
001548  7630              STRB     r0,[r6,#0x18]
00154a  e006              B        |L1.5466|
                  |L1.5452|
00154c  e00f              B        |L1.5486|
                  |L1.5454|
00154e  e03b              B        |L1.5576|
                  |L1.5456|
;;;2186           } else {
;;;2187             data->err = igmp_leavegroup(&if_addr, &multi_addr);
001550  4669              MOV      r1,sp
001552  a801              ADD      r0,sp,#4
001554  f7fffffe          BL       igmp_leavegroup
001558  7630              STRB     r0,[r6,#0x18]
                  |L1.5466|
;;;2188           }
;;;2189           if(data->err != ERR_OK) {
00155a  7e30              LDRB     r0,[r6,#0x18]
00155c  b108              CBZ      r0,|L1.5474|
;;;2190             data->err = EADDRNOTAVAIL;
00155e  2063              MOVS     r0,#0x63
001560  7630              STRB     r0,[r6,#0x18]
                  |L1.5474|
;;;2191           }
;;;2192         }
;;;2193         break;
001562  e002              B        |L1.5482|
                  |L1.5476|
;;;2194   #endif /* LWIP_IGMP */
;;;2195       default:
;;;2196         LWIP_ASSERT("unhandled optname", 0);
001564  bf00              NOP      
001566  bf00              NOP      
;;;2197         break;
001568  bf00              NOP      
                  |L1.5482|
00156a  bf00              NOP                            ;2155
;;;2198       }  /* switch (optname) */
;;;2199       break;
00156c  e02f              B        |L1.5582|
                  |L1.5486|
;;;2200   
;;;2201   #if LWIP_TCP
;;;2202   /* Level: IPPROTO_TCP */
;;;2203     case IPPROTO_TCP:
;;;2204       switch (optname) {
00156e  2f01              CMP      r7,#1
001570  d002              BEQ      |L1.5496|
001572  2f02              CMP      r7,#2
001574  d123              BNE      |L1.5566|
001576  e01a              B        |L1.5550|
                  |L1.5496|
;;;2205       case TCP_NODELAY:
;;;2206         if (*(int*)optval) {
001578  6828              LDR      r0,[r5,#0]
00157a  b168              CBZ      r0,|L1.5528|
;;;2207           tcp_nagle_disable(sock->conn->pcb.tcp);
00157c  6820              LDR      r0,[r4,#0]
00157e  6840              LDR      r0,[r0,#4]
001580  7f80              LDRB     r0,[r0,#0x1e]
001582  f0400040          ORR      r0,r0,#0x40
001586  6821              LDR      r1,[r4,#0]
001588  6849              LDR      r1,[r1,#4]
00158a  7788              STRB     r0,[r1,#0x1e]
00158c  e00c              B        |L1.5544|
00158e  0000              DCW      0x0000
                  |L1.5520|
                          DCD      err_to_errno_table
                  |L1.5524|
                          DCD      lwip_getsockopt_internal
                  |L1.5528|
;;;2208         } else {
;;;2209           tcp_nagle_enable(sock->conn->pcb.tcp);
001598  6820              LDR      r0,[r4,#0]
00159a  6840              LDR      r0,[r0,#4]
00159c  7f80              LDRB     r0,[r0,#0x1e]
00159e  f0200040          BIC      r0,r0,#0x40
0015a2  6821              LDR      r1,[r4,#0]
0015a4  6849              LDR      r1,[r1,#4]
0015a6  7788              STRB     r0,[r1,#0x1e]
                  |L1.5544|
;;;2210         }
;;;2211         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
0015a8  bf00              NOP      
0015aa  bf00              NOP      
;;;2212                     s, (*(int *)optval)?"on":"off") );
;;;2213         break;
0015ac  e00a              B        |L1.5572|
                  |L1.5550|
;;;2214       case TCP_KEEPALIVE:
;;;2215         sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
0015ae  6828              LDR      r0,[r5,#0]
0015b0  6821              LDR      r1,[r4,#0]
0015b2  6849              LDR      r1,[r1,#4]
0015b4  f8c1008c          STR      r0,[r1,#0x8c]
;;;2216         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
0015b8  bf00              NOP      
0015ba  bf00              NOP      
;;;2217                     s, sock->conn->pcb.tcp->keep_idle));
;;;2218         break;
0015bc  e002              B        |L1.5572|
                  |L1.5566|
;;;2219   
;;;2220   #if LWIP_TCP_KEEPALIVE
;;;2221       case TCP_KEEPIDLE:
;;;2222         sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
;;;2223         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
;;;2224                     s, sock->conn->pcb.tcp->keep_idle));
;;;2225         break;
;;;2226       case TCP_KEEPINTVL:
;;;2227         sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
;;;2228         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
;;;2229                     s, sock->conn->pcb.tcp->keep_intvl));
;;;2230         break;
;;;2231       case TCP_KEEPCNT:
;;;2232         sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
;;;2233         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
;;;2234                     s, sock->conn->pcb.tcp->keep_cnt));
;;;2235         break;
;;;2236   #endif /* LWIP_TCP_KEEPALIVE */
;;;2237       default:
;;;2238         LWIP_ASSERT("unhandled optname", 0);
0015be  bf00              NOP      
0015c0  bf00              NOP      
;;;2239         break;
0015c2  bf00              NOP      
                  |L1.5572|
0015c4  bf00              NOP                            ;2213
;;;2240       }  /* switch (optname) */
;;;2241       break;
0015c6  e002              B        |L1.5582|
                  |L1.5576|
;;;2242   #endif /* LWIP_TCP*/
;;;2243   #if LWIP_UDP && LWIP_UDPLITE
;;;2244     /* Level: IPPROTO_UDPLITE */
;;;2245     case IPPROTO_UDPLITE:
;;;2246       switch (optname) {
;;;2247       case UDPLITE_SEND_CSCOV:
;;;2248         if ((*(int*)optval != 0) && ((*(int*)optval < 8) || (*(int*)optval > 0xffff))) {
;;;2249           /* don't allow illegal values! */
;;;2250           sock->conn->pcb.udp->chksum_len_tx = 8;
;;;2251         } else {
;;;2252           sock->conn->pcb.udp->chksum_len_tx = (u16_t)*(int*)optval;
;;;2253         }
;;;2254         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",
;;;2255                     s, (*(int*)optval)) );
;;;2256         break;
;;;2257       case UDPLITE_RECV_CSCOV:
;;;2258         if ((*(int*)optval != 0) && ((*(int*)optval < 8) || (*(int*)optval > 0xffff))) {
;;;2259           /* don't allow illegal values! */
;;;2260           sock->conn->pcb.udp->chksum_len_rx = 8;
;;;2261         } else {
;;;2262           sock->conn->pcb.udp->chksum_len_rx = (u16_t)*(int*)optval;
;;;2263         }
;;;2264         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",
;;;2265                     s, (*(int*)optval)) );
;;;2266         break;
;;;2267       default:
;;;2268         LWIP_ASSERT("unhandled optname", 0);
;;;2269         break;
;;;2270       }  /* switch (optname) */
;;;2271       break;
;;;2272   #endif /* LWIP_UDP */
;;;2273     default:
;;;2274       LWIP_ASSERT("unhandled level", 0);
0015c8  bf00              NOP      
0015ca  bf00              NOP      
;;;2275       break;
0015cc  bf00              NOP      
                  |L1.5582|
0015ce  bf00              NOP                            ;2146
;;;2276     }  /* switch (level) */
;;;2277     sys_sem_signal(&sock->conn->op_completed);
0015d0  6821              LDR      r1,[r4,#0]
0015d2  f101000c          ADD      r0,r1,#0xc
0015d6  f7fffffe          BL       sys_sem_signal
;;;2278   }
0015da  e8bd9ffc          POP      {r2-r12,pc}
;;;2279   
                          ENDP

                  lwip_setsockopt PROC
;;;1862   int
;;;1863   lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
0015de  e92d43f0          PUSH     {r4-r9,lr}
;;;1864   {
0015e2  b087              SUB      sp,sp,#0x1c
0015e4  4681              MOV      r9,r0
0015e6  460f              MOV      r7,r1
0015e8  4615              MOV      r5,r2
0015ea  4698              MOV      r8,r3
;;;1865     struct lwip_sock *sock = get_socket(s);
0015ec  4648              MOV      r0,r9
0015ee  f7fffffe          BL       get_socket
0015f2  4604              MOV      r4,r0
;;;1866     err_t err = ERR_OK;
0015f4  2600              MOVS     r6,#0
;;;1867     struct lwip_setgetsockopt_data data;
;;;1868   
;;;1869     if (!sock) {
0015f6  b91c              CBNZ     r4,|L1.5632|
;;;1870       return -1;
0015f8  1e70              SUBS     r0,r6,#1
                  |L1.5626|
;;;1871     }
;;;1872   
;;;1873     if (NULL == optval) {
;;;1874       sock_set_errno(sock, EFAULT);
;;;1875       return -1;
;;;1876     }
;;;1877   
;;;1878     /* Do length and type checks for the various options first, to keep it readable. */
;;;1879     switch (level) {
;;;1880   
;;;1881   /* Level: SOL_SOCKET */
;;;1882     case SOL_SOCKET:
;;;1883       switch (optname) {
;;;1884   
;;;1885       case SO_BROADCAST:
;;;1886       /* UNIMPL case SO_DEBUG: */
;;;1887       /* UNIMPL case SO_DONTROUTE: */
;;;1888       case SO_KEEPALIVE:
;;;1889       /* UNIMPL case case SO_CONTIMEO: */
;;;1890   #if LWIP_SO_SNDTIMEO
;;;1891       case SO_SNDTIMEO:
;;;1892   #endif /* LWIP_SO_SNDTIMEO */
;;;1893   #if LWIP_SO_RCVTIMEO
;;;1894       case SO_RCVTIMEO:
;;;1895   #endif /* LWIP_SO_RCVTIMEO */
;;;1896   #if LWIP_SO_RCVBUF
;;;1897       case SO_RCVBUF:
;;;1898   #endif /* LWIP_SO_RCVBUF */
;;;1899       /* UNIMPL case SO_OOBINLINE: */
;;;1900       /* UNIMPL case SO_SNDBUF: */
;;;1901       /* UNIMPL case SO_RCVLOWAT: */
;;;1902       /* UNIMPL case SO_SNDLOWAT: */
;;;1903   #if SO_REUSE
;;;1904       case SO_REUSEADDR:
;;;1905       case SO_REUSEPORT:
;;;1906   #endif /* SO_REUSE */
;;;1907       /* UNIMPL case SO_USELOOPBACK: */
;;;1908         if (optlen < sizeof(int)) {
;;;1909           err = EINVAL;
;;;1910         }
;;;1911         break;
;;;1912       case SO_NO_CHECK:
;;;1913         if (optlen < sizeof(int)) {
;;;1914           err = EINVAL;
;;;1915         }
;;;1916   #if LWIP_UDP
;;;1917         if ((sock->conn->type != NETCONN_UDP) ||
;;;1918             ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
;;;1919           /* this flag is only available for UDP, not for UDP lite */
;;;1920           err = EAFNOSUPPORT;
;;;1921         }
;;;1922   #endif /* LWIP_UDP */
;;;1923         break;
;;;1924       default:
;;;1925         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
;;;1926                     s, optname));
;;;1927         err = ENOPROTOOPT;
;;;1928       }  /* switch (optname) */
;;;1929       break;
;;;1930   
;;;1931   /* Level: IPPROTO_IP */
;;;1932     case IPPROTO_IP:
;;;1933       switch (optname) {
;;;1934       /* UNIMPL case IP_HDRINCL: */
;;;1935       /* UNIMPL case IP_RCVDSTADDR: */
;;;1936       /* UNIMPL case IP_RCVIF: */
;;;1937       case IP_TTL:
;;;1938       case IP_TOS:
;;;1939         if (optlen < sizeof(int)) {
;;;1940           err = EINVAL;
;;;1941         }
;;;1942         break;
;;;1943   #if LWIP_IGMP
;;;1944       case IP_MULTICAST_TTL:
;;;1945         if (optlen < sizeof(u8_t)) {
;;;1946           err = EINVAL;
;;;1947         }
;;;1948         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1949           err = EAFNOSUPPORT;
;;;1950         }
;;;1951         break;
;;;1952       case IP_MULTICAST_IF:
;;;1953         if (optlen < sizeof(struct in_addr)) {
;;;1954           err = EINVAL;
;;;1955         }
;;;1956         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1957           err = EAFNOSUPPORT;
;;;1958         }
;;;1959         break;
;;;1960       case IP_MULTICAST_LOOP:
;;;1961         if (optlen < sizeof(u8_t)) {
;;;1962           err = EINVAL;
;;;1963         }
;;;1964         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1965           err = EAFNOSUPPORT;
;;;1966         }
;;;1967         break;
;;;1968       case IP_ADD_MEMBERSHIP:
;;;1969       case IP_DROP_MEMBERSHIP:
;;;1970         if (optlen < sizeof(struct ip_mreq)) {
;;;1971           err = EINVAL;
;;;1972         }
;;;1973         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1974           err = EAFNOSUPPORT;
;;;1975         }
;;;1976         break;
;;;1977   #endif /* LWIP_IGMP */
;;;1978         default:
;;;1979           LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
;;;1980                       s, optname));
;;;1981           err = ENOPROTOOPT;
;;;1982       }  /* switch (optname) */
;;;1983       break;
;;;1984   
;;;1985   #if LWIP_TCP
;;;1986   /* Level: IPPROTO_TCP */
;;;1987     case IPPROTO_TCP:
;;;1988       if (optlen < sizeof(int)) {
;;;1989         err = EINVAL;
;;;1990         break;
;;;1991       }
;;;1992   
;;;1993       /* If this is no TCP socket, ignore any options. */
;;;1994       if (sock->conn->type != NETCONN_TCP)
;;;1995         return 0;
;;;1996   
;;;1997       switch (optname) {
;;;1998       case TCP_NODELAY:
;;;1999       case TCP_KEEPALIVE:
;;;2000   #if LWIP_TCP_KEEPALIVE
;;;2001       case TCP_KEEPIDLE:
;;;2002       case TCP_KEEPINTVL:
;;;2003       case TCP_KEEPCNT:
;;;2004   #endif /* LWIP_TCP_KEEPALIVE */
;;;2005         break;
;;;2006   
;;;2007       default:
;;;2008         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
;;;2009                     s, optname));
;;;2010         err = ENOPROTOOPT;
;;;2011       }  /* switch (optname) */
;;;2012       break;
;;;2013   #endif /* LWIP_TCP */
;;;2014   #if LWIP_UDP && LWIP_UDPLITE
;;;2015   /* Level: IPPROTO_UDPLITE */
;;;2016     case IPPROTO_UDPLITE:
;;;2017       if (optlen < sizeof(int)) {
;;;2018         err = EINVAL;
;;;2019         break;
;;;2020       }
;;;2021   
;;;2022       /* If this is no UDP lite socket, ignore any options. */
;;;2023       if (sock->conn->type != NETCONN_UDPLITE)
;;;2024         return 0;
;;;2025   
;;;2026       switch (optname) {
;;;2027       case UDPLITE_SEND_CSCOV:
;;;2028       case UDPLITE_RECV_CSCOV:
;;;2029         break;
;;;2030   
;;;2031       default:
;;;2032         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
;;;2033                     s, optname));
;;;2034         err = ENOPROTOOPT;
;;;2035       }  /* switch (optname) */
;;;2036       break;
;;;2037   #endif /* LWIP_UDP && LWIP_UDPLITE */
;;;2038   /* UNDEFINED LEVEL */
;;;2039     default:
;;;2040       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
;;;2041                   s, level, optname));
;;;2042       err = ENOPROTOOPT;
;;;2043     }  /* switch (level) */
;;;2044   
;;;2045   
;;;2046     if (err != ERR_OK) {
;;;2047       sock_set_errno(sock, err);
;;;2048       return -1;
;;;2049     }
;;;2050   
;;;2051   
;;;2052     /* Now do the actual option processing */
;;;2053     data.sock = sock;
;;;2054   #ifdef LWIP_DEBUG
;;;2055     data.s = s;
;;;2056   #endif /* LWIP_DEBUG */
;;;2057     data.level = level;
;;;2058     data.optname = optname;
;;;2059     data.optval = (void*)optval;
;;;2060     data.optlen = &optlen;
;;;2061     data.err = err;
;;;2062     tcpip_callback(lwip_setsockopt_internal, &data);
;;;2063     sys_arch_sem_wait(&sock->conn->op_completed, 0);
;;;2064     /* maybe lwip_setsockopt_internal has changed err */
;;;2065     err = data.err;
;;;2066   
;;;2067     sock_set_errno(sock, err);
;;;2068     return err ? -1 : 0;
;;;2069   }
0015fa  b007              ADD      sp,sp,#0x1c
0015fc  e8bd83f0          POP      {r4-r9,pc}
                  |L1.5632|
001600  f1b80f00          CMP      r8,#0                 ;1873
001604  d106              BNE      |L1.5652|
001606  bf00              NOP                            ;1874
001608  200e              MOVS     r0,#0xe               ;1874
00160a  6120              STR      r0,[r4,#0x10]         ;1874
00160c  bf00              NOP                            ;1874
00160e  f04f30ff          MOV      r0,#0xffffffff        ;1875
001612  e7f2              B        |L1.5626|
                  |L1.5652|
001614  b357              CBZ      r7,|L1.5740|
001616  2f06              CMP      r7,#6                 ;1879
001618  d06b              BEQ      |L1.5874|
00161a  f6a770ff          SUB      r0,r7,#0xfff          ;1879
00161e  2800              CMP      r0,#0                 ;1879
001620  d172              BNE      |L1.5896|
001622  2d08              CMP      r5,#8                 ;1883
001624  d007              BEQ      |L1.5686|
001626  2d20              CMP      r5,#0x20              ;1883
001628  d004              BEQ      |L1.5684|
00162a  f5a55080          SUB      r0,r5,#0x1000         ;1883
00162e  380a              SUBS     r0,r0,#0xa            ;1883
001630  b9b0              CBNZ     r0,|L1.5728|
001632  e005              B        |L1.5696|
                  |L1.5684|
001634  bf00              NOP                            ;1888
                  |L1.5686|
001636  980e              LDR      r0,[sp,#0x38]         ;1908
001638  2804              CMP      r0,#4                 ;1908
00163a  d200              BCS      |L1.5694|
00163c  2616              MOVS     r6,#0x16              ;1909
                  |L1.5694|
00163e  e013              B        |L1.5736|
                  |L1.5696|
001640  980e              LDR      r0,[sp,#0x38]         ;1913
001642  2804              CMP      r0,#4                 ;1913
001644  d200              BCS      |L1.5704|
001646  2616              MOVS     r6,#0x16              ;1914
                  |L1.5704|
001648  6820              LDR      r0,[r4,#0]            ;1917
00164a  7800              LDRB     r0,[r0,#0]            ;1917
00164c  2820              CMP      r0,#0x20              ;1917
00164e  d105              BNE      |L1.5724|
001650  6820              LDR      r0,[r4,#0]            ;1918
001652  6840              LDR      r0,[r0,#4]            ;1918
001654  7c00              LDRB     r0,[r0,#0x10]         ;1918
001656  f0000002          AND      r0,r0,#2              ;1918
00165a  b100              CBZ      r0,|L1.5726|
                  |L1.5724|
00165c  2661              MOVS     r6,#0x61              ;1920
                  |L1.5726|
00165e  e003              B        |L1.5736|
                  |L1.5728|
001660  bf00              NOP                            ;1925
001662  bf00              NOP                            ;1925
001664  265c              MOVS     r6,#0x5c              ;1927
001666  bf00              NOP                            ;1883
                  |L1.5736|
001668  bf00              NOP                            ;1911
00166a  e05f              B        |L1.5932|
                  |L1.5740|
00166c  2d08              CMP      r5,#8                 ;1933
00166e  d23a              BCS      |L1.5862|
001670  e8dff005          TBB      [pc,r5]               ;1933
001674  3905042c          DCB      0x39,0x05,0x04,0x2c
001678  2d0a1521          DCB      0x2d,0x0a,0x15,0x21
00167c  bf00              NOP                            ;1938
00167e  980e              LDR      r0,[sp,#0x38]         ;1939
001680  2804              CMP      r0,#4                 ;1939
001682  d200              BCS      |L1.5766|
001684  2616              MOVS     r6,#0x16              ;1940
                  |L1.5766|
001686  e032              B        |L1.5870|
001688  980e              LDR      r0,[sp,#0x38]         ;1945
00168a  b900              CBNZ     r0,|L1.5774|
00168c  2616              MOVS     r6,#0x16              ;1946
                  |L1.5774|
00168e  6820              LDR      r0,[r4,#0]            ;1948
001690  7800              LDRB     r0,[r0,#0]            ;1948
001692  f00000f0          AND      r0,r0,#0xf0           ;1948
001696  2820              CMP      r0,#0x20              ;1948
001698  d000              BEQ      |L1.5788|
00169a  2661              MOVS     r6,#0x61              ;1949
                  |L1.5788|
00169c  e027              B        |L1.5870|
00169e  980e              LDR      r0,[sp,#0x38]         ;1953
0016a0  2804              CMP      r0,#4                 ;1953
0016a2  d200              BCS      |L1.5798|
0016a4  2616              MOVS     r6,#0x16              ;1954
                  |L1.5798|
0016a6  6820              LDR      r0,[r4,#0]            ;1956
0016a8  7800              LDRB     r0,[r0,#0]            ;1956
0016aa  f00000f0          AND      r0,r0,#0xf0           ;1956
0016ae  2820              CMP      r0,#0x20              ;1956
0016b0  d000              BEQ      |L1.5812|
0016b2  2661              MOVS     r6,#0x61              ;1957
                  |L1.5812|
0016b4  e01b              B        |L1.5870|
0016b6  980e              LDR      r0,[sp,#0x38]         ;1961
0016b8  b900              CBNZ     r0,|L1.5820|
0016ba  2616              MOVS     r6,#0x16              ;1962
                  |L1.5820|
0016bc  6820              LDR      r0,[r4,#0]            ;1964
0016be  7800              LDRB     r0,[r0,#0]            ;1964
0016c0  f00000f0          AND      r0,r0,#0xf0           ;1964
0016c4  2820              CMP      r0,#0x20              ;1964
0016c6  d000              BEQ      |L1.5834|
0016c8  2661              MOVS     r6,#0x61              ;1965
                  |L1.5834|
0016ca  e010              B        |L1.5870|
0016cc  bf00              NOP                            ;1969
0016ce  980e              LDR      r0,[sp,#0x38]         ;1970
0016d0  2808              CMP      r0,#8                 ;1970
0016d2  d200              BCS      |L1.5846|
0016d4  2616              MOVS     r6,#0x16              ;1971
                  |L1.5846|
0016d6  6820              LDR      r0,[r4,#0]            ;1973
0016d8  7800              LDRB     r0,[r0,#0]            ;1973
0016da  f00000f0          AND      r0,r0,#0xf0           ;1973
0016de  2820              CMP      r0,#0x20              ;1973
0016e0  d000              BEQ      |L1.5860|
0016e2  2661              MOVS     r6,#0x61              ;1974
                  |L1.5860|
0016e4  e003              B        |L1.5870|
                  |L1.5862|
0016e6  bf00              NOP                            ;1979
0016e8  bf00              NOP                            ;1979
0016ea  265c              MOVS     r6,#0x5c              ;1981
0016ec  bf00              NOP                            ;1933
                  |L1.5870|
0016ee  bf00              NOP                            ;1942
0016f0  e01c              B        |L1.5932|
                  |L1.5874|
0016f2  980e              LDR      r0,[sp,#0x38]         ;1988
0016f4  2804              CMP      r0,#4                 ;1988
0016f6  d201              BCS      |L1.5884|
0016f8  2616              MOVS     r6,#0x16              ;1989
0016fa  e017              B        |L1.5932|
                  |L1.5884|
0016fc  6820              LDR      r0,[r4,#0]            ;1994
0016fe  7800              LDRB     r0,[r0,#0]            ;1994
001700  2810              CMP      r0,#0x10              ;1994
001702  d002              BEQ      |L1.5898|
001704  2000              MOVS     r0,#0                 ;1995
001706  e778              B        |L1.5626|
                  |L1.5896|
001708  e00c              B        |L1.5924|
                  |L1.5898|
00170a  2d01              CMP      r5,#1                 ;1997
00170c  d002              BEQ      |L1.5908|
00170e  2d02              CMP      r5,#2                 ;1997
001710  d102              BNE      |L1.5912|
001712  e000              B        |L1.5910|
                  |L1.5908|
001714  bf00              NOP                            ;1999
                  |L1.5910|
001716  e003              B        |L1.5920|
                  |L1.5912|
001718  bf00              NOP                            ;2008
00171a  bf00              NOP                            ;2008
00171c  265c              MOVS     r6,#0x5c              ;2010
00171e  bf00              NOP                            ;1997
                  |L1.5920|
001720  bf00              NOP                            ;2005
001722  e003              B        |L1.5932|
                  |L1.5924|
001724  bf00              NOP                            ;2040
001726  bf00              NOP                            ;2040
001728  265c              MOVS     r6,#0x5c              ;2042
00172a  bf00              NOP                            ;1879
                  |L1.5932|
00172c  bf00              NOP                            ;1929
00172e  b12e              CBZ      r6,|L1.5948|
001730  bf00              NOP                            ;2047
001732  6126              STR      r6,[r4,#0x10]         ;2047
001734  bf00              NOP                            ;2047
001736  f04f30ff          MOV      r0,#0xffffffff        ;2048
00173a  e75e              B        |L1.5626|
                  |L1.5948|
00173c  9400              STR      r4,[sp,#0]            ;2053
00173e  f8cd9004          STR      r9,[sp,#4]            ;2055
001742  9702              STR      r7,[sp,#8]            ;2057
001744  9503              STR      r5,[sp,#0xc]          ;2058
001746  f8cd8010          STR      r8,[sp,#0x10]         ;2059
00174a  a80e              ADD      r0,sp,#0x38           ;2060
00174c  9005              STR      r0,[sp,#0x14]         ;2060
00174e  f88d6018          STRB     r6,[sp,#0x18]         ;2061
001752  2201              MOVS     r2,#1                 ;2062
001754  4669              MOV      r1,sp                 ;2062
001756  4846              LDR      r0,|L1.6256|
001758  f7fffffe          BL       tcpip_callback_with_block
00175c  6821              LDR      r1,[r4,#0]            ;2063
00175e  f101000c          ADD      r0,r1,#0xc            ;2063
001762  2100              MOVS     r1,#0                 ;2063
001764  f7fffffe          BL       sys_arch_sem_wait
001768  f99d6018          LDRSB    r6,[sp,#0x18]         ;2065
00176c  bf00              NOP                            ;2067
00176e  6126              STR      r6,[r4,#0x10]         ;2067
001770  bf00              NOP                            ;2067
001772  b116              CBZ      r6,|L1.6010|
001774  f04f30ff          MOV      r0,#0xffffffff        ;2068
001778  e73f              B        |L1.5626|
                  |L1.6010|
00177a  2000              MOVS     r0,#0                 ;2068
00177c  e73d              B        |L1.5626|
;;;2070   
                          ENDP

                  lwip_ioctl PROC
;;;2280   int
;;;2281   lwip_ioctl(int s, long cmd, void *argp)
00177e  e92d41f0          PUSH     {r4-r8,lr}
;;;2282   {
001782  4680              MOV      r8,r0
001784  460e              MOV      r6,r1
001786  4615              MOV      r5,r2
;;;2283     struct lwip_sock *sock = get_socket(s);
001788  4640              MOV      r0,r8
00178a  f7fffffe          BL       get_socket
00178e  4604              MOV      r4,r0
;;;2284     u8_t val;
;;;2285   #if LWIP_SO_RCVBUF
;;;2286     u16_t buflen = 0;
;;;2287     s16_t recv_avail;
;;;2288   #endif /* LWIP_SO_RCVBUF */
;;;2289   
;;;2290     if (!sock) {
001790  b91c              CBNZ     r4,|L1.6042|
;;;2291       return -1;
001792  f04f30ff          MOV      r0,#0xffffffff
                  |L1.6038|
;;;2292     }
;;;2293   
;;;2294     switch (cmd) {
;;;2295   #if LWIP_SO_RCVBUF
;;;2296     case FIONREAD:
;;;2297       if (!argp) {
;;;2298         sock_set_errno(sock, EINVAL);
;;;2299         return -1;
;;;2300       }
;;;2301   
;;;2302       SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
;;;2303       if (recv_avail < 0) {
;;;2304         recv_avail = 0;
;;;2305       }
;;;2306       *((u16_t*)argp) = (u16_t)recv_avail;
;;;2307   
;;;2308       /* Check if there is data left from the last recv operation. /maq 041215 */
;;;2309       if (sock->lastdata) {
;;;2310         struct pbuf *p = (struct pbuf *)sock->lastdata;
;;;2311         if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;2312           p = ((struct netbuf *)p)->p;
;;;2313         }
;;;2314         buflen = p->tot_len;
;;;2315         buflen -= sock->lastoffset;
;;;2316   
;;;2317         *((u16_t*)argp) += buflen;
;;;2318       }
;;;2319   
;;;2320       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %"U16_F"\n", s, argp, *((u16_t*)argp)));
;;;2321       sock_set_errno(sock, 0);
;;;2322       return 0;
;;;2323   #endif /* LWIP_SO_RCVBUF */
;;;2324   
;;;2325     case FIONBIO:
;;;2326       val = 0;
;;;2327       if (argp && *(u32_t*)argp) {
;;;2328         val = 1;
;;;2329       }
;;;2330       netconn_set_nonblocking(sock->conn, val);
;;;2331       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
;;;2332       sock_set_errno(sock, 0);
;;;2333       return 0;
;;;2334   
;;;2335     default:
;;;2336       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
;;;2337       sock_set_errno(sock, ENOSYS); /* not yet implemented */
;;;2338       return -1;
;;;2339     } /* switch (cmd) */
;;;2340   }
001796  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6042|
00179a  4836              LDR      r0,|L1.6260|
00179c  4430              ADD      r0,r0,r6              ;2294
00179e  b9f8              CBNZ     r0,|L1.6112|
0017a0  2700              MOVS     r7,#0                 ;2326
0017a2  b115              CBZ      r5,|L1.6058|
0017a4  6828              LDR      r0,[r5,#0]            ;2327
0017a6  b100              CBZ      r0,|L1.6058|
0017a8  2701              MOVS     r7,#1                 ;2328
                  |L1.6058|
0017aa  bf00              NOP                            ;2330
0017ac  b147              CBZ      r7,|L1.6080|
0017ae  6820              LDR      r0,[r4,#0]            ;2330
0017b0  f89000d8          LDRB     r0,[r0,#0xd8]         ;2330
0017b4  f0400002          ORR      r0,r0,#2              ;2330
0017b8  6821              LDR      r1,[r4,#0]            ;2330
0017ba  f88100d8          STRB     r0,[r1,#0xd8]         ;2330
0017be  e007              B        |L1.6096|
                  |L1.6080|
0017c0  6820              LDR      r0,[r4,#0]            ;2330
0017c2  f89000d8          LDRB     r0,[r0,#0xd8]         ;2330
0017c6  f0200002          BIC      r0,r0,#2              ;2330
0017ca  6821              LDR      r1,[r4,#0]            ;2330
0017cc  f88100d8          STRB     r0,[r1,#0xd8]         ;2330
                  |L1.6096|
0017d0  bf00              NOP                            ;2330
0017d2  bf00              NOP                            ;2331
0017d4  bf00              NOP                            ;2331
0017d6  bf00              NOP                            ;2332
0017d8  2000              MOVS     r0,#0                 ;2332
0017da  6120              STR      r0,[r4,#0x10]         ;2332
0017dc  bf00              NOP                            ;2332
0017de  e7da              B        |L1.6038|
                  |L1.6112|
0017e0  bf00              NOP                            ;2336
0017e2  bf00              NOP                            ;2336
0017e4  bf00              NOP                            ;2337
0017e6  2026              MOVS     r0,#0x26              ;2337
0017e8  6120              STR      r0,[r4,#0x10]         ;2337
0017ea  bf00              NOP                            ;2337
0017ec  f04f30ff          MOV      r0,#0xffffffff        ;2338
0017f0  e7d1              B        |L1.6038|
;;;2341   
                          ENDP

                  lwip_fcntl PROC
;;;2346   int
;;;2347   lwip_fcntl(int s, int cmd, int val)
0017f2  e92d41f0          PUSH     {r4-r8,lr}
;;;2348   {
0017f6  4607              MOV      r7,r0
0017f8  460e              MOV      r6,r1
0017fa  4615              MOV      r5,r2
;;;2349     struct lwip_sock *sock = get_socket(s);
0017fc  4638              MOV      r0,r7
0017fe  f7fffffe          BL       get_socket
001802  4604              MOV      r4,r0
;;;2350     int ret = -1;
001804  f04f38ff          MOV      r8,#0xffffffff
;;;2351   
;;;2352     if (!sock || !sock->conn) {
001808  b10c              CBZ      r4,|L1.6158|
00180a  6820              LDR      r0,[r4,#0]
00180c  b918              CBNZ     r0,|L1.6166|
                  |L1.6158|
;;;2353       return -1;
00180e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.6162|
;;;2354     }
;;;2355   
;;;2356     switch (cmd) {
;;;2357     case F_GETFL:
;;;2358       ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
;;;2359       break;
;;;2360     case F_SETFL:
;;;2361       if ((val & ~O_NONBLOCK) == 0) {
;;;2362         /* only O_NONBLOCK, all other bits are zero */
;;;2363         netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
;;;2364         ret = 0;
;;;2365       }
;;;2366       break;
;;;2367     default:
;;;2368       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
;;;2369       break;
;;;2370     }
;;;2371     return ret;
;;;2372   }
001812  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6166|
001816  2e03              CMP      r6,#3                 ;2356
001818  d002              BEQ      |L1.6176|
00181a  2e04              CMP      r6,#4                 ;2356
00181c  d122              BNE      |L1.6244|
00181e  e005              B        |L1.6188|
                  |L1.6176|
001820  6820              LDR      r0,[r4,#0]            ;2358
001822  f89000d8          LDRB     r0,[r0,#0xd8]         ;2358
001826  f3c00840          UBFX     r8,r0,#1,#1           ;2358
00182a  e01e              B        |L1.6250|
                  |L1.6188|
00182c  f0250001          BIC      r0,r5,#1              ;2361
001830  b9b8              CBNZ     r0,|L1.6242|
001832  bf00              NOP                            ;2363
001834  f0050001          AND      r0,r5,#1              ;2363
001838  b140              CBZ      r0,|L1.6220|
00183a  6820              LDR      r0,[r4,#0]            ;2363
00183c  f89000d8          LDRB     r0,[r0,#0xd8]         ;2363
001840  f0400002          ORR      r0,r0,#2              ;2363
001844  6821              LDR      r1,[r4,#0]            ;2363
001846  f88100d8          STRB     r0,[r1,#0xd8]         ;2363
00184a  e007              B        |L1.6236|
                  |L1.6220|
00184c  6820              LDR      r0,[r4,#0]            ;2363
00184e  f89000d8          LDRB     r0,[r0,#0xd8]         ;2363
001852  f0200002          BIC      r0,r0,#2              ;2363
001856  6821              LDR      r1,[r4,#0]            ;2363
001858  f88100d8          STRB     r0,[r1,#0xd8]         ;2363
                  |L1.6236|
00185c  bf00              NOP                            ;2363
00185e  f04f0800          MOV      r8,#0                 ;2364
                  |L1.6242|
001862  e002              B        |L1.6250|
                  |L1.6244|
001864  bf00              NOP                            ;2368
001866  bf00              NOP                            ;2368
001868  bf00              NOP                            ;2369
                  |L1.6250|
00186a  bf00              NOP                            ;2359
00186c  4640              MOV      r0,r8                 ;2371
00186e  e7d0              B        |L1.6162|
;;;2373   
                          ENDP

                  |L1.6256|
                          DCD      lwip_setsockopt_internal
                  |L1.6260|
                          DCD      0x7ffb9982

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sockets
                          %        480

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  err_to_errno_table
                          DCD      0x00000000
                          DCD      0x0000000c
                          DCD      0x00000069
                          DCD      0x0000000b
                          DCD      0x00000071
                          DCD      0x00000073
                          DCD      0x00000016
                          DCD      0x0000000b
                          DCD      0x00000062
                          DCD      0x00000072
                          DCD      0x00000067
                          DCD      0x00000068
                          DCD      0x0000006b
                          DCD      0x0000006b
                          DCD      0x00000005
                          DCD      0xffffffff

                          AREA ||.data||, DATA, ALIGN=2

                  select_cb_list
                          DCD      0x00000000
                  select_cb_ctr
                          DCD      0x00000000
