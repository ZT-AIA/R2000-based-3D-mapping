; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\discovery\stm32f4x7_eth_bsp.o --asm_dir=.\Discovery\ --list_dir=.\Discovery\ --depend=.\discovery\stm32f4x7_eth_bsp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\inc -I..\src -I..\..\libraries\CMSIS\Include -I..\..\libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\libraries\STM32F4x7_ETH_Driver\inc -I..\..\libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\libraries\STM32F4-Discovery -I..\..\libraries\lwip-1.4.1\port\STM32F4x7 -I..\..\libraries\lwip-1.4.1\src\include -I..\..\libraries\lwip-1.4.1\src\include\ipv4 -I..\..\libraries\lwip-1.4.1\src\include\lwip -I..\..\libraries\lwip-1.4.1\src\include\netif -I..\..\libraries\lwip-1.4.1\port\STM32F4x7\arch -I..\..\libraries\rtx-v4.73\INC -I..\..\libraries\rtx-v4.73\SRC -I..\..\libraries\ptpd-2.0.0\src -I..\inc\system -I..\inc\laser -I..\inc\motorCtrl -I..\..\libraries\lwip-1.4.1\src\include\ipv4\lwip -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=520 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -D__CORTEX_M4F -D__FPU_PRESENT -D__CMSIS_RTOS -DSTM32F40_41xxx --omf_browse=.\discovery\stm32f4x7_eth_bsp.crf ..\src\stm32f4x7_eth_bsp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETH_MACDMA_Config PROC
;;;97       */
;;;98     static void ETH_MACDMA_Config(void)
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100      //ETH_InitTypeDef ETH_InitStructure;
;;;101    
;;;102      /* Enable ETHERNET clock  */
;;;103      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |
000002  2101              MOVS     r1,#1
000004  f04f50f0          MOV      r0,#0x1e000000
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;104                             RCC_AHB1Periph_ETH_MAC_Rx | RCC_AHB1Periph_ETH_MAC_PTP, ENABLE);                                             
;;;105    
;;;106      /* Reset ETHERNET on AHB Bus */
;;;107      ETH_DeInit();
00000c  f7fffffe          BL       ETH_DeInit
;;;108    
;;;109      /* Software reset */
;;;110      ETH_SoftwareReset();
000010  f7fffffe          BL       ETH_SoftwareReset
;;;111    
;;;112      /* Wait for software reset */
;;;113      while (ETH_GetSoftwareResetStatus() == SET);
000014  bf00              NOP      
                  |L1.22|
000016  f7fffffe          BL       ETH_GetSoftwareResetStatus
00001a  2801              CMP      r0,#1
00001c  d0fb              BEQ      |L1.22|
;;;114    
;;;115      /* ETHERNET Configuration --------------------------------------------------*/
;;;116      /* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
;;;117      ETH_StructInit(&ETH_InitStructure);
00001e  48fc              LDR      r0,|L1.1040|
000020  f7fffffe          BL       ETH_StructInit
;;;118    
;;;119      /* Fill ETH_InitStructure parametrs */
;;;120      /*------------------------   MAC   -----------------------------------*/
;;;121      ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
000024  2001              MOVS     r0,#1
000026  49fa              LDR      r1,|L1.1040|
000028  6008              STR      r0,[r1,#0]  ; ETH_InitStructure
;;;122      //ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
;;;123      //ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
;;;124      //ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;   
;;;125    
;;;126      ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
00002a  2000              MOVS     r0,#0
00002c  61c8              STR      r0,[r1,#0x1c]  ; ETH_InitStructure
;;;127      ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
00002e  f44f7000          MOV      r0,#0x200
000032  6288              STR      r0,[r1,#0x28]  ; ETH_InitStructure
;;;128      ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
000034  2000              MOVS     r0,#0
000036  62c8              STR      r0,[r1,#0x2c]  ; ETH_InitStructure
;;;129      ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Disable;
000038  6388              STR      r0,[r1,#0x38]  ; ETH_InitStructure
;;;130      ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
00003a  6448              STR      r0,[r1,#0x44]  ; ETH_InitStructure
;;;131      ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
00003c  64c8              STR      r0,[r1,#0x4c]  ; ETH_InitStructure
;;;132      ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_None;//ETH_MulticastFramesFilter_Perfect
00003e  2010              MOVS     r0,#0x10
000040  6508              STR      r0,[r1,#0x50]  ; ETH_InitStructure
;;;133      ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
000042  2000              MOVS     r0,#0
000044  6548              STR      r0,[r1,#0x54]  ; ETH_InitStructure
;;;134    #ifdef CHECKSUM_BY_HARDWARE
;;;135      ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable;
000046  f44f6080          MOV      r0,#0x400
00004a  6248              STR      r0,[r1,#0x24]  ; ETH_InitStructure
;;;136    #endif
;;;137    
;;;138      /*------------------------   DMA   -----------------------------------*/  
;;;139      
;;;140      /* When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
;;;141      the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
;;;142      if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
;;;143      ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
00004c  2000              MOVS     r0,#0
00004e  f8c10080          STR      r0,[r1,#0x80]  ; ETH_InitStructure
;;;144      ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
000052  f04f7000          MOV      r0,#0x2000000
000056  f8c10084          STR      r0,[r1,#0x84]  ; ETH_InitStructure
;;;145      ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
00005a  1100              ASRS     r0,r0,#4
00005c  f8c1008c          STR      r0,[r1,#0x8c]  ; ETH_InitStructure
;;;146     
;;;147      ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
000060  2000              MOVS     r0,#0
000062  f8c10094          STR      r0,[r1,#0x94]  ; ETH_InitStructure
;;;148      ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
000066  f8c10098          STR      r0,[r1,#0x98]  ; ETH_InitStructure
;;;149      ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
00006a  2004              MOVS     r0,#4
00006c  f8c100a0          STR      r0,[r1,#0xa0]  ; ETH_InitStructure
;;;150      ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;      
000070  05c0              LSLS     r0,r0,#23
000072  f8c100a4          STR      r0,[r1,#0xa4]  ; ETH_InitStructure
;;;151      ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;                
000076  1240              ASRS     r0,r0,#9
000078  f8c100a8          STR      r0,[r1,#0xa8]  ; ETH_InitStructure
;;;152      ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
00007c  0180              LSLS     r0,r0,#6
00007e  f8c100ac          STR      r0,[r1,#0xac]  ; ETH_InitStructure
;;;153      ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
000082  1240              ASRS     r0,r0,#9
000084  f8c100b0          STR      r0,[r1,#0xb0]  ; ETH_InitStructure
;;;154      ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
000088  0040              LSLS     r0,r0,#1
00008a  f8c100b8          STR      r0,[r1,#0xb8]  ; ETH_InitStructure
;;;155    
;;;156      /* Configure Ethernet */
;;;157      EthInitStatus = ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);//LAN8720_PHY_ADDRESS);
00008e  2101              MOVS     r1,#1
000090  48df              LDR      r0,|L1.1040|
000092  f7fffffe          BL       ETH_Init
000096  49df              LDR      r1,|L1.1044|
000098  6008              STR      r0,[r1,#0]  ; EthInitStatus
;;;158    
;;;159      /* Enable the Ethernet Rx Interrupt */
;;;160      ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  48de              LDR      r0,|L1.1048|
00009e  f7fffffe          BL       ETH_DMAITConfig
;;;161    }
0000a2  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  ETH_NVIC_Config PROC
;;;231      */
;;;232    void ETH_NVIC_Config(void)
0000a4  b508              PUSH     {r3,lr}
;;;233    {
;;;234      NVIC_InitTypeDef   NVIC_InitStructure;
;;;235    
;;;236    	/* The interrupt controller (NVIC) allows the bits that define each 
;;;237    	interrupt's priority to be split between bits that define the interrupt's 
;;;238    	pre-emption priority bits and bits that define the interrupt's sub-
;;;239    	priority.  For simplicity FreeRTOS requires all bits must be defined to 
;;;240    	be pre-emption priority bits.  An assertion in vPortValidateInterruptPriority() 
;;;241    	function in the file port.c will fail if this is not the case (if some bits 
;;;242    	represent a sub-priority).
;;;243    
;;;244    	With FreeRTOS it is recommended to assign all the priority bits to be 
;;;245    	preempt priority bits, leaving no priority bits as subpriority bits. Any 
;;;246    	other configuration complicates the otherwise direct relationship between 
;;;247    	the configMAX_SYSCALL_INTERRUPT_PRIORITY setting and the priority 
;;;248    	assigned to individual peripheral interrupts.
;;;249    
;;;250    	Most systems default to the wanted configuration, with the noticeable 
;;;251    	exception of the STM32 driver library. If you are using an STM32 with the 
;;;252    	STM32 driver library then ensure all the priority bits are assigned to be 
;;;253    	preempt priority bits by calling NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); 
;;;254    	before the RTOS schedulre is started. 	
;;;255    	
;;;256    	See 'Preempt Priority and Subpriority': http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;257    
;;;258      /* 4 bit for pre-emption priority, 0 bits for subpriority */
;;;259      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); 
0000a6  f44f7040          MOV      r0,#0x300
0000aa  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;260    
;;;261      /* Enable the Ethernet global Interrupt */
;;;262    	/* Preemption priority must be less than or equal to 
;;;263    	configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY as specified 
;;;264    	in FreeRTOSConfig.h */
;;;265      NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn;
0000ae  203d              MOVS     r0,#0x3d
0000b0  f88d0000          STRB     r0,[sp,#0]
;;;266      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = Ether_PRIO;
0000b4  2006              MOVS     r0,#6
0000b6  f88d0001          STRB     r0,[sp,#1]
;;;267      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000ba  2000              MOVS     r0,#0
0000bc  f88d0002          STRB     r0,[sp,#2]
;;;268      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000c0  2001              MOVS     r0,#1
0000c2  f88d0003          STRB     r0,[sp,#3]
;;;269      NVIC_Init(&NVIC_InitStructure);
0000c6  4668              MOV      r0,sp
0000c8  f7fffffe          BL       NVIC_Init
;;;270    }
0000cc  bd08              POP      {r3,pc}
;;;271    
                          ENDP

                  ETH_GPIO_Config PROC
;;;168      */
;;;169    void ETH_GPIO_Config(void)
0000ce  b51c              PUSH     {r2-r4,lr}
;;;170    {
;;;171      volatile uint32_t i;
;;;172      GPIO_InitTypeDef GPIO_InitStructure;
;;;173      
;;;174      /* Enable GPIOs clocks */
;;;175      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB
0000d0  2101              MOVS     r1,#1
0000d2  2007              MOVS     r0,#7
0000d4  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;176    	                       | RCC_AHB1Periph_GPIOC, ENABLE);
;;;177    
;;;178      /* Enable SYSCFG clock */
;;;179      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);  
0000d8  2101              MOVS     r1,#1
0000da  0388              LSLS     r0,r1,#14
0000dc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;180      
;;;181      /* MII/RMII Media interface selection --------------------------------------*/
;;;182      SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII);
0000e0  2001              MOVS     r0,#1
0000e2  f7fffffe          BL       SYSCFG_ETH_MediaInterfaceConfig
;;;183    
;;;184    
;;;185    /* Ethernet pins configuration ************************************************/
;;;186       /*
;;;187            ETH_MDIO --------------> PA2
;;;188            ETH_MDC ---------------> PC1
;;;189        
;;;190            ETH_RMII_REF_CLK-------> PA1
;;;191            ETH_RMII_CRS_DV -------> PA7
;;;192            ETH_RMII_RXD0   -------> PC4
;;;193            ETH_RMII_RXD1   -------> PC5
;;;194            ETH_RMII_TX_EN  -------> PB11
;;;195            ETH_RMII_TXD0   -------> PB12
;;;196            ETH_RMII_TXD1   -------> PB13
;;;197       */
;;;198    
;;;199      /* Configure PA1,PA2 and PA7 */
;;;200      GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
0000e6  2086              MOVS     r0,#0x86
0000e8  9000              STR      r0,[sp,#0]
;;;201    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0000ea  2003              MOVS     r0,#3
0000ec  f88d0005          STRB     r0,[sp,#5]
;;;202      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
0000f0  2002              MOVS     r0,#2
0000f2  f88d0004          STRB     r0,[sp,#4]
;;;203      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000f6  2000              MOVS     r0,#0
0000f8  f88d0006          STRB     r0,[sp,#6]
;;;204      GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL ;
0000fc  f88d0007          STRB     r0,[sp,#7]
;;;205      GPIO_Init(GPIOA, &GPIO_InitStructure);
000100  4669              MOV      r1,sp
000102  48c6              LDR      r0,|L1.1052|
000104  f7fffffe          BL       GPIO_Init
;;;206      GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
000108  220b              MOVS     r2,#0xb
00010a  2101              MOVS     r1,#1
00010c  48c3              LDR      r0,|L1.1052|
00010e  f7fffffe          BL       GPIO_PinAFConfig
;;;207      GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
000112  220b              MOVS     r2,#0xb
000114  2102              MOVS     r1,#2
000116  48c1              LDR      r0,|L1.1052|
000118  f7fffffe          BL       GPIO_PinAFConfig
;;;208      GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);
00011c  220b              MOVS     r2,#0xb
00011e  2107              MOVS     r1,#7
000120  48be              LDR      r0,|L1.1052|
000122  f7fffffe          BL       GPIO_PinAFConfig
;;;209    
;;;210      /* Configure PB11,PB12 and PB13 */
;;;211      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
000126  f44f5060          MOV      r0,#0x3800
00012a  9000              STR      r0,[sp,#0]
;;;212      GPIO_Init(GPIOB, &GPIO_InitStructure);
00012c  4669              MOV      r1,sp
00012e  48bc              LDR      r0,|L1.1056|
000130  f7fffffe          BL       GPIO_Init
;;;213      GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_ETH);	
000134  220b              MOVS     r2,#0xb
000136  210a              MOVS     r1,#0xa
000138  48b9              LDR      r0,|L1.1056|
00013a  f7fffffe          BL       GPIO_PinAFConfig
;;;214      GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_ETH);
00013e  220b              MOVS     r2,#0xb
000140  4611              MOV      r1,r2
000142  48b7              LDR      r0,|L1.1056|
000144  f7fffffe          BL       GPIO_PinAFConfig
;;;215      GPIO_PinAFConfig(GPIOB, GPIO_PinSource12, GPIO_AF_ETH);
000148  220b              MOVS     r2,#0xb
00014a  210c              MOVS     r1,#0xc
00014c  48b4              LDR      r0,|L1.1056|
00014e  f7fffffe          BL       GPIO_PinAFConfig
;;;216      GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_ETH);
000152  220b              MOVS     r2,#0xb
000154  210d              MOVS     r1,#0xd
000156  48b2              LDR      r0,|L1.1056|
000158  f7fffffe          BL       GPIO_PinAFConfig
;;;217    
;;;218      /* Configure PC1, PC4 and PC5 */
;;;219      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
00015c  2032              MOVS     r0,#0x32
00015e  9000              STR      r0,[sp,#0]
;;;220      GPIO_Init(GPIOC, &GPIO_InitStructure);
000160  4669              MOV      r1,sp
000162  48b0              LDR      r0,|L1.1060|
000164  f7fffffe          BL       GPIO_Init
;;;221      GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
000168  220b              MOVS     r2,#0xb
00016a  2101              MOVS     r1,#1
00016c  48ad              LDR      r0,|L1.1060|
00016e  f7fffffe          BL       GPIO_PinAFConfig
;;;222      GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
000172  220b              MOVS     r2,#0xb
000174  2104              MOVS     r1,#4
000176  48ab              LDR      r0,|L1.1060|
000178  f7fffffe          BL       GPIO_PinAFConfig
;;;223      GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
00017c  220b              MOVS     r2,#0xb
00017e  2105              MOVS     r1,#5
000180  48a8              LDR      r0,|L1.1060|
000182  f7fffffe          BL       GPIO_PinAFConfig
;;;224    	
;;;225    }
000186  bd1c              POP      {r2-r4,pc}
;;;226    
                          ENDP

                  ETH_BSP_Config PROC
;;;68       */
;;;69     void ETH_BSP_Config(void)
000188  b510              PUSH     {r4,lr}
;;;70     {
;;;71       /* Configure the GPIO ports for ethernet pins */
;;;72       ETH_GPIO_Config();
00018a  f7fffffe          BL       ETH_GPIO_Config
;;;73       
;;;74       /* Config NVIC for Ethernet */
;;;75       ETH_NVIC_Config();
00018e  f7fffffe          BL       ETH_NVIC_Config
;;;76     
;;;77       /* Configure the Ethernet MAC/DMA */
;;;78       ETH_MACDMA_Config();
000192  f7fffffe          BL       ETH_MACDMA_Config
;;;79     	
;;;80     	if(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS,PHY_SR)&1)
000196  2110              MOVS     r1,#0x10
000198  2001              MOVS     r0,#1
00019a  f7fffffe          BL       ETH_ReadPHYRegister
00019e  f0000001          AND      r0,r0,#1
0001a2  b128              CBZ      r0,|L1.432|
;;;81     	{
;;;82     		EthInitStatus |= ETH_LINK_FLAG;
0001a4  489b              LDR      r0,|L1.1044|
0001a6  6800              LDR      r0,[r0,#0]  ; EthInitStatus
0001a8  f0400010          ORR      r0,r0,#0x10
0001ac  4999              LDR      r1,|L1.1044|
0001ae  6008              STR      r0,[r1,#0]  ; EthInitStatus
                  |L1.432|
;;;83     	}
;;;84     
;;;85       if (EthInitStatus == 0) {
0001b0  4898              LDR      r0,|L1.1044|
0001b2  6800              LDR      r0,[r0,#0]  ; EthInitStatus
0001b4  b9d0              CBNZ     r0,|L1.492|
;;;86         LCD_SetTextColor(LCD_COLOR_RED);
0001b6  f44f4078          MOV      r0,#0xf800
0001ba  f7fffffe          BL       LCD_SetTextColor
;;;87         LCD_DisplayStringLine(Line5, (uint8_t*)"   Ethernet Init   ");
0001be  f7fffffe          BL       LCD_GetFont
0001c2  88c0              LDRH     r0,[r0,#6]
0001c4  eb000080          ADD      r0,r0,r0,LSL #2
0001c8  b284              UXTH     r4,r0
0001ca  a197              ADR      r1,|L1.1064|
0001cc  4620              MOV      r0,r4
0001ce  f7fffffe          BL       LCD_DisplayStringLine
;;;88         LCD_DisplayStringLine(Line6, (uint8_t*)"      failed      ");
0001d2  f7fffffe          BL       LCD_GetFont
0001d6  88c0              LDRH     r0,[r0,#6]
0001d8  eb000040          ADD      r0,r0,r0,LSL #1
0001dc  0440              LSLS     r0,r0,#17
0001de  0c04              LSRS     r4,r0,#16
0001e0  a196              ADR      r1,|L1.1084|
0001e2  4620              MOV      r0,r4
0001e4  f7fffffe          BL       LCD_DisplayStringLine
;;;89         while(1);
0001e8  bf00              NOP      
                  |L1.490|
0001ea  e7fe              B        |L1.490|
                  |L1.492|
;;;90       }
;;;91     }
0001ec  bd10              POP      {r4,pc}
;;;92     
                          ENDP

                  Eth_Link_PHYITConfig PROC
;;;276      */
;;;277    uint32_t Eth_Link_PHYITConfig(uint16_t PHYAddress)
0001ee  b570              PUSH     {r4-r6,lr}
;;;278    {
0001f0  4605              MOV      r5,r0
;;;279      uint16_t tmpreg = 0;
0001f2  2400              MOVS     r4,#0
;;;280    
;;;281      /* Read MICR register */
;;;282      tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MICR);
0001f4  2111              MOVS     r1,#0x11
0001f6  4628              MOV      r0,r5
0001f8  f7fffffe          BL       ETH_ReadPHYRegister
0001fc  4604              MOV      r4,r0
;;;283    
;;;284      /* Enable output interrupt events to signal via the INT pin */
;;;285      tmpreg |= (uint16_t)(PHY_MICR_INT_EN | PHY_MICR_INT_OE);
0001fe  f0440403          ORR      r4,r4,#3
;;;286      if(!(ETH_WritePHYRegister(PHYAddress, PHY_MICR, tmpreg)))
000202  4622              MOV      r2,r4
000204  2111              MOVS     r1,#0x11
000206  4628              MOV      r0,r5
000208  f7fffffe          BL       ETH_WritePHYRegister
00020c  b908              CBNZ     r0,|L1.530|
;;;287      {
;;;288        /* Return ERROR in case of write timeout */
;;;289        return ETH_ERROR;
00020e  2000              MOVS     r0,#0
                  |L1.528|
;;;290      }
;;;291    
;;;292      /* Read MISR register */
;;;293      tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MISR);
;;;294    
;;;295      /* Enable Interrupt on change of link status */
;;;296      tmpreg |= (uint16_t)PHY_MISR_LINK_INT_EN;
;;;297      if(!(ETH_WritePHYRegister(PHYAddress, PHY_MISR, tmpreg)))
;;;298      {
;;;299        /* Return ERROR in case of write timeout */
;;;300        return ETH_ERROR;
;;;301      }
;;;302      /* Return SUCCESS */
;;;303      return ETH_SUCCESS;   
;;;304    }
000210  bd70              POP      {r4-r6,pc}
                  |L1.530|
000212  2112              MOVS     r1,#0x12              ;293
000214  4628              MOV      r0,r5                 ;293
000216  f7fffffe          BL       ETH_ReadPHYRegister
00021a  4604              MOV      r4,r0                 ;293
00021c  f0440420          ORR      r4,r4,#0x20           ;296
000220  4622              MOV      r2,r4                 ;297
000222  2112              MOVS     r1,#0x12              ;297
000224  4628              MOV      r0,r5                 ;297
000226  f7fffffe          BL       ETH_WritePHYRegister
00022a  b908              CBNZ     r0,|L1.560|
00022c  2000              MOVS     r0,#0                 ;300
00022e  e7ef              B        |L1.528|
                  |L1.560|
000230  2001              MOVS     r0,#1                 ;303
000232  e7ed              B        |L1.528|
;;;305    
                          ENDP

                  Eth_Link_EXTIConfig PROC
;;;310      */
;;;311    void Eth_Link_EXTIConfig(void)
000234  b500              PUSH     {lr}
;;;312    {
000236  b085              SUB      sp,sp,#0x14
;;;313      GPIO_InitTypeDef GPIO_InitStructure;
;;;314      EXTI_InitTypeDef EXTI_InitStructure;
;;;315      NVIC_InitTypeDef NVIC_InitStructure;
;;;316    
;;;317      /* Enable the INT (PB14) Clock */
;;;318      RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
000238  2101              MOVS     r1,#1
00023a  2002              MOVS     r0,#2
00023c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;319      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000240  2101              MOVS     r1,#1
000242  0388              LSLS     r0,r1,#14
000244  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;320    
;;;321      /* Configure INT pin as input */
;;;322      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
000248  2000              MOVS     r0,#0
00024a  f88d0010          STRB     r0,[sp,#0x10]
;;;323      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00024e  f88d0013          STRB     r0,[sp,#0x13]
;;;324      GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
000252  f44f4080          MOV      r0,#0x4000
000256  9003              STR      r0,[sp,#0xc]
;;;325      GPIO_Init(ETH_LINK_GPIO_PORT, &GPIO_InitStructure);
000258  a903              ADD      r1,sp,#0xc
00025a  4871              LDR      r0,|L1.1056|
00025c  f7fffffe          BL       GPIO_Init
;;;326    
;;;327      /* Connect EXTI Line to INT Pin */
;;;328      SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);
000260  210e              MOVS     r1,#0xe
000262  2001              MOVS     r0,#1
000264  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;329    
;;;330      /* Configure EXTI line */
;;;331      EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
000268  f44f4080          MOV      r0,#0x4000
00026c  9001              STR      r0,[sp,#4]
;;;332      EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00026e  2000              MOVS     r0,#0
000270  f88d0008          STRB     r0,[sp,#8]
;;;333      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000274  200c              MOVS     r0,#0xc
000276  f88d0009          STRB     r0,[sp,#9]
;;;334      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00027a  2001              MOVS     r0,#1
00027c  f88d000a          STRB     r0,[sp,#0xa]
;;;335      EXTI_Init(&EXTI_InitStructure);
000280  a801              ADD      r0,sp,#4
000282  f7fffffe          BL       EXTI_Init
;;;336    
;;;337      /* Enable and set the EXTI interrupt to priority 1*/
;;;338      NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
000286  2028              MOVS     r0,#0x28
000288  f88d0000          STRB     r0,[sp,#0]
;;;339      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00028c  2001              MOVS     r0,#1
00028e  f88d0001          STRB     r0,[sp,#1]
;;;340      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000292  f88d0003          STRB     r0,[sp,#3]
;;;341      NVIC_Init(&NVIC_InitStructure);
000296  4668              MOV      r0,sp
000298  f7fffffe          BL       NVIC_Init
;;;342    }
00029c  b005              ADD      sp,sp,#0x14
00029e  bd00              POP      {pc}
;;;343    
                          ENDP

                  Eth_Link_ITHandler PROC
;;;348      */
;;;349    void Eth_Link_ITHandler(uint16_t PHYAddress)
0002a0  b510              PUSH     {r4,lr}
;;;350    {
0002a2  4604              MOV      r4,r0
;;;351      /* Check whether the link interrupt has occurred or not */
;;;352      if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
0002a4  2112              MOVS     r1,#0x12
0002a6  4620              MOV      r0,r4
0002a8  f7fffffe          BL       ETH_ReadPHYRegister
0002ac  f4005000          AND      r0,r0,#0x2000
0002b0  b180              CBZ      r0,|L1.724|
;;;353      {
;;;354        if((ETH_ReadPHYRegister(PHYAddress, PHY_SR) & 1))
0002b2  2110              MOVS     r1,#0x10
0002b4  4620              MOV      r0,r4
0002b6  f7fffffe          BL       ETH_ReadPHYRegister
0002ba  f0000001          AND      r0,r0,#1
0002be  b118              CBZ      r0,|L1.712|
;;;355        {
;;;356          netif_set_link_up(&xnetif);
0002c0  4863              LDR      r0,|L1.1104|
0002c2  f7fffffe          BL       netif_set_link_up
0002c6  e005              B        |L1.724|
                  |L1.712|
;;;357        }
;;;358        else
;;;359        {
;;;360          EthLinkStatus = 1;
0002c8  2001              MOVS     r0,#1
0002ca  4962              LDR      r1,|L1.1108|
0002cc  7008              STRB     r0,[r1,#0]
;;;361          netif_set_link_down(&xnetif);
0002ce  4860              LDR      r0,|L1.1104|
0002d0  f7fffffe          BL       netif_set_link_down
                  |L1.724|
;;;362        }
;;;363      }
;;;364    }
0002d4  bd10              POP      {r4,pc}
;;;365    
                          ENDP

                  ETH_link_callback PROC
;;;370      */
;;;371    void ETH_link_callback(struct netif *netif)
0002d6  b5f0              PUSH     {r4-r7,lr}
;;;372    {
0002d8  b085              SUB      sp,sp,#0x14
0002da  4606              MOV      r6,r0
;;;373      __IO uint32_t timeout = 0;
0002dc  2000              MOVS     r0,#0
0002de  9004              STR      r0,[sp,#0x10]
;;;374     uint32_t tmpreg,RegValue;
;;;375      struct ip_addr ipaddr;
;;;376      struct ip_addr netmask;
;;;377      struct ip_addr gw;
;;;378    #ifndef USE_DHCP
;;;379      uint8_t iptab[4] = {0};
0002e0  9000              STR      r0,[sp,#0]
;;;380      uint8_t iptxt[20];
;;;381    #endif /* USE_DHCP */
;;;382    
;;;383      /* Clear LCD */
;;;384      LCD_ClearLine(Line4);
0002e2  f7fffffe          BL       LCD_GetFont
0002e6  88c0              LDRH     r0,[r0,#6]
0002e8  0480              LSLS     r0,r0,#18
0002ea  0c07              LSRS     r7,r0,#16
0002ec  4638              MOV      r0,r7
0002ee  f7fffffe          BL       LCD_ClearLine
;;;385      LCD_ClearLine(Line5);
0002f2  f7fffffe          BL       LCD_GetFont
0002f6  88c0              LDRH     r0,[r0,#6]
0002f8  eb000080          ADD      r0,r0,r0,LSL #2
0002fc  b287              UXTH     r7,r0
0002fe  4638              MOV      r0,r7
000300  f7fffffe          BL       LCD_ClearLine
;;;386      LCD_ClearLine(Line6);
000304  f7fffffe          BL       LCD_GetFont
000308  88c0              LDRH     r0,[r0,#6]
00030a  eb000040          ADD      r0,r0,r0,LSL #1
00030e  0440              LSLS     r0,r0,#17
000310  0c07              LSRS     r7,r0,#16
000312  4638              MOV      r0,r7
000314  f7fffffe          BL       LCD_ClearLine
;;;387      LCD_ClearLine(Line7);
000318  f7fffffe          BL       LCD_GetFont
00031c  88c0              LDRH     r0,[r0,#6]
00031e  ebc000c0          RSB      r0,r0,r0,LSL #3
000322  b287              UXTH     r7,r0
000324  4638              MOV      r0,r7
000326  f7fffffe          BL       LCD_ClearLine
;;;388      LCD_ClearLine(Line8);
00032a  f7fffffe          BL       LCD_GetFont
00032e  88c0              LDRH     r0,[r0,#6]
000330  04c0              LSLS     r0,r0,#19
000332  0c07              LSRS     r7,r0,#16
000334  4638              MOV      r0,r7
000336  f7fffffe          BL       LCD_ClearLine
;;;389      LCD_ClearLine(Line9);
00033a  f7fffffe          BL       LCD_GetFont
00033e  88c0              LDRH     r0,[r0,#6]
000340  eb0000c0          ADD      r0,r0,r0,LSL #3
000344  b287              UXTH     r7,r0
000346  4638              MOV      r0,r7
000348  f7fffffe          BL       LCD_ClearLine
;;;390    
;;;391      if(netif_is_link_up(netif))
00034c  f896002d          LDRB     r0,[r6,#0x2d]
000350  f3c01000          UBFX     r0,r0,#4,#1
000354  2800              CMP      r0,#0
000356  d059              BEQ      |L1.1036|
;;;392      {
;;;393        /* Restart the autonegotiation */
;;;394        if(ETH_InitStructure.ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
000358  482d              LDR      r0,|L1.1040|
00035a  6800              LDR      r0,[r0,#0]  ; ETH_InitStructure
00035c  2800              CMP      r0,#0
00035e  d03f              BEQ      |L1.992|
;;;395        {
;;;396          /* Reset Timeout counter */
;;;397          timeout = 0;
000360  2000              MOVS     r0,#0
000362  9004              STR      r0,[sp,#0x10]
;;;398    
;;;399          /* Enable auto-negotiation */
;;;400          ETH_WritePHYRegister(DP83848_PHY_ADDRESS, PHY_BCR, PHY_AutoNegotiation);
000364  f44f5280          MOV      r2,#0x1000
000368  2100              MOVS     r1,#0
00036a  2001              MOVS     r0,#1
00036c  f7fffffe          BL       ETH_WritePHYRegister
;;;401    
;;;402          /* Wait until the auto-negotiation will be completed */
;;;403          do
000370  bf00              NOP      
                  |L1.882|
;;;404          {
;;;405            timeout++;
000372  9804              LDR      r0,[sp,#0x10]
000374  1c40              ADDS     r0,r0,#1
000376  9004              STR      r0,[sp,#0x10]
;;;406          } while (!(ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
000378  2101              MOVS     r1,#1
00037a  4608              MOV      r0,r1
00037c  f7fffffe          BL       ETH_ReadPHYRegister
000380  f0000020          AND      r0,r0,#0x20
000384  b918              CBNZ     r0,|L1.910|
000386  4934              LDR      r1,|L1.1112|
000388  9804              LDR      r0,[sp,#0x10]
00038a  4288              CMP      r0,r1
00038c  d3f1              BCC      |L1.882|
                  |L1.910|
;;;407    
;;;408          /* Reset Timeout counter */
;;;409          timeout = 0;
00038e  2000              MOVS     r0,#0
000390  9004              STR      r0,[sp,#0x10]
;;;410    
;;;411          /* Read the result of the auto-negotiation */
;;;412          RegValue = ETH_ReadPHYRegister(DP83848_PHY_ADDRESS, PHY_SR);
000392  2110              MOVS     r1,#0x10
000394  2001              MOVS     r0,#1
000396  f7fffffe          BL       ETH_ReadPHYRegister
00039a  4604              MOV      r4,r0
;;;413        
;;;414          /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;415          if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
00039c  f0040004          AND      r0,r4,#4
0003a0  b120              CBZ      r0,|L1.940|
;;;416          {
;;;417            /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;418            ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;  
0003a2  f44f6000          MOV      r0,#0x800
0003a6  491a              LDR      r1,|L1.1040|
0003a8  6208              STR      r0,[r1,#0x20]  ; ETH_InitStructure
0003aa  e002              B        |L1.946|
                  |L1.940|
;;;419          }
;;;420          else
;;;421          {
;;;422            /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;423            ETH_InitStructure.ETH_Mode = ETH_Mode_HalfDuplex;           
0003ac  2000              MOVS     r0,#0
0003ae  4918              LDR      r1,|L1.1040|
0003b0  6208              STR      r0,[r1,#0x20]  ; ETH_InitStructure
                  |L1.946|
;;;424          }
;;;425          /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;426          if(RegValue & PHY_SPEED_STATUS)
0003b2  f0040002          AND      r0,r4,#2
0003b6  b118              CBZ      r0,|L1.960|
;;;427          {
;;;428            /* Set Ethernet speed to 10M following the auto-negotiation */    
;;;429            ETH_InitStructure.ETH_Speed = ETH_Speed_10M; 
0003b8  2000              MOVS     r0,#0
0003ba  4915              LDR      r1,|L1.1040|
0003bc  6148              STR      r0,[r1,#0x14]  ; ETH_InitStructure
0003be  e003              B        |L1.968|
                  |L1.960|
;;;430          }
;;;431          else
;;;432          {
;;;433            /* Set Ethernet speed to 100M following the auto-negotiation */ 
;;;434            ETH_InitStructure.ETH_Speed = ETH_Speed_100M;      
0003c0  f44f4080          MOV      r0,#0x4000
0003c4  4912              LDR      r1,|L1.1040|
0003c6  6148              STR      r0,[r1,#0x14]  ; ETH_InitStructure
                  |L1.968|
;;;435          }
;;;436    
;;;437          /*------------------------ ETHERNET MACCR Re-Configuration --------------------*/
;;;438          /* Get the ETHERNET MACCR value */  
;;;439          tmpreg = ETH->MACCR;
0003c8  4824              LDR      r0,|L1.1116|
0003ca  6805              LDR      r5,[r0,#0]
;;;440    
;;;441          /* Set the FES bit according to ETH_Speed value */ 
;;;442          /* Set the DM bit according to ETH_Mode value */ 
;;;443          tmpreg |= (uint32_t)(ETH_InitStructure.ETH_Speed | ETH_InitStructure.ETH_Mode);
0003cc  4810              LDR      r0,|L1.1040|
0003ce  6940              LDR      r0,[r0,#0x14]  ; ETH_InitStructure
0003d0  490f              LDR      r1,|L1.1040|
0003d2  6a09              LDR      r1,[r1,#0x20]  ; ETH_InitStructure
0003d4  4308              ORRS     r0,r0,r1
0003d6  4305              ORRS     r5,r5,r0
;;;444    
;;;445          /* Write to ETHERNET MACCR */
;;;446          ETH->MACCR = (uint32_t)tmpreg;
0003d8  4820              LDR      r0,|L1.1116|
0003da  6005              STR      r5,[r0,#0]
;;;447    
;;;448          //_eth_delay_(ETH_REG_WRITE_DELAY);
;;;449          tmpreg = ETH->MACCR;
0003dc  6805              LDR      r5,[r0,#0]
;;;450          ETH->MACCR = tmpreg;
0003de  6005              STR      r5,[r0,#0]
                  |L1.992|
;;;451        }
;;;452    
;;;453        /* Restart MAC interface */
;;;454        ETH_Start();
0003e0  f7fffffe          BL       ETH_Start
;;;455    
;;;456    #ifdef USE_DHCP
;;;457        ipaddr.addr = 0;
;;;458        netmask.addr = 0;
;;;459        gw.addr = 0;
;;;460        DHCP_state = DHCP_START;
;;;461    #else
;;;462        IP4_ADDR(&ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);
0003e4  481e              LDR      r0,|L1.1120|
0003e6  9003              STR      r0,[sp,#0xc]
;;;463        IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3);
0003e8  f06f407f          MVN      r0,#0xff000000
0003ec  9002              STR      r0,[sp,#8]
;;;464        IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
0003ee  481d              LDR      r0,|L1.1124|
0003f0  9001              STR      r0,[sp,#4]
;;;465    #endif /* USE_DHCP */
;;;466    
;;;467        netif_set_addr(&xnetif, &ipaddr , &netmask, &gw);
0003f2  ab01              ADD      r3,sp,#4
0003f4  aa02              ADD      r2,sp,#8
0003f6  a903              ADD      r1,sp,#0xc
0003f8  4815              LDR      r0,|L1.1104|
0003fa  f7fffffe          BL       netif_set_addr
;;;468        
;;;469        /* When the netif is fully configured this function must be called.*/
;;;470        netif_set_up(&xnetif);    
0003fe  4814              LDR      r0,|L1.1104|
000400  f7fffffe          BL       netif_set_up
;;;471    
;;;472    #ifdef USE_LCD
;;;473        /* Set the LCD Text Color */
;;;474        LCD_SetTextColor(Green);
;;;475    
;;;476        /* Display message on the LCD */
;;;477        LCD_DisplayStringLine(Line5, (uint8_t*)"  Network Cable is  ");
;;;478        LCD_DisplayStringLine(Line6, (uint8_t*)"    now connected   ");
;;;479    
;;;480        /* Set the LCD Text Color */
;;;481        LCD_SetTextColor(White);
;;;482    
;;;483      #ifndef USE_DHCP
;;;484        /* Display static IP address */
;;;485        iptab[0] = IP_ADDR3;
;;;486        iptab[1] = IP_ADDR2;
;;;487        iptab[2] = IP_ADDR1;
;;;488        iptab[3] = IP_ADDR0;
;;;489        sprintf((char*)iptxt, "  %d.%d.%d.%d", iptab[3], iptab[2], iptab[1], iptab[0]);
;;;490        LCD_DisplayStringLine(Line8, (uint8_t*)"  Static IP address   ");
;;;491        LCD_DisplayStringLine(Line9, iptxt);
;;;492    
;;;493        /* Clear LCD */
;;;494        LCD_ClearLine(Line5);
;;;495        LCD_ClearLine(Line6);
;;;496      #endif /* USE_DHCP */
;;;497    #endif /* USE_LCD */
;;;498        EthLinkStatus = 0;
000404  2000              MOVS     r0,#0
000406  4913              LDR      r1,|L1.1108|
000408  7008              STRB     r0,[r1,#0]
00040a  e032              B        |L1.1138|
                  |L1.1036|
00040c  e02c              B        |L1.1128|
00040e  0000              DCW      0x0000
                  |L1.1040|
                          DCD      ETH_InitStructure
                  |L1.1044|
                          DCD      EthInitStatus
                  |L1.1048|
                          DCD      0x00010040
                  |L1.1052|
                          DCD      0x40020000
                  |L1.1056|
                          DCD      0x40020400
                  |L1.1060|
                          DCD      0x40020800
                  |L1.1064|
000428  20202045          DCB      "   Ethernet Init   ",0
00042c  74686572
000430  6e657420
000434  496e6974
000438  20202000
                  |L1.1084|
00043c  20202020          DCB      "      failed      ",0
000440  20206661
000444  696c6564
000448  20202020
00044c  202000  
00044f  00                DCB      0
                  |L1.1104|
                          DCD      xnetif
                  |L1.1108|
                          DCD      EthLinkStatus
                  |L1.1112|
                          DCD      0x0004ffff
                  |L1.1116|
                          DCD      0x40028000
                  |L1.1120|
                          DCD      0x0a01a8c0
                  |L1.1124|
                          DCD      0x0101a8c0
                  |L1.1128|
;;;499      }
;;;500      else
;;;501      {
;;;502        ETH_Stop();
000468  f7fffffe          BL       ETH_Stop
;;;503    #ifdef USE_DHCP
;;;504        DHCP_state = DHCP_LINK_DOWN;
;;;505        dhcp_stop(netif);
;;;506    #endif /* USE_DHCP */
;;;507    
;;;508        /*  When the netif link is down this function must be called.*/
;;;509        netif_set_down(&xnetif);
00046c  4802              LDR      r0,|L1.1144|
00046e  f7fffffe          BL       netif_set_down
                  |L1.1138|
;;;510    #ifdef USE_LCD
;;;511        /* Set the LCD Text Color */
;;;512        LCD_SetTextColor(Red);
;;;513    
;;;514        /* Display message on the LCD */
;;;515        LCD_DisplayStringLine(Line5, (uint8_t*)"  Network Cable is  ");
;;;516        LCD_DisplayStringLine(Line6, (uint8_t*)"     unplugged   ");
;;;517    
;;;518        /* Set the LCD Text Color */
;;;519        LCD_SetTextColor(White);
;;;520    #endif /* USE_LCD */
;;;521      }
;;;522    }
000472  b005              ADD      sp,sp,#0x14
000474  bdf0              POP      {r4-r7,pc}
;;;523    	
                          ENDP

000476  0000              DCW      0x0000
                  |L1.1144|
                          DCD      xnetif

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ETH_InitStructure
                          %        188

                          AREA ||.data||, DATA, ALIGN=2

                  EthInitStatus
                          DCD      0x00000000
                  EthLinkStatus
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\stm32f4x7_eth_bsp.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4x7_eth_bsp_c_8e6e51b1____REV16|
#line 114 "..\\..\\libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f4x7_eth_bsp_c_8e6e51b1____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4x7_eth_bsp_c_8e6e51b1____REVSH|
#line 128
|__asm___19_stm32f4x7_eth_bsp_c_8e6e51b1____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
